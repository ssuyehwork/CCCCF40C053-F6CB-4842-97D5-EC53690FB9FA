# 代码导出结果 - 20260218_110008

**项目路径**: `G:\C++\Inspirenote\H 合并`

**文件总数**: 114

## 文件: `src/ui/AdvancedTagSelector.cpp`

```cpp
#include "AdvancedTagSelector.h"
#include "IconHelper.h"
#include <QPushButton>
#include <QLabel>
#include <QKeyEvent>
#include <QGuiApplication>
#include <QScreen>
#include <QGraphicsDropShadowEffect>
#include <QScrollArea>
#include <QTimer>
#include <QRegularExpression>

AdvancedTagSelector::AdvancedTagSelector(QWidget* parent) 
    : QWidget(parent, Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint) 
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_DeleteOnClose);
    
    // 1:1 匹配 QuickWindow 的整体架构
    setFixedSize(400, 500); 

    auto* mainLayout = new QVBoxLayout(this);
    // [CRITICAL] 边距调整为 20px 以容纳阴影，防止出现“断崖式”阴影截止
    mainLayout->setContentsMargins(20, 20, 20, 20); 
    mainLayout->setSpacing(0);

    // 内部容器
    auto* container = new QWidget();
    container->setObjectName("container");
    container->setMouseTracking(true);
    container->setStyleSheet(
        "QWidget#container { background: #1E1E1E; border-radius: 10px; border: 1px solid #333; }"
    );

    // 阴影效果: 严格 1:1 复制 QuickWindow 参数 (同步修复模糊截止问题)
    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(20);
    shadow->setColor(QColor(0, 0, 0, 120));
    shadow->setOffset(0, 4);
    container->setGraphicsEffect(shadow);

    mainLayout->addWidget(container);

    // 容器内部布局
    auto* layout = new QVBoxLayout(container);
    layout->setContentsMargins(16, 16, 16, 16);
    layout->setSpacing(12);

    // 1. 搜索框
    m_search = new QLineEdit();
    m_search->setPlaceholderText("搜索或新建...");
    m_search->setStyleSheet(
        "QLineEdit {"
        "  background-color: #2D2D2D;"
        "  border: none;"
        "  border-bottom: 1px solid #444;"
        "  border-radius: 4px;"
        "  padding: 8px;"
        "  font-size: 13px;"
        "  color: #DDD;"
        "}"
        "QLineEdit:focus { border-bottom: 1px solid #4a90e2; }"
    );
    
    connect(m_search, &QLineEdit::textChanged, this, &AdvancedTagSelector::updateList);
    connect(m_search, &QLineEdit::returnPressed, this, [this](){
        QString text = m_search->text().trimmed();
        if (!text.isEmpty()) {
            // [CRITICAL] 支持使用中英文逗号分割标签，提升批量输入体验
            QStringList newTags = text.split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
            bool changed = false;
            for (QString& tag : newTags) {
                tag = tag.trimmed();
                if (!tag.isEmpty() && !m_selected.contains(tag)) {
                    m_selected.append(tag);
                    changed = true;
                }
            }
            
            if (changed) {
                emit tagsChanged();
            }
            // 关键：先清空搜索框，再刷新列表，确保新添加的标签出现在“最近使用”列表首位
            m_search->clear(); 
            updateList();
        }
    });
    layout->addWidget(m_search);

    // 2. 提示标签
    m_tipsLabel = new QLabel("最近使用");
    m_tipsLabel->setStyleSheet("color: #888; font-size: 12px; font-weight: bold; margin-top: 5px;");
    layout->addWidget(m_tipsLabel);

    // 3. 滚动区域
    auto* scroll = new QScrollArea();
    scroll->setWidgetResizable(true);
    scroll->setFrameShape(QFrame::NoFrame);
    scroll->setStyleSheet(
        "QScrollArea { background: transparent; border: none; }"
        "QScrollBar:vertical { width: 6px; background: transparent; }"
        "QScrollBar::handle:vertical { background: #444; border-radius: 3px; }"
    );

    m_tagContainer = new QWidget();
    m_tagContainer->setStyleSheet("background: transparent;");
    
    m_flow = new FlowLayout(m_tagContainer, 0, 8, 8);
    scroll->setWidget(m_tagContainer);
    layout->addWidget(scroll);
}

void AdvancedTagSelector::setup(const QList<QVariantMap>& recentTags, const QStringList& allTags, const QStringList& selectedTags) {
    m_recentTags = recentTags;
    m_allTags = allTags;
    m_selected = selectedTags;
    updateList();
}

void AdvancedTagSelector::setTags(const QStringList& allTags, const QStringList& selectedTags) {
    m_allTags = allTags;
    m_recentTags.clear();
    for (const QString& t : allTags) {
        QVariantMap m;
        m["name"] = t;
        m["count"] = 0;
        m_recentTags.append(m);
    }
    m_selected = selectedTags;
    updateList();
}

void AdvancedTagSelector::updateList() {
    // 清空现有项
    QLayoutItem* child;
    while ((child = m_flow->takeAt(0)) != nullptr) {
        if (child->widget()) {
            child->widget()->deleteLater();
        }
        delete child;
    }

    QString filter = m_search->text().trimmed();
    QString filterLower = filter.toLower();
    
    QList<QVariantMap> displayList;

    if (filter.isEmpty()) {
        m_tipsLabel->setText(QString("最近使用 (%1)").arg(m_recentTags.count()));
        
        // 整理显示列表：优先显示已选中的标签（新操作的排在最前）
        QStringList seen;
        
        // 1. 已选中的标签（按最后添加顺序逆序，最新添加的在第一位）
        for (int i = m_selected.size() - 1; i >= 0; --i) {
            QString name = m_selected[i];
            if (!seen.contains(name)) {
                QVariantMap m;
                m["name"] = name;
                int count = 0;
                for (const auto& rm : m_recentTags) {
                    if (rm["name"].toString() == name) {
                        count = rm["count"].toInt();
                        break;
                    }
                }
                m["count"] = count;
                displayList.append(m);
                seen << name;
            }
        }

        // 2. 数据库返回的其他最近标签
        for (const auto& rm : m_recentTags) {
            QString name = rm["name"].toString();
            if (!seen.contains(name)) {
                displayList.append(rm);
                seen << name;
            }
        }
    } else {
        // 搜索模式
        for (const QString& tag : m_allTags) {
            if (tag.toLower().contains(filterLower)) {
                QVariantMap m;
                m["name"] = tag;
                int count = 0;
                for (const auto& rm : m_recentTags) {
                    if (rm["name"].toString() == tag) {
                        count = rm["count"].toInt();
                        break;
                    }
                }
                m["count"] = count;
                displayList.append(m);
            }
        }
        m_tipsLabel->setText(QString("搜索结果 (%1)").arg(displayList.count()));
    }

    for (const auto& tagData : displayList) {
        QString tag = tagData["name"].toString();
        int count = tagData["count"].toInt();

        bool isSelected = m_selected.contains(tag);
        
        auto* btn = new QPushButton();
        btn->setCheckable(true);
        btn->setChecked(isSelected);
        btn->setCursor(Qt::PointingHandCursor);
        btn->setProperty("tag_name", tag);
        btn->setProperty("tag_count", count);
        
        updateChipState(btn, isSelected);
        
        connect(btn, &QPushButton::clicked, this, [this, btn, tag](){ 
            toggleTag(tag); 
        });
        m_flow->addWidget(btn);
    }
}

void AdvancedTagSelector::updateChipState(QPushButton* btn, bool checked) {
    QString name = btn->property("tag_name").toString();
    int count = btn->property("tag_count").toInt();
    
    QString text = name;
    if (count > 0) text += QString(" (%1)").arg(count);
    btn->setText(text);
    
    QIcon icon = checked ? IconHelper::getIcon("select", "#ffffff", 14) 
                         : IconHelper::getIcon("clock", "#bbbbbb", 14);
    btn->setIcon(icon);
    btn->setIconSize(QSize(14, 14));

    if (checked) {
        btn->setStyleSheet(
            "QPushButton {"
            "  background-color: #4a90e2;"
            "  color: white;"
            "  border: 1px solid #4a90e2;"
            "  border-radius: 14px;"
            "  padding: 6px 12px;"
            "  font-size: 12px;"
            "  font-family: 'Segoe UI', 'Microsoft YaHei';"
            "}"
        );
    } else {
        btn->setStyleSheet(
            "QPushButton {"
            "  background-color: #2D2D2D;"
            "  color: #BBB;"
            "  border: 1px solid #444;"
            "  border-radius: 14px;"
            "  padding: 6px 12px;"
            "  font-size: 12px;"
            "  font-family: 'Segoe UI', 'Microsoft YaHei';"
            "}"
            "QPushButton:hover {"
            "  background-color: #383838;"
            "  border-color: #666;"
            "  color: white;"
            "}"
        );
    }
}

void AdvancedTagSelector::toggleTag(const QString& tag) {
    if (m_selected.contains(tag)) {
        m_selected.removeAll(tag);
    } else {
        m_selected.append(tag);
    }
    emit tagsChanged();
    updateList();
    m_search->setFocus();
}

void AdvancedTagSelector::showAtCursor() {
    QPoint pos = QCursor::pos();
    QScreen *screen = QGuiApplication::screenAt(pos);
    if (screen) {
        QRect geo = screen->geometry();
        int x = pos.x() - 40; 
        int y = pos.y() - 10;
        if (x + width() > geo.right()) x = geo.right() - width();
        if (x < geo.left()) x = geo.left();
        if (y + height() > geo.bottom()) y = geo.bottom() - height();
        if (y < geo.top()) y = geo.top();
        move(x, y);
    }
    m_confirmed = false;
    show();
    raise();
    activateWindow();
    
    // 增加延迟确保焦点获取成功，解决“无法激活”的问题
    QTimer::singleShot(50, m_search, qOverload<>(&QWidget::setFocus));
}

void AdvancedTagSelector::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Escape) {
        close();
    } else if (event->modifiers() == Qt::ControlModifier && event->key() == Qt::Key_W) {
        close();
    } else {
        QWidget::keyPressEvent(event);
    }
}

void AdvancedTagSelector::hideEvent(QHideEvent* event) {
    if (!m_confirmed) {
        m_confirmed = true;
        emit tagsConfirmed(m_selected);
    }
    // 确保隐藏后能够自动销毁，避免内存累积或下次双击无法激活
    deleteLater();
    QWidget::hideEvent(event);
}
```

## 文件: `src/ui/AdvancedTagSelector.h`

```cpp
#ifndef ADVANCEDTAGSELECTOR_H
#define ADVANCEDTAGSELECTOR_H

#include <QWidget>
#include <QStringList>
#include <QList>
#include <QMap>
#include <QVariant>
#include <QVBoxLayout>
#include <QLineEdit>
#include <QLabel>
#include <QScrollArea>
#include <QPushButton>
#include "FlowLayout.h"

class AdvancedTagSelector : public QWidget {
    Q_OBJECT
public:
    explicit AdvancedTagSelector(QWidget* parent = nullptr);
    // 修复构造函数匹配问题，支持初始化数据
    void setup(const QList<QVariantMap>& recentTags, const QStringList& allTags, const QStringList& selectedTags);
    
    void setTags(const QStringList& allTags, const QStringList& selectedTags);
    QStringList selectedTags() const { return m_selected; }

    // 修复缺失的 showAtCursor 方法
    void showAtCursor();

signals:
    void tagsChanged();
    void tagsConfirmed(const QStringList& tags); // 修复缺失的信号

protected:
    void keyPressEvent(QKeyEvent* event) override;
    void hideEvent(QHideEvent* event) override;

private:
    void updateList();
    void toggleTag(const QString& tag);
    void updateChipState(QPushButton* btn, bool checked);

    QList<QVariantMap> m_recentTags;
    QStringList m_allTags;
    QStringList m_selected;
    bool m_confirmed = false;
    QLineEdit* m_search;
    QLabel* m_tipsLabel; // 新增提示标签
    QWidget* m_tagContainer;
    FlowLayout* m_flow;
};

#endif // ADVANCEDTAGSELECTOR_H
```

## 文件: `src/core/AES.cpp`

```cpp
#include "AES.h"
#include <cstring>
#include <algorithm>
#include <cstdint>

// S-Box, Inverse S-Box, Rcon... (Standard AES lookup tables)
static const std::uint8_t sbox[256] = {
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

static const std::uint8_t rsbox[256] = {
  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

static const std::uint8_t Rcon[11] = {
  0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
};

AES::AES(KeyLength keyLength) {
    m_nk = keyLength / 4;
    m_nb = 4;
    if (keyLength == AES_128) m_nr = 10;
    else if (keyLength == AES_192) m_nr = 12;
    else m_nr = 14;
}

AES::~AES() {}

void AES::keyExpansion(const std::uint8_t* key, std::uint8_t* w) {
    std::uint8_t temp[4];
    for (int i = 0; i < m_nk; ++i) {
        w[4 * i] = key[4 * i];
        w[4 * i + 1] = key[4 * i + 1];
        w[4 * i + 2] = key[4 * i + 2];
        w[4 * i + 3] = key[4 * i + 3];
    }
    for (int i = m_nk; i < m_nb * (m_nr + 1); ++i) {
        temp[0] = w[4 * (i - 1)];
        temp[1] = w[4 * (i - 1) + 1];
        temp[2] = w[4 * (i - 1) + 2];
        temp[3] = w[4 * (i - 1) + 3];
        if (i % m_nk == 0) {
            std::uint8_t t = temp[0];
            temp[0] = sbox[temp[1]] ^ Rcon[i / m_nk];
            temp[1] = sbox[temp[2]];
            temp[2] = sbox[temp[3]];
            temp[3] = sbox[t];
        } else if (m_nk > 6 && i % m_nk == 4) {
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
        }
        w[4 * i] = w[4 * (i - m_nk)] ^ temp[0];
        w[4 * i + 1] = w[4 * (i - m_nk) + 1] ^ temp[1];
        w[4 * i + 2] = w[4 * (i - m_nk) + 2] ^ temp[2];
        w[4 * i + 3] = w[4 * (i - m_nk) + 3] ^ temp[3];
    }
}

static std::uint8_t gmul(std::uint8_t a, std::uint8_t b) {
    std::uint8_t p = 0;
    for (int i = 0; i < 8; ++i) {
        if (b & 1) p ^= a;
        bool hi_bit_set = (a & 0x80);
        a <<= 1;
        if (hi_bit_set) a ^= 0x1b;
        b >>= 1;
    }
    return p;
}

void AES::cipher(const std::uint8_t in[16], std::uint8_t out[16], const std::uint8_t* w) {
    std::uint8_t state[4][4];
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            state[j][i] = in[i * 4 + j] ^ w[i * 4 + j];

    for (int round = 1; round < m_nr; ++round) {
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                state[i][j] = sbox[state[i][j]];

        std::uint8_t temp = state[1][0];
        state[1][0] = state[1][1]; state[1][1] = state[1][2]; state[1][2] = state[1][3]; state[1][3] = temp;
        temp = state[2][0]; std::uint8_t temp2 = state[2][1];
        state[2][0] = state[2][2]; state[2][1] = state[2][3]; state[2][2] = temp; state[2][3] = temp2;
        temp = state[3][0]; temp2 = state[3][1]; std::uint8_t temp3 = state[3][2];
        state[3][0] = state[3][3]; state[3][1] = temp; state[3][2] = temp2; state[3][3] = temp3;

        for (int j = 0; j < 4; ++j) {
            std::uint8_t a = state[0][j], b = state[1][j], c = state[2][j], d = state[3][j];
            state[0][j] = gmul(a, 2) ^ gmul(b, 3) ^ c ^ d;
            state[1][j] = a ^ gmul(b, 2) ^ gmul(c, 3) ^ d;
            state[2][j] = a ^ b ^ gmul(c, 2) ^ gmul(d, 3);
            state[3][j] = gmul(a, 3) ^ b ^ c ^ gmul(d, 2);
        }

        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                state[j][i] ^= w[round * 16 + i * 4 + j];
    }

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            state[i][j] = sbox[state[i][j]];

    std::uint8_t temp = state[1][0];
    state[1][0] = state[1][1]; state[1][1] = state[1][2]; state[1][2] = state[1][3]; state[1][3] = temp;
    temp = state[2][0]; std::uint8_t temp2 = state[2][1];
    state[2][0] = state[2][2]; state[2][1] = state[2][3]; state[2][2] = temp; state[2][3] = temp2;
    temp = state[3][0]; temp2 = state[3][1]; std::uint8_t temp3 = state[3][2];
    state[3][0] = state[3][3]; state[3][1] = temp; state[3][2] = temp2; state[3][3] = temp3;

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            out[i * 4 + j] = state[j][i] ^ w[m_nr * 16 + i * 4 + j];
}

void AES::invCipher(const std::uint8_t in[16], std::uint8_t out[16], const std::uint8_t* w) {
    std::uint8_t state[4][4];
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            state[j][i] = in[i * 4 + j] ^ w[m_nr * 16 + i * 4 + j];

    for (int round = m_nr - 1; round > 0; --round) {
        std::uint8_t temp = state[1][3];
        state[1][3] = state[1][2]; state[1][2] = state[1][1]; state[1][1] = state[1][0]; state[1][0] = temp;
        temp = state[2][2]; std::uint8_t temp2 = state[2][3];
        state[2][2] = state[2][0]; state[2][3] = state[2][1]; state[2][0] = temp; state[2][1] = temp2;
        temp = state[3][0]; temp2 = state[3][1]; std::uint8_t temp3 = state[3][2];
        state[3][0] = state[3][1]; state[3][1] = state[3][2]; state[3][2] = state[3][3]; state[3][3] = temp;

        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                state[i][j] = rsbox[state[i][j]];

        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                state[j][i] ^= w[round * 16 + i * 4 + j];

        for (int j = 0; j < 4; ++j) {
            std::uint8_t a = state[0][j], b = state[1][j], c = state[2][j], d = state[3][j];
            state[0][j] = gmul(a, 14) ^ gmul(b, 11) ^ gmul(c, 13) ^ gmul(d, 9);
            state[1][j] = gmul(a, 9) ^ gmul(b, 14) ^ gmul(c, 11) ^ gmul(d, 13);
            state[2][j] = gmul(a, 13) ^ gmul(b, 9) ^ gmul(c, 14) ^ gmul(d, 11);
            state[3][j] = gmul(a, 11) ^ gmul(b, 13) ^ gmul(c, 9) ^ gmul(d, 14);
        }
    }

    std::uint8_t temp = state[1][3];
    state[1][3] = state[1][2]; state[1][2] = state[1][1]; state[1][1] = state[1][0]; state[1][0] = temp;
    temp = state[2][2]; std::uint8_t temp2 = state[2][3];
    state[2][2] = state[2][0]; state[2][3] = state[2][1]; state[2][0] = temp; state[2][1] = temp2;
    temp = state[3][0]; temp2 = state[3][1]; std::uint8_t temp3 = state[3][2];
    state[3][0] = state[3][1]; state[3][1] = state[3][2]; state[3][2] = state[3][3]; state[3][3] = temp;

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            state[i][j] = rsbox[state[i][j]];

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            out[i * 4 + j] = state[j][i] ^ w[i * 4 + j];
}

std::vector<std::uint8_t> AES::encryptCBC(const std::vector<std::uint8_t>& input, const std::vector<std::uint8_t>& key, const std::vector<std::uint8_t>& iv) {
    std::vector<std::uint8_t> w(m_nb * (m_nr + 1) * 4);
    keyExpansion(key.data(), w.data());

    // PKCS#7 Padding
    std::size_t paddingLen = 16 - (input.size() % 16);
    std::vector<std::uint8_t> paddedInput = input;
    for (std::size_t i = 0; i < paddingLen; ++i) paddedInput.push_back((std::uint8_t)paddingLen);

    std::vector<std::uint8_t> output(paddedInput.size());
    std::uint8_t prevBlock[16];
    std::memcpy(prevBlock, iv.data(), 16);

    for (std::size_t i = 0; i < paddedInput.size(); i += 16) {
        std::uint8_t block[16];
        for (int j = 0; j < 16; ++j) block[j] = paddedInput[i + j] ^ prevBlock[j];
        cipher(block, &output[i], w.data());
        std::memcpy(prevBlock, &output[i], 16);
    }
    return output;
}

std::vector<std::uint8_t> AES::decryptCBC(const std::vector<std::uint8_t>& input, const std::vector<std::uint8_t>& key, const std::vector<std::uint8_t>& iv) {
    if (input.empty() || input.size() % 16 != 0) return {};
    std::vector<std::uint8_t> w(m_nb * (m_nr + 1) * 4);
    keyExpansion(key.data(), w.data());

    std::vector<std::uint8_t> output(input.size());
    std::uint8_t prevBlock[16];
    std::memcpy(prevBlock, iv.data(), 16);

    for (std::size_t i = 0; i < input.size(); i += 16) {
        std::uint8_t block[16];
        invCipher(&input[i], block, w.data());
        for (int j = 0; j < 16; ++j) output[i + j] = block[j] ^ prevBlock[j];
        std::memcpy(prevBlock, &input[i], 16);
    }

    // PKCS#7 Unpadding
    std::uint8_t paddingLen = output.back();
    if (paddingLen > 0 && paddingLen <= 16) {
        bool valid = true;
        for (std::size_t i = 0; i < paddingLen; ++i) {
            if (output[output.size() - 1 - i] != paddingLen) { valid = false; break; }
        }
        if (valid) output.resize(output.size() - paddingLen);
    }
    return output;
}
```

## 文件: `src/core/AES.h`

```cpp
#ifndef AES_H
#define AES_H

#include <vector>
#include <cstdint>

class AES {
public:
    enum KeyLength { AES_128 = 16, AES_192 = 24, AES_256 = 32 };

    explicit AES(KeyLength keyLength);
    ~AES();

    // CBC 加密
    std::vector<std::uint8_t> encryptCBC(const std::vector<std::uint8_t>& input, const std::vector<std::uint8_t>& key, const std::vector<std::uint8_t>& iv);
    // CBC 解密
    std::vector<std::uint8_t> decryptCBC(const std::vector<std::uint8_t>& input, const std::vector<std::uint8_t>& key, const std::vector<std::uint8_t>& iv);

private:
    void cipher(const std::uint8_t in[16], std::uint8_t out[16], const std::uint8_t* w);
    void invCipher(const std::uint8_t in[16], std::uint8_t out[16], const std::uint8_t* w);
    void keyExpansion(const std::uint8_t* key, std::uint8_t* w);
    
    int m_nb;
    int m_nk;
    int m_nr;
};

#endif // AES_H
```

## 文件: `src/ui/CategoryDelegate.h`

```cpp
#ifndef CATEGORYDELEGATE_H
#define CATEGORYDELEGATE_H

#include <QStyledItemDelegate>
#include <QPainter>
#include <QApplication>
#include "../models/CategoryModel.h"

class CategoryDelegate : public QStyledItemDelegate {
public:
    using QStyledItemDelegate::QStyledItemDelegate;
    
    void paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        if (!index.isValid()) return;

        bool selected = option.state & QStyle::State_Selected;
        bool hover = option.state & QStyle::State_MouseOver;
        bool isSelectable = index.flags() & Qt::ItemIsSelectable;

        if (isSelectable && (selected || hover)) {
            painter->save();
            painter->setRenderHint(QPainter::Antialiasing);

            QString colorHex = index.data(CategoryModel::ColorRole).toString();
            QColor baseColor = colorHex.isEmpty() ? QColor("#4a90e2") : QColor(colorHex);
            QColor bg = selected ? baseColor : QColor("#2a2d2e");
            if (selected) bg.setAlphaF(0.2); // 选中时应用 20% 透明度联动分类颜色

            // 精准计算高亮区域：联合图标与文字区域，避开左侧缩进/箭头区域
            QStyle* style = option.widget ? option.widget->style() : QApplication::style();
            QRect decoRect = style->subElementRect(QStyle::SE_ItemViewItemDecoration, &option, option.widget);
            QRect textRect = style->subElementRect(QStyle::SE_ItemViewItemText, &option, option.widget);
            
            // 联合区域并与当前行 rect 取交集，防止溢出
            QRect contentRect = decoRect.united(textRect);
            contentRect = contentRect.intersected(option.rect);
            
            // 向左右微调 (padding)，并保持上下略有间隙以体现圆角效果
            contentRect.adjust(-6, 1, 6, -1);
            
            painter->setBrush(bg);
            painter->setPen(Qt::NoPen);
            painter->drawRoundedRect(contentRect, 5, 5);
            painter->restore();
        }

        // 绘制原内容 (图标、文字)
        QStyleOptionViewItem opt = option;
        // 关键：移除 Selected 状态，由我们自己控制背景，防止 QStyle 绘制默认的蓝色/灰色整行高亮
        opt.state &= ~QStyle::State_Selected;
        opt.state &= ~QStyle::State_MouseOver;
        
        // 选中时文字强制设为白色以确保清晰度
        if (selected) {
            opt.palette.setColor(QPalette::Text, Qt::white);
            opt.palette.setColor(QPalette::HighlightedText, Qt::white);
        }
        
        QStyledItemDelegate::paint(painter, opt, index);
    }
};

#endif // CATEGORYDELEGATE_H
```

## 文件: `src/ui/CategoryLockWidget.cpp`

```cpp
#include "CategoryLockWidget.h"
#include "IconHelper.h"
#include "../core/DatabaseManager.h"
#include <QGraphicsDropShadowEffect>

CategoryLockWidget::CategoryLockWidget(QWidget* parent) : QWidget(parent) {
    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setAlignment(Qt::AlignCenter);

    auto* container = new QWidget();
    auto* layout = new QVBoxLayout(container);
    layout->setContentsMargins(10, 10, 10, 10);
    layout->setAlignment(Qt::AlignCenter);
    layout->setSpacing(8);

    // 1. 锁图标 (精简至 32x32)
    auto* lockIcon = new QLabel();
    lockIcon->setPixmap(IconHelper::getIcon("lock_secure", "#aaaaaa").pixmap(32, 32));
    lockIcon->setAlignment(Qt::AlignCenter);
    layout->addWidget(lockIcon);

    // 2. 提示文字 (精简至 13px)
    auto* titleLabel = new QLabel("输入密码查看内容");
    titleLabel->setStyleSheet("color: #999999; font-size: 13px; font-weight: bold; background: transparent;");
    titleLabel->setAlignment(Qt::AlignCenter);
    layout->addWidget(titleLabel);

    // 3. 密码提示 (精简至 11px)
    m_hintLabel = new QLabel("密码提示: ");
    m_hintLabel->setStyleSheet("color: #555555; font-size: 11px; background: transparent;");
    m_hintLabel->setAlignment(Qt::AlignCenter);
    layout->addWidget(m_hintLabel);

    layout->addSpacing(2);

    // 4. 密码输入框 (收紧至 180px)
    m_pwdEdit = new QLineEdit();
    m_pwdEdit->setPlaceholderText("输入密码");
    m_pwdEdit->setEchoMode(QLineEdit::Password);
    m_pwdEdit->setFixedWidth(180);
    m_pwdEdit->setFixedHeight(28);
    m_pwdEdit->setStyleSheet(
        "QLineEdit {"
        "  background-color: #121212; border: 1px solid #333; border-radius: 4px;"
        "  padding: 0 8px; color: white; font-size: 12px;"
        "}"
        "QLineEdit:focus { border: 1px solid #3a90ff; }"
    );
    connect(m_pwdEdit, &QLineEdit::returnPressed, this, &CategoryLockWidget::onVerify);
    layout->addWidget(m_pwdEdit, 0, Qt::AlignHCenter);

    mainLayout->addWidget(container);

    // 移除强制背景色，使其自然融合到父容器 (#1e1e1e) 中
    setStyleSheet("background: transparent;");
}

void CategoryLockWidget::setCategory(int id, const QString& hint) {
    if (m_catId == id && isVisible()) return; // 关键修复：防止因数据刷新导致的输入框重置
    
    m_catId = id;
    m_hintLabel->setText(QString("密码提示: %1").arg(hint.isEmpty() ? "无" : hint));
    m_pwdEdit->clear();
    m_pwdEdit->setFocus();
}

void CategoryLockWidget::clearInput() {
    m_pwdEdit->clear();
    m_pwdEdit->setFocus();
}

void CategoryLockWidget::onVerify() {
    if (m_catId == -1) return;
    
    if (DatabaseManager::instance().verifyCategoryPassword(m_catId, m_pwdEdit->text())) {
        emit unlocked(m_catId);
    } else {
        m_pwdEdit->setStyleSheet(m_pwdEdit->styleSheet() + "border: 1px solid #e74c3c;");
        m_pwdEdit->selectAll();
    }
}
```

## 文件: `src/ui/CategoryLockWidget.h`

```cpp
#ifndef CATEGORYLOCKWIDGET_H
#define CATEGORYLOCKWIDGET_H

#include <QWidget>
#include <QLineEdit>
#include <QLabel>
#include <QVBoxLayout>

class CategoryLockWidget : public QWidget {
    Q_OBJECT
public:
    explicit CategoryLockWidget(QWidget* parent = nullptr);
    
    void setCategory(int id, const QString& hint);
    void clearInput();

signals:
    void unlocked(int id);

private slots:
    void onVerify();

private:
    int m_catId = -1;
    QLabel* m_hintLabel;
    QLineEdit* m_pwdEdit;
};

#endif // CATEGORYLOCKWIDGET_H
```

## 文件: `src/models/CategoryModel.cpp`

```cpp
#include "CategoryModel.h"
#include "../core/DatabaseManager.h"
#include "../ui/IconHelper.h"
#include <QMimeData>
#include <QFont>
#include <QTimer>
#include <QSet>

CategoryModel::CategoryModel(Type type, QObject* parent) 
    : QStandardItemModel(parent), m_type(type) 
{
    refresh();
}

void CategoryModel::refresh() {
    clear();
    QStandardItem* root = invisibleRootItem();
    QVariantMap counts = DatabaseManager::instance().getCounts();

    if (m_type == System || m_type == Both) {
        auto addSystemItem = [&](const QString& name, const QString& type, const QString& icon, const QString& color = "#aaaaaa") {
            int count = counts.value(type, 0).toInt();
            QString display = QString("%1 (%2)").arg(name).arg(count);
            QStandardItem* item = new QStandardItem(display);
            item->setData(type, TypeRole);
            item->setData(name, NameRole);
            item->setData(color, ColorRole); // 设置颜色角色
            item->setEditable(false); // 系统项目不可重命名
            item->setIcon(IconHelper::getIcon(icon, color));
            root->appendRow(item);
        };

        addSystemItem("全部数据", "all", "all_data", "#3498db");
        addSystemItem("今日数据", "today", "today", "#2ecc71");
        addSystemItem("昨日数据", "yesterday", "today", "#f39c12"); // 使用橙色区分
        addSystemItem("最近访问", "recently_visited", "clock", "#9b59b6");
        addSystemItem("未分类", "uncategorized", "uncategorized", "#e67e22");
        addSystemItem("未标签", "untagged", "untagged", "#95a5a6");
        addSystemItem("书签", "bookmark", "bookmark", "#e74c3c");
        addSystemItem("回收站", "trash", "trash", "#7f8c8d");
    }
    
    if (m_type == User || m_type == Both) {
        // 用户分类
        QStandardItem* userGroup = new QStandardItem("我的分区");
        userGroup->setSelectable(false);
        userGroup->setEditable(false);
        userGroup->setFlags(userGroup->flags() | Qt::ItemIsDropEnabled);
        userGroup->setIcon(IconHelper::getIcon("branch", "#FFFFFF"));
        
        // 设为粗体白色
        QFont font = userGroup->font();
        font.setBold(true);
        userGroup->setFont(font);
        userGroup->setForeground(QColor("#FFFFFF"));
        
        root->appendRow(userGroup);

        auto categories = DatabaseManager::instance().getAllCategories();
        QMap<int, QStandardItem*> itemMap;

        for (const auto& cat : categories) {
            int id = cat["id"].toInt();
            int count = counts.value("cat_" + QString::number(id), 0).toInt();
            QString name = cat["name"].toString();
            QString display = QString("%1 (%2)").arg(name).arg(count);
            QStandardItem* item = new QStandardItem(display);
            item->setData("category", TypeRole);
            item->setData(id, IdRole);
            item->setData(cat["color"], ColorRole);
            item->setData(name, NameRole);
            item->setFlags(item->flags() | Qt::ItemIsDragEnabled | Qt::ItemIsDropEnabled);
            
            if (DatabaseManager::instance().isCategoryLocked(id)) {
                item->setIcon(IconHelper::getIcon("lock", "#aaaaaa"));
            } else {
                item->setIcon(IconHelper::getIcon("circle_filled", cat["color"].toString()));
            }
            itemMap[cat["id"].toInt()] = item;
        }

        for (const auto& cat : categories) {
            int id = cat["id"].toInt();
            int parentId = cat["parent_id"].toInt();
            if (parentId > 0 && itemMap.contains(parentId)) {
                itemMap[parentId]->appendRow(itemMap[id]);
            } else {
                userGroup->appendRow(itemMap[id]);
            }
        }
    }
}

Qt::DropActions CategoryModel::supportedDropActions() const {
    return Qt::MoveAction;
}

bool CategoryModel::dropMimeData(const QMimeData* data, Qt::DropAction action, int row, int column, const QModelIndex& parent) {
    QModelIndex actualParent = parent;
    
    // 核心修复：处理正在拖拽分类的情况（m_draggingId != -1）
    if (m_draggingId != -1) {
        bool needsRedirect = false;
        if (!actualParent.isValid()) {
            needsRedirect = true;
        } else {
            QStandardItem* targetItem = itemFromIndex(actualParent);
            QString type = targetItem->data(TypeRole).toString();
            // 如果释放到了系统项或非分类区域，强制重定向到 "我的分区"
            if (type != "category" && targetItem->text() != "我的分区") {
                needsRedirect = true;
            }
        }

        if (needsRedirect) {
            // 寻找 "我的分区" 容器索引
            for (int i = 0; i < rowCount(); ++i) {
                QStandardItem* it = item(i);
                if (it->text() == "我的分区") {
                    actualParent = index(i, 0);
                    break;
                }
            }
        }
    }

    // 再次检查重定向后的合法性
    if (actualParent.isValid()) {
        QStandardItem* parentItem = itemFromIndex(actualParent);
        QString type = parentItem->data(TypeRole).toString();
        if (type != "category" && parentItem->text() != "我的分区") {
            return false; // 依然非法则拒绝，防止回弹
        }
    } else {
        return false; // 根部非法释放
    }

    bool ok = QStandardItemModel::dropMimeData(data, action, row, column, actualParent);
    if (ok && action == Qt::MoveAction) {
        QPersistentModelIndex persistentParent = actualParent;
        QTimer::singleShot(0, this, [this, persistentParent]() {
            syncOrders(persistentParent);
        });
    } else {
        m_draggingId = -1; 
    }
    return ok;
}

void CategoryModel::syncOrders(const QModelIndex& parent) {
    QStandardItem* parentItem = parent.isValid() ? itemFromIndex(parent) : invisibleRootItem();
    
    // 核心修复：无论在 User 还是 Both 模式下，如果落在根部或无效区，尝试找到 "我的分区" 同步
    if (parentItem == invisibleRootItem() || (parentItem->data(TypeRole).toString() != "category" && parentItem->text() != "我的分区")) {
        for (int i = 0; i < rowCount(); ++i) {
            QStandardItem* it = item(i);
            if (it->text() == "我的分区") {
                parentItem = it;
                break;
            }
        }
    }

    QList<int> categoryIds;
    int parentId = -1;
    
    // 再次确认父节点类型，确保同步到正确的数据库父 ID
    QString parentType = parentItem->data(TypeRole).toString();
    if (parentType == "category") {
        parentId = parentItem->data(IdRole).toInt();
    } else if (parentItem->text() == "我的分区") {
        parentId = -1; // 顶级分类
    } else {
        return; // 依然找不到有效的用户分类容器，放弃同步以防破坏数据
    }

    // 收集所有分类 ID，维护当前物理顺序
    QSet<int> seenIds;
    for (int i = 0; i < parentItem->rowCount(); ++i) {
        QStandardItem* child = parentItem->child(i);
        if (child->data(TypeRole).toString() == "category") {
            int id = child->data(IdRole).toInt();
            if (seenIds.contains(id)) continue; // 深度防御：跳过重复项
            seenIds.insert(id);
            categoryIds << id;
        }
    }
    
    if (!categoryIds.isEmpty()) {
        DatabaseManager::instance().updateCategoryOrder(parentId, categoryIds);
    }
    
    m_draggingId = -1; // 完成同步后重置
}
```

## 文件: `src/models/CategoryModel.h`

```cpp
#ifndef CATEGORYMODEL_H
#define CATEGORYMODEL_H

#include <QStandardItemModel>

class CategoryModel : public QStandardItemModel {
    Q_OBJECT
public:
    enum Type { System, User, Both };
    enum Roles {
        TypeRole = Qt::UserRole,
        IdRole,
        ColorRole,
        NameRole
    };
    explicit CategoryModel(Type type, QObject* parent = nullptr);
    void refresh();
    void setDraggingId(int id) { m_draggingId = id; }

    // D&D support
    Qt::DropActions supportedDropActions() const override;
    bool dropMimeData(const QMimeData* data, Qt::DropAction action, int row, int column, const QModelIndex& parent) override;

private:
    void syncOrders(const QModelIndex& parent);
    Type m_type;
    int m_draggingId = -1;
};

#endif // CATEGORYMODEL_H
```

## 文件: `src/ui/CategoryPasswordDialog.cpp`

```cpp
#include "CategoryPasswordDialog.h"
#include <QTextEdit>
#include <QVBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QTimer>

CategoryPasswordDialog::CategoryPasswordDialog(const QString& title, QWidget* parent)
    : FramelessDialog(title, parent)
{
    setFixedSize(360, 435);

    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(20, 15, 20, 20);
    layout->setSpacing(12);

    QString labelStyle = "color: #eee; font-size: 13px; font-weight: bold;";
    QString editStyle = 
        "QLineEdit, QTextEdit {"
        "  background-color: #121212; border: 1px solid #333; border-radius: 6px;"
        "  padding: 8px; color: white; selection-background-color: #4a90e2;"
        "}"
        "QLineEdit:focus, QTextEdit:focus { border: 1px solid #3a90ff; }";

    // 密码
    auto* lblPwd = new QLabel("密码");
    lblPwd->setStyleSheet(labelStyle);
    layout->addWidget(lblPwd);

    m_pwdEdit = new QLineEdit();
    m_pwdEdit->setEchoMode(QLineEdit::Password);
    m_pwdEdit->setStyleSheet(editStyle);
    layout->addWidget(m_pwdEdit);

    // 密码确认
    auto* lblConfirm = new QLabel("密码确认");
    lblConfirm->setStyleSheet(labelStyle);
    layout->addWidget(lblConfirm);

    m_confirmEdit = new QLineEdit();
    m_confirmEdit->setEchoMode(QLineEdit::Password);
    m_confirmEdit->setStyleSheet(editStyle);
    layout->addWidget(m_confirmEdit);

    // 密码提示
    auto* lblHint = new QLabel("密码提示");
    lblHint->setStyleSheet(labelStyle);
    layout->addWidget(lblHint);

    m_hintEdit = new QTextEdit();
    m_hintEdit->setFixedHeight(80);
    m_hintEdit->setStyleSheet(editStyle);
    layout->addWidget(m_hintEdit);

    layout->addStretch();
    layout->addSpacing(15);

    // 保存按钮
    auto* btnSave = new QPushButton("保存密码设置");
    btnSave->setAutoDefault(false);
    btnSave->setFixedHeight(44);
    btnSave->setCursor(Qt::PointingHandCursor);
    btnSave->setStyleSheet(
        "QPushButton {"
        "  background-color: #3a90ff; color: white; border: none; border-radius: 8px;"
        "  font-weight: bold; font-size: 14px;"
        "}"
        "QPushButton:hover { background-color: #2b7ae6; }"
        "QPushButton:pressed { background-color: #1a5dbf; }"
    );
    connect(btnSave, &QPushButton::clicked, this, [this](){
        if (m_pwdEdit->text() != m_confirmEdit->text()) {
            // 这里以后可以加个提示，但按用户要求尽量简洁
            m_confirmEdit->setStyleSheet(m_confirmEdit->styleSheet() + "border: 1px solid #e74c3c;");
            return;
        }
        accept();
    });
    layout->addWidget(btnSave);
}

void CategoryPasswordDialog::showEvent(QShowEvent* event) {
    FramelessDialog::showEvent(event);
    // 使用 QTimer 确保在窗口完全显示后获取焦点，增加延迟至 100ms 以应对复杂的菜单关闭场景
    QTimer::singleShot(100, m_pwdEdit, qOverload<>(&QWidget::setFocus));
}

void CategoryPasswordDialog::setInitialData(const QString& hint) {
    m_hintEdit->setPlainText(hint);
}

QString CategoryPasswordDialog::password() const {
    return m_pwdEdit->text();
}

QString CategoryPasswordDialog::confirmPassword() const {
    return m_confirmEdit->text();
}

QString CategoryPasswordDialog::passwordHint() const {
    return m_hintEdit->toPlainText();
}
```

## 文件: `src/ui/CategoryPasswordDialog.h`

```cpp
#ifndef CATEGORYPASSWORDDIALOG_H
#define CATEGORYPASSWORDDIALOG_H

#include "FramelessDialog.h"
#include <QLineEdit>
#include <QTextEdit>

class CategoryPasswordDialog : public FramelessDialog {
    Q_OBJECT
public:
    explicit CategoryPasswordDialog(const QString& title, QWidget* parent = nullptr);
    
    void setInitialData(const QString& hint);
    
    QString password() const;
    QString confirmPassword() const;
    QString passwordHint() const;

protected:
    void showEvent(QShowEvent* event) override;

private:
    QLineEdit* m_pwdEdit;
    QLineEdit* m_confirmEdit;
    QTextEdit* m_hintEdit;
};

#endif // CATEGORYPASSWORDDIALOG_H
```

## 文件: `src/ui/CleanListView.cpp`

```cpp
#include "CleanListView.h"
#include <QDrag>
#include <QPixmap>
#include <QMimeData>

CleanListView::CleanListView(QWidget* parent) : QListView(parent) {}

void CleanListView::startDrag(Qt::DropActions supportedActions) {
    QModelIndexList indexes = selectedIndexes();
    if (indexes.isEmpty()) return;

    QMimeData* data = model()->mimeData(indexes);
    if (!data) return;

    QDrag* drag = new QDrag(this);
    drag->setMimeData(data);
    
    // 关键：在这里设置一个 1x1 像素的透明 Pixmap 用以消除臃肿的截图
    QPixmap transparentPixmap(1, 1);
    transparentPixmap.fill(Qt::transparent);
    drag->setPixmap(transparentPixmap);
    drag->setHotSpot(QPoint(0, 0));

    drag->exec(supportedActions, Qt::MoveAction);
}
```

## 文件: `src/ui/CleanListView.h`

```cpp
#ifndef CLEANLISTVIEW_H
#define CLEANLISTVIEW_H

#include <QListView>

class CleanListView : public QListView {
    Q_OBJECT
public:
    explicit CleanListView(QWidget* parent = nullptr);

protected:
    void startDrag(Qt::DropActions supportedActions) override;
};

#endif // CLEANLISTVIEW_H
```

## 文件: `src/ui/ClickableLineEdit.h`

```cpp
#ifndef CLICKABLELINEEDIT_H
#define CLICKABLELINEEDIT_H

#include <QLineEdit>
#include <QMouseEvent>

class ClickableLineEdit : public QLineEdit {
    Q_OBJECT
public:
    using QLineEdit::QLineEdit;
signals:
    void doubleClicked();
protected:
    void mouseDoubleClickEvent(QMouseEvent* event) override {
        if (event->button() == Qt::LeftButton) emit doubleClicked();
        QLineEdit::mouseDoubleClickEvent(event);
    }
};

#endif // CLICKABLELINEEDIT_H
```

## 文件: `src/core/ClipboardMonitor.cpp`

```cpp
#include "ClipboardMonitor.h"
#include <QMimeData>
#include <QDebug>

ClipboardMonitor& ClipboardMonitor::instance() {
    static ClipboardMonitor inst;
    return inst;
}

ClipboardMonitor::ClipboardMonitor(QObject* parent) : QObject(parent) {
    connect(QGuiApplication::clipboard(), &QClipboard::dataChanged, this, &ClipboardMonitor::onClipboardChanged);
    qDebug() << "[ClipboardMonitor] 初始化完成，开始监听...";
}

#include <QApplication>
#include <QImage>
#include <QBuffer>
#include <QUrl>
#include <QFileInfo>
#include <QDir>
#include <QCryptographicHash>

#ifdef Q_OS_WIN
#include <windows.h>
#include <psapi.h>
#endif

void ClipboardMonitor::onClipboardChanged() {
    emit clipboardChanged();

    bool forced = m_forceNext;
    QString forcedType = m_forcedType;
    m_forceNext = false;
    m_forcedType = "";

    if (m_skipNext) {
        m_skipNext = false;
        return;
    }

    // 抓取来源窗口信息 (对标 Ditto)
    QString sourceApp = forced ? "RapidNotes (内建工具)" : "未知应用";
    QString sourceTitle = "未知窗口";

    // 1. 过滤本程序自身的复制 (通过进程 ID 判定，比 activeWindow 更可靠)
#ifdef Q_OS_WIN
    HWND hwnd = GetForegroundWindow();
    if (hwnd) {
        DWORD processId;
        GetWindowThreadProcessId(hwnd, &processId);
        
        // 既然已经拿到了 HWND 和 PID，直接抓取标题和应用名，避免重复调用系统 API
        wchar_t title[512];
        if (GetWindowTextW(hwnd, title, 512)) {
            sourceTitle = QString::fromWCharArray(title);
        }

        // [CRITICAL] 过滤逻辑精细化：仅针对主窗口和极速窗口的常规复制操作进行拦截（防止回环）。
        // 如果开启了 forced (forceNext)，说明是内建工具的主动行为，必须予以记录，无论当前窗口是谁。
        if (processId == GetCurrentProcessId()) {
            if (!forced) {
                // [NOTE] 如果没有强制标志，且活跃窗口是主界面，则判定为需要过滤的内部回环
                if (sourceTitle == "RapidNotes" || sourceTitle == "快速笔记") {
                    return;
                }
            } else {
                // 如果是强制记录，确保来源 App 显示为内建工具
                sourceApp = "RapidNotes (内建工具)";
            }
        }

        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processId);
        if (hProcess) {
            wchar_t exePath[MAX_PATH];
            if (GetModuleFileNameExW(hProcess, NULL, exePath, MAX_PATH)) {
                sourceApp = QFileInfo(QString::fromWCharArray(exePath)).baseName();
            }
            CloseHandle(hProcess);
        }
    }
#else
    QWidget* activeWin = QApplication::activeWindow();
    if (activeWin && !forced) {
        QString title = activeWin->windowTitle();
        if (title == "RapidNotes" || title == "快速笔记") {
            return;
        }
    }
#endif

    const QMimeData* mimeData = QGuiApplication::clipboard()->mimeData();
    if (!mimeData) return;

    QString type;
    QString content;
    QByteArray dataBlob;

    // 优先级 1: 本地文件
    if (mimeData->hasUrls()) {
        QStringList paths;
        for (const QUrl& url : mimeData->urls()) {
            if (url.isLocalFile()) {
                paths << QDir::toNativeSeparators(url.toLocalFile());
            }
        }
        if (!paths.isEmpty()) {
            type = "file";
            content = paths.join(";");
        }
    }

    // 优先级 2: 图片 (仅当不是文件时)
    if (type.isEmpty() && mimeData->hasImage()) {
        QImage img = qvariant_cast<QImage>(mimeData->imageData());
        if (!img.isNull()) {
            type = "image";
            content = "[图片]";
            QBuffer buffer(&dataBlob);
            buffer.open(QIODevice::WriteOnly);
            img.save(&buffer, "PNG");
        }
    }

    // 优先级 3: 文本 (包括网页链接)
    if (type.isEmpty() && mimeData->hasText() && !mimeData->text().trimmed().isEmpty()) {
        type = "text";
        content = mimeData->text();
    }

    // 如果都没有识别出来，则忽略
    if (type.isEmpty()) return;

    // [CRITICAL] 如果指定了强制类型，则覆盖，用于区分普通文本与图片识别出的文字
    if (forced && !forcedType.isEmpty()) {
        type = forcedType;
    }

    // SHA256 去重
    QByteArray hashData = dataBlob.isEmpty() ? content.toUtf8() : dataBlob;
    QString currentHash = QCryptographicHash::hash(hashData, QCryptographicHash::Sha256).toHex();
    
    if (currentHash == m_lastHash) return;
    m_lastHash = currentHash;

    qDebug() << "[ClipboardMonitor] 捕获新内容 (来自:" << sourceApp << "):" << type << content.left(30);
    emit newContentDetected(content, type, dataBlob, sourceApp, sourceTitle);
}
```

## 文件: `src/core/ClipboardMonitor.h`

```cpp
#ifndef CLIPBOARDMONITOR_H
#define CLIPBOARDMONITOR_H

#include <QObject>
#include <QClipboard>
#include <QGuiApplication>
#include <QCryptographicHash>
#include <QStringList>

class ClipboardMonitor : public QObject {
    Q_OBJECT
public:
    static ClipboardMonitor& instance();
    void skipNext() { m_skipNext = true; }
    // [CRITICAL] forceNext 支持传入预设类型（如 ocr_text），确保识别出的文字使用专用图标
    void forceNext(const QString& type = "") { m_forceNext = true; m_forcedType = type; }

signals:
    void newContentDetected(const QString& content, const QString& type, const QByteArray& data = QByteArray(),
                            const QString& sourceApp = "", const QString& sourceTitle = "");
    void clipboardChanged();

private slots:
    void onClipboardChanged();

private:
    ClipboardMonitor(QObject* parent = nullptr);
    QString m_lastHash;
    bool m_skipNext = false;
    bool m_forceNext = false;
    // [CRITICAL] 记录强制触发时的预设类型
    QString m_forcedType;
};

#endif // CLIPBOARDMONITOR_H
```

## 文件: `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.16)

project(RapidNotes VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

find_package(Qt6 REQUIRED COMPONENTS Core Gui Widgets Sql Network Concurrent Svg)

# 源代码列表 - 确保 NoteEditWindow 相关的两个文件都在这里
set(SOURCES
    src/core/AES.cpp
    src/core/AES.h
    src/core/ClipboardMonitor.cpp
    src/core/ClipboardMonitor.h
    src/core/DatabaseManager.cpp
    src/core/DatabaseManager.h
    src/core/FileCryptoHelper.cpp
    src/core/FileCryptoHelper.h
    src/core/HotkeyManager.cpp
    src/core/HotkeyManager.h
    src/core/KeyboardHook.cpp
    src/core/KeyboardHook.h
    src/core/MessageCaptureHandler.cpp
    src/core/MessageCaptureHandler.h
    src/core/OCRManager.cpp
    src/core/OCRManager.h
    src/core/ShortcutManager.cpp
    src/core/ShortcutManager.h
    src/main.cpp
    src/models/CategoryModel.cpp
    src/models/CategoryModel.h
    src/models/NoteModel.cpp
    src/models/NoteModel.h
    src/ui/AdvancedTagSelector.cpp
    src/ui/AdvancedTagSelector.h
    src/ui/CategoryDelegate.h
    src/ui/CategoryLockWidget.cpp
    src/ui/CategoryLockWidget.h
    src/ui/CategoryPasswordDialog.cpp
    src/ui/CategoryPasswordDialog.h
    src/ui/CleanListView.cpp
    src/ui/CleanListView.h
    src/ui/ClickableLineEdit.h
    src/ui/ColorPickerWindow.cpp
    src/ui/ColorPickerWindow.h
    src/ui/DropTreeView.cpp
    src/ui/DropTreeView.h
    src/ui/Editor.cpp
    src/ui/Editor.h
    src/ui/FileSearchWindow.cpp
    src/ui/FileSearchWindow.h
    src/ui/FileStorageWindow.cpp
    src/ui/FileStorageWindow.h
    src/ui/FilterPanel.cpp
    src/ui/FilterPanel.h
    src/ui/FireworksOverlay.cpp
    src/ui/FireworksOverlay.h
    src/ui/FloatingBall.cpp
    src/ui/FloatingBall.h
    src/ui/FlowLayout.cpp
    src/ui/FlowLayout.h
    src/ui/FramelessDialog.cpp
    src/ui/FramelessDialog.h
    src/ui/HeaderBar.cpp
    src/ui/HeaderBar.h
    src/ui/HelpWindow.cpp
    src/ui/HelpWindow.h
    src/ui/IconHelper.h
    src/ui/KeywordSearchWindow.cpp
    src/ui/KeywordSearchWindow.h
    src/ui/MainWindow.cpp
    src/ui/MainWindow.h
    src/ui/MetadataPanel.cpp
    src/ui/MetadataPanel.h
    src/ui/NoteDelegate.h
    src/ui/NoteEditWindow.cpp
    src/ui/NoteEditWindow.h
    src/ui/OCRResultWindow.cpp
    src/ui/OCRResultWindow.h
    src/ui/OCRWindow.cpp
    src/ui/OCRWindow.h
    src/ui/PasswordGeneratorWindow.cpp
    src/ui/PasswordGeneratorWindow.h
    src/ui/PixelRulerOverlay.cpp
    src/ui/PixelRulerOverlay.h
    src/ui/QuickNoteDelegate.h
    src/ui/QuickPreview.h
    src/ui/QuickWindow.cpp
    src/ui/QuickWindow.h
    src/ui/ResizeHandle.cpp
    src/ui/ResizeHandle.h
    src/ui/ScreenshotTool.cpp
    src/ui/ScreenshotTool.h
    src/ui/SearchLineEdit.cpp
    src/ui/SearchLineEdit.h
    src/ui/SettingsWindow.cpp
    src/ui/SettingsWindow.h
    src/ui/StringUtils.h
    src/ui/SvgIcons.h
    src/ui/SystemTray.cpp
    src/ui/SystemTray.h
    src/ui/TagEditDialog.cpp
    src/ui/TitleEditorDialog.h
    src/ui/TagEditDialog.h
    src/ui/TagEditorWidget.cpp
    src/ui/TagEditorWidget.h
    src/ui/TagManagerWindow.cpp
    src/ui/TagManagerWindow.h
    src/ui/TimePasteWindow.cpp
    src/ui/TimePasteWindow.h
    src/ui/ToolTipOverlay.h
    src/ui/Toolbox.cpp
    src/ui/Toolbox.h
    src/ui/WritingAnimation.cpp
    src/ui/WritingAnimation.h
    resources/resources.qrc
)

if(WIN32)
    list(APPEND SOURCES resources/app_icon.rc)
endif()

add_executable(RapidNotes ${SOURCES})

target_link_libraries(RapidNotes PRIVATE
    Qt6::Core
    Qt6::Gui
    Qt6::Widgets
    Qt6::Sql
    Qt6::Network
    Qt6::Concurrent
    Qt6::Svg
)

if(WIN32)
    target_link_libraries(RapidNotes PRIVATE user32 shell32 psapi dwmapi)
    set_target_properties(RapidNotes PROPERTIES
        WIN32_EXECUTABLE TRUE
    )
endif()
```

## 文件: `src/ui/ColorPickerWindow.cpp`

```cpp
#include "ColorPickerWindow.h"
#include "ToolTipOverlay.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include "../core/DatabaseManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QApplication>
#include <QScreen>
#include <QGuiApplication>
#include <QMouseEvent>
#include <QCursor>
#include <QClipboard>
#include <QMimeData>
#include <QSettings>
#include <QPainter>
#include <QBuffer>
#include <QImageReader>
#include <QToolTip>
#include <QSet>
#include <QScrollArea>
#include <QFrame>
#include <QTimer>
#include <QFileDialog>
#include <QMenu>
#include <QProcess>
#include <QDesktopServices>
#include <QJsonDocument>
#include <QJsonArray>
#include <QJsonObject>
#include <QFile>
#include <QPainterPath>
#include <cmath>
#include <algorithm>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#include <QPropertyAnimation>
#include <QGraphicsOpacityEffect>
#include <QColorDialog>
#include <QGridLayout>
#include <QStackedWidget>
#include <QSlider>
#include "FlowLayout.h"
#include "PixelRulerOverlay.h"

#ifdef Q_OS_WIN
#include <windows.h>
#endif

// ----------------------------------------------------------------------------
// ToolTipOverlay: 自定义绘制的 Tooltip 覆盖层
// ----------------------------------------------------------------------------
// 已移至 ToolTipOverlay.h

// ----------------------------------------------------------------------------
// ScreenColorPickerOverlay: 屏幕取色器 (多显示器/HighDPI 稳定版)
// ----------------------------------------------------------------------------
class ScreenColorPickerOverlay : public QWidget {
    Q_OBJECT
    struct ScreenCapture {
        QPixmap pixmap;
        QImage image;
        QRect geometry;
        qreal dpr;
    };
public:
    explicit ScreenColorPickerOverlay(std::function<void(QString)> callback, QWidget* parent = nullptr) 
        : QWidget(nullptr), m_callback(callback) 
    {
        setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool);
        setAttribute(Qt::WA_DeleteOnClose);
        setAttribute(Qt::WA_NoSystemBackground);
        setAttribute(Qt::WA_TranslucentBackground); 
        
        QRect totalRect;
        const auto screens = QGuiApplication::screens();
        for (QScreen* screen : screens) {
            QRect geom = screen->geometry();
            totalRect = totalRect.united(geom);
            
            ScreenCapture cap;
            cap.geometry = geom;
            cap.dpr = screen->devicePixelRatio();
            // [CRITICAL] 核心修复：必须使用本地坐标 (0,0) 抓取。
            // QScreen::grabWindow 的坐标参数在 WId 为 0 时是相对于该屏幕的，使用全局坐标会导致多屏采样偏移。
            cap.pixmap = screen->grabWindow(0, 0, 0, geom.width(), geom.height());
            cap.pixmap.setDevicePixelRatio(cap.dpr);
            cap.image = cap.pixmap.toImage();
            m_captures.append(cap);
        }
        setGeometry(totalRect);

        setCursor(Qt::BlankCursor);
        setMouseTracking(true);
        
        QTimer* timer = new QTimer(this);
        connect(timer, &QTimer::timeout, this, QOverload<>::of(&ScreenColorPickerOverlay::update));
        timer->start(16);
    }

protected:
    void showEvent(QShowEvent* event) override {
        QWidget::showEvent(event);
        QTimer::singleShot(50, this, [this]() {
            if (isVisible()) {
                this->grabMouse();
                this->grabKeyboard();
            }
        });
    }

    void mousePressEvent(QMouseEvent* event) override {
        if (event->button() == Qt::LeftButton) {
            if (m_callback) m_callback(m_currentColorHex);
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("已颜色提取器: %1\n(右键可退出取色模式)").arg(m_currentColorHex));
        } else if (event->button() == Qt::RightButton) {
            cancelPicker();
        }
    }

    void keyPressEvent(QKeyEvent* event) override {
        if (event->key() == Qt::Key_Escape) {
            cancelPicker();
        }
    }

    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        
        QPoint globalPos = QCursor::pos();
        QPoint localPos = mapFromGlobal(globalPos);
        
        // 1. 寻找当前鼠标所在的屏幕捕捉
        const ScreenCapture* currentCap = nullptr;
        for (const auto& cap : m_captures) {
            if (cap.geometry.contains(globalPos)) {
                currentCap = &cap;
                break;
            }
        }
        if (!currentCap && !m_captures.isEmpty()) currentCap = &m_captures[0];
        if (!currentCap) return;

        // 2. 绘制所有屏幕背景 (保持相对位置)
        for (const auto& cap : m_captures) {
            p.drawPixmap(cap.geometry.topLeft() - geometry().topLeft(), cap.pixmap);
        }

        // 3. 采样颜色：使用物理像素坐标，使用 qFloor 确保对齐
        QPoint relativePos = globalPos - currentCap->geometry.topLeft();
        // [CRITICAL] 精确采样坐标计算：必须结合 DPR 并使用 qFloor，防止缩放环境下采样点发生亚像素偏移。
        QPoint pixelPos(qFloor(relativePos.x() * currentCap->dpr), qFloor(relativePos.y() * currentCap->dpr));
        
        QColor centerColor = Qt::black;
        if (pixelPos.x() >= 0 && pixelPos.x() < currentCap->image.width() && 
            pixelPos.y() >= 0 && pixelPos.y() < currentCap->image.height()) {
            centerColor = currentCap->image.pixelColor(pixelPos);
        }
        centerColor.setAlpha(255); // 强制不透明，确保预览颜色准确
        m_currentColorHex = centerColor.name().toUpper();

        // 4. 更新光标样式为针筒
        QString syringeColor = (centerColor.lightness() > 128) ? "#000000" : "#FFFFFF";
        if (syringeColor != m_lastSyringeColor) {
            QPixmap syringe = IconHelper::getIcon("screen_picker", syringeColor).pixmap(32, 32);
            setCursor(QCursor(syringe, 3, 29)); // 针尖对准点击位置
            m_lastSyringeColor = syringeColor;
        }

        // 5. 绘制放大镜
        int grabRadius = 8;
        int grabSize = grabRadius * 2 + 1;
        int lensSize = 160; 
        
        int lensX = localPos.x() + 25;
        int lensY = localPos.y() + 25;
        if (lensX + lensSize > width()) lensX = localPos.x() - lensSize - 25;
        if (lensY + lensSize > height()) lensY = localPos.y() - lensSize - 25;

        QRect lensRect(lensX, lensY, lensSize, lensSize);
        p.setRenderHint(QPainter::Antialiasing);

        p.setPen(Qt::NoPen);
        p.setBrush(QColor(0, 0, 0, 150));
        p.drawRoundedRect(lensRect.adjusted(3, 3, 3, 3), 10, 10);

        QPainterPath path;
        path.addRoundedRect(lensRect, 10, 10);
        // 核心修复：移除暗色背景填充，改用黑色底色，并确保像素网格完全覆盖
        p.fillPath(path, Qt::black); 
        p.setPen(QPen(QColor(100, 100, 100), 2));
        p.drawPath(path);

        // 绘制像素网格 (确保采样源一致且不透明)
        p.save();
        QRect gridArea = lensRect.adjusted(2, 2, -2, -50);
        p.setClipRect(gridArea);
        // [CRITICAL] 核心修复：必须关闭抗锯齿，防止高 DPI 下像素块边缘颜色插值导致采样色变暗或模糊。
        p.setRenderHint(QPainter::Antialiasing, false);
        // [CRITICAL] 核心修复：必须清除之前的画刷残留，否则 drawRect 会使用旧的半透明阴影画刷对像素格进行二次填充。
        p.setBrush(Qt::NoBrush);

        for(int j = 0; j < grabSize; ++j) {
            for(int i = 0; i < grabSize; ++i) {
                int px = pixelPos.x() + i - grabRadius;
                int py = pixelPos.y() + j - grabRadius;
                QColor c = Qt::black;
                if (px >= 0 && px < currentCap->image.width() && py >= 0 && py < currentCap->image.height()) {
                    c = currentCap->image.pixelColor(px, py);
                }
                c.setAlpha(255);
                
                int x1 = gridArea.left() + i * gridArea.width() / grabSize;
                int x2 = gridArea.left() + (i + 1) * gridArea.width() / grabSize;
                int y1 = gridArea.top() + j * gridArea.height() / grabSize;
                int y2 = gridArea.top() + (j + 1) * gridArea.height() / grabSize;
                
                p.fillRect(x1, y1, x2 - x1, y2 - y1, c);
                p.setPen(QPen(QColor(255, 255, 255, 15), 1));
                p.drawRect(x1, y1, x2 - x1, y2 - y1);
            }
        }
        
        // 中心高亮框，同样使用精确计算的坐标
        int cx1 = gridArea.left() + grabRadius * gridArea.width() / grabSize;
        int cx2 = gridArea.left() + (grabRadius + 1) * gridArea.width() / grabSize;
        int cy1 = gridArea.top() + grabRadius * gridArea.height() / grabSize;
        int cy2 = gridArea.top() + (grabRadius + 1) * gridArea.height() / grabSize;
        p.setPen(QPen(Qt::red, 2));
        p.drawRect(cx1, cy1, cx2 - cx1, cy2 - cy1);
        p.restore();

        // 信息栏：预览色块必须与 centerColor 完全一致
        QRect infoRect = lensRect;
        infoRect.setTop(lensRect.bottom() - 50);
        p.setPen(QPen(QColor(176, 176, 176), 1));
        p.drawLine(infoRect.left(), infoRect.top(), infoRect.right(), infoRect.top());

        QRect colorRect(infoRect.left() + 10, infoRect.top() + 12, 26, 26);
        p.setBrush(centerColor); // 使用 Brush 确保填充效果
        p.setPen(QPen(Qt::white, 1));
        p.drawRect(colorRect);

        p.setPen(Qt::white);
        p.setRenderHint(QPainter::TextAntialiasing);
        QFont font = p.font();
        font.setBold(true);
        font.setPixelSize(14);
        p.setFont(font);
        p.drawText(infoRect.left() + 45, infoRect.top() + 22, m_currentColorHex);

        font.setPixelSize(11);
        font.setBold(false);
        p.setFont(font);
        QString rgbText = QString("RGB: %1, %2, %3").arg(centerColor.red()).arg(centerColor.green()).arg(centerColor.blue());
        p.drawText(infoRect.left() + 45, infoRect.top() + 40, rgbText);
    }

private:
    void cancelPicker() {
        releaseMouse();
        releaseKeyboard();
        close();
    }

    std::function<void(QString)> m_callback;
    QString m_currentColorHex = "#FFFFFF";
    QString m_lastSyringeColor;
    QList<ScreenCapture> m_captures;
};


// ----------------------------------------------------------------------------
// ColorWheel: 基于 HSV 的圆形色轮
// ----------------------------------------------------------------------------
class ColorWheel : public QWidget {
    Q_OBJECT
public:
    explicit ColorWheel(QWidget* parent = nullptr) : QWidget(parent) {
        setFixedSize(320, 320);
        // [FIX] 使用 ARGB32_Premultiplied 支持透明背景，Format_RGB32 会导致 transparent 变成黑色
        m_wheelImg = QImage(320, 320, QImage::Format_ARGB32_Premultiplied);
        m_wheelImg.fill(Qt::transparent);
        
        int center = 160;
        int radius = 150;
        for (int y = 0; y < 320; ++y) {
            for (int x = 0; x < 320; ++x) {
                int dx = x - center;
                // [FIX] 翻转 y 轴，使得红色(0度)在右侧，与其通常习惯一致（可选，保持原样也可，这里仅优化计算）
                int dy = y - center; 
                double dist = std::sqrt((double)dx*dx + (double)dy*dy);
                
                // [FIX] 增加简单的边缘抗锯齿 (1px 范围内 alpha 渐变)
                if (dist <= radius + 1.0) {
                    double angle = std::atan2((double)dy, (double)dx);
                    double hue = (angle + M_PI) / (2 * M_PI);
                    double sat = dist / radius;
                    if (sat > 1.0) sat = 1.0; // clamp for internal correctness within AA region

                    QColor c = QColor::fromHsvF(hue, sat, 1.0);
                    
                    // 边缘平滑处理
                    if (dist > radius - 1.0) {
                        double alpha = (radius + 1.0 - dist) / 2.0; // Simple linear falloff
                        if (alpha > 1.0) alpha = 1.0;
                        if (alpha < 0.0) alpha = 0.0;
                        c.setAlphaF(alpha);
                    }
                    
                    m_wheelImg.setPixelColor(x, y, c);
                }
            }
        }
    }

signals:
    void colorChanged(double hue, double sat);

protected:
    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        p.setRenderHint(QPainter::Antialiasing); // [FIX] 开启抗锯齿，让选中点圆圈更平滑
        p.drawImage(0, 0, m_wheelImg);
        if (m_hue >= 0) {
            int center = 160;
            int radius = 150;
            double angle = m_hue * 2 * M_PI - M_PI;
            double dist = m_sat * radius;
            int cx = center + std::cos(angle) * dist;
            int cy = center + std::sin(angle) * dist;
            p.setPen(QPen(Qt::black, 2));
            p.setBrush(Qt::white);
            p.drawEllipse(QPoint(cx, cy), 6, 6);
        }
    }

    void mousePressEvent(QMouseEvent* event) override { handleMouse(event); }
    void mouseMoveEvent(QMouseEvent* event) override { if (event->buttons() & Qt::LeftButton) handleMouse(event); }

private:
    void handleMouse(QMouseEvent* event) {
        int center = 160;
        int dx = event->pos().x() - center;
        int dy = event->pos().y() - center;
        double dist = std::sqrt((double)dx*dx + (double)dy*dy);
        if (dist <= 160) {
            double angle = std::atan2((double)dy, (double)dx);
            m_hue = (angle + M_PI) / (2 * M_PI);
            m_sat = std::min(dist / 150.0, 1.0);
            emit colorChanged(m_hue, m_sat);
            update();
        }
    }
    QImage m_wheelImg;
    double m_hue = 0.0;
    double m_sat = 0.0;
};

// ----------------------------------------------------------------------------
// ColorPickerDialog: 独立选色弹窗
// ----------------------------------------------------------------------------
class ColorPickerDialog : public QDialog {
    Q_OBJECT
public:
    ColorPickerDialog(QWidget* parent, std::function<void(QString)> callback) 
        : QDialog(parent, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool), m_callback(callback) 
    {
        setFixedSize(500, 600);
        setAttribute(Qt::WA_TranslucentBackground);
        
        auto* container = new QWidget(this);
        container->setObjectName("container");
        container->setStyleSheet("QWidget#container { background: #1a1a1a; border-radius: 15px; border: 1px solid #444; }");
        auto* mainL = new QVBoxLayout(this);
        mainL->setContentsMargins(0,0,0,0);
        mainL->addWidget(container);

        auto* l = new QVBoxLayout(container);
        l->setContentsMargins(20, 20, 20, 20);
        l->setSpacing(15);

        auto* headerLayout = new QHBoxLayout();
        // [FIX] 使用占位控件平衡右侧关闭按钮，确保标题视觉绝对居中
        auto* spacerBtn = new QWidget();
        spacerBtn->setFixedSize(28, 28);
        spacerBtn->setStyleSheet("background: transparent;");
        headerLayout->addWidget(spacerBtn);

        headerLayout->addStretch();
        auto* title = new QLabel("颜色选择器");
        title->setStyleSheet("color: white; font-weight: bold; font-size: 16px; border: none; background: transparent;");
        headerLayout->addWidget(title);
        headerLayout->addStretch();

        auto* closeTopBtn = new QPushButton();
        closeTopBtn->setFixedSize(28, 28);
        closeTopBtn->setIcon(IconHelper::getIcon("close", "#aaaaaa", 16));
        closeTopBtn->setCursor(Qt::PointingHandCursor);
        closeTopBtn->setStyleSheet("QPushButton { background: transparent; border-radius: 4px; border: none; } QPushButton:hover { background-color: #E81123; }");
        connect(closeTopBtn, &QPushButton::clicked, this, &QDialog::reject);
        headerLayout->addWidget(closeTopBtn);

        l->addLayout(headerLayout);

        m_wheel = new ColorWheel();
        connect(m_wheel, &ColorWheel::colorChanged, this, &ColorPickerDialog::onWheelChanged);
        l->addWidget(m_wheel, 0, Qt::AlignCenter);

        auto* bRow = new QHBoxLayout();
        auto* blbl = new QLabel("亮度:");
        blbl->setStyleSheet("color: white; border: none; background: transparent;");
        bRow->addWidget(blbl);
        m_brightSlider = new QSlider(Qt::Horizontal);
        m_brightSlider->setRange(0, 100);
        m_brightSlider->setValue(100);
        m_brightSlider->setStyleSheet("QSlider::groove:horizontal { height: 6px; background: #444; border-radius: 3px; } QSlider::handle:horizontal { background: white; width: 16px; margin: -5px 0; border-radius: 8px; }");
        connect(m_brightSlider, &QSlider::valueChanged, this, &ColorPickerDialog::updatePreview);
        bRow->addWidget(m_brightSlider);
        l->addLayout(bRow);

        m_preview = new QFrame();
        m_preview->setFixedHeight(60);
        m_preview->setStyleSheet("border-radius: 10px; background: white; border: 1px solid #555;");
        auto* pl = new QVBoxLayout(m_preview);
        m_hexLabel = new QLabel("#FFFFFF");
        m_hexLabel->setStyleSheet("color: #1a1a1a; font-weight: bold; font-size: 18px; border: none; background: transparent;");
        m_hexLabel->setAlignment(Qt::AlignCenter);
        pl->addWidget(m_hexLabel);
        l->addWidget(m_preview);

        auto* btnRow = new QHBoxLayout();
        auto* btnClose = new QPushButton("取消");
        btnClose->setAutoDefault(false);
        btnClose->setFixedHeight(36);
        btnClose->setStyleSheet("background: #444; color: white; border-radius: 6px; border: none;");
        connect(btnClose, &QPushButton::clicked, this, &QDialog::reject);
        btnRow->addWidget(btnClose);
        
        auto* btnConfirm = new QPushButton("确认选择");
        btnConfirm->setAutoDefault(false);
        btnConfirm->setFixedHeight(36);
        btnConfirm->setStyleSheet("background: #3b8ed0; color: white; border-radius: 6px; border: none; font-weight: bold;");
        connect(btnConfirm, &QPushButton::clicked, this, &ColorPickerDialog::onConfirm);
        btnRow->addWidget(btnConfirm);
        l->addLayout(btnRow);
    }

private slots:
    void onWheelChanged(double h, double s) { m_hue = h; m_sat = s; updatePreview(); }
    void updatePreview() {
        QColor c = QColor::fromHsvF(m_hue, m_sat, m_brightSlider->value() / 100.0);
        m_selectedHex = c.name().toUpper();
        m_preview->setStyleSheet(QString("border-radius: 10px; background: %1; border: 1px solid #555;").arg(m_selectedHex));
        m_hexLabel->setText(m_selectedHex);
        m_hexLabel->setStyleSheet(QString("color: %1; font-weight: bold; font-size: 18px; border: none; background: transparent;")
            .arg(c.lightness() > 128 ? "#1a1a1a" : "white"));
    }
    void onConfirm() { m_callback(m_selectedHex); accept(); }

private:
    std::function<void(QString)> m_callback;
    ColorWheel* m_wheel;
    QSlider* m_brightSlider;
    QFrame* m_preview;
    QLabel* m_hexLabel;
    double m_hue = 0, m_sat = 0;
    QString m_selectedHex = "#FFFFFF";
};

// ----------------------------------------------------------------------------
// ColorPickerWindow 实现
// ----------------------------------------------------------------------------

ColorPickerWindow::ColorPickerWindow(QWidget* parent)
    : FramelessDialog("颜色提取器", parent)
{
    setObjectName("ColorPickerWindow");
    setWindowTitle("颜色提取器");
    // [CRITICAL] 缩小窗口默认大小以适应更多屏幕。从 1400x900 调整。
    resize(1000, 750);
    setMinimumSize(850, 600);
    setAcceptDrops(true);
    m_favorites = loadFavorites();
    loadWindowSettings();
    initUI();
    QSettings s("RapidNotes", "ColorPicker");
    QString lastColor = s.value("lastColor", "#D64260").toString();
    useColor(lastColor);
}

ColorPickerWindow::~ColorPickerWindow() {
    saveFavorites();
}

void ColorPickerWindow::initUI() {
    setStyleSheet(R"(
        QWidget { font-family: "Microsoft YaHei", "Segoe UI", sans-serif; color: #E0E0E0; }
        QLineEdit { background-color: #2A2A2A; border: 1px solid #444; color: #FFFFFF; border-radius: 6px; padding: 4px; font-weight: bold; }
        QLineEdit:focus { border: 1px solid #3b8ed0; }
        QPushButton { background-color: #333; border: 1px solid #444; border-radius: 4px; padding: 6px; outline: none; }
        QPushButton:hover { background-color: #444; }
        QPushButton:pressed { background-color: #222; }
        QScrollArea { background: transparent; border: none; }
        QScrollBar:vertical { background: transparent; width: 8px; }
        QScrollBar::handle:vertical { background: #444; border-radius: 4px; min-height: 20px; }
        QScrollBar::handle:vertical:hover { background: #555; }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }
    )");

    auto* mainVLayout = new QVBoxLayout(m_contentArea);
    mainVLayout->setContentsMargins(20, 20, 20, 20);
    mainVLayout->setSpacing(15);

    // --- 第一排：颜色预览 ①、输入框 ②、输入框 ③、工具按钮 ④ ---
    auto* row1 = new QHBoxLayout();
    row1->setSpacing(10);

    // ① 颜色预览 (200x50)
    auto* previewContainer = new QFrame();
    previewContainer->setFixedSize(200, 50);
    previewContainer->setStyleSheet("background: #1e1e1e; border-radius: 8px; border: 1px solid #333;");
    auto* pl = new QVBoxLayout(previewContainer);
    pl->setContentsMargins(2, 2, 2, 2);
    m_colorDisplay = new QWidget();
    m_colorDisplay->setObjectName("mainPreview");
    m_colorDisplay->setStyleSheet("border-radius: 6px; background: #D64260;");
    auto* cl = new QVBoxLayout(m_colorDisplay);
    cl->setContentsMargins(0, 0, 0, 0);
    m_colorLabel = new QLabel("#D64260");
    m_colorLabel->setCursor(Qt::PointingHandCursor);
    m_colorLabel->setAlignment(Qt::AlignCenter);
    m_colorLabel->setStyleSheet("font-family: Consolas; font-size: 18px; font-weight: bold; border: none; background: transparent;");
    // m_colorLabel->setToolTip("当前 HEX 颜色");
    m_colorLabel->setProperty("tooltipText", "当前 HEX 颜色");
    m_colorLabel->installEventFilter(this);
    cl->addWidget(m_colorLabel);
    pl->addWidget(m_colorDisplay);
    row1->addWidget(previewContainer);

    // ② HEX 框 (含复制按钮)
    auto* hexLayout = new QHBoxLayout();
    hexLayout->setSpacing(2);
    m_hexEntry = new QLineEdit();
    m_hexEntry->setPlaceholderText("HEX");
    m_hexEntry->setFixedWidth(80);
    m_hexEntry->setFixedHeight(36);
    m_hexEntry->setAlignment(Qt::AlignCenter);
    // m_hexEntry->setToolTip("输入 HEX 代码并回车应用");
    m_hexEntry->setProperty("tooltipText", "输入 HEX 代码并回车应用");
    m_hexEntry->installEventFilter(this);
    connect(m_hexEntry, &QLineEdit::returnPressed, this, &ColorPickerWindow::applyHexColor);
    hexLayout->addWidget(m_hexEntry);
    
    auto* btnCopyHex = new QPushButton();
    btnCopyHex->setAutoDefault(false);
    btnCopyHex->setIcon(IconHelper::getIcon("copy", "#CCCCCC"));
    btnCopyHex->setFixedSize(28, 36);
    // btnCopyHex->setToolTip("复制 HEX 代码");
    btnCopyHex->setProperty("tooltipText", "复制 HEX 代码");
    btnCopyHex->installEventFilter(this);
    btnCopyHex->setStyleSheet("QPushButton { background: transparent; border: none; } QPushButton:hover { background: rgba(255,255,255,0.1); }");
    connect(btnCopyHex, &QPushButton::clicked, this, &ColorPickerWindow::copyHexValue);
    hexLayout->addWidget(btnCopyHex);
    row1->addLayout(hexLayout);

    // ③ RGB 框 (含复制按钮)
    auto* rgbContainer = new QWidget();
    rgbContainer->setFixedHeight(36);
    auto* rl = new QHBoxLayout(rgbContainer);
    rl->setContentsMargins(0, 0, 0, 0); rl->setSpacing(2);
    m_rEntry = new QLineEdit(); m_rEntry->setFixedWidth(35); m_rEntry->setFixedHeight(36); m_rEntry->setAlignment(Qt::AlignCenter); m_rEntry->setPlaceholderText("R");
    m_gEntry = new QLineEdit(); m_gEntry->setFixedWidth(35); m_gEntry->setFixedHeight(36); m_gEntry->setAlignment(Qt::AlignCenter); m_gEntry->setPlaceholderText("G");
    m_bEntry = new QLineEdit(); m_bEntry->setFixedWidth(35); m_bEntry->setFixedHeight(36); m_bEntry->setAlignment(Qt::AlignCenter); m_bEntry->setPlaceholderText("B");
    connect(m_rEntry, &QLineEdit::returnPressed, this, &ColorPickerWindow::applyRgbColor);
    connect(m_gEntry, &QLineEdit::returnPressed, this, &ColorPickerWindow::applyRgbColor);
    connect(m_bEntry, &QLineEdit::returnPressed, this, &ColorPickerWindow::applyRgbColor);
    rl->addWidget(m_rEntry);
    rl->addWidget(m_gEntry);
    rl->addWidget(m_bEntry);
    
    auto* btnCopyRgb = new QPushButton();
    btnCopyRgb->setAutoDefault(false);
    btnCopyRgb->setIcon(IconHelper::getIcon("copy", "#CCCCCC"));
    btnCopyRgb->setFixedSize(28, 36);
    // btnCopyRgb->setToolTip("复制 RGB 代码");
    btnCopyRgb->setProperty("tooltipText", "复制 RGB 代码");
    btnCopyRgb->installEventFilter(this);
    btnCopyRgb->setStyleSheet("QPushButton { background: transparent; border: none; } QPushButton:hover { background: rgba(255,255,255,0.1); }");
    connect(btnCopyRgb, &QPushButton::clicked, this, &ColorPickerWindow::copyRgbValue);
    rl->addWidget(btnCopyRgb);
    row1->addWidget(rgbContainer);

    // ④ 工具按钮 (整合进首排)
    auto* toolsLayout = new QHBoxLayout();
    toolsLayout->setSpacing(6);
    auto createToolBtn = [&](const QString& iconName, std::function<void()> cmd, QString color, QString tip) {
        auto* btn = new QPushButton();
        btn->setAutoDefault(false);
        btn->setIcon(IconHelper::getIcon(iconName, "#FFFFFF"));
        btn->setIconSize(QSize(18, 18));
        btn->setFixedSize(36, 36);
        btn->setStyleSheet(QString("QPushButton { background: %1; border: none; border-radius: 6px; } QPushButton:hover { opacity: 0.8; }").arg(color));
        // btn->setToolTip(tip);
        btn->setProperty("tooltipText", tip);
        btn->installEventFilter(this);
        connect(btn, &QPushButton::clicked, cmd);
        toolsLayout->addWidget(btn);
    };
    createToolBtn("palette", [this](){ openColorPicker(); }, "#3b8ed0", "色轮");
    createToolBtn("screen_picker", [this](){ startScreenPicker(); }, "#9b59b6", "吸色器");
    createToolBtn("pixel_ruler", [this](){ openPixelRuler(); }, "#e67e22", "标尺");
    createToolBtn("image", [this](){ extractFromImage(); }, "#2ecc71", "提取图片");
    createToolBtn("star", [this](){ addToFavorites(); }, "#f39c12", "收藏");
    row1->addLayout(toolsLayout);
    
    row1->addStretch();
    mainVLayout->addLayout(row1);

    // --- 第二排：渐变生成器 ⑤ (摊平成一行) ---
    auto* gradBox = new QFrame();
    gradBox->setObjectName("gradBox");
    gradBox->setFixedHeight(50);
    gradBox->setStyleSheet("QFrame#gradBox { background: #252526; border-radius: 8px; border: 1px solid #383838; }");
    auto* gl = new QHBoxLayout(gradBox);
    gl->setContentsMargins(15, 0, 15, 0);
    gl->setSpacing(8);

    auto* gt = new QLabel("渐变生成器");
    gt->setStyleSheet("font-weight: bold; font-size: 12px; color: #888; background: transparent;");
    gl->addWidget(gt);

    auto addGradInput = [&](const QString& label, QLineEdit*& entry, int width) {
        auto* lbl = new QLabel(label);
        lbl->setStyleSheet("font-size: 11px; color: #666; background: transparent;");
        gl->addWidget(lbl);
        entry = new QLineEdit();
        entry->setFixedWidth(width);
        entry->setFixedHeight(28);
        gl->addWidget(entry);
    };
    addGradInput("起始", m_gradStart, 80);
    addGradInput("结束", m_gradEnd, 80);
    
    auto* stepslbl = new QLabel("步数");
    stepslbl->setStyleSheet("color: #666; font-size: 11px; background: transparent; border: none;");
    gl->addWidget(stepslbl);
    
    m_gradSteps = new QLineEdit("7");
    m_gradSteps->setFixedWidth(77);
    m_gradSteps->setFixedHeight(28);
    m_gradSteps->setAlignment(Qt::AlignCenter);
    gl->addWidget(m_gradSteps);
    
    auto* sl = new QVBoxLayout();
    sl->setContentsMargins(0, 4, 0, 4);
    sl->setSpacing(0);
    
    QString spinBtnStyle = "QPushButton { background: transparent; border: none; padding: 0px; margin: 0px; } "
                           "QPushButton:hover { background: rgba(255, 255, 255, 0.1); border-radius: 2px; }";

    auto* btnUp = new QPushButton();
    btnUp->setFixedSize(16, 12);
    btnUp->setCursor(Qt::PointingHandCursor);
    btnUp->setIcon(IconHelper::getIcon("arrow_up", "#aaaaaa", 12));
    btnUp->setIconSize(QSize(12, 12));
    btnUp->setStyleSheet(spinBtnStyle);
    connect(btnUp, &QPushButton::clicked, [this](){
        int val = m_gradSteps->text().toInt();
        m_gradSteps->setText(QString::number(val + 1));
    });
    
    auto* btnDown = new QPushButton();
    btnDown->setFixedSize(16, 12);
    btnDown->setCursor(Qt::PointingHandCursor);
    btnDown->setIcon(IconHelper::getIcon("arrow_down", "#aaaaaa", 12));
    btnDown->setIconSize(QSize(12, 12));
    btnDown->setStyleSheet(spinBtnStyle);
    connect(btnDown, &QPushButton::clicked, [this](){
        int val = m_gradSteps->text().toInt();
        if (val > 2) m_gradSteps->setText(QString::number(val - 1));
    });
    
    sl->addWidget(btnUp);
    sl->addWidget(btnDown);
    
    gl->addSpacing(-6); 
    gl->addLayout(sl);

    gl->addSpacing(5);
    auto createModeBtn = [&](const QString& mode) {
        auto* btn = new QPushButton(mode);
        btn->setAutoDefault(false);
        btn->setCheckable(true);
        btn->setFixedWidth(45);
        btn->setFixedHeight(26);
        btn->setStyleSheet(
            "QPushButton { background: #333; border: 1px solid #444; border-radius: 4px; font-size: 11px; padding: 0; } "
            "QPushButton:hover { background: #444; } "
            "QPushButton:checked { background: #007ACC; color: white; border-color: #007ACC; }"
        );
        if (m_gradMode == mode) btn->setChecked(true);
        connect(btn, &QPushButton::clicked, [this, mode, gradBox](){
            m_gradMode = mode;
            for(auto* b : gradBox->findChildren<QPushButton*>()) {
                if(b->isCheckable()) b->setChecked(b->text() == mode);
            }
        });
        return btn;
    };
    gl->addWidget(createModeBtn("变暗"));
    gl->addWidget(createModeBtn("变亮"));
    gl->addWidget(createModeBtn("饱和"));

    auto* btnGrad = new QPushButton("生成渐变");
    btnGrad->setAutoDefault(false);
    btnGrad->setFixedSize(80, 28);
    btnGrad->setStyleSheet("background: #007ACC; font-weight: bold; color: white; border: none; border-radius: 4px;");
    connect(btnGrad, &QPushButton::clicked, this, &ColorPickerWindow::generateGradient);
    gl->addWidget(btnGrad);
    gl->addStretch();
    
    mainVLayout->addWidget(gradBox);

    // --- 图片预览区域 (从左侧面板移出，由逻辑触发显示) ---
    m_imagePreviewFrame = new QFrame();
    m_imagePreviewFrame->setObjectName("imagePreviewFrame");
    m_imagePreviewFrame->setStyleSheet("QFrame#imagePreviewFrame { background: #1e1e1e; border: 1px dashed #555; border-radius: 12px; }");
    m_imagePreviewFrame->setFixedHeight(120);
    auto* ipl = new QHBoxLayout(m_imagePreviewFrame);
    ipl->setContentsMargins(10, 5, 10, 5);
    m_imagePreviewLabel = new QLabel("暂无图片");
    m_imagePreviewLabel->setAlignment(Qt::AlignCenter);
    m_imagePreviewLabel->setStyleSheet("color: #666; border: none; background: transparent;");
    ipl->addWidget(m_imagePreviewLabel, 1);
    auto* btnClearImg = new QPushButton("重置图片提取");
    btnClearImg->setAutoDefault(false);
    btnClearImg->setFixedSize(120, 30);
    btnClearImg->setStyleSheet("color: #888; border: 1px solid #444; background: #2A2A2A; font-size: 11px; border-radius: 4px;");
    connect(btnClearImg, &QPushButton::clicked, [this](){
        m_imagePreviewFrame->hide();
        m_imagePreviewLabel->setPixmap(QPixmap());
        qDeleteAll(m_extractGridContainer->findChildren<QWidget*>(QString(), Qt::FindDirectChildrenOnly));
        m_dropHintContainer->show();
        showNotification("已重置图片提取");
    });
    ipl->addWidget(btnClearImg);
    mainVLayout->addWidget(m_imagePreviewFrame);
    m_imagePreviewFrame->hide();

    // --- 第三排：导航切换 ---
    auto* navBar = new QHBoxLayout();
    navBar->setSpacing(10);
    auto createNavBtn = [&](const QString& text) {
        auto* btn = new QPushButton(text);
        btn->setAutoDefault(false);
        btn->setFixedHeight(36);
        btn->setFixedWidth(120);
        btn->setStyleSheet(
            "QPushButton { background: #333; border-radius: 6px; font-weight: bold; border: 1px solid #444; } "
            "QPushButton:hover { background: #444; } "
            "QPushButton:checked { background: #007ACC; color: white; border-color: #007ACC; }"
        );
        btn->setCheckable(true);
        connect(btn, &QPushButton::clicked, [this, text, navBar, btn](){ 
            for(int i=0; i<navBar->count(); i++) {
                auto* b = qobject_cast<QPushButton*>(navBar->itemAt(i)->widget());
                if(b) b->setChecked(false);
            }
            btn->setChecked(true);
            switchView(text); 
        });
        if(text=="我的收藏") btn->setChecked(true);
        return btn;
    };
    navBar->addStretch();
    navBar->addWidget(createNavBtn("我的收藏"));
    navBar->addWidget(createNavBtn("渐变预览"));
    navBar->addWidget(createNavBtn("图片提取"));
    navBar->addStretch();
    mainVLayout->addLayout(navBar);

    // --- 第四排：内容区域 (Stacked Widget) ---
    createRightPanel(m_contentArea);
    mainVLayout->addWidget(m_stack, 1);
}

void ColorPickerWindow::createRightPanel(QWidget* parent) {
    m_stack = new QStackedWidget();
    auto createScroll = [&](QWidget*& content) {
        auto* scroll = new QScrollArea();
        scroll->setWidgetResizable(true);
        scroll->setFrameShape(QFrame::NoFrame);
        scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        content = new QWidget();
        content->setStyleSheet("background: transparent;");
        scroll->setWidget(content);
        return scroll;
    };
    m_favScroll = createScroll(m_favContent);
    m_gradScroll = createScroll(m_gradContent);
    m_extractScroll = createScroll(m_extractContent);
    
    auto* fl = new QVBoxLayout(m_favContent);
    fl->setContentsMargins(20, 20, 25, 20);
    fl->setSpacing(15);
    auto* ft = new QLabel("我的收藏");
    ft->setStyleSheet("font-size: 20px; font-weight: bold; color: white; border: none;");
    fl->addWidget(ft);
    
    m_favGridContainer = new QFrame();
    m_favGridContainer->setObjectName("cardContainer");
    m_favGridContainer->setStyleSheet("QFrame#cardContainer { background: #252526; border-radius: 12px; }");
    m_favGridContainer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    new FlowLayout(m_favGridContainer, 10, 5, 5); 
    fl->addWidget(m_favGridContainer);
    fl->addStretch();

    auto* gl = new QVBoxLayout(m_gradContent);
    gl->setContentsMargins(20, 20, 25, 20);
    gl->setSpacing(15);
    auto* gt = new QLabel("渐变预览");
    gt->setStyleSheet("font-size: 20px; font-weight: bold; color: white; border: none;");
    gl->addWidget(gt);

    auto* gt2 = new QLabel("生成结果 (左键应用 / 右键收藏)");
    gt2->setStyleSheet("font-weight: bold; font-size: 14px; border: none; background: transparent; color: #888;");
    gl->addWidget(gt2);

    m_gradGridContainer = new QFrame();
    m_gradGridContainer->setObjectName("cardContainer");
    m_gradGridContainer->setStyleSheet("QFrame#cardContainer { background: #252526; border-radius: 12px; }");
    m_gradGridContainer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    new FlowLayout(m_gradGridContainer, 10, 5, 5);
    gl->addWidget(m_gradGridContainer);
    gl->addStretch();

    auto* el = new QVBoxLayout(m_extractContent);
    el->setContentsMargins(20, 20, 25, 20);
    el->setSpacing(15);
    auto* et = new QLabel("图片提取");
    et->setStyleSheet("font-size: 20px; font-weight: bold; color: white; border: none;");
    el->addWidget(et);

    auto* et2 = new QLabel("提取结果 (左键应用 / 右键收藏)");
    et2->setStyleSheet("font-weight: bold; font-size: 14px; border: none; background: transparent; color: #888;");
    el->addWidget(et2);

    m_dropHintContainer = new QFrame();
    m_dropHintContainer->setStyleSheet("background: transparent; border: 3px dashed #555; border-radius: 15px;");
    m_dropHintContainer->setFixedHeight(300);
    auto* hl = new QVBoxLayout(m_dropHintContainer);
    hl->setAlignment(Qt::AlignCenter);
    
    auto* iconHint = new QLabel();
    iconHint->setPixmap(IconHelper::getIcon("image", "#444444").pixmap(64, 64));
    iconHint->setAlignment(Qt::AlignCenter);
    iconHint->setStyleSheet("border: none; background: transparent;");
    hl->addWidget(iconHint);

    auto* hint = new QLabel("拖放图片到软件任意位置\n\n或\n\nCtrl+V 粘贴\n点击左侧相机图标");
    hint->setStyleSheet("color: #666; font-size: 16px; border: none; background: transparent; margin-top: 10px;");
    hint->setAlignment(Qt::AlignCenter);
    hl->addWidget(hint);
    el->addWidget(m_dropHintContainer);

    m_extractGridContainer = new QFrame();
    m_extractGridContainer->setObjectName("cardContainer");
    m_extractGridContainer->setStyleSheet("QFrame#cardContainer { background: #252526; border-radius: 12px; }");
    m_extractGridContainer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    new FlowLayout(m_extractGridContainer, 10, 5, 5);
    el->addWidget(m_extractGridContainer);
    el->addStretch();

    m_stack->addWidget(m_favScroll);
    m_stack->addWidget(m_gradScroll);
    m_stack->addWidget(m_extractScroll);
    
    updateFavoritesDisplay();
}

void ColorPickerWindow::switchView(const QString& value) {
    if (value == "我的收藏") { m_stack->setCurrentWidget(m_favScroll); updateFavoritesDisplay(); }
    else if (value == "渐变预览") { m_stack->setCurrentWidget(m_gradScroll); }
    else if (value == "图片提取") { m_stack->setCurrentWidget(m_extractScroll); }
}

void ColorPickerWindow::updateColorDisplay() {
    m_colorDisplay->setStyleSheet(QString("border-radius: 6px; background: %1;").arg(m_currentColor));
    m_colorLabel->setText(m_currentColor);
    QColor c = hexToColor(m_currentColor);
    m_colorLabel->setStyleSheet(QString("font-family: Consolas; font-size: 18px; font-weight: bold; border: none; background: transparent; color: %1;")
        .arg(c.lightness() > 128 ? "#1a1a1a" : "white"));
    m_hexEntry->setText(m_currentColor);
    m_rEntry->setText(QString::number(c.red()));
    m_gEntry->setText(QString::number(c.green()));
    m_bEntry->setText(QString::number(c.blue()));
    if(m_gradStart->text().isEmpty()) m_gradStart->setText(m_currentColor);
}

void ColorPickerWindow::useColor(const QString& hex) {
    m_currentColor = hex.toUpper();
    QSettings s("RapidNotes", "ColorPicker");
    s.setValue("lastColor", m_currentColor);
    updateColorDisplay();
}

void ColorPickerWindow::applyHexColor() {
    QString h = m_hexEntry->text().trimmed();
    if (!h.startsWith("#")) h = "#" + h;
    QColor c(h);
    if (c.isValid()) useColor(c.name().toUpper());
    else showNotification("无效的 HEX 颜色代码", true);
}

void ColorPickerWindow::applyRgbColor() {
    int r = m_rEntry->text().toInt();
    int g = m_gEntry->text().toInt();
    int b = m_bEntry->text().toInt();
    QColor c(r, g, b);
    if (c.isValid()) useColor(c.name().toUpper());
    else showNotification("RGB 值必须在 0-255 之间", true);
}

void ColorPickerWindow::copyHexValue() {
    ClipboardMonitor::instance().forceNext();
    QApplication::clipboard()->setText(m_currentColor);
    showNotification("已复制 " + m_currentColor);
}

void ColorPickerWindow::copyRgbValue() {
    QColor c = hexToColor(m_currentColor);
    QString rgb = QString("rgb(%1, %2, %3)").arg(c.red()).arg(c.green()).arg(c.blue());
    ClipboardMonitor::instance().forceNext();
    QApplication::clipboard()->setText(rgb);
    showNotification("已复制 " + rgb);
}

void ColorPickerWindow::startScreenPicker() {
    auto* picker = new ScreenColorPickerOverlay([this](QString hex){
        useColor(hex);
        addSpecificColorToFavorites(hex);
    }, nullptr);
    picker->show();
}

void ColorPickerWindow::openPixelRuler() {
    auto* ruler = new PixelRulerOverlay(nullptr);
    ruler->setAttribute(Qt::WA_DeleteOnClose);
    ruler->show();
}

void ColorPickerWindow::openColorPicker() {
    auto* dlg = new ColorPickerDialog(this, [this](QString hex){ useColor(hex); });
    dlg->show();
}

void ColorPickerWindow::addToFavorites() {
    addSpecificColorToFavorites(m_currentColor);
}

void ColorPickerWindow::addSpecificColorToFavorites(const QString& color) {
    if (!m_favorites.contains(color)) {
        m_favorites.prepend(color);
        saveFavorites();
        updateFavoritesDisplay();
        showNotification("已收藏: " + color);

        // 同步存入数据库，以便全局查找
        QStringList tags;
        tags << "颜色" << "收藏" << "色码" << "色值" << "颜值" << "颜色码";
        if (color.startsWith("#")) tags << "HEX";
        
        DatabaseManager::instance().addNoteAsync(
            color,              // 标题用颜色码
            color,              // 内容用颜色码
            tags,               // 标签
            color,              // 笔记卡片背景色直接设为该颜色
            -1,                 // 默认分类
            "color"             // 类型设为 color
        );
    } else {
        showNotification(color + " 已在收藏中", true);
    }
}

void ColorPickerWindow::removeFavorite(const QString& color) {
    m_favorites.removeAll(color);
    saveFavorites();
    updateFavoritesDisplay();
}

void ColorPickerWindow::updateFavoritesDisplay() {
    auto* flow = qobject_cast<FlowLayout*>(m_favGridContainer->layout());
    if (!flow) return;
    
    QLayoutItem *child;
    while ((child = flow->takeAt(0)) != nullptr) {
        if (child->widget()) child->widget()->deleteLater();
        delete child;
    }
    
    if (m_favorites.isEmpty()) {
        auto* lbl = new QLabel("暂无收藏\n右键点击任何颜色块即可收藏");
        lbl->setStyleSheet("color: #666; font-size: 16px; border: none; background: transparent; padding: 40px;");
        lbl->setAlignment(Qt::AlignCenter);
        flow->addWidget(lbl);
        return;
    }

    for (int i = 0; i < m_favorites.size(); ++i) {
        QWidget* tile = createFavoriteTile(m_favGridContainer, m_favorites[i]);
        flow->addWidget(tile);
    }
    m_favGridContainer->updateGeometry();
}

QWidget* ColorPickerWindow::createFavoriteTile(QWidget* parent, const QString& colorHex) {
    auto* tile = new QFrame(parent);
    // [CRITICAL] 将收藏项改为 30*30 的纯色方块，视觉更整洁
    tile->setFixedSize(30, 30);
    
    tile->setStyleSheet(QString(
        "QFrame { background-color: %1; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); }"
        "QFrame:hover { border: 1px solid white; }"
    ).arg(colorHex));
    
    // 悬停显示 HEX 值
    // tile->setToolTip(colorHex);
    tile->setProperty("tooltipText", colorHex);
    tile->setCursor(Qt::PointingHandCursor);
    tile->setProperty("color", colorHex);
    tile->installEventFilter(this);

    return tile;
}

void ColorPickerWindow::generateGradient() {
    QString startHex = m_gradStart->text().trimmed();
    if (!startHex.startsWith("#")) startHex = "#" + startHex;
    QColor start = QColor(startHex);
    if (!start.isValid()) { showNotification("起始色无效", true); return; }
    QString endHex = m_gradEnd->text().trimmed();
    int steps = m_gradSteps->text().toInt();
    if (steps < 2) steps = 2;
    QStringList colors;
    if (endHex.isEmpty()) {
        float h, s, v;
        start.getHsvF(&h, &s, &v);
        for (int i = 0; i < steps; ++i) {
            double ratio = (double)i / (steps - 1);
            QColor c;
            if (m_gradMode == "变暗") c = QColor::fromHsvF(h, s, v * (1 - ratio * 0.7));
            else if (m_gradMode == "变亮") c = QColor::fromHsvF(h, s, v + (1 - v) * ratio);
            else if (m_gradMode == "饱和") c = QColor::fromHsvF(h, std::min(1.0f, std::max(0.0f, s + (1 - s) * (float)ratio * (s < 0.5f ? 1.0f : -1.0f))), v);
            colors << c.name().toUpper();
        }
    } else {
        if (!endHex.startsWith("#")) endHex = "#" + endHex;
        QColor end = QColor(endHex);
        if (!end.isValid()) { showNotification("结束色无效", true); return; }
        for (int i = 0; i < steps; ++i) {
            double r = (double)i / (steps - 1);
            int red = start.red() + (end.red() - start.red()) * r;
            int green = start.green() + (end.green() - start.green()) * r;
            int blue = start.blue() + (end.blue() - start.blue()) * r;
            colors << QColor(red, green, blue).name().toUpper();
        }
    }
    
    auto* flow = qobject_cast<FlowLayout*>(m_gradGridContainer->layout());
    if (!flow) return;

    QLayoutItem *child;
    while ((child = flow->takeAt(0)) != nullptr) {
        if (child->widget()) child->widget()->deleteLater();
        delete child;
    }
    
    for (int i = 0; i < colors.size(); ++i) {
        QWidget* tile = createColorTile(m_gradGridContainer, colors[i]);
        flow->addWidget(tile);
    }
    m_gradGridContainer->updateGeometry();
    switchView("渐变预览");
}

QWidget* ColorPickerWindow::createColorTile(QWidget* parent, const QString& colorHex) {
    auto* tile = new QFrame(parent);
    // 同步修改为 30*30 色块以保持视觉统一
    tile->setFixedSize(30, 30); 
    
    tile->setStyleSheet(QString(
        "QFrame { background-color: %1; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); }"
        "QFrame:hover { border: 1px solid white; }"
    ).arg(colorHex));
    
    // tile->setToolTip(colorHex);
    tile->setProperty("tooltipText", colorHex);
    tile->setCursor(Qt::PointingHandCursor);
    tile->setProperty("color", colorHex);
    tile->installEventFilter(this);
    
    return tile;
}

void ColorPickerWindow::extractFromImage() {
    QString path = QFileDialog::getOpenFileName(this, "选择图片", "", "Images (*.png *.jpg *.jpeg *.bmp *.webp)");
    if (!path.isEmpty()) processImage(path);
}

void ColorPickerWindow::processImage(const QString& filePath, const QImage& image) {
    m_currentImagePath = filePath;
    QImage img = image;
    if (img.isNull() && !filePath.isEmpty()) {
        img.load(filePath);
    }
    if (img.isNull()) return;

    m_imagePreviewFrame->show();
    m_imagePreviewLabel->setPixmap(QPixmap::fromImage(img).scaled(340, 180, Qt::KeepAspectRatio, Qt::SmoothTransformation));
    m_imagePreviewLabel->setText("");
    
    m_dropHintContainer->hide();
    m_extractGridContainer->show();

    auto* flow = qobject_cast<FlowLayout*>(m_extractGridContainer->layout());
    if (!flow) return;

    QLayoutItem *child;
    while ((child = flow->takeAt(0)) != nullptr) {
        if (child->widget()) child->widget()->deleteLater();
        delete child;
    }
    
    QStringList colors = extractDominantColors(img, 24);
    for (int i = 0; i < colors.size(); ++i) {
        QWidget* tile = createColorTile(m_extractGridContainer, colors[i]);
        flow->addWidget(tile);
    }
    m_extractGridContainer->updateGeometry();
    
    switchView("图片提取");
    showNotification("图片已加载，调色板生成完毕");
}

void ColorPickerWindow::pasteImage() {
    const QMimeData* mime = QApplication::clipboard()->mimeData();
    if (!mime) return;

    if (mime->hasImage()) {
        QImage img = qvariant_cast<QImage>(mime->imageData());
        if (!img.isNull()) {
            processImage("", img);
            return;
        }
    }
    
    if (mime->hasUrls()) {
        QString path = mime->urls().first().toLocalFile();
        if (!path.isEmpty()) {
            QImage img(path);
            if (!img.isNull()) {
                processImage(path, img);
                return;
            }
        }
    }

    if (mime->hasFormat("image/png") || mime->hasFormat("image/jpeg") || mime->hasFormat("image/bmp")) {
        QImage img;
        if (img.loadFromData(mime->data("image/png"), "PNG") || 
            img.loadFromData(mime->data("image/jpeg"), "JPG") ||
            img.loadFromData(mime->data("image/bmp"), "BMP")) {
            processImage("", img);
            return;
        }
    }

    showNotification("剪贴板中没有图片或格式不支持", true);
}

QStringList ColorPickerWindow::extractDominantColors(const QImage& img, int num) {
    QImage small = img.scaled(120, 120, Qt::IgnoreAspectRatio, Qt::FastTransformation).convertToFormat(QImage::Format_RGB32);
    QMap<QRgb, int> counts;
    for (int y = 0; y < small.height(); ++y) {
        for (int x = 0; x < small.width(); ++x) { counts[small.pixel(x, y)]++; }
    }
    QList<QRgb> sorted = counts.keys();
    std::sort(sorted.begin(), sorted.end(), [&](QRgb a, QRgb b){ return counts[a] > counts[b]; });
    
    QStringList result;
    for (QRgb rgb : sorted) {
        QColor c(rgb);
        bool distinct = true;
        for(const QString& ex : result) {
            QColor exc(ex);
            int diff = abs(exc.red() - c.red()) + abs(exc.green() - c.green()) + abs(exc.blue() - c.blue());
            if(diff < 20) { distinct = false; break; }
        }
        if(distinct) {
            result << c.name().toUpper(); 
            if (result.size() >= num) break;
        }
    }
    return result;
}

void ColorPickerWindow::showNotification(const QString& message, bool isError) {
    if (m_notification) {
        m_notification->hide();
        m_notification->deleteLater();
    }
    
    m_notification = new QFrame(this);
    m_notification->setObjectName("notification");
    m_notification->setStyleSheet(QString("QFrame#notification { background: %1; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); }")
        .arg(isError ? "#e74c3c" : "#2ecc71"));
    
    auto* l = new QHBoxLayout(m_notification);
    l->setContentsMargins(15, 8, 15, 8);
    l->setSpacing(10);
    
    auto* icon = new QLabel();
    icon->setPixmap(IconHelper::getIcon(isError ? "close" : "select", "#FFFFFF").pixmap(18, 18));
    icon->setStyleSheet("border: none; background: transparent;");
    l->addWidget(icon);
    
    auto* lbl = new QLabel(message);
    lbl->setStyleSheet("color: white; font-weight: bold; font-size: 13px; border: none; background: transparent;");
    l->addWidget(lbl);
    
    m_notification->adjustSize();
    m_notification->move(width()/2 - m_notification->width()/2, height() - 80);
    m_notification->show();
    m_notification->raise();
    
    QTimer::singleShot(2500, m_notification, &QWidget::hide);
}

void ColorPickerWindow::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls() || event->mimeData()->hasImage()) event->acceptProposedAction();
}

void ColorPickerWindow::dropEvent(QDropEvent* event) {
    if (event->mimeData()->hasImage()) {
        QImage img = qvariant_cast<QImage>(event->mimeData()->imageData());
        if (!img.isNull()) processImage("", img);
    } else if (event->mimeData()->hasUrls()) {
        processImage(event->mimeData()->urls().first().toLocalFile());
    }
}

void ColorPickerWindow::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_V && (event->modifiers() & Qt::ControlModifier)) pasteImage();
    else FramelessDialog::keyPressEvent(event);
}

void ColorPickerWindow::hideEvent(QHideEvent* event) {
    QList<QWidget*> overlays = findChildren<QWidget*>();
    for (auto* w : overlays) {
        if (qobject_cast<ScreenColorPickerOverlay*>(w) || qobject_cast<PixelRulerOverlay*>(w)) {
            w->close();
        }
    }
    FramelessDialog::hideEvent(event);
}

bool ColorPickerWindow::eventFilter(QObject* watched, QEvent* event) {
    if (event->type() == QEvent::HoverEnter) {
        QString text = watched->property("tooltipText").toString();
        if (!text.isEmpty()) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), text);
            return true;
        }
    } else if (event->type() == QEvent::HoverLeave) {
        ToolTipOverlay::hideTip();
    } else if (event->type() == QEvent::MouseMove) {
        // [FIX] 拦截色块的鼠标移动事件，防止冒泡到父窗口触发错误的拖拽逻辑导致窗口跳动
        if (!watched->property("color").toString().isEmpty()) {
            return true;
        }
    } else if (event->type() == QEvent::MouseButtonPress) {
        auto* me = static_cast<QMouseEvent*>(event);
        QString color = watched->property("color").toString();
        if (!color.isEmpty()) {
            if (me->button() == Qt::LeftButton) {
                useColor(color);
                ClipboardMonitor::instance().forceNext();
                QApplication::clipboard()->setText(color);
                showNotification("已应用并复制 " + color);
                return true;
            } else if (me->button() == Qt::RightButton) {
                // 右键弹出菜单，包含“从收藏中移除”
                showColorContextMenu(color, me->globalPosition().toPoint());
                return true;
            }
        } else if (watched == m_colorLabel) {
            if (me->button() == Qt::LeftButton) {
                // 根据用户要求：主预览标签点击不再自动复制，仅作展示
            } else if (me->button() == Qt::RightButton) {
                showColorContextMenu(m_currentColor, me->globalPosition().toPoint());
            }
            return true;
        }
    }
    return FramelessDialog::eventFilter(watched, event);
}

void ColorPickerWindow::showColorContextMenu(const QString& colorHex, const QPoint& globalPos) {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       "QMenu::item { padding: 6px 20px 6px 10px; border-radius: 3px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    menu.addAction(IconHelper::getIcon("copy", "#1abc9c", 18), "复制 HEX 代码", [this, colorHex]() {
        ClipboardMonitor::instance().forceNext();
        QApplication::clipboard()->setText(colorHex);
        showNotification("已复制 HEX: " + colorHex);
    });

    QColor c(colorHex);
    QString rgb = QString("rgb(%1, %2, %3)").arg(c.red()).arg(c.green()).arg(c.blue());
    menu.addAction(IconHelper::getIcon("copy", "#3498db", 18), "复制 RGB 代码", [this, rgb]() {
        ClipboardMonitor::instance().forceNext();
        QApplication::clipboard()->setText(rgb);
        showNotification("已复制 RGB: " + rgb);
    });

    if (m_favorites.contains(colorHex)) {
        menu.addAction(IconHelper::getIcon("close", "#e74c3c", 18), "从收藏中移除", [this, colorHex]() {
            removeFavorite(colorHex);
        });
    } else {
        menu.addAction(IconHelper::getIcon("star", "#f1c40f", 18), "收藏此颜色", [this, colorHex]() {
            addSpecificColorToFavorites(colorHex);
        });
    }

    if (!m_currentImagePath.isEmpty() && m_stack->currentWidget() == m_extractScroll) {
        menu.addSeparator();
        QString path = m_currentImagePath;
        
        menu.addAction(IconHelper::getIcon("link", "#9b59b6", 18), "复制图片路径", [this, path]() {
            ClipboardMonitor::instance().forceNext();
            QApplication::clipboard()->setText(path);
            showNotification("已复制路径");
        });

        menu.addAction(IconHelper::getIcon("file", "#34495e", 18), "复制图片文件", [path]() {
            QMimeData* data = new QMimeData;
            QList<QUrl> urls;
            urls << QUrl::fromLocalFile(path);
            data->setUrls(urls);
            ClipboardMonitor::instance().forceNext();
            QApplication::clipboard()->setMimeData(data);
        });

        menu.addAction(IconHelper::getIcon("search", "#e67e22", 18), "定位图片文件", [path]() {
            QProcess::startDetached("explorer.exe", { "/select,", QDir::toNativeSeparators(path) });
        });

        menu.addAction(IconHelper::getIcon("folder", "#f39c12", 18), "定位文件夹", [path]() {
            QFileInfo fi(path);
            QDesktopServices::openUrl(QUrl::fromLocalFile(fi.absolutePath()));
        });
    }

    menu.exec(globalPos);
}

QString ColorPickerWindow::rgbToHex(int r, int g, int b) { return QColor(r, g, b).name().toUpper(); }
QColor ColorPickerWindow::hexToColor(const QString& hex) { return QColor(hex); }
QString ColorPickerWindow::colorToHex(const QColor& c) { return c.name().toUpper(); }

QStringList ColorPickerWindow::loadFavorites() {
    QSettings s("RapidNotes", "ColorPicker");
    return s.value("favorites").toStringList();
}

void ColorPickerWindow::saveFavorites() {
    QSettings s("RapidNotes", "ColorPicker");
    s.setValue("favorites", m_favorites);
}

#include "ColorPickerWindow.moc"
```

## 文件: `src/ui/ColorPickerWindow.h`

```cpp
#ifndef COLORPICKERWINDOW_H
#define COLORPICKERWINDOW_H

#include "FramelessDialog.h"
#include <QPushButton>
#include <QLabel>
#include <QLineEdit>
#include <QListWidget>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QStackedWidget>
#include <QScrollArea>
#include <QTimer>
#include <QFrame>

/**
 * @brief 专业颜色管理器 Pro
 */
class ColorPickerWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit ColorPickerWindow(QWidget* parent = nullptr);
    ~ColorPickerWindow();

    void showNotification(const QString& message, bool isError = false);
    void useColor(const QString& hex);

public slots:
    void startScreenPicker();   

protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dropEvent(QDropEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void hideEvent(QHideEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

private slots:
    // 工具按钮槽
    void openColorPicker();      
    void openPixelRuler();      
    void extractFromImage();     
    void addToFavorites();       

    // 颜色更新槽
    void applyHexColor();
    void applyRgbColor();
    void copyHexValue();
    void copyRgbValue();
    
    // 渐变生成
    void generateGradient();

    // 视图切换
    void switchView(const QString& value);

    // 右键菜单
    void showColorContextMenu(const QString& colorHex, const QPoint& globalPos);

    // 图片处理
    void processImage(const QString& filePath, const QImage& image = QImage());
    void pasteImage();

private:
    void initUI();
    void createRightPanel(QWidget* parent);
    void updateColorDisplay();
    
    // 辅助组件创建
    QWidget* createColorTile(QWidget* parent, const QString& color);
    QWidget* createFavoriteTile(QWidget* parent, const QString& color);
    
    // 数据持久化
    QStringList loadFavorites();
    void saveFavorites();
    void updateFavoritesDisplay();
    void addSpecificColorToFavorites(const QString& color);
    void removeFavorite(const QString& color);

    // 颜色计算辅助
    QString rgbToHex(int r, int g, int b);
    QColor hexToColor(const QString& hex);
    QString colorToHex(const QColor& c);
    QStringList extractDominantColors(const QImage& img, int num);

    // --- UI 组件 ---
    // 左侧
    // [CRITICAL] 核心状态变量，记录当前吸取的颜色。
    QString m_currentColor = "#D64260";
    QWidget* m_colorDisplay;
    QLabel* m_colorLabel;
    QLineEdit* m_hexEntry;
    QLineEdit* m_rEntry;
    QLineEdit* m_gEntry;
    QLineEdit* m_bEntry;
    
    QLineEdit* m_gradStart;
    QLineEdit* m_gradEnd;
    QLineEdit* m_gradSteps;
    QString m_gradMode = "变暗";

    QWidget* m_imagePreviewFrame;
    QLabel* m_imagePreviewLabel;

    // 右侧
    QStackedWidget* m_stack;
    QScrollArea* m_favScroll;
    QScrollArea* m_gradScroll;
    QScrollArea* m_extractScroll;
    
    QWidget* m_favContent;
    QWidget* m_gradContent;
    QWidget* m_extractContent;
    
    QWidget* m_dropHintContainer;
    QWidget* m_favGridContainer;
    QWidget* m_gradGridContainer;
    QWidget* m_extractGridContainer;

    // 状态
    QString m_currentImagePath = "";
    // [CRITICAL] 收藏夹列表，持久化存储用户喜爱的颜色。
    QStringList m_favorites;
    QFrame* m_notification = nullptr;

};

#endif // COLORPICKERWINDOW_H
```

## 文件: `src/core/DatabaseManager.cpp`

```cpp
#include "DatabaseManager.h"
#include <QDebug>
#include <QSqlRecord>
#include <QCoreApplication>
#include <QDateTime>
#include <QFile>
#include <QDir>
#include <QCryptographicHash>
#include <QRandomGenerator>
#include <QRegularExpression>
#include <QFileInfo>
#include <QStandardPaths>
#include "FileCryptoHelper.h"

DatabaseManager& DatabaseManager::instance() {
    static DatabaseManager inst;
    return inst;
}

QStringList DatabaseManager::s_tagClipboard;
QMutex DatabaseManager::s_tagClipboardMutex;

void DatabaseManager::setTagClipboard(const QStringList& tags) {
    QMutexLocker locker(&s_tagClipboardMutex);
    s_tagClipboard = tags;
}

QStringList DatabaseManager::getTagClipboard() {
    QMutexLocker locker(&s_tagClipboardMutex);
    return s_tagClipboard;
}

DatabaseManager::DatabaseManager(QObject* parent) : QObject(parent) {}

DatabaseManager::~DatabaseManager() {
    if (m_db.isOpen()) {
        m_db.close();
    }
}

bool DatabaseManager::init(const QString& dbPath) {
    QMutexLocker locker(&m_mutex);
    
    // 1. 确定路径
    // 外壳路径: 程序目录下的 inspiration.db
    m_realDbPath = dbPath; 
    
    // 内核路径: 用户 AppData 目录 (隐藏路径，用户通常不会去删这里)
    QString appDataPath = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    if (appDataPath.isEmpty()) {
        appDataPath = QCoreApplication::applicationDirPath() + "/data";
    }
    QDir().mkpath(appDataPath);
    m_dbPath = appDataPath + "/rapidnotes_kernel.db";
    
    qDebug() << "[DB] 外壳路径 (Shell):" << m_realDbPath;
    qDebug() << "[DB] 内核路径 (Kernel):" << m_dbPath;

    // 2. 自动迁移逻辑 (Legacy support)
    QString legacyDbPath = QFileInfo(m_realDbPath).absolutePath() + "/notes.db";
    if (!QFile::exists(m_realDbPath) && QFile::exists(legacyDbPath) && !QFile::exists(m_dbPath)) {
        qDebug() << "[DB] 检测到旧版 notes.db，且无新版内核，正在自动迁移至新的三层保护体系...";
        if (QFile::copy(legacyDbPath, m_dbPath)) {
            qDebug() << "[DB] 旧版数据已拷贝至内核，等待退出时加密合壳。";
        }
    }

    // 3. 解壳加载逻辑
    bool kernelExists = QFile::exists(m_dbPath);
    bool shellExists = QFile::exists(m_realDbPath);

    if (kernelExists) {
        // 如果 AppData 下的内核还在，即使外壳被删了，也会从这里加载并“复活”外壳
        qDebug() << "[DB] 检测到残留内核文件 (可能是上次异常退出或仅删除了外壳)，优先加载以恢复数据。";
    } else if (shellExists) {
        qDebug() << "[DB] 发现外壳文件，尝试加载...";
        
        QString key = FileCryptoHelper::getCombinedKey();
        
        if (FileCryptoHelper::decryptFileWithShell(m_realDbPath, m_dbPath, key)) {
            qDebug() << "[DB] 现代解密成功。";
        } else {
            qDebug() << "[DB] 现代解密失败 (未发现魔数标记)，尝试旧版解密 (Legacy)...";
            if (FileCryptoHelper::decryptFileLegacy(m_realDbPath, m_dbPath, key)) {
                qDebug() << "[DB] 旧版解密成功。";
            } else {
                qDebug() << "[DB] 旧版解密也失败 (密码错误或数据损坏)，尝试明文检测...";
                QFile file(m_realDbPath);
                if (file.open(QIODevice::ReadOnly)) {
                    QByteArray header = file.read(16);
                    file.close();
                    if (header.startsWith("SQLite format 3")) {
                        qDebug() << "[DB] 检测到明文数据库，执行直接加载。";
                        QFile::copy(m_realDbPath, m_dbPath);
                    } else {
                        qCritical() << "[DB] 外壳文件已损坏或格式完全无法识别。";
                        return false;
                    }
                } else {
                    qCritical() << "[DB] 无法读取外壳文件。";
                    return false;
                }
            }
        }
    } else {
        qDebug() << "[DB] 未发现现有数据库及内核，将创建新数据库。";
    }

    // 4. 打开数据库
    if (m_db.isOpen()) m_db.close();
    
    QString connectionName = "RapidNotes_Main_Conn";
    if (QSqlDatabase::contains(connectionName)) {
        m_db = QSqlDatabase::database(connectionName);
    } else {
        m_db = QSqlDatabase::addDatabase("QSQLITE", connectionName);
    }
    
    m_db.setDatabaseName(m_dbPath);

    if (!m_db.open()) {
        qCritical() << "无法打开数据库内核:" << m_db.lastError().text();
        return false;
    }

    if (!createTables()) return false;

    return true;
}

void DatabaseManager::closeAndPack() {
    QMutexLocker locker(&m_mutex);
    
    QString connName = m_db.connectionName();
    if (m_db.isOpen()) {
        m_db.close();
    }
    m_db = QSqlDatabase(); 
    if (!connName.isEmpty()) {
        QSqlDatabase::removeDatabase(connName);
    }
    
    if (QFile::exists(m_dbPath)) {
        qDebug() << "[DB] 正在执行退出合壳 (将内核加密保存至外壳文件)...";
        if (FileCryptoHelper::encryptFileWithShell(m_dbPath, m_realDbPath, FileCryptoHelper::getCombinedKey())) {
            if (QFile::exists(m_realDbPath) && QFileInfo(m_realDbPath).size() > 0) {
                if (FileCryptoHelper::secureDelete(m_dbPath)) {
                    qDebug() << "[DB] 合壳完成，安全擦除内核文件。";
                }
            }
        } else {
            qCritical() << "[DB] 合壳失败！数据保留在内核文件中。";
        }
    }
}

bool DatabaseManager::createTables() {
    QSqlQuery query(m_db);
    QString createNotesTable = R"(
        CREATE TABLE IF NOT EXISTS notes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT,
            content TEXT,
            tags TEXT,
            color TEXT DEFAULT '#2d2d2d',
            category_id INTEGER,
            item_type TEXT DEFAULT 'text',
            data_blob BLOB,
            content_hash TEXT,
            rating INTEGER DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            is_pinned INTEGER DEFAULT 0,
            is_locked INTEGER DEFAULT 0,
            is_favorite INTEGER DEFAULT 0,
            is_deleted INTEGER DEFAULT 0,
            source_app TEXT,
            source_title TEXT,
            last_accessed_at DATETIME
        )
    )";
    if (!query.exec(createNotesTable)) return false;

    QString createCategoriesTable = R"(
        CREATE TABLE IF NOT EXISTS categories (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            parent_id INTEGER,
            color TEXT DEFAULT '#808080',
            sort_order INTEGER DEFAULT 0,
            preset_tags TEXT,
            password TEXT,
            password_hint TEXT
        )
    )";
    query.exec(createCategoriesTable);
    query.exec("CREATE TABLE IF NOT EXISTS tags (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE NOT NULL)");
    query.exec("CREATE TABLE IF NOT EXISTS note_tags (note_id INTEGER, tag_id INTEGER, PRIMARY KEY (note_id, tag_id))");
    query.exec("CREATE INDEX IF NOT EXISTS idx_notes_content_hash ON notes(content_hash)");
    QString createFtsTable = R"(
        CREATE VIRTUAL TABLE IF NOT EXISTS notes_fts USING fts5(
            title, content, content='notes', content_rowid='id'
        )
    )";
    query.exec(createFtsTable);

    // 试用期与使用次数表
    query.exec("CREATE TABLE IF NOT EXISTS system_config (key TEXT PRIMARY KEY, value TEXT)");
    
    // 初始化试用信息
    QSqlQuery checkLaunch(m_db);
    checkLaunch.prepare("SELECT value FROM system_config WHERE key = 'first_launch_date'");
    if (checkLaunch.exec() && !checkLaunch.next()) {
        QSqlQuery initQuery(m_db);
        initQuery.prepare("INSERT INTO system_config (key, value) VALUES ('first_launch_date', :date)");
        initQuery.bindValue(":date", QDateTime::currentDateTime().toString(Qt::ISODate));
        initQuery.exec();
        
        initQuery.prepare("INSERT INTO system_config (key, value) VALUES ('usage_count', '0')");
        initQuery.exec();
    }

    return true;
}

int DatabaseManager::addNote(const QString& title, const QString& content, const QStringList& tags,
                            const QString& color, int categoryId,
                            const QString& itemType, const QByteArray& dataBlob,
                            const QString& sourceApp, const QString& sourceTitle) {
    // 试用限制检查
    QVariantMap trial = getTrialStatus();
    if (trial["expired"].toBool() || trial["usage_limit_reached"].toBool()) {
        qWarning() << "[DB] 试用已结束或达到使用上限，停止新增灵感。";
        return 0;
    }

    QVariantMap newNoteMap;
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    QByteArray hashData = dataBlob.isEmpty() ? content.toUtf8() : dataBlob;
    QString contentHash = QCryptographicHash::hash(hashData, QCryptographicHash::Sha256).toHex();
    {   
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return 0;

        QString finalColor = color.isEmpty() ? "#2d2d2d" : color;
        QStringList finalTags = tags;

        // 查重：如果内容已存在，则更新标题和标签
        QSqlQuery checkQuery(m_db);
        checkQuery.prepare("SELECT id FROM notes WHERE content_hash = :hash AND is_deleted = 0 LIMIT 1");
        checkQuery.bindValue(":hash", contentHash);
        if (checkQuery.exec() && checkQuery.next()) {
            int existingId = checkQuery.value(0).toInt();

            QSqlQuery updateQuery(m_db);
            // [CRITICAL] 重复内容时，旧的标题和标签直接“不理会”，更新为当前的新标题和新标签
            updateQuery.prepare("UPDATE notes SET title = :title, tags = :tags, updated_at = :now, source_app = :app, source_title = :stitle WHERE id = :id");
            updateQuery.bindValue(":title", title);
            updateQuery.bindValue(":tags", finalTags.join(","));
            updateQuery.bindValue(":now", currentTime);
            updateQuery.bindValue(":app", sourceApp);
            updateQuery.bindValue(":stitle", sourceTitle);
            updateQuery.bindValue(":id", existingId);
            
            if (updateQuery.exec()) success = true;
            if (success) { 
                locker.unlock(); 
                emit noteUpdated(); 
                return existingId; 
            }
        }
        if (categoryId != -1) {
            QSqlQuery catQuery(m_db);
            catQuery.prepare("SELECT color, preset_tags FROM categories WHERE id = :id");
            catQuery.bindValue(":id", categoryId);
            if (catQuery.exec() && catQuery.next()) {
                if (color.isEmpty()) finalColor = catQuery.value(0).toString();
                QString preset = catQuery.value(1).toString();
                if (!preset.isEmpty()) {
                    QStringList pTags = preset.split(",", Qt::SkipEmptyParts);
                    for (const QString& t : pTags) {
                        QString trimmed = t.trimmed();
                        if (!finalTags.contains(trimmed)) finalTags << trimmed;
                    }
                }
            }
        }
        QSqlQuery query(m_db);
        query.prepare("INSERT INTO notes (title, content, tags, color, category_id, item_type, data_blob, content_hash, created_at, updated_at, source_app, source_title) VALUES (:title, :content, :tags, :color, :category_id, :item_type, :data_blob, :hash, :created_at, :updated_at, :source_app, :source_title)");
        query.bindValue(":title", title);
        query.bindValue(":content", content);
        query.bindValue(":tags", finalTags.join(","));
        query.bindValue(":color", finalColor);
        query.bindValue(":category_id", categoryId == -1 ? QVariant(QMetaType::fromType<int>()) : categoryId);
        query.bindValue(":item_type", itemType);
        query.bindValue(":data_blob", dataBlob);
        query.bindValue(":hash", contentHash);
        query.bindValue(":created_at", currentTime);
        query.bindValue(":updated_at", currentTime);
        query.bindValue(":source_app", sourceApp);
        query.bindValue(":source_title", sourceTitle);
        if (query.exec()) {
            success = true;
            QVariant lastId = query.lastInsertId();
            QSqlQuery fetch(m_db);
            fetch.prepare("SELECT * FROM notes WHERE id = :id");
            fetch.bindValue(":id", lastId);
            if (fetch.exec() && fetch.next()) {
                QSqlRecord rec = fetch.record();
                for (int i = 0; i < rec.count(); ++i) newNoteMap[rec.fieldName(i)] = fetch.value(i);
            }
        }
    }
    if (success && !newNoteMap.isEmpty()) {
        int newId = newNoteMap["id"].toInt();
        syncFts(newId, title, content);
        incrementUsageCount(); // 每次增加笔记视为一次使用
        emit noteAdded(newNoteMap);
        return newId;
    }
    return 0;
}

bool DatabaseManager::updateNote(int id, const QString& title, const QString& content, const QStringList& tags, const QString& color, int categoryId) {
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        QString sql = "UPDATE notes SET title=:title, content=:content, tags=:tags, updated_at=:updated_at";
        if (!color.isEmpty()) sql += ", color=:color";
        else if (categoryId != -1) {
            QSqlQuery catQuery(m_db);
            catQuery.prepare("SELECT color FROM categories WHERE id = :id");
            catQuery.bindValue(":id", categoryId);
            if (catQuery.exec() && catQuery.next()) sql += ", color=:color";
        }
        if (categoryId != -1) sql += ", category_id=:category_id";
        sql += " WHERE id=:id";
        query.prepare(sql);
        query.bindValue(":title", title);
        query.bindValue(":content", content);
        query.bindValue(":tags", tags.join(","));
        query.bindValue(":updated_at", currentTime);
        if (!color.isEmpty()) query.bindValue(":color", color);
        else if (categoryId != -1) {
            QSqlQuery catQuery(m_db);
            catQuery.prepare("SELECT color FROM categories WHERE id = :id");
            catQuery.bindValue(":id", categoryId);
            if (catQuery.exec() && catQuery.next()) query.bindValue(":color", catQuery.value(0).toString());
        }
        if (categoryId != -1) query.bindValue(":category_id", categoryId);
        query.bindValue(":id", id);
        success = query.exec();
    }
    if (success) { syncFts(id, title, content); emit noteUpdated(); }
    return success;
}

bool DatabaseManager::reorderCategories(int parentId, bool ascending) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    QSqlQuery query(m_db);
    if (parentId <= 0) query.prepare("SELECT id, name FROM categories WHERE parent_id IS NULL OR parent_id <= 0");
    else { query.prepare("SELECT id, name FROM categories WHERE parent_id = :pid"); query.bindValue(":pid", parentId); }
    if (!query.exec()) return false;
    struct CatInfo { int id; QString name; };
    QList<CatInfo> list;
    while (query.next()) list.append({query.value(0).toInt(), query.value(1).toString()});
    if (list.isEmpty()) return true;
    std::sort(list.begin(), list.end(), [ascending](const CatInfo& a, const CatInfo& b) {
        if (ascending) return a.name.localeAwareCompare(b.name) < 0;
        return a.name.localeAwareCompare(b.name) > 0;
    });
    m_db.transaction();
    QSqlQuery update(m_db);
    for (int i = 0; i < list.size(); ++i) {
        update.prepare("UPDATE categories SET sort_order = :val WHERE id = :id");
        update.bindValue(":val", i);
        update.bindValue(":id", list[i].id);
        update.exec();
    }
    bool ok = m_db.commit();
    if (ok) emit categoriesChanged();
    return ok;
}

bool DatabaseManager::updateCategoryOrder(int parentId, const QList<int>& categoryIds) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    if (!m_db.transaction()) return false;
    QSqlQuery query(m_db);
    query.prepare("UPDATE categories SET parent_id = :pid, sort_order = :order WHERE id = :id");
    for (int i = 0; i < categoryIds.size(); ++i) {
        query.bindValue(":pid", parentId <= 0 ? QVariant() : parentId);
        query.bindValue(":order", i);
        query.bindValue(":id", categoryIds[i]);
        if (!query.exec()) { m_db.rollback(); return false; }
    }
    bool ok = m_db.commit();
    if (ok) emit categoriesChanged();
    return ok;
}

bool DatabaseManager::reorderAllCategories(bool ascending) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    QSqlQuery query(m_db);
    query.exec("SELECT DISTINCT parent_id FROM categories");
    QList<int> parents;
    bool hasRoot = false;
    while (query.next()) {
        if (query.value(0).isNull() || query.value(0).toInt() <= 0) hasRoot = true;
        else parents.append(query.value(0).toInt());
    }
    bool success = true;
    if (hasRoot) success &= reorderCategories(-1, ascending);
    for (int pid : parents) success &= reorderCategories(pid, ascending);
    return success;
}

bool DatabaseManager::setCategoryPassword(int id, const QString& password, const QString& hint) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QString hashedPassword = QString(QCryptographicHash::hash(password.toUtf8(), QCryptographicHash::Sha256).toHex());
        QSqlQuery query(m_db);
        query.prepare("UPDATE categories SET password=:password, password_hint=:hint WHERE id=:id");
        query.bindValue(":password", hashedPassword);
        query.bindValue(":hint", hint);
        query.bindValue(":id", id);
        success = query.exec();
    }
    if (success) emit categoriesChanged();
    return success;
}

bool DatabaseManager::removeCategoryPassword(int id) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        query.prepare("UPDATE categories SET password=NULL, password_hint=NULL WHERE id=:id");
        query.bindValue(":id", id);
        success = query.exec();
        if (success) m_unlockedCategories.remove(id);
    }
    if (success) emit categoriesChanged();
    return success;
}

bool DatabaseManager::verifyCategoryPassword(int id, const QString& password) {
    bool correct = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QString hashedPassword = QString(QCryptographicHash::hash(password.toUtf8(), QCryptographicHash::Sha256).toHex());
        QSqlQuery query(m_db);
        query.prepare("SELECT password FROM categories WHERE id=:id");
        query.bindValue(":id", id);
        if (query.exec() && query.next()) {
            if (query.value(0).toString() == hashedPassword) correct = true;
        }
    }
    if (correct) unlockCategory(id);
    return correct;
}

bool DatabaseManager::isCategoryLocked(int id) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    if (m_unlockedCategories.contains(id)) return false;
    QSqlQuery query(m_db);
    query.prepare("SELECT password FROM categories WHERE id=:id");
    query.bindValue(":id", id);
    if (query.exec() && query.next()) return !query.value(0).toString().isEmpty();
    return false;
}

void DatabaseManager::lockCategory(int id) { { QMutexLocker locker(&m_mutex); m_unlockedCategories.remove(id); } emit categoriesChanged(); }
void DatabaseManager::unlockCategory(int id) { { QMutexLocker locker(&m_mutex); m_unlockedCategories.insert(id); } emit categoriesChanged(); }

bool DatabaseManager::restoreAllFromTrash() {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        success = query.exec("UPDATE notes SET is_deleted = 0, category_id = NULL, color = '#0A362F' WHERE is_deleted = 1");
    }
    if (success) { emit noteUpdated(); emit categoriesChanged(); }
    return success;
}

bool DatabaseManager::updateNoteState(int id, const QString& column, const QVariant& value) {
    bool success = false;
    QString title, content;
    bool needsFts = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        // [CRITICAL] 必须包含 item_type 以支持从图片识别提取的文字类型标记
        QStringList allowedColumns = {"is_pinned", "is_locked", "is_favorite", "is_deleted", "tags", "rating", "category_id", "color", "content", "title", "item_type"};
        if (!allowedColumns.contains(column)) return false;
        QSqlQuery query(m_db);
        if (column == "is_favorite") {
            bool fav = value.toBool();
            QString color = fav ? "#ff6b81" : ""; 
            if (!fav) {
                QSqlQuery catQuery(m_db);
                catQuery.prepare("SELECT c.color FROM categories c JOIN notes n ON n.category_id = c.id WHERE n.id = :id");
                catQuery.bindValue(":id", id);
                if (catQuery.exec() && catQuery.next()) color = catQuery.value(0).toString();
                else color = "#0A362F"; 
            }
            query.prepare("UPDATE notes SET is_favorite = :val, color = :color, updated_at = :now WHERE id = :id");
            query.bindValue(":color", color);
        } else if (column == "is_deleted") {
            bool del = value.toBool();
            QString color = del ? "#2d2d2d" : "#0A362F";
            query.prepare("UPDATE notes SET is_deleted = :val, color = :color, category_id = NULL, updated_at = :now WHERE id = :id");
            query.bindValue(":color", color);
        } else if (column == "category_id") {
            int catId = value.isNull() ? -1 : value.toInt();
            QString color = "#0A362F"; 
            if (catId != -1) {
                QSqlQuery catQuery(m_db);
                catQuery.prepare("SELECT color FROM categories WHERE id = :id");
                catQuery.bindValue(":id", catId);
                if (catQuery.exec() && catQuery.next()) color = catQuery.value(0).toString();
            }
            query.prepare("UPDATE notes SET category_id = :val, color = :color, is_deleted = 0, updated_at = :now WHERE id = :id");
            query.bindValue(":color", color);
        } else {
            query.prepare(QString("UPDATE notes SET %1 = :val, updated_at = :now WHERE id = :id").arg(column));
        }
        query.bindValue(":val", value);
        query.bindValue(":now", currentTime);
        query.bindValue(":id", id);
        success = query.exec();
        if (success && (column == "content" || column == "title")) {
            needsFts = true;
            QSqlQuery fetch(m_db);
            fetch.prepare("SELECT title, content FROM notes WHERE id = ?");
            fetch.addBindValue(id);
            if (fetch.exec() && fetch.next()) { title = fetch.value(0).toString(); content = fetch.value(1).toString(); }
        }
    } 
    if (success) { if (needsFts) syncFts(id, title, content); emit noteUpdated(); }
    return success;
}

bool DatabaseManager::updateNoteStateBatch(const QList<int>& ids, const QString& column, const QVariant& value) {
    if (ids.isEmpty()) return true;
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QStringList allowedColumns = {"is_pinned", "is_locked", "is_favorite", "is_deleted", "tags", "rating", "category_id"};
        if (!allowedColumns.contains(column)) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        if (column == "category_id") {
            int catId = value.isNull() ? -1 : value.toInt();
            QString color = "#0A362F";
            if (catId != -1) {
                QSqlQuery catQuery(m_db);
                catQuery.prepare("SELECT color FROM categories WHERE id = :id");
                catQuery.bindValue(":id", catId);
                if (catQuery.exec() && catQuery.next()) color = catQuery.value(0).toString();
            }
            query.prepare("UPDATE notes SET category_id = :val, color = :color, is_deleted = 0, updated_at = :updated_at WHERE id = :id");
            for (int id : ids) {
                query.bindValue(":val", value);
                query.bindValue(":color", color);
                query.bindValue(":updated_at", currentTime);
                query.bindValue(":id", id);
                query.exec();
            }
        } else {
            QString sql = QString("UPDATE notes SET %1 = :val, updated_at = :updated_at WHERE id = :id").arg(column);
            query.prepare(sql);
            for (int id : ids) {
                query.bindValue(":val", value);
                query.bindValue(":updated_at", currentTime);
                query.bindValue(":id", id);
                query.exec();
            }
        }
        success = m_db.commit();
    }
    if (success) emit noteUpdated();
    return success;
}

bool DatabaseManager::recordAccess(int id) {
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        query.prepare("UPDATE notes SET last_accessed_at = :now WHERE id = :id");
        query.bindValue(":now", currentTime);
        query.bindValue(":id", id);
        success = query.exec();
    }
    return success;
}

bool DatabaseManager::toggleNoteState(int id, const QString& column) {
    QVariant currentVal;
    {
        QMutexLocker locker(&m_mutex);
        QSqlQuery query(m_db);
        query.prepare(QString("SELECT %1 FROM notes WHERE id = :id").arg(column));
        query.bindValue(":id", id);
        if (query.exec() && query.next()) currentVal = query.value(0);
    }
    if (currentVal.isValid()) return updateNoteState(id, column, !currentVal.toBool());
    return false;
}

bool DatabaseManager::moveNotesToCategory(const QList<int>& noteIds, int catId) {
    if (noteIds.isEmpty()) return true;
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QString catColor = "#0A362F"; 
        QString presetTags;
        if (catId != -1) {
            QSqlQuery catQuery(m_db);
            catQuery.prepare("SELECT color, preset_tags FROM categories WHERE id = :id");
            catQuery.bindValue(":id", catId);
            if (catQuery.exec() && catQuery.next()) { catColor = catQuery.value(0).toString(); presetTags = catQuery.value(1).toString(); }
        }
        QSqlQuery query(m_db);
        query.prepare("UPDATE notes SET category_id = :cat_id, color = :color, is_deleted = 0, updated_at = :now WHERE id = :id");
        QString now = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
        for (int id : noteIds) {
            query.bindValue(":cat_id", catId == -1 ? QVariant() : catId);
            query.bindValue(":color", catColor);
            query.bindValue(":now", now);
            query.bindValue(":id", id);
            query.exec();
            if (!presetTags.isEmpty()) {
                QSqlQuery fetchTags(m_db);
                fetchTags.prepare("SELECT tags FROM notes WHERE id = :id");
                fetchTags.bindValue(":id", id);
                if (fetchTags.exec() && fetchTags.next()) {
                    QString existing = fetchTags.value(0).toString();
                    QStringList tagList = existing.split(",", Qt::SkipEmptyParts);
                    QStringList newTags = presetTags.split(",", Qt::SkipEmptyParts);
                    bool changed = false;
                    for (const QString& t : newTags) { if (!tagList.contains(t.trimmed())) { tagList.append(t.trimmed()); changed = true; } }
                    if (changed) { QSqlQuery updateTags(m_db); updateTags.prepare("UPDATE notes SET tags = :tags WHERE id = :id"); updateTags.bindValue(":tags", tagList.join(",")); updateTags.bindValue(":id", id); updateTags.exec(); }
                }
            }
        }
        success = m_db.commit();
    }
    if (success) emit noteUpdated();
    return success;
}

bool DatabaseManager::deleteNotesBatch(const QList<int>& ids) {
    if (ids.isEmpty()) return true;
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("DELETE FROM notes WHERE id=:id");
        for (int id : ids) { query.bindValue(":id", id); if (query.exec()) removeFts(id); }
        success = m_db.commit();
    }
    if (success) emit noteUpdated();
    return success;
}

bool DatabaseManager::softDeleteNotes(const QList<int>& ids) {
    if (ids.isEmpty()) return true;
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("UPDATE notes SET is_deleted = 1, category_id = NULL, color = '#2d2d2d', is_pinned = 0, is_favorite = 0, updated_at = :now WHERE id = :id");
        for (int id : ids) { query.bindValue(":now", currentTime); query.bindValue(":id", id); query.exec(); }
        success = m_db.commit();
    }
    if (success) emit noteUpdated();
    return success;
}

void DatabaseManager::addNoteAsync(const QString& title, const QString& content, const QStringList& tags, const QString& color, int categoryId, const QString& itemType, const QByteArray& dataBlob, const QString& sourceApp, const QString& sourceTitle) {
    QMetaObject::invokeMethod(this, [this, title, content, tags, color, categoryId, itemType, dataBlob, sourceApp, sourceTitle]() { addNote(title, content, tags, color, categoryId, itemType, dataBlob, sourceApp, sourceTitle); }, Qt::QueuedConnection);
}

QList<QVariantMap> DatabaseManager::searchNotes(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page, int pageSize, const QVariantMap& criteria) {
    QMutexLocker locker(&m_mutex);
    QList<QVariantMap> results;
    if (!m_db.isOpen()) return results;
    QString baseSql = "SELECT notes.* FROM notes ";
    QString whereClause;
    QVariantList params;
    applyCommonFilters(whereClause, params, filterType, filterValue, criteria);
    
    if (!keyword.isEmpty()) {
        whereClause += "AND (notes.tags LIKE ? OR notes.title LIKE ? OR notes.content LIKE ?) ";
        QString likeVal = "%" + keyword + "%";
        params << likeVal << likeVal << likeVal;
    }
    
    QString finalSql = baseSql + whereClause + "ORDER BY ";
    if (!keyword.isEmpty()) { 
        finalSql += "CASE WHEN notes.tags LIKE ? THEN 0 ELSE 1 END, "; 
        params << "%" + keyword + "%"; 
    }
    
    if (filterType == "recently_visited") finalSql += "is_pinned DESC, last_accessed_at DESC";
    else finalSql += "is_pinned DESC, updated_at DESC";
    
    if (page > 0 && filterType != "trash") finalSql += QString(" LIMIT %1 OFFSET %2").arg(pageSize).arg((page - 1) * pageSize);
    
    QSqlQuery query(m_db);
    query.prepare(finalSql);
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    
    if (query.exec()) { 
        while (query.next()) { 
            QVariantMap map; 
            QSqlRecord rec = query.record(); 
            for (int i = 0; i < rec.count(); ++i) map[rec.fieldName(i)] = query.value(i); 
            results.append(map); 
        } 
    }
    else qCritical() << "searchNotes failed:" << query.lastError().text();
    return results;
}

int DatabaseManager::getNotesCount(const QString& keyword, const QString& filterType, const QVariant& filterValue, const QVariantMap& criteria) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return 0;
    QString baseSql = "SELECT COUNT(*) FROM notes ";
    QString whereClause;
    QVariantList params;
    applyCommonFilters(whereClause, params, filterType, filterValue, criteria);
    
    if (!keyword.isEmpty()) {
        whereClause += "AND (notes.tags LIKE ? OR notes.title LIKE ? OR notes.content LIKE ?) ";
        QString likeVal = "%" + keyword + "%";
        params << likeVal << likeVal << likeVal;
    }
    
    QSqlQuery query(m_db);
    query.prepare(baseSql + whereClause);
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { if (query.next()) return query.value(0).toInt(); }
    else qCritical() << "getNotesCount failed:" << query.lastError().text();
    return 0;
}

QStringList DatabaseManager::getAllTags() {
    QMutexLocker locker(&m_mutex);
    QStringList allTags;
    if (!m_db.isOpen()) return allTags;
    QSqlQuery query(m_db);
    if (query.exec("SELECT tags FROM notes WHERE tags != '' AND is_deleted = 0")) { while (query.next()) { QString tagsStr = query.value(0).toString(); QStringList parts = tagsStr.split(",", Qt::SkipEmptyParts); for (const QString& part : parts) { QString trimmed = part.trimmed(); if (!allTags.contains(trimmed)) allTags.append(trimmed); } } }
    allTags.sort();
    return allTags;
}

QList<QVariantMap> DatabaseManager::getRecentTagsWithCounts(int limit) {
    QMutexLocker locker(&m_mutex);
    QList<QVariantMap> results;
    if (!m_db.isOpen()) return results;
    struct TagData { QString name; int count = 0; QDateTime lastUsed; };
    QMap<QString, TagData> tagMap;
    QSqlQuery query(m_db);
    if (query.exec("SELECT tags, updated_at FROM notes WHERE tags != '' AND is_deleted = 0")) { while (query.next()) { QString tagsStr = query.value(0).toString(); QDateTime updatedAt = query.value(1).toDateTime(); QStringList parts = tagsStr.split(",", Qt::SkipEmptyParts); for (const QString& part : parts) { QString name = part.trimmed(); if (name.isEmpty()) continue; if (!tagMap.contains(name)) tagMap[name] = {name, 1, updatedAt}; else { tagMap[name].count++; if (updatedAt > tagMap[name].lastUsed) tagMap[name].lastUsed = updatedAt; } } } }
    QList<TagData> sortedList = tagMap.values();
    std::sort(sortedList.begin(), sortedList.end(), [](const TagData& a, const TagData& b) { if (a.lastUsed != b.lastUsed) return a.lastUsed > b.lastUsed; return a.count > b.count; });
    int actualLimit = qMin(limit, (int)sortedList.size());
    for (int i = 0; i < actualLimit; ++i) { QVariantMap m; m["name"] = sortedList[i].name; m["count"] = sortedList[i].count; results.append(m); }
    return results;
}

int DatabaseManager::addCategory(const QString& name, int parentId, const QString& color) {
    int lastId = -1;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return -1;
        int maxOrder = 0;
        QSqlQuery orderQuery(m_db);
        if (parentId == -1) orderQuery.exec("SELECT MAX(sort_order) FROM categories WHERE parent_id IS NULL OR parent_id = -1");
        else { orderQuery.prepare("SELECT MAX(sort_order) FROM categories WHERE parent_id = :pid"); orderQuery.bindValue(":pid", parentId); orderQuery.exec(); }
        if (orderQuery.next()) maxOrder = orderQuery.value(0).toInt();
        QString chosenColor = color;
        if (chosenColor.isEmpty()) { static const QStringList palette = { "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEEAD", "#D4A5A5", "#9B59B6", "#3498DB", "#E67E22", "#2ECC71", "#E74C3C", "#F1C40F", "#1ABC9C", "#34495E", "#95A5A6" }; chosenColor = palette.at(QRandomGenerator::global()->bounded(palette.size())); }
        QSqlQuery query(m_db);
        query.prepare("INSERT INTO categories (name, parent_id, color, sort_order) VALUES (:name, :parent_id, :color, :sort_order)");
        query.bindValue(":name", name);
        query.bindValue(":parent_id", parentId == -1 ? QVariant(QMetaType::fromType<int>()) : parentId);
        query.bindValue(":color", chosenColor);
        query.bindValue(":sort_order", maxOrder + 1);
        if (query.exec()) lastId = query.lastInsertId().toInt();
    }
    if (lastId != -1) emit categoriesChanged();
    return lastId;
}

bool DatabaseManager::renameCategory(int id, const QString& name) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        query.prepare("UPDATE categories SET name=:name WHERE id=:id");
        query.bindValue(":name", name);
        query.bindValue(":id", id);
        success = query.exec();
    }
    if (success) emit categoriesChanged();
    return success;
}

bool DatabaseManager::setCategoryColor(int id, const QString& color) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery treeQuery(m_db);
        treeQuery.prepare(R"(WITH RECURSIVE category_tree(id) AS (SELECT :id UNION ALL SELECT c.id FROM categories c JOIN category_tree ct ON c.parent_id = ct.id) SELECT id FROM category_tree)");
        treeQuery.bindValue(":id", id);
        QList<int> allIds;
        if (treeQuery.exec()) { while (treeQuery.next()) allIds << treeQuery.value(0).toInt(); }
        if (!allIds.isEmpty()) {
            QString placeholders;
            for(int i=0; i<allIds.size(); ++i) placeholders += (i==0 ? "?" : ",?");
            QSqlQuery updateNotes(m_db);
            updateNotes.prepare(QString("UPDATE notes SET color = ? WHERE category_id IN (%1)").arg(placeholders));
            updateNotes.addBindValue(color);
            for(int cid : allIds) updateNotes.addBindValue(cid);
            updateNotes.exec();
            QSqlQuery updateCats(m_db);
            updateCats.prepare(QString("UPDATE categories SET color = ? WHERE id IN (%1)").arg(placeholders));
            updateCats.addBindValue(color);
            for(int cid : allIds) updateCats.addBindValue(cid);
            updateCats.exec();
        }
        success = m_db.commit();
    }
    if (success) { emit categoriesChanged(); emit noteUpdated(); }
    return success;
}

bool DatabaseManager::deleteCategory(int id) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        query.prepare("DELETE FROM categories WHERE id=:id");
        query.bindValue(":id", id);
        if (query.exec()) { QSqlQuery updateNotes(m_db); updateNotes.prepare("UPDATE notes SET category_id = NULL WHERE category_id = :id"); updateNotes.bindValue(":id", id); updateNotes.exec(); success = true; }
    }
    if (success) emit categoriesChanged();
    return success;
}

bool DatabaseManager::moveCategory(int id, MoveDirection direction) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    int parentId = -1;
    QSqlQuery parentQuery(m_db);
    parentQuery.prepare("SELECT parent_id FROM categories WHERE id = :id");
    parentQuery.bindValue(":id", id);
    if (parentQuery.exec() && parentQuery.next()) parentId = parentQuery.value(0).isNull() ? -1 : parentQuery.value(0).toInt();
    else return false;
    QSqlQuery siblingsQuery(m_db);
    if (parentId == -1) siblingsQuery.prepare("SELECT id FROM categories WHERE parent_id IS NULL OR parent_id = -1 ORDER BY sort_order ASC");
    else { siblingsQuery.prepare("SELECT id FROM categories WHERE parent_id = :pid ORDER BY sort_order ASC"); siblingsQuery.bindValue(":pid", parentId); }
    if (!siblingsQuery.exec()) return false;
    QList<int> siblings;
    while (siblingsQuery.next()) siblings << siblingsQuery.value(0).toInt();
    int currentIndex = siblings.indexOf(id);
    if (currentIndex == -1) return false;
    switch (direction) {
        case Up: if (currentIndex > 0) std::swap(siblings[currentIndex], siblings[currentIndex - 1]); else return false; break;
        case Down: if (currentIndex < siblings.size() - 1) std::swap(siblings[currentIndex], siblings[currentIndex + 1]); else return false; break;
        case Top: if (currentIndex > 0) { siblings.removeAt(currentIndex); siblings.prepend(id); } else return false; break;
        case Bottom: if (currentIndex < siblings.size() - 1) { siblings.removeAt(currentIndex); siblings.append(id); } else return false; break;
    }
    return updateCategoryOrder(parentId, siblings);
}

QList<QVariantMap> DatabaseManager::getAllCategories() {
    QMutexLocker locker(&m_mutex);
    QList<QVariantMap> results;
    if (!m_db.isOpen()) return results;
    QSqlQuery query(m_db);
    if (query.exec("SELECT * FROM categories ORDER BY sort_order")) { while (query.next()) { QVariantMap map; QSqlRecord rec = query.record(); for (int i = 0; i < rec.count(); ++i) map[rec.fieldName(i)] = query.value(i); results.append(map); } }
    return results;
}

bool DatabaseManager::emptyTrash() {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        success = query.exec("DELETE FROM notes WHERE is_deleted = 1");
    }
    if (success) emit noteUpdated();
    return success;
}

bool DatabaseManager::setCategoryPresetTags(int catId, const QString& tags) {
    bool ok = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("UPDATE categories SET preset_tags=:tags WHERE id=:id");
        query.bindValue(":tags", tags);
        query.bindValue(":id", catId);
        if (!query.exec()) { m_db.rollback(); return false; }
        if (!tags.isEmpty()) {
            QStringList newTagsList = tags.split(",", Qt::SkipEmptyParts);
            QSqlQuery fetchNotes(m_db);
            fetchNotes.prepare("SELECT id, tags FROM notes WHERE category_id = :catId AND is_deleted = 0");
            fetchNotes.bindValue(":catId", catId);
            if (fetchNotes.exec()) {
                while (fetchNotes.next()) {
                    int noteId = fetchNotes.value(0).toInt();
                    QString existingTagsStr = fetchNotes.value(1).toString();
                    QStringList existingTags = existingTagsStr.split(",", Qt::SkipEmptyParts);
                    bool changed = false;
                    for (const QString& t : newTagsList) { QString trimmed = t.trimmed(); if (!trimmed.isEmpty() && !existingTags.contains(trimmed)) { existingTags.append(trimmed); changed = true; } }
                    if (changed) { QSqlQuery updateNote(m_db); updateNote.prepare("UPDATE notes SET tags = :tags WHERE id = :id"); updateNote.bindValue(":tags", existingTags.join(",")); updateNote.bindValue(":id", noteId); updateNote.exec(); }
                }
            }
        }
        ok = m_db.commit();
    }
    if (ok) { emit categoriesChanged(); emit noteUpdated(); }
    return ok;
}

QString DatabaseManager::getCategoryPresetTags(int catId) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return "";
    QSqlQuery query(m_db);
    query.prepare("SELECT preset_tags FROM categories WHERE id=:id");
    query.bindValue(":id", catId);
    if (query.exec() && query.next()) return query.value(0).toString();
    return "";
}

QVariantMap DatabaseManager::getNoteById(int id) {
    QMutexLocker locker(&m_mutex);
    QVariantMap map;
    if (!m_db.isOpen()) return map;
    QSqlQuery query(m_db);
    query.prepare("SELECT * FROM notes WHERE id = :id");
    query.bindValue(":id", id);
    if (query.exec() && query.next()) { QSqlRecord rec = query.record(); for (int i = 0; i < rec.count(); ++i) map[rec.fieldName(i)] = query.value(i); }
    return map;
}

QVariantMap DatabaseManager::getCounts() {
    QMutexLocker locker(&m_mutex);
    QVariantMap counts;
    if (!m_db.isOpen()) return counts;
    QSqlQuery query(m_db);
    auto getCount = [&](const QString& where, bool applySecurity = true) {
        QString sql = "SELECT COUNT(*) FROM notes WHERE " + where;
        QVariantList params;
        if (applySecurity) { QString securityClause; applySecurityFilter(securityClause, params, "all"); sql += " " + securityClause; }
        QSqlQuery q(m_db);
        q.prepare(sql);
        for(int i=0; i<params.size(); ++i) q.bindValue(i, params[i]);
        if (q.exec()) { if (q.next()) return q.value(0).toInt(); }
        return 0;
    };
    counts["all"] = getCount("is_deleted = 0");
    counts["today"] = getCount("is_deleted = 0 AND date(created_at) = date('now', 'localtime')");
    counts["yesterday"] = getCount("is_deleted = 0 AND date(created_at) = date('now', '-1 day', 'localtime')");
    counts["recently_visited"] = getCount("is_deleted = 0 AND (date(last_accessed_at) = date('now', 'localtime') OR date(updated_at) = date('now', 'localtime')) AND date(created_at) < date('now', 'localtime')");
    counts["uncategorized"] = getCount("is_deleted = 0 AND category_id IS NULL");
    counts["untagged"] = getCount("is_deleted = 0 AND (tags IS NULL OR tags = '')");
    counts["bookmark"] = getCount("is_deleted = 0 AND is_favorite = 1");
    counts["trash"] = getCount("is_deleted = 1", false);
    if (query.exec("SELECT category_id, COUNT(*) FROM notes WHERE is_deleted = 0 AND category_id IS NOT NULL GROUP BY category_id")) { while (query.next()) { counts["cat_" + query.value(0).toString()] = query.value(1).toInt(); } }
    return counts;
}

QVariantMap DatabaseManager::getTrialStatus() {
    QMutexLocker locker(&m_mutex);
    QVariantMap status;
    status["expired"] = false;
    status["usage_limit_reached"] = false;
    status["days_left"] = 30;
    status["usage_count"] = 0;

    if (!m_db.isOpen()) return status;

    QSqlQuery query(m_db);
    query.exec("SELECT key, value FROM system_config");
    while (query.next()) {
        QString key = query.value(0).toString();
        QString value = query.value(1).toString();
        if (key == "first_launch_date") {
            QDateTime firstLaunch = QDateTime::fromString(value, Qt::ISODate);
            qint64 daysPassed = firstLaunch.daysTo(QDateTime::currentDateTime());
            status["days_left"] = qMax(0LL, 30 - daysPassed);
            if (daysPassed > 30) status["expired"] = true;
        } else if (key == "usage_count") {
            int count = value.toInt();
            status["usage_count"] = count;
            if (count >= 100) status["usage_limit_reached"] = true;
        }
    }
    return status;
}

void DatabaseManager::incrementUsageCount() {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return;
    QSqlQuery query(m_db);
    query.exec("UPDATE system_config SET value = CAST(CAST(value AS INTEGER) + 1 AS TEXT) WHERE key = 'usage_count'");
}

void DatabaseManager::resetUsageCount() {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return;
    QSqlQuery query(m_db);
    query.prepare("UPDATE system_config SET value = '0' WHERE key = 'usage_count'");
    query.exec();
}

QVariantMap DatabaseManager::getFilterStats(const QString& keyword, const QString& filterType, const QVariant& filterValue, const QVariantMap& criteria) {
    QMutexLocker locker(&m_mutex);
    QVariantMap stats;
    if (!m_db.isOpen()) return stats;
    QString whereClause;
    QVariantList params;
    applyCommonFilters(whereClause, params, filterType, filterValue, criteria);
    
    if (!keyword.isEmpty()) {
        whereClause += "AND (tags LIKE ? OR title LIKE ? OR content LIKE ?) ";
        QString likeVal = "%" + keyword + "%";
        params << likeVal << likeVal << likeVal;
    }
    QSqlQuery query(m_db);
    QMap<int, int> stars;
    query.prepare("SELECT rating, COUNT(*) FROM notes " + whereClause + " GROUP BY rating");
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { while (query.next()) stars[query.value(0).toInt()] = query.value(1).toInt(); }
    QVariantMap starsMap;
    for (auto it = stars.begin(); it != stars.end(); ++it) starsMap[QString::number(it.key())] = it.value();
    stats["stars"] = starsMap;
    QMap<QString, int> colors;
    query.prepare("SELECT color, COUNT(*) FROM notes " + whereClause + " GROUP BY color");
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { while (query.next()) colors[query.value(0).toString()] = query.value(1).toInt(); }
    QVariantMap colorsMap;
    for (auto it = colors.begin(); it != colors.end(); ++it) colorsMap[it.key()] = it.value();
    stats["colors"] = colorsMap;
    QMap<QString, int> types;
    query.prepare("SELECT item_type, COUNT(*) FROM notes " + whereClause + " GROUP BY item_type");
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { while (query.next()) types[query.value(0).toString()] = query.value(1).toInt(); }
    QVariantMap typesMap;
    for (auto it = types.begin(); it != types.end(); ++it) typesMap[it.key()] = it.value();
    stats["types"] = typesMap;
    QMap<QString, int> tags;
    query.prepare("SELECT tags FROM notes " + whereClause);
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { while (query.next()) { QStringList parts = query.value(0).toString().split(",", Qt::SkipEmptyParts); for (const QString& t : parts) tags[t.trimmed()]++; } }
    QVariantMap tagsMap;
    for (auto it = tags.begin(); it != tags.end(); ++it) tagsMap[it.key()] = it.value();
    stats["tags"] = tagsMap;
    QVariantMap dateStats;
    auto getCountDate = [&](const QString& dateCond) {
        QSqlQuery q(m_db);
        q.prepare("SELECT COUNT(*) FROM notes " + whereClause + " AND " + dateCond);
        for (int i = 0; i < params.size(); ++i) q.bindValue(i, params[i]);
        if (q.exec() && q.next()) return q.value(0).toInt();
        return 0;
    };
    dateStats["today"] = getCountDate("date(created_at) = date('now', 'localtime')");
    dateStats["yesterday"] = getCountDate("date(created_at) = date('now', '-1 day', 'localtime')");
    dateStats["week"] = getCountDate("date(created_at) >= date('now', '-6 days', 'localtime')");
    dateStats["month"] = getCountDate("strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now', 'localtime')");
    stats["date_create"] = dateStats;
    return stats;
}

bool DatabaseManager::addTagsToNote(int noteId, const QStringList& tags) { QVariantMap note = getNoteById(noteId); if (note.isEmpty()) return false; QStringList existing = note["tags"].toString().split(",", Qt::SkipEmptyParts); for (const QString& t : tags) { if (!existing.contains(t.trimmed())) existing.append(t.trimmed()); } return updateNoteState(noteId, "tags", existing.join(",")); }
bool DatabaseManager::renameTagGlobally(const QString& oldName, const QString& newName) {
    if (oldName.trimmed().isEmpty() || oldName == newName) return true;
    bool ok = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("SELECT id, tags FROM notes WHERE (',' || tags || ',') LIKE ? AND is_deleted = 0");
        query.addBindValue("%," + oldName.trimmed() + ",%");
        if (query.exec()) {
            while (query.next()) {
                int noteId = query.value(0).toInt(); QString tagsStr = query.value(1).toString(); QStringList tagList = tagsStr.split(",", Qt::SkipEmptyParts);
                for (int i = 0; i < tagList.size(); ++i) { if (tagList[i].trimmed() == oldName.trimmed()) tagList[i] = newName.trimmed(); }
                tagList.removeDuplicates();
                QSqlQuery updateQuery(m_db); updateQuery.prepare("UPDATE notes SET tags = ? WHERE id = ?"); updateQuery.addBindValue(tagList.join(",")); updateQuery.addBindValue(noteId); updateQuery.exec();
            }
        }
        ok = m_db.commit();
    }
    if (ok) emit noteUpdated();
    return ok;
}

bool DatabaseManager::deleteTagGlobally(const QString& tagName) {
    if (tagName.trimmed().isEmpty()) return true;
    bool ok = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("SELECT id, tags FROM notes WHERE (',' || tags || ',') LIKE ? AND is_deleted = 0");
        query.addBindValue("%," + tagName.trimmed() + ",%");
        if (query.exec()) {
            while (query.next()) {
                int noteId = query.value(0).toInt(); QString tagsStr = query.value(1).toString(); QStringList tagList = tagsStr.split(",", Qt::SkipEmptyParts);
                tagList.removeAll(tagName.trimmed());
                QSqlQuery updateQuery(m_db); updateQuery.prepare("UPDATE notes SET tags = ? WHERE id = ?"); updateQuery.addBindValue(tagList.join(",")); updateQuery.addBindValue(noteId); updateQuery.exec();
            }
        }
        ok = m_db.commit();
    }
    if (ok) emit noteUpdated();
    return ok;
}

void DatabaseManager::syncFts(int id, const QString& title, const QString& content) {
    QString plainTitle = title; QString plainContent = stripHtml(content);
    QMutexLocker locker(&m_mutex);
    QSqlQuery query(m_db);
    query.prepare("DELETE FROM notes_fts WHERE rowid = ?"); query.addBindValue(id); query.exec();
    query.prepare("INSERT INTO notes_fts(rowid, title, content) VALUES (?, ?, ?)"); query.addBindValue(id); query.addBindValue(plainTitle); query.addBindValue(plainContent); query.exec();
}

void DatabaseManager::removeFts(int id) { QSqlQuery query(m_db); query.prepare("DELETE FROM notes_fts WHERE rowid = ?"); query.addBindValue(id); query.exec(); }

void DatabaseManager::applySecurityFilter(QString& whereClause, QVariantList& params, const QString& filterType) {
    if (filterType == "category" || filterType == "trash" || filterType == "uncategorized") return;
    QSqlQuery catQuery(m_db);
    catQuery.exec("SELECT id FROM categories WHERE password IS NOT NULL AND password != ''");
    QList<int> lockedIds;
    while (catQuery.next()) { int cid = catQuery.value(0).toInt(); if (!m_unlockedCategories.contains(cid)) lockedIds.append(cid); }
    if (!lockedIds.isEmpty()) {
        QStringList placeholders; for (int i = 0; i < lockedIds.size(); ++i) placeholders << "?";
        whereClause += QString("AND (category_id IS NULL OR category_id NOT IN (%1)) ").arg(placeholders.join(","));
        for (int id : lockedIds) params << id;
    }
}

QString DatabaseManager::stripHtml(const QString& html) {
    if (!html.contains("<") && !html.contains("&")) return html;
    QString plain = html;
    plain.remove(QRegularExpression("<style.*?>.*?</style>", QRegularExpression::DotMatchesEverythingOption | QRegularExpression::CaseInsensitiveOption));
    plain.remove(QRegularExpression("<script.*?>.*?</script>", QRegularExpression::DotMatchesEverythingOption | QRegularExpression::CaseInsensitiveOption));
    plain.remove(QRegularExpression("<[^>]*>"));
    plain.replace("&nbsp;", " ", Qt::CaseInsensitive);
    plain.replace("&lt;", "<", Qt::CaseInsensitive);
    plain.replace("&gt;", ">", Qt::CaseInsensitive);
    plain.replace("&amp;", "&", Qt::CaseInsensitive);
    plain.replace("&quot;", "\"", Qt::CaseInsensitive);
    plain.replace("&#39;", "'");
    return plain.simplified();
}

void DatabaseManager::applyCommonFilters(QString& whereClause, QVariantList& params, const QString& filterType, const QVariant& filterValue, const QVariantMap& criteria) {
    if (filterType == "trash") {
        whereClause = "WHERE is_deleted = 1 ";
    } else {
        whereClause = "WHERE is_deleted = 0 ";
        applySecurityFilter(whereClause, params, filterType);
        
        if (filterType == "category") { 
            if (filterValue.toInt() == -1) whereClause += "AND category_id IS NULL "; 
            else { whereClause += "AND category_id = ? "; params << filterValue.toInt(); } 
        }
        else if (filterType == "uncategorized") whereClause += "AND category_id IS NULL ";
        else if (filterType == "today") whereClause += "AND date(created_at) = date('now', 'localtime') ";
        else if (filterType == "yesterday") whereClause += "AND date(created_at) = date('now', '-1 day', 'localtime') ";
        else if (filterType == "recently_visited") whereClause += "AND (date(last_accessed_at) = date('now', 'localtime') OR date(updated_at) = date('now', 'localtime')) AND date(created_at) < date('now', 'localtime') ";
        else if (filterType == "bookmark") whereClause += "AND is_favorite = 1 ";
        else if (filterType == "untagged") whereClause += "AND (tags IS NULL OR tags = '') ";
    }
    
    if (filterType != "trash" && !criteria.isEmpty()) {
        if (criteria.contains("stars")) { 
            QStringList stars = criteria.value("stars").toStringList(); 
            if (!stars.isEmpty()) whereClause += QString("AND rating IN (%1) ").arg(stars.join(",")); 
        }
        if (criteria.contains("types")) { 
            QStringList types = criteria.value("types").toStringList(); 
            if (!types.isEmpty()) { 
                QStringList placeholders; 
                for (const auto& t : types) { placeholders << "?"; params << t; } 
                whereClause += QString("AND item_type IN (%1) ").arg(placeholders.join(",")); 
            } 
        }
        if (criteria.contains("colors")) { 
            QStringList colors = criteria.value("colors").toStringList(); 
            if (!colors.isEmpty()) { 
                QStringList placeholders; 
                for (const auto& c : colors) { placeholders << "?"; params << c; } 
                whereClause += QString("AND color IN (%1) ").arg(placeholders.join(",")); 
            } 
        }
        if (criteria.contains("tags")) { 
            QStringList tags = criteria.value("tags").toStringList(); 
            if (!tags.isEmpty()) { 
                QStringList tagConds; 
                for (const auto& t : tags) { tagConds << "(',' || tags || ',') LIKE ?"; params << "%," + t.trimmed() + ",%"; } 
                whereClause += QString("AND (%1) ").arg(tagConds.join(" OR ")); 
            } 
        }
        if (criteria.contains("date_create")) { 
            QStringList dates = criteria.value("date_create").toStringList(); 
            if (!dates.isEmpty()) { 
                QStringList dateConds; 
                for (const auto& d : dates) { 
                    if (d == "today") dateConds << "date(created_at) = date('now', 'localtime')"; 
                    else if (d == "yesterday") dateConds << "date(created_at) = date('now', '-1 day', 'localtime')"; 
                    else if (d == "week") dateConds << "date(created_at) >= date('now', '-6 days', 'localtime')"; 
                    else if (d == "month") dateConds << "strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now', 'localtime')"; 
                } 
                if (!dateConds.isEmpty()) whereClause += QString("AND (%1) ").arg(dateConds.join(" OR ")); 
            } 
        }
    }
}
```

## 文件: `src/core/DatabaseManager.h`

```cpp
#ifndef DATABASEMANAGER_H
#define DATABASEMANAGER_H

#include <QObject>
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QSqlError>
#include <QDateTime>
#include <QVariant>
#include <QVariantList>
#include <QRecursiveMutex>
#include <QStringList>
#include <QSet>
#include <QMutex>

class DatabaseManager : public QObject {
    Q_OBJECT
public:
    static DatabaseManager& instance();

    bool init(const QString& dbPath = "rapid_notes.db");
    void closeAndPack();
    
    // 核心 CRUD 操作
    int addNote(const QString& title, const QString& content, const QStringList& tags = QStringList(), 
                const QString& color = "", int categoryId = -1, 
                const QString& itemType = "text", const QByteArray& dataBlob = QByteArray(),
                const QString& sourceApp = "", const QString& sourceTitle = "");
    bool updateNote(int id, const QString& title, const QString& content, const QStringList& tags, 
                    const QString& color = "", int categoryId = -1);
    bool deleteNotesBatch(const QList<int>& ids);
    bool updateNoteState(int id, const QString& column, const QVariant& value);
    bool updateNoteStateBatch(const QList<int>& ids, const QString& column, const QVariant& value);
    // 批量软删除 (放入回收站)
    bool softDeleteNotes(const QList<int>& ids);
    bool toggleNoteState(int id, const QString& column);
    bool moveNotesToCategory(const QList<int>& noteIds, int catId);
    bool recordAccess(int id);

    // 分类管理
    enum MoveDirection { Up, Down, Top, Bottom };
    int addCategory(const QString& name, int parentId = -1, const QString& color = "");
    bool renameCategory(int id, const QString& name);
    bool setCategoryColor(int id, const QString& color);
    bool deleteCategory(int id);
    bool moveCategory(int id, MoveDirection direction);
    bool reorderCategories(int parentId, bool ascending);
    bool reorderAllCategories(bool ascending);
    bool updateCategoryOrder(int parentId, const QList<int>& categoryIds);
    QList<QVariantMap> getAllCategories();
    bool emptyTrash();
    bool restoreAllFromTrash();

    // 分类密码保护
    bool setCategoryPassword(int id, const QString& password, const QString& hint);
    bool removeCategoryPassword(int id);
    bool verifyCategoryPassword(int id, const QString& password);
    bool isCategoryLocked(int id);
    void lockCategory(int id);
    void unlockCategory(int id);

    // 预设标签
    bool setCategoryPresetTags(int catId, const QString& tags);
    QString getCategoryPresetTags(int catId);

    // 标签管理
    bool addTagsToNote(int noteId, const QStringList& tags);
    bool renameTagGlobally(const QString& oldName, const QString& newName);
    bool deleteTagGlobally(const QString& tagName);

    // 搜索与查询
    QList<QVariantMap> searchNotes(const QString& keyword, const QString& filterType = "all", const QVariant& filterValue = -1, int page = -1, int pageSize = 20, const QVariantMap& criteria = QVariantMap());
    int getNotesCount(const QString& keyword, const QString& filterType = "all", const QVariant& filterValue = -1, const QVariantMap& criteria = QVariantMap());
    QStringList getAllTags();
    QList<QVariantMap> getRecentTagsWithCounts(int limit = 20);
    QVariantMap getNoteById(int id);

    // 统计
    QVariantMap getCounts();
    QVariantMap getFilterStats(const QString& keyword = "", const QString& filterType = "all", const QVariant& filterValue = -1, const QVariantMap& criteria = QVariantMap());

    // 试用期与使用次数管理
    QVariantMap getTrialStatus();
    void incrementUsageCount();
    void resetUsageCount();

    // 异步操作
    void addNoteAsync(const QString& title, const QString& content, const QStringList& tags = QStringList(),
                      const QString& color = "", int categoryId = -1,
                      const QString& itemType = "text", const QByteArray& dataBlob = QByteArray(),
                      const QString& sourceApp = "", const QString& sourceTitle = "");

signals:
    // 【修改】现在信号携带具体数据，实现增量更新
    void noteAdded(const QVariantMap& note);
    void noteUpdated(); // 用于普通刷新
    void categoriesChanged();

private:
    DatabaseManager(QObject* parent = nullptr);
    ~DatabaseManager();
    DatabaseManager(const DatabaseManager&) = delete;
    DatabaseManager& operator=(const DatabaseManager&) = delete;

    bool createTables();
    void syncFts(int id, const QString& title, const QString& content);
    void removeFts(int id);
    QString stripHtml(const QString& html);
    void applySecurityFilter(QString& whereClause, QVariantList& params, const QString& filterType);
    void applyCommonFilters(QString& whereClause, QVariantList& params, const QString& filterType, const QVariant& filterValue, const QVariantMap& criteria);
    
    QSqlDatabase m_db;
    QString m_dbPath;      // 当前正在使用的内核路径 (.notes_core)
    QString m_realDbPath;  // 最终持久化的外壳路径 (notes.db)
    QRecursiveMutex m_mutex;

    QSet<int> m_unlockedCategories; // 仅存储当前会话已解锁的分类 ID

    // 标签剪贴板 (全局静态)
    static QStringList s_tagClipboard;
    static QMutex s_tagClipboardMutex;

public:
    static void setTagClipboard(const QStringList& tags);
    static QStringList getTagClipboard();
};

#endif // DATABASEMANAGER_H
```

## 文件: `src/ui/DropTreeView.cpp`

```cpp
#include "DropTreeView.h"
#include "../models/CategoryModel.h"
#include <QDrag>
#include <QPixmap>

DropTreeView::DropTreeView(QWidget* parent) : QTreeView(parent) {
    setAcceptDrops(true);
    setDropIndicatorShown(true);
}

void DropTreeView::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasFormat("application/x-note-ids")) {
        event->acceptProposedAction();
    } else {
        QTreeView::dragEnterEvent(event);
    }
}

void DropTreeView::dragMoveEvent(QDragMoveEvent* event) {
    if (event->mimeData()->hasFormat("application/x-note-ids")) {
        event->acceptProposedAction();
    } else {
        QTreeView::dragMoveEvent(event);
    }
}

void DropTreeView::dropEvent(QDropEvent* event) {
    if (event->mimeData()->hasFormat("application/x-note-ids")) {
        QByteArray data = event->mimeData()->data("application/x-note-ids");
        QStringList idStrs = QString::fromUtf8(data).split(",", Qt::SkipEmptyParts);
        QList<int> ids;
        for (const QString& s : idStrs) ids << s.toInt();

        QModelIndex index = indexAt(event->position().toPoint());
        emit notesDropped(ids, index);
        event->acceptProposedAction();
    } else {
        QTreeView::dropEvent(event);
    }
}

void DropTreeView::startDrag(Qt::DropActions supportedActions) {
    // 追踪拖拽 ID
    auto* catModel = qobject_cast<CategoryModel*>(model());
    if (catModel && !selectedIndexes().isEmpty()) {
        catModel->setDraggingId(selectedIndexes().first().data(CategoryModel::IdRole).toInt());
    }

    // 禁用默认的快照卡片预览，改用 1x1 透明占位符
    QDrag* drag = new QDrag(this);
    drag->setMimeData(model()->mimeData(selectedIndexes()));
    
    QPixmap pix(1, 1);
    pix.fill(Qt::transparent);
    drag->setPixmap(pix);
    drag->setHotSpot(QPoint(0, 0));
    
    drag->exec(supportedActions, Qt::MoveAction);
}
```

## 文件: `src/ui/DropTreeView.h`

```cpp
#ifndef DROPTREEVIEW_H
#define DROPTREEVIEW_H

#include <QTreeView>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QMimeData>

class DropTreeView : public QTreeView {
    Q_OBJECT
public:
    explicit DropTreeView(QWidget* parent = nullptr);

signals:
    void notesDropped(const QList<int>& noteIds, const QModelIndex& targetIndex);

protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
    void startDrag(Qt::DropActions supportedActions) override;
};

#endif // DROPTREEVIEW_H
```

## 文件: `src/ui/Editor.cpp`

```cpp
#include "Editor.h"
#include <QMimeData>
#include <QFileInfo>
#include <utility>
#include <QUrl>
#include <QTextList>

MarkdownHighlighter::MarkdownHighlighter(QTextDocument* parent) : QSyntaxHighlighter(parent) {
    HighlightingRule rule;

    // 标题 (Headers) - 蓝色
    QTextCharFormat headerFormat;
    headerFormat.setForeground(QColor("#569CD6"));
    headerFormat.setFontWeight(QFont::Bold);
    rule.pattern = QRegularExpression("^#{1,6}\\s.*");
    rule.format = headerFormat;
    m_highlightingRules.append(rule);

    // 粗体 (**bold**) - 红色
    QTextCharFormat boldFormat;
    boldFormat.setFontWeight(QFont::Bold);
    boldFormat.setForeground(QColor("#E06C75"));
    rule.pattern = QRegularExpression("\\*\\*.*?\\*\\*");
    rule.format = boldFormat;
    m_highlightingRules.append(rule);

    // 待办事项 ([ ] [x]) - 黄色/绿色
    QTextCharFormat uncheckedFormat;
    uncheckedFormat.setForeground(QColor("#E5C07B"));
    rule.pattern = QRegularExpression("-\\s\\[\\s\\]");
    rule.format = uncheckedFormat;
    m_highlightingRules.append(rule);

    QTextCharFormat checkedFormat;
    checkedFormat.setForeground(QColor("#6A9955"));
    rule.pattern = QRegularExpression("-\\s\\[x\\]");
    rule.format = checkedFormat;
    m_highlightingRules.append(rule);

    // 代码 (Code) - 绿色
    QTextCharFormat codeFormat;
    codeFormat.setForeground(QColor("#98C379"));
    codeFormat.setFontFamilies({"Consolas", "Monaco", "monospace"});
    rule.pattern = QRegularExpression("`[^`]+`|```.*");
    rule.format = codeFormat;
    m_highlightingRules.append(rule);

    // 引用 (> Quote) - 灰色
    QTextCharFormat quoteFormat;
    quoteFormat.setForeground(QColor("#808080"));
    quoteFormat.setFontItalic(true);
    rule.pattern = QRegularExpression("^\\s*>.*");
    rule.format = quoteFormat;
    m_highlightingRules.append(rule);
    
    // 列表 (Lists) - 紫色
    QTextCharFormat listFormat;
    listFormat.setForeground(QColor("#C678DD"));
    rule.pattern = QRegularExpression("^\\s*[\\-\\*]\\s");
    rule.format = listFormat;
    m_highlightingRules.append(rule);

    // 链接 (Links) - 浅蓝
    QTextCharFormat linkFormat;
    linkFormat.setForeground(QColor("#61AFEF"));
    linkFormat.setFontUnderline(true);
    rule.pattern = QRegularExpression("\\[.*?\\]\\(.*?\\)|https?://\\S+");
    rule.format = linkFormat;
    m_highlightingRules.append(rule);
}

void MarkdownHighlighter::highlightBlock(const QString& text) {
    for (const HighlightingRule& rule : m_highlightingRules) {
        QRegularExpressionMatchIterator matchIterator = rule.pattern.globalMatch(text);
        while (matchIterator.hasNext()) {
            QRegularExpressionMatch match = matchIterator.next();
            setFormat(match.capturedStart(), match.capturedLength(), rule.format);
        }
    }
}

#include <QVBoxLayout>
#include <QFrame>
#include <QMimeData>
#include <QUrl>

InternalEditor::InternalEditor(QWidget* parent) : QTextEdit(parent) {
    setStyleSheet("background: #1E1E1E; color: #D4D4D4; font-family: 'Consolas', 'Courier New'; font-size: 13pt; border: none; outline: none; padding: 10px;");
    setAcceptRichText(true); // 允许富文本以支持高亮和图片
}

void InternalEditor::insertTodo() {
    QTextCursor cursor = textCursor();
    if (!cursor.atBlockStart()) {
        cursor.insertText("\n");
    }
    cursor.insertText("- [ ] ");
    setTextCursor(cursor);
    setFocus();
}

void InternalEditor::highlightSelection(const QColor& color) {
    QTextCursor cursor = textCursor();
    if (!cursor.hasSelection()) return;
    QTextCharFormat format;
    format.setBackground(color);
    cursor.mergeCharFormat(format);
    setTextCursor(cursor);
}

void InternalEditor::insertFromMimeData(const QMimeData* source) {
    if (source->hasImage()) {
        QImage image = qvariant_cast<QImage>(source->imageData());
        if (!image.isNull()) {
            // 自动缩放宽图
            if (image.width() > 600) {
                image = image.scaledToWidth(600, Qt::SmoothTransformation);
            }
            textCursor().insertImage(image);
            return;
        }
    }
    if (source->hasUrls()) {
        for (const QUrl& url : source->urls()) {
            if (url.isLocalFile()) insertPlainText(QString("\n[文件引用: %1]\n").arg(url.toLocalFile()));
            else insertPlainText(QString("\n[链接: %1]\n").arg(url.toString()));
        }
        return;
    }
    QTextEdit::insertFromMimeData(source);
}

Editor::Editor(QWidget* parent) : QWidget(parent) {
    auto* layout = new QVBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0); 

    m_stack = new QStackedWidget(this);
    m_stack->setStyleSheet("background: transparent; border: none;");
    
    m_edit = new InternalEditor(this);
    m_edit->setStyleSheet("background: transparent; color: #D4D4D4; font-family: 'Consolas', 'Courier New'; font-size: 13pt; border: none; outline: none; padding: 15px;");
    m_highlighter = new MarkdownHighlighter(m_edit->document());

    m_preview = new QTextEdit(this);
    m_preview->setReadOnly(true);
    m_preview->setStyleSheet("background: transparent; color: #D4D4D4; padding: 15px; border: none; outline: none;");

    m_stack->addWidget(m_edit);
    m_stack->addWidget(m_preview);
    
    layout->addWidget(m_stack);
}

void Editor::setNote(const QVariantMap& note, bool isPreview) {
    m_currentNote = note;
    QString title = note.value("title").toString();
    QString content = note.value("content").toString();
    QString type = note.value("item_type").toString();
    QByteArray blob = note.value("data_blob").toByteArray();

    m_edit->clear();
    
    // 增强 HTML 检测：采用更严谨的启发式算法，识别 Qt 生成的 HTML 模式
    // Qt 生成的 HTML 通常以 <!DOCTYPE HTML 开始，或者包含大量的 <style>
    QString trimmed = content.trimmed();
    m_isRichText = trimmed.startsWith("<!DOCTYPE", Qt::CaseInsensitive) || 
                   trimmed.startsWith("<html", Qt::CaseInsensitive) || 
                   trimmed.contains("<style", Qt::CaseInsensitive) ||
                   Qt::mightBeRichText(content);

    if (m_isRichText) {
        // 如果是 HTML 内容，加载为 HTML
        m_edit->setHtml(content);
        return;
    }

    // 纯文本/Markdown 逻辑
    QTextCursor cursor = m_edit->textCursor();

    if (type == "image" && !blob.isEmpty()) {
        QImage img;
        img.loadFromData(blob);
        if (!img.isNull()) {
            if (img.width() > 550) {
                img = img.scaledToWidth(550, Qt::SmoothTransformation);
            }
            cursor.insertImage(img);
            cursor.insertText("\n\n");
        }
    } else if (type == "local_file" || type == "local_folder" || type == "local_batch") {
        QTextCharFormat linkFmt;
        linkFmt.setForeground(QColor("#569CD6"));
        linkFmt.setFontUnderline(true);
        cursor.setCharFormat(linkFmt);
        cursor.insertText("📂 本地托管项目: " + title + "\n");
        cursor.setCharFormat(QTextCharFormat());
        cursor.insertText("相对路径: " + content + "\n\n");
        cursor.insertText("(双击左侧列表项可直接在资源管理器中打开)\n\n");
    } else if (type == "color") {
        cursor.insertHtml(QString("<div style='margin: 20px; text-align: center;'>"
                                  "  <div style='background-color: %1; width: 100%; height: 200px; border-radius: 12px; border: 1px solid #555;'></div>"
                                  "  <h1 style='color: white; margin-top: 20px; font-family: Consolas; font-size: 32px;'>%1</h1>"
                                  "</div>").arg(content));
    } else {
        cursor.insertText(content);
    }
    
    // 滚动到顶部
    m_edit->moveCursor(QTextCursor::Start);
}

void Editor::setPlainText(const QString& text) {
    m_currentNote.clear();
    m_edit->setPlainText(text);
}

QString Editor::toPlainText() const {
    return m_edit->toPlainText();
}

QString Editor::toHtml() const {
    return m_edit->toHtml();
}

void Editor::setPlaceholderText(const QString& text) {
    m_edit->setPlaceholderText(text);
}

void Editor::clearFormatting() {
    QTextCursor cursor = m_edit->textCursor();
    if (cursor.hasSelection()) {
        QTextCharFormat format;
        m_edit->setCurrentCharFormat(format);
        cursor.setCharFormat(format);
    } else {
        m_edit->setCurrentCharFormat(QTextCharFormat());
    }
}

void Editor::toggleList(bool ordered) {
    QTextCursor cursor = m_edit->textCursor();
    cursor.beginEditBlock();
    QTextList* list = cursor.currentList();
    QTextListFormat format;
    format.setStyle(ordered ? QTextListFormat::ListDecimal : QTextListFormat::ListDisc);
    
    if (list) {
        if (list->format().style() == format.style()) {
            QTextBlockFormat blockFmt;
            blockFmt.setObjectIndex(-1);
            cursor.setBlockFormat(blockFmt);
        } else {
            list->setFormat(format);
        }
    } else {
        cursor.createList(format);
    }
    cursor.endEditBlock();
}

bool Editor::findText(const QString& text, bool backward) {
    if (text.isEmpty()) return false;
    QTextDocument::FindFlags flags;
    if (backward) flags |= QTextDocument::FindBackward;
    
    bool found = m_edit->find(text, flags);
    if (!found) {
        // 循环搜索
        QTextCursor cursor = m_edit->textCursor();
        cursor.movePosition(backward ? QTextCursor::End : QTextCursor::Start);
        m_edit->setTextCursor(cursor);
        found = m_edit->find(text, flags);
    }
    return found;
}

void Editor::togglePreview(bool preview) {
    if (preview) {
        if (m_isRichText) {
            // 如果已经是富文本，直接同步 HTML 到预览框
            m_preview->setHtml(m_edit->toHtml());
            m_stack->setCurrentWidget(m_preview);
            return;
        }

        QString text = m_edit->toPlainText();
        QString html = "<html><head><style>"
                       "body { font-family: 'Microsoft YaHei'; color: #ddd; background-color: #1e1e1e; line-height: 1.6; padding: 20px; }"
                       "h1 { color: #569CD6; border-bottom: 1px solid #333; padding-bottom: 5px; }"
                       "h2 { color: #569CD6; border-bottom: 1px solid #222; }"
                       "code { background-color: #333; padding: 2px 4px; border-radius: 3px; font-family: Consolas; color: #98C379; }"
                       "pre { background-color: #252526; padding: 10px; border-radius: 5px; border: 1px solid #444; }"
                       "blockquote { border-left: 4px solid #569CD6; padding-left: 15px; color: #888; font-style: italic; background: #252526; margin: 10px 0; }"
                       "p { margin: 10px 0; }"
                       "img { max-width: 100%; border-radius: 5px; border: 1px solid #333; margin: 10px 0; }"
                       "</style></head><body>";

        // 如果是图片笔记，且 text 没有包含图片标记（目前逻辑下 text 是 H1 + content）
        // 我们在预览模式下根据 m_currentNote 显式渲染
        QString type = m_currentNote["item_type"].toString();
        QByteArray blob = m_currentNote["data_blob"].toByteArray();
        
        QStringList lines = text.split("\n");
        bool inCodeBlock = false;
        bool imageRendered = false;

        for (const QString& line : std::as_const(lines)) {
            if (line.startsWith("```")) {
                if (!inCodeBlock) { html += "<pre><code>"; inCodeBlock = true; }
                else { html += "</code></pre>"; inCodeBlock = false; }
                continue;
            }
            
            if (inCodeBlock) {
                html += line.toHtmlEscaped() + "<br>";
                continue;
            }

            if (line.startsWith("###### ")) html += "<h6>" + line.mid(7).toHtmlEscaped() + "</h6>";
            else if (line.startsWith("##### ")) html += "<h5>" + line.mid(6).toHtmlEscaped() + "</h5>";
            else if (line.startsWith("#### ")) html += "<h4>" + line.mid(5).toHtmlEscaped() + "</h4>";
            else if (line.startsWith("### ")) html += "<h3>" + line.mid(4).toHtmlEscaped() + "</h3>";
            else if (line.startsWith("## ")) html += "<h2>" + line.mid(3).toHtmlEscaped() + "</h2>";
            else if (line.startsWith("# ")) html += "<h1>" + line.mid(2).toHtmlEscaped() + "</h1>";
            else if (line.startsWith("> ")) html += "<blockquote>" + line.mid(2).toHtmlEscaped() + "</blockquote>";
            else if (line.startsWith("- [ ] ")) html += "<p><span style='color:#E5C07B;'>☐</span> " + line.mid(6).toHtmlEscaped() + "</p>";
            else if (line.startsWith("- [x] ")) html += "<p><span style='color:#6A9955;'>☑</span> " + line.mid(6).toHtmlEscaped() + "</p>";
            else if (line.isEmpty()) html += "<br>";
            else {
                // 处理行内代码 `code`
                QString processedLine = line.toHtmlEscaped();
                QRegularExpression inlineCode("`(.*?)`");
                processedLine.replace(inlineCode, "<code>\\1</code>");
                html += "<p>" + processedLine + "</p>";
            }
        }
        
        html += "</body></html>";
        m_preview->setHtml(html);
        m_stack->setCurrentWidget(m_preview);
    } else {
        m_stack->setCurrentWidget(m_edit);
    }
}

void Editor::setReadOnly(bool ro) {
    m_edit->setReadOnly(ro);
}
```

## 文件: `src/ui/Editor.h`

```cpp
#ifndef EDITOR_H
#define EDITOR_H

#include <QTextEdit>
#include <QSyntaxHighlighter>
#include <QRegularExpression>

class MarkdownHighlighter : public QSyntaxHighlighter {
    Q_OBJECT
public:
    explicit MarkdownHighlighter(QTextDocument* parent = nullptr);
protected:
    void highlightBlock(const QString& text) override;
private:
    struct HighlightingRule {
        QRegularExpression pattern;
        QTextCharFormat format;
    };
    QList<HighlightingRule> m_highlightingRules;
};

#include <QStackedWidget>

class InternalEditor : public QTextEdit {
    Q_OBJECT
public:
    explicit InternalEditor(QWidget* parent = nullptr);
    void insertTodo();
    void highlightSelection(const QColor& color);
protected:
    void insertFromMimeData(const QMimeData* source) override;
};

class Editor : public QWidget {
    Q_OBJECT
public:
    explicit Editor(QWidget* parent = nullptr);
    void setNote(const QVariantMap& note, bool isPreview = false);
    void setPlainText(const QString& text);
    QString toPlainText() const;
    QString toHtml() const;
    void setPlaceholderText(const QString& text);
    void togglePreview(bool preview);
    void setReadOnly(bool ro);
    
    // 代理 InternalEditor 的功能
    void undo() { m_edit->undo(); }
    void redo() { m_edit->redo(); }
    void insertTodo() { m_edit->insertTodo(); }
    void highlightSelection(const QColor& color) { m_edit->highlightSelection(color); }
    void clearFormatting();
    void toggleList(bool ordered);
    
    // 搜索功能
    bool findText(const QString& text, bool backward = false);

private:
    QStackedWidget* m_stack;
    InternalEditor* m_edit;
    QTextEdit* m_preview;
    MarkdownHighlighter* m_highlighter;
    QVariantMap m_currentNote;
    bool m_isRichText = false;
};

#endif // EDITOR_H
```

## 文件: `src/core/FileCryptoHelper.cpp`

```cpp
#include "FileCryptoHelper.h"
#include "AES.h"
#include <QDebug>
#include <QCryptographicHash>
#include <QRandomGenerator>
#include <QSysInfo>
#include <QThread>
#include <cstdint>

#define MAGIC_HEADER_SIZE 16
#define SALT_SIZE 16
#define IV_SIZE 16
#define KEY_SIZE 32
#define PBKDF2_ITERATIONS 5000 

static const char SHELL_MAGIC[MAGIC_HEADER_SIZE] = {'R', 'A', 'P', 'I', 'D', 'N', 'O', 'T', 'E', 'S', 'S', 'H', 'E', 'L', 'L', '!'};

QByteArray FileCryptoHelper::deriveKey(const QString& password, const QByteArray& salt) {
    QByteArray key = password.toUtf8();
    for (int i = 0; i < PBKDF2_ITERATIONS; ++i) {
        key = QCryptographicHash::hash(key + salt, QCryptographicHash::Sha256);
    }
    return key;
}

bool FileCryptoHelper::decryptFileLegacy(const QString& sourcePath, const QString& destPath, const QString& password) {
    QFile src(sourcePath);
    if (!src.open(QIODevice::ReadOnly)) return false;

    QByteArray salt = src.read(SALT_SIZE);
    QByteArray iv = src.read(IV_SIZE);
    QByteArray encryptedData = src.readAll();
    src.close();

    if (salt.size() != SALT_SIZE || iv.size() != IV_SIZE) return false;

    QByteArray key = deriveKey(password, salt);

    AES aes(AES::AES_256);
    std::vector<std::uint8_t> input((const std::uint8_t*)encryptedData.constData(), (const std::uint8_t*)encryptedData.constData() + encryptedData.size());
    std::vector<std::uint8_t> keyVec((const std::uint8_t*)key.constData(), (const std::uint8_t*)key.constData() + key.size());
    std::vector<std::uint8_t> ivVec((const std::uint8_t*)iv.constData(), (const std::uint8_t*)iv.constData() + iv.size());

    std::vector<std::uint8_t> decrypted = aes.decryptCBC(input, keyVec, ivVec);
    if (decrypted.empty()) return false;

    QFile dest(destPath);
    if (!dest.open(QIODevice::WriteOnly)) return false;
    dest.write((const char*)decrypted.data(), decrypted.size());
    dest.close();

    return true;
}

bool FileCryptoHelper::encryptFileWithShell(const QString& sourcePath, const QString& destPath, const QString& password) {
    QFile src(sourcePath);
    if (!src.open(QIODevice::ReadOnly)) return false;
    QByteArray srcData = src.readAll();
    src.close();

    QByteArray salt(SALT_SIZE, 0);
    QByteArray iv(IV_SIZE, 0);
    for(int i=0; i<SALT_SIZE; ++i) salt[i] = (char)QRandomGenerator::global()->bounded(256);
    for(int i=0; i<IV_SIZE; ++i) iv[i] = (char)QRandomGenerator::global()->bounded(256);

    QByteArray key = deriveKey(password, salt);

    AES aes(AES::AES_256);
    std::vector<std::uint8_t> input((const std::uint8_t*)srcData.constData(), (const std::uint8_t*)srcData.constData() + srcData.size());
    std::vector<std::uint8_t> keyVec((const std::uint8_t*)key.constData(), (const std::uint8_t*)key.constData() + key.size());
    std::vector<std::uint8_t> ivVec((const std::uint8_t*)iv.constData(), (const std::uint8_t*)iv.constData() + iv.size());
    
    std::vector<std::uint8_t> encrypted = aes.encryptCBC(input, keyVec, ivVec);

    QFile dest(destPath);
    if (!dest.open(QIODevice::WriteOnly)) return false;
    dest.write(SHELL_MAGIC, MAGIC_HEADER_SIZE);
    dest.write(salt);
    dest.write(iv);
    dest.write((const char*)encrypted.data(), encrypted.size());
    dest.close();

    return true;
}

bool FileCryptoHelper::decryptFileWithShell(const QString& sourcePath, const QString& destPath, const QString& password) {
    QFile src(sourcePath);
    if (!src.open(QIODevice::ReadOnly)) return false;

    QByteArray header = src.read(MAGIC_HEADER_SIZE);
    if (header != QByteArray(SHELL_MAGIC, MAGIC_HEADER_SIZE)) {
        src.close();
        return false;
    }

    QByteArray salt = src.read(SALT_SIZE);
    QByteArray iv = src.read(IV_SIZE);
    QByteArray encryptedData = src.readAll();
    src.close();

    if (salt.size() != SALT_SIZE || iv.size() != IV_SIZE) return false;

    QByteArray key = deriveKey(password, salt);

    AES aes(AES::AES_256);
    std::vector<std::uint8_t> input((const std::uint8_t*)encryptedData.constData(), (const std::uint8_t*)encryptedData.constData() + encryptedData.size());
    std::vector<std::uint8_t> keyVec((const std::uint8_t*)key.constData(), (const std::uint8_t*)key.constData() + key.size());
    std::vector<std::uint8_t> ivVec((const std::uint8_t*)iv.constData(), (const std::uint8_t*)iv.constData() + iv.size());

    std::vector<std::uint8_t> decrypted = aes.decryptCBC(input, keyVec, ivVec);
    if (decrypted.empty()) return false;

    QFile dest(destPath);
    if (!dest.open(QIODevice::WriteOnly)) return false;
    dest.write((const char*)decrypted.data(), decrypted.size());
    dest.close();

    return true;
}

QString FileCryptoHelper::getCombinedKey() {
    QString hardcode = "RapidNotes-Internal-Secret-Key-2024";
    QString fingerprint = QSysInfo::machineUniqueId();
    if (fingerprint.isEmpty()) fingerprint = QSysInfo::bootUniqueId();
    if (fingerprint.isEmpty()) fingerprint = "RapidNotes-Fallback-Fingerprint-v1";
    
    return QCryptographicHash::hash((hardcode + fingerprint).toUtf8(), QCryptographicHash::Sha256).toHex();
}

bool FileCryptoHelper::secureDelete(const QString& filePath) {
    QFile file(filePath);
    if (!file.exists()) return true;
    
    // 尝试多次删除 (处理 SQLite 延迟释放)
    for (int retry = 0; retry < 3; ++retry) {
        if (file.open(QIODevice::ReadWrite)) {
            qint64 size = file.size();
            if (size > 0) {
                QByteArray junk(4096, 0);
                for (qint64 i = 0; i < size; i += junk.size()) {
                    for(int j=0; j<junk.size(); ++j) junk[j] = (char)QRandomGenerator::global()->bounded(256);
                    file.write(junk);
                }
                file.flush();
            }
            file.close();
            if (QFile::remove(filePath)) return true;
        }
        QThread::msleep(100);
    }
    
    return QFile::remove(filePath);
}
```

## 文件: `src/core/FileCryptoHelper.h`

```cpp
#ifndef FILECRYPTOHELPER_H
#define FILECRYPTOHELPER_H

#include <QString>
#include <QByteArray>
#include <QFile>

class FileCryptoHelper {
public:
    // 三层架构专用：带魔数的壳加密/解密
    static bool encryptFileWithShell(const QString& sourcePath, const QString& destPath, const QString& password);
    static bool decryptFileWithShell(const QString& sourcePath, const QString& destPath, const QString& password);
    
    // 旧版解密 (Legacy): 不检查魔数
    static bool decryptFileLegacy(const QString& sourcePath, const QString& destPath, const QString& password);
    
    // 获取设备指纹与内置 Hardcode 结合的密钥
    static QString getCombinedKey();

    // 安全删除文件（覆盖后再删除）
    static bool secureDelete(const QString& filePath);

private:
    static QByteArray deriveKey(const QString& password, const QByteArray& salt);
};

#endif // FILECRYPTOHELPER_H
```

## 文件: `src/ui/FileSearchWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "FileSearchWindow.h"
#include "StringUtils.h"
#include "../core/ShortcutManager.h"

#include "IconHelper.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFileDialog>
#include <QDirIterator>
#include <QDesktopServices>
#include <QUrl>
#include <QFileInfo>
#include <QLabel>
#include <QProcess>
#include <QClipboard>
#include <QApplication>
#include <QMouseEvent>
#include <QPainter>
#include <QDir>
#include <QFile>
#include <QToolTip>
#include <QSettings>
#include <QSplitter>
#include <QMenu>
#include <QAction>
#include <QToolButton>
#include <QMimeData>
#include <QDropEvent>
#include <QDragEnterEvent>
#include <QDragMoveEvent>
#include <QGraphicsDropShadowEffect>
#include <QPropertyAnimation>
#include <QScrollArea>
#include <functional>
#include <utility>
#include <QSet>
#include <QDateTime>

// ----------------------------------------------------------------------------
// 合并逻辑相关常量与辅助函数
// ----------------------------------------------------------------------------
static const QSet<QString> SUPPORTED_EXTENSIONS = {
    ".py", ".pyw", ".cpp", ".cc", ".cxx", ".c", ".h", ".hpp", ".hxx",
    ".java", ".js", ".jsx", ".ts", ".tsx", ".cs", ".go", ".rs", ".swift",
    ".kt", ".kts", ".php", ".rb", ".lua", ".r", ".m", ".scala", ".sh",
    ".bash", ".zsh", ".ps1", ".bat", ".cmd", ".html", ".htm", ".css",
    ".scss", ".sass", ".less", ".xml", ".svg", ".vue", ".json", ".yaml",
    ".yml", ".toml", ".ini", ".cfg", ".conf", ".env", ".properties",
    ".cmake", ".gradle", ".make", ".mk", ".dockerfile", ".md", ".markdown",
    ".txt", ".rst", ".qml", ".qrc", ".qss", ".ui", ".sql", ".graphql",
    ".gql", ".proto", ".asm", ".s", ".v", ".vh", ".vhdl", ".vhd"
};

static const QSet<QString> SPECIAL_FILENAMES = {
    "Makefile", "makefile", "Dockerfile", "dockerfile", "CMakeLists.txt",
    "Rakefile", "Gemfile", ".gitignore", ".dockerignore", ".editorconfig",
    ".eslintrc", ".prettierrc"
};

static QString getFileLanguage(const QString& filePath) {
    QFileInfo fi(filePath);
    QString basename = fi.fileName();
    QString ext = "." + fi.suffix().toLower();
    
    static const QMap<QString, QString> specialMap = {
        {"Makefile", "makefile"}, {"makefile", "makefile"},
        {"Dockerfile", "dockerfile"}, {"dockerfile", "dockerfile"},
        {"CMakeLists.txt", "cmake"}
    };
    if (specialMap.contains(basename)) return specialMap[basename];

    static const QMap<QString, QString> extMap = {
        {".py", "python"}, {".pyw", "python"}, {".cpp", "cpp"}, {".cc", "cpp"},
        {".cxx", "cpp"}, {".c", "c"}, {".h", "cpp"}, {".hpp", "cpp"},
        {".hxx", "cpp"}, {".java", "java"}, {".js", "javascript"},
        {".jsx", "jsx"}, {".ts", "typescript"}, {".tsx", "tsx"},
        {".cs", "csharp"}, {".go", "go"}, {".rs", "rust"}, {".swift", "swift"},
        {".kt", "kotlin"}, {".kts", "kotlin"}, {".php", "php"}, {".rb", "ruby"},
        {".lua", "lua"}, {".r", "r"}, {".m", "objectivec"}, {".scala", "scala"},
        {".sh", "bash"}, {".bash", "bash"}, {".zsh", "zsh"}, {".ps1", "powershell"},
        {".bat", "batch"}, {".cmd", "batch"}, {".html", "html"}, {".htm", "html"},
        {".css", "css"}, {".scss", "scss"}, {".sass", "sass"}, {".less", "less"},
        {".xml", "xml"}, {".svg", "svg"}, {".vue", "vue"}, {".json", "json"},
        {".yaml", "yaml"}, {".yml", "yaml"}, {".toml", "toml"}, {".ini", "ini"},
        {".cfg", "ini"}, {".conf", "conf"}, {".env", "bash"},
        {".properties", "properties"}, {".cmake", "cmake"}, {".gradle", "gradle"},
        {".make", "makefile"}, {".mk", "makefile"}, {".dockerfile", "dockerfile"},
        {".md", "markdown"}, {".markdown", "markdown"}, {".txt", "text"},
        {".rst", "restructuredtext"}, {".qml", "qml"}, {".qrc", "xml"},
        {".qss", "css"}, {".ui", "xml"}, {".sql", "sql"}, {".graphql", "graphql"},
        {".gql", "graphql"}, {".proto", "protobuf"}, {".asm", "asm"},
        {".s", "asm"}, {".v", "verilog"}, {".vh", "verilog"}, {".vhdl", "vhdl"},
        {".vhd", "vhdl"}
    };
    return extMap.value(ext, ext.mid(1).isEmpty() ? "text" : ext.mid(1));
}

static bool isSupportedFile(const QString& filePath) {
    QFileInfo fi(filePath);
    if (SPECIAL_FILENAMES.contains(fi.fileName())) return true;
    return SUPPORTED_EXTENSIONS.contains("." + fi.suffix().toLower());
}

// ----------------------------------------------------------------------------
// PathHistory 相关辅助类 (复刻 SearchHistoryPopup 逻辑)
// ----------------------------------------------------------------------------
class PathChip : public QFrame {
    Q_OBJECT
public:
    PathChip(const QString& text, QWidget* parent = nullptr) : QFrame(parent), m_text(text) {
        setAttribute(Qt::WA_StyledBackground);
        setCursor(Qt::PointingHandCursor);
        setObjectName("PathChip");
        
        auto* layout = new QHBoxLayout(this);
        layout->setContentsMargins(10, 6, 10, 6);
        layout->setSpacing(10);
        
        auto* lbl = new QLabel(text);
        lbl->setStyleSheet("border: none; background: transparent; color: #DDD; font-size: 13px;");
        layout->addWidget(lbl);
        layout->addStretch();
        
        auto* btnDel = new QPushButton();
        btnDel->setIcon(IconHelper::getIcon("close", "#666", 16));
        btnDel->setIconSize(QSize(10, 10));
        btnDel->setFixedSize(16, 16);
        btnDel->setCursor(Qt::PointingHandCursor);
        btnDel->setStyleSheet(
            "QPushButton { background-color: transparent; border-radius: 4px; padding: 0px; }"
            "QPushButton:hover { background-color: #E74C3C; }"
        );
        
        connect(btnDel, &QPushButton::clicked, this, [this](){ emit deleted(m_text); });
        layout->addWidget(btnDel);

        setStyleSheet(
            "#PathChip { background-color: transparent; border: none; border-radius: 4px; }"
            "#PathChip:hover { background-color: #3E3E42; }"
        );
    }
    
    void mousePressEvent(QMouseEvent* e) override { 
        if(e->button() == Qt::LeftButton) emit clicked(m_text); 
        QFrame::mousePressEvent(e);
    }

signals:
    void clicked(const QString& text);
    void deleted(const QString& text);
private:
    QString m_text;
};

// ----------------------------------------------------------------------------
// Sidebar ListWidget subclass for Drag & Drop
// ----------------------------------------------------------------------------
class FileSidebarListWidget : public QListWidget {
    Q_OBJECT
public:
    explicit FileSidebarListWidget(QWidget* parent = nullptr) : QListWidget(parent) {
        setAcceptDrops(true);
    }
signals:
    void folderDropped(const QString& path);
protected:
    void dragEnterEvent(QDragEnterEvent* event) override {
        if (event->mimeData()->hasUrls() || event->mimeData()->hasText()) {
            event->acceptProposedAction();
        }
    }
    void dragMoveEvent(QDragMoveEvent* event) override {
        event->acceptProposedAction();
    }
    void dropEvent(QDropEvent* event) override {
        QString path;
        if (event->mimeData()->hasUrls()) {
            path = event->mimeData()->urls().at(0).toLocalFile();
        } else if (event->mimeData()->hasText()) {
            path = event->mimeData()->text();
        }
        
        if (!path.isEmpty() && QDir(path).exists()) {
            emit folderDropped(path);
            event->acceptProposedAction();
        }
    }
};

// ----------------------------------------------------------------------------
// FileCollectionListWidget 实现 (右侧边栏，支持多选和拖拽文件)
// ----------------------------------------------------------------------------
FileCollectionListWidget::FileCollectionListWidget(QWidget* parent) : QListWidget(parent) {
    setAcceptDrops(true);
    setSelectionMode(QAbstractItemView::ExtendedSelection); // 支持多选
}

void FileCollectionListWidget::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls() || event->mimeData()->hasText()) {
        event->acceptProposedAction();
    }
}

void FileCollectionListWidget::dragMoveEvent(QDragMoveEvent* event) {
    event->acceptProposedAction();
}

void FileCollectionListWidget::dropEvent(QDropEvent* event) {
    QStringList paths;
    if (event->mimeData()->hasUrls()) {
        for (const QUrl& url : event->mimeData()->urls()) {
            QString p = url.toLocalFile();
            if (!p.isEmpty() && QFileInfo(p).isFile()) paths << p;
        }
    } else if (event->mimeData()->hasText()) {
        QStringList texts = event->mimeData()->text().split("\n", Qt::SkipEmptyParts);
        for (const QString& t : texts) {
            QString p = t.trimmed();
            if (!p.isEmpty() && QFileInfo(p).isFile()) paths << p;
        }
    }
    
    if (!paths.isEmpty()) {
        emit filesDropped(paths);
        event->acceptProposedAction();
    } else if (event->source() && event->source() != this) {
        // 支持从中间列表拖拽 (通过 QListWidget 内部机制)
        QListWidget* sourceList = qobject_cast<QListWidget*>(event->source());
        if (sourceList) {
            QStringList sourcePaths;
            for (auto* item : sourceList->selectedItems()) {
                QString p = item->data(Qt::UserRole).toString();
                if (!p.isEmpty()) sourcePaths << p;
            }
            if (!sourcePaths.isEmpty()) {
                emit filesDropped(sourcePaths);
                event->acceptProposedAction();
            }
        }
    }
}

class FileSearchHistoryPopup : public QWidget {
    Q_OBJECT
public:
    enum Type { Path, Filename };

    explicit FileSearchHistoryPopup(FileSearchWindow* window, QLineEdit* edit, Type type) 
        : QWidget(window->window(), Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint) 
    {
        m_window = window;
        m_edit = edit;
        m_type = type;
        setAttribute(Qt::WA_TranslucentBackground);
        
        auto* rootLayout = new QVBoxLayout(this);
        rootLayout->setContentsMargins(12, 12, 12, 12);
        
        auto* container = new QFrame();
        container->setObjectName("PopupContainer");
        container->setStyleSheet(
            "#PopupContainer { background-color: #252526; border: 1px solid #444; border-radius: 10px; }"
        );
        rootLayout->addWidget(container);

        auto* layout = new QVBoxLayout(container);
        layout->setContentsMargins(12, 12, 12, 12);
        layout->setSpacing(10);

        auto* top = new QHBoxLayout();
        auto* icon = new QLabel();
        icon->setPixmap(IconHelper::getIcon("clock", "#888").pixmap(14, 14));
        icon->setStyleSheet("border: none; background: transparent;");
        top->addWidget(icon);

        auto* title = new QLabel(m_type == Path ? "最近扫描路径" : "最近搜索文件名");
        title->setStyleSheet("color: #888; font-weight: bold; font-size: 11px; background: transparent; border: none;");
        top->addWidget(title);
        top->addStretch();
        auto* clearBtn = new QPushButton("清空");
        clearBtn->setCursor(Qt::PointingHandCursor);
        clearBtn->setStyleSheet("QPushButton { background: transparent; color: #666; border: none; font-size: 11px; } QPushButton:hover { color: #E74C3C; }");
        connect(clearBtn, &QPushButton::clicked, [this](){
            if (m_type == Path) m_window->clearHistory();
            else m_window->clearSearchHistory();
            refreshUI();
        });
        top->addWidget(clearBtn);
        layout->addLayout(top);

        auto* scroll = new QScrollArea();
        scroll->setWidgetResizable(true);
        scroll->setStyleSheet(
            "QScrollArea { background-color: transparent; border: none; }"
            "QScrollArea > QWidget > QWidget { background-color: transparent; }"
        );
        scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

        m_chipsWidget = new QWidget();
        m_chipsWidget->setStyleSheet("background-color: transparent;");
        m_vLayout = new QVBoxLayout(m_chipsWidget);
        m_vLayout->setContentsMargins(0, 0, 0, 0);
        m_vLayout->setSpacing(2);
        m_vLayout->addStretch();
        scroll->setWidget(m_chipsWidget);
        layout->addWidget(scroll);

        m_opacityAnim = new QPropertyAnimation(this, "windowOpacity");
        m_opacityAnim->setDuration(200);
    }

    void refreshUI() {
        QLayoutItem* item;
        while ((item = m_vLayout->takeAt(0))) {
            if(item->widget()) item->widget()->deleteLater();
            delete item;
        }
        m_vLayout->addStretch();
        
        QStringList history = (m_type == Path) ? m_window->getHistory() : m_window->getSearchHistory();
        if(history.isEmpty()) {
            auto* lbl = new QLabel("暂无历史记录");
            lbl->setAlignment(Qt::AlignCenter);
            lbl->setStyleSheet("color: #555; font-style: italic; margin: 20px; border: none;");
            m_vLayout->insertWidget(0, lbl);
        } else {
            for(const QString& val : std::as_const(history)) {
                auto* chip = new PathChip(val);
                chip->setFixedHeight(32);
                connect(chip, &PathChip::clicked, this, [this](const QString& v){ 
                    if (m_type == Path) m_window->useHistoryPath(v);
                    else m_edit->setText(v);
                    close(); 
                });
                connect(chip, &PathChip::deleted, this, [this](const QString& v){ 
                    if (m_type == Path) m_window->removeHistoryEntry(v);
                    else m_window->removeSearchHistoryEntry(v);
                    refreshUI(); 
                });
                m_vLayout->insertWidget(m_vLayout->count() - 1, chip);
            }
        }
        
        int targetWidth = m_edit->width();
        // 统一高度为 410px，确保视觉一致性，不论记录多少（如同图一的效果）
        int contentHeight = 410;
        resize(targetWidth + 24, contentHeight);
    }

    void showAnimated() {
        refreshUI();
        QPoint pos = m_edit->mapToGlobal(QPoint(0, m_edit->height()));
        move(pos.x() - 12, pos.y() - 7);
        setWindowOpacity(0);
        show();
        m_opacityAnim->setStartValue(0);
        m_opacityAnim->setEndValue(1);
        m_opacityAnim->start();
    }

private:
    FileSearchWindow* m_window;
    QLineEdit* m_edit;
    Type m_type;
    QWidget* m_chipsWidget;
    QVBoxLayout* m_vLayout;
    QPropertyAnimation* m_opacityAnim;
};

// ----------------------------------------------------------------------------
// ScannerThread 实现
// ----------------------------------------------------------------------------
ScannerThread::ScannerThread(const QString& folderPath, QObject* parent)
    : QThread(parent), m_folderPath(folderPath) {}

void ScannerThread::stop() {
    m_isRunning = false;
    wait();
}

void ScannerThread::run() {
    int count = 0;
    if (m_folderPath.isEmpty() || !QDir(m_folderPath).exists()) {
        emit finished(0);
        return;
    }

    QStringList ignored = {".git", ".idea", "__pycache__", "node_modules", "$RECYCLE.BIN", "System Volume Information"};
    
    // 使用 std::function 实现递归扫描，支持目录剪枝
    std::function<void(const QString&)> scanDir = [&](const QString& currentPath) {
        if (!m_isRunning) return;

        QDir dir(currentPath);
        // 1. 获取当前目录下所有文件
        QFileInfoList files = dir.entryInfoList(QDir::Files | QDir::NoDotAndDotDot | QDir::Hidden);
        for (const auto& fi : std::as_const(files)) {
            if (!m_isRunning) return;
            bool hidden = fi.isHidden();
            // 在某些平台上，以 . 开头的文件可能没被标记为 hidden，但通常我们也视为隐性文件
            if (!hidden && fi.fileName().startsWith('.')) hidden = true;
            
            emit fileFound(fi.fileName(), fi.absoluteFilePath(), hidden);
            count++;
        }

        // 2. 获取子目录并递归 (排除忽略列表)
        QFileInfoList subDirs = dir.entryInfoList(QDir::Dirs | QDir::NoDotAndDotDot | QDir::Hidden);
        for (const auto& di : std::as_const(subDirs)) {
            if (!m_isRunning) return;
            if (!ignored.contains(di.fileName())) {
                scanDir(di.absoluteFilePath());
            }
        }
    };

    scanDir(m_folderPath);
    emit finished(count);
}

// ----------------------------------------------------------------------------
// FileSearchWindow 实现
// ----------------------------------------------------------------------------
FileSearchWindow::FileSearchWindow(QWidget* parent) 
    : FramelessDialog("查找文件", parent) 
{
    setObjectName("FileSearchWindow");
    loadWindowSettings();
    resize(1200, 680); // 增加默认宽度以容纳两个侧边栏
    setupStyles();
    initUI();
    loadFavorites();
    loadCollection(); // 加载收藏文件
    m_resizeHandle = new ResizeHandle(this, this);
    m_resizeHandle->raise();
}

FileSearchWindow::~FileSearchWindow() {
    if (m_scanThread) {
        m_scanThread->stop();
        m_scanThread->deleteLater();
    }
}

void FileSearchWindow::setupStyles() {
    // 1:1 复刻 Python 脚本中的 STYLESHEET
    setStyleSheet(R"(
        QWidget {
            font-family: "Microsoft YaHei", "Segoe UI", sans-serif;
            font-size: 14px;
            color: #E0E0E0;
            outline: none;
        }
        QSplitter::handle {
            background-color: #333;
        }
        QListWidget {
            background-color: #252526; 
            border: 1px solid #333333;
            border-radius: 6px;
            padding: 4px;
        }
        QListWidget::item {
            min-height: 20px;
            max-height: 20px;
            padding-left: 8px;
            border-radius: 4px;
            color: #CCCCCC;
        }
        QListWidget::item:selected {
            background-color: #37373D;
            border-left: 3px solid #007ACC;
            color: #FFFFFF;
        }
        #SidebarList::item:selected {
            background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #007ACC, stop:0.015 #007ACC, stop:0.016 #37373D, stop:1 #37373D);
            color: #FFFFFF;
            border-radius: 4px;
        }
        QListWidget::item:hover {
            background-color: #2A2D2E;
        }
        QLineEdit {
            background-color: #333333;
            border: 1px solid #444444;
            color: #FFFFFF;
            border-radius: 6px;
            padding: 8px;
            selection-background-color: #264F78;
        }
        QLineEdit:focus {
            border: 1px solid #007ACC;
            background-color: #2D2D2D;
        }
        #ActionBtn {
            background-color: #007ACC;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
        }
        #ActionBtn:hover {
            background-color: #0062A3;
        }
        QScrollBar:vertical {
            background: transparent;
            width: 8px;
            margin: 0px;
        }
        QScrollBar::handle:vertical {
            background: #555555;
            min-height: 20px;
            border-radius: 4px;
        }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
            height: 0px;
        }
    )");
}

void FileSearchWindow::initUI() {
    auto* mainLayout = new QHBoxLayout(m_contentArea);
    mainLayout->setContentsMargins(10, 10, 10, 10);
    mainLayout->setSpacing(0);

    auto* splitter = new QSplitter(Qt::Horizontal);
    splitter->setHandleWidth(1); // 细分界线
    mainLayout->addWidget(splitter);

    // --- 左侧边栏 ---
    auto* sidebarWidget = new QWidget();
    auto* sidebarLayout = new QVBoxLayout(sidebarWidget);
    sidebarLayout->setContentsMargins(0, 0, 10, 0); // 增加右侧间距，与 splitter handle 配合
    sidebarLayout->setSpacing(10);

    auto* headerLayout = new QHBoxLayout();
    headerLayout->setSpacing(5);
    auto* sidebarIcon = new QLabel();
    sidebarIcon->setPixmap(IconHelper::getIcon("folder", "#888").pixmap(14, 14));
    sidebarIcon->setStyleSheet("border: none; background: transparent;");
    headerLayout->addWidget(sidebarIcon);

    auto* sidebarHeader = new QLabel("收藏夹 (可拖入)");
    sidebarHeader->setStyleSheet("color: #888; font-weight: bold; font-size: 12px; border: none; background: transparent;");
    headerLayout->addWidget(sidebarHeader);
    headerLayout->addStretch();
    sidebarLayout->addLayout(headerLayout);

    auto* sidebar = new FileSidebarListWidget();
    m_sidebar = sidebar;
    m_sidebar->setObjectName("SidebarList");
    m_sidebar->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_sidebar->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_sidebar->setMinimumWidth(200);
    m_sidebar->setDragEnabled(false);
    m_sidebar->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(sidebar, &FileSidebarListWidget::folderDropped, this, &FileSearchWindow::addFavorite);
    connect(m_sidebar, &QListWidget::itemClicked, this, &FileSearchWindow::onSidebarItemClicked);
    connect(m_sidebar, &QListWidget::customContextMenuRequested, this, &FileSearchWindow::showSidebarContextMenu);
    sidebarLayout->addWidget(m_sidebar);

    auto* btnAddFav = new QPushButton("收藏当前路径");
    btnAddFav->setFixedHeight(32);
    btnAddFav->setCursor(Qt::PointingHandCursor);
    btnAddFav->setStyleSheet(
        "QPushButton { background-color: #2D2D30; border: 1px solid #444; color: #AAA; border-radius: 4px; font-size: 12px; }"
        "QPushButton:hover { background-color: #3E3E42; color: #FFF; border-color: #666; }"
    );
    connect(btnAddFav, &QPushButton::clicked, this, [this](){
        QString p = m_pathInput->text().trimmed();
        if (QDir(p).exists()) addFavorite(p);
    });
    sidebarLayout->addWidget(btnAddFav);

    splitter->addWidget(sidebarWidget);

    // --- 右侧主区域 ---
    auto* rightWidget = new QWidget();
    auto* layout = new QVBoxLayout(rightWidget);
    layout->setContentsMargins(10, 0, 10, 0); // 两侧保留间距
    layout->setSpacing(10);

    // 第一行：路径输入与浏览
    auto* pathLayout = new QHBoxLayout();
    m_pathInput = new QLineEdit();
    m_pathInput->setPlaceholderText("双击查看历史，或在此粘贴路径...");
    m_pathInput->setClearButtonEnabled(true);
    m_pathInput->installEventFilter(this);
    connect(m_pathInput, &QLineEdit::returnPressed, this, &FileSearchWindow::onPathReturnPressed);
    
    auto* btnScan = new QToolButton();
    btnScan->setIcon(IconHelper::getIcon("scan", "#1abc9c", 18));
    btnScan->setToolTip("开始扫描");
    btnScan->setFixedSize(38, 38);
    btnScan->setCursor(Qt::PointingHandCursor);
    btnScan->setStyleSheet("QToolButton { border: 1px solid #444; background: #2D2D30; border-radius: 6px; }"
                           "QToolButton:hover { background-color: #3E3E42; border-color: #007ACC; }");
    connect(btnScan, &QToolButton::clicked, this, &FileSearchWindow::onPathReturnPressed);

    auto* btnBrowse = new QToolButton();
    btnBrowse->setObjectName("ActionBtn");
    btnBrowse->setIcon(IconHelper::getIcon("folder", "#ffffff", 18));
    btnBrowse->setToolTip("浏览文件夹");
    btnBrowse->setFixedSize(38, 38);
    btnBrowse->setCursor(Qt::PointingHandCursor);
    connect(btnBrowse, &QToolButton::clicked, this, &FileSearchWindow::selectFolder);

    pathLayout->addWidget(m_pathInput);
    pathLayout->addWidget(btnScan);
    pathLayout->addWidget(btnBrowse);
    layout->addLayout(pathLayout);

    // 第二行：搜索过滤与后缀名
    auto* searchLayout = new QHBoxLayout();
    m_searchInput = new QLineEdit();
    m_searchInput->setPlaceholderText("输入文件名过滤...");
    m_searchInput->setClearButtonEnabled(true);
    m_searchInput->installEventFilter(this);
    connect(m_searchInput, &QLineEdit::textChanged, this, &FileSearchWindow::refreshList);
    connect(m_searchInput, &QLineEdit::returnPressed, this, [this](){
        addSearchHistoryEntry(m_searchInput->text().trimmed());
    });

    m_extInput = new QLineEdit();
    m_extInput->setPlaceholderText("后缀 (如 py)");
    m_extInput->setClearButtonEnabled(true);
    m_extInput->setFixedWidth(120);
    connect(m_extInput, &QLineEdit::textChanged, this, &FileSearchWindow::refreshList);

    searchLayout->addWidget(m_searchInput);
    searchLayout->addWidget(m_extInput);
    layout->addLayout(searchLayout);

    // 信息标签与显示隐藏文件勾选
    auto* infoLayout = new QHBoxLayout();
    m_infoLabel = new QLabel("等待操作...");
    m_infoLabel->setStyleSheet("color: #888888; font-size: 12px;");
    
    m_showHiddenCheck = new QCheckBox("显示隐性文件");
    m_showHiddenCheck->setStyleSheet(R"(
        QCheckBox { color: #888; font-size: 12px; spacing: 5px; }
        QCheckBox::indicator { width: 15px; height: 15px; border: 1px solid #444; border-radius: 3px; background: #2D2D30; }
        QCheckBox::indicator:checked { background-color: #007ACC; border-color: #007ACC; }
        QCheckBox::indicator:hover { border-color: #666; }
    )");
    connect(m_showHiddenCheck, &QCheckBox::toggled, this, &FileSearchWindow::refreshList);

    infoLayout->addWidget(m_infoLabel);
    infoLayout->addWidget(m_showHiddenCheck);
    infoLayout->addStretch();
    layout->addLayout(infoLayout);

    // 列表标题与复制全部按钮
    auto* listHeaderLayout = new QHBoxLayout();
    listHeaderLayout->setContentsMargins(0, 0, 0, 0);
    auto* listTitle = new QLabel("搜索结果");
    listTitle->setStyleSheet("color: #888; font-size: 11px; font-weight: bold; border: none; background: transparent;");
    
    auto* btnCopyAll = new QToolButton();
    btnCopyAll->setIcon(IconHelper::getIcon("copy", "#1abc9c", 14));
    btnCopyAll->setToolTip("复制全部搜索结果的路径");
    btnCopyAll->setFixedSize(20, 20);
    btnCopyAll->setCursor(Qt::PointingHandCursor);
    btnCopyAll->setStyleSheet("QToolButton { border: none; background: transparent; padding: 2px; }"
                               "QToolButton:hover { background-color: #3E3E42; border-radius: 4px; }");
    connect(btnCopyAll, &QToolButton::clicked, this, [this](){
        if (m_fileList->count() == 0) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 结果列表为空</b>");
            return;
        }
        QStringList paths;
        for (int i = 0; i < m_fileList->count(); ++i) {
            QString p = m_fileList->item(i)->data(Qt::UserRole).toString();
            if (!p.isEmpty()) paths << p;
        }
        if (paths.isEmpty()) return;
        QApplication::clipboard()->setText(paths.join("\n"));
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 已复制全部搜索结果</b>");
    });

    listHeaderLayout->addWidget(listTitle);
    listHeaderLayout->addStretch();
    listHeaderLayout->addWidget(btnCopyAll);
    layout->addLayout(listHeaderLayout);

    // 文件列表
    m_fileList = new QListWidget();
    m_fileList->setObjectName("FileList");
    m_fileList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_fileList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_fileList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    m_fileList->setContextMenuPolicy(Qt::CustomContextMenu);
    m_fileList->setDragEnabled(true);
    m_fileList->setDragDropMode(QAbstractItemView::DragOnly);
    connect(m_fileList, &QListWidget::customContextMenuRequested, this, &FileSearchWindow::showFileContextMenu);
    
    // 快捷键支持
    m_actionSelectAll = new QAction(this);
    m_actionSelectAll->setShortcutContext(Qt::WidgetShortcut);
    connect(m_actionSelectAll, &QAction::triggered, [this](){ m_fileList->selectAll(); });
    m_fileList->addAction(m_actionSelectAll);

    m_actionCopy = new QAction(this);
    m_actionCopy->setShortcutContext(Qt::WidgetShortcut);
    connect(m_actionCopy, &QAction::triggered, this, [this](){ copySelectedFiles(); });
    m_fileList->addAction(m_actionCopy);

    m_actionDelete = new QAction(this);
    m_actionDelete->setShortcutContext(Qt::WidgetShortcut);
    connect(m_actionDelete, &QAction::triggered, this, [this](){ onDeleteFile(); });
    m_fileList->addAction(m_actionDelete);

    m_actionScan = new QAction(this);
    connect(m_actionScan, &QAction::triggered, this, &FileSearchWindow::onPathReturnPressed);
    addAction(m_actionScan);

    updateShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &FileSearchWindow::updateShortcuts);

    layout->addWidget(m_fileList);

    splitter->addWidget(rightWidget);

    // --- 右侧边栏 (文件收藏) ---
    auto* collectionWidget = new QWidget();
    auto* collectionLayout = new QVBoxLayout(collectionWidget);
    collectionLayout->setContentsMargins(10, 0, 0, 0); // 增加左侧间距
    collectionLayout->setSpacing(10);

    auto* collHeaderLayout = new QHBoxLayout();
    collHeaderLayout->setSpacing(5);
    auto* collIcon = new QLabel();
    collIcon->setPixmap(IconHelper::getIcon("file", "#888").pixmap(14, 14));
    collIcon->setStyleSheet("border: none; background: transparent;");
    collHeaderLayout->addWidget(collIcon);

    auto* collHeader = new QLabel("文件收藏 (可多选/拖入)");
    collHeader->setStyleSheet("color: #888; font-weight: bold; font-size: 12px; border: none; background: transparent;");
    collHeaderLayout->addWidget(collHeader);
    collHeaderLayout->addStretch();
    collectionLayout->addLayout(collHeaderLayout);

    m_collectionSidebar = new FileCollectionListWidget();
    m_collectionSidebar->setObjectName("SidebarList"); // 复用样式
    m_collectionSidebar->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_collectionSidebar->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_collectionSidebar->setMinimumWidth(200);
    m_collectionSidebar->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_collectionSidebar, &FileCollectionListWidget::filesDropped, this, [this](const QStringList& paths){
        for(const QString& p : paths) addCollectionItem(p);
    });
    connect(m_collectionSidebar, &QListWidget::itemClicked, this, &FileSearchWindow::onCollectionItemClicked);
    connect(m_collectionSidebar, &QListWidget::customContextMenuRequested, this, &FileSearchWindow::showCollectionContextMenu);
    collectionLayout->addWidget(m_collectionSidebar);

    auto* btnMergeColl = new QPushButton("合并收藏内容");
    btnMergeColl->setFixedHeight(32);
    btnMergeColl->setCursor(Qt::PointingHandCursor);
    btnMergeColl->setStyleSheet(
        "QPushButton { background-color: #2D2D30; border: 1px solid #444; color: #AAA; border-radius: 4px; font-size: 12px; }"
        "QPushButton:hover { background-color: #3E3E42; color: #FFF; border-color: #666; }"
    );
    connect(btnMergeColl, &QPushButton::clicked, this, &FileSearchWindow::onMergeCollectionFiles);
    collectionLayout->addWidget(btnMergeColl);

    splitter->addWidget(collectionWidget);

    splitter->setStretchFactor(0, 0); // 左侧固定
    splitter->setStretchFactor(1, 1); // 中间伸缩
    splitter->setStretchFactor(2, 0); // 右侧固定
}

void FileSearchWindow::selectFolder() {
    QString d = QFileDialog::getExistingDirectory(this, "选择文件夹");
    if (!d.isEmpty()) {
        m_pathInput->setText(d);
        startScan(d);
    }
}

void FileSearchWindow::onPathReturnPressed() {
    QString p = m_pathInput->text().trimmed();
    if (QDir(p).exists()) {
        startScan(p);
    } else {
        m_infoLabel->setText("路径不存在");
        m_pathInput->setStyleSheet("border: 1px solid #FF3333;");
    }
}

void FileSearchWindow::startScan(const QString& path) {
    m_pathInput->setStyleSheet("");
    if (m_scanThread) {
        m_scanThread->stop();
        m_scanThread->deleteLater();
    }

    m_fileList->clear();
    m_filesData.clear();
    m_visibleCount = 0;
    m_hiddenCount = 0;
    m_infoLabel->setText("正在扫描: " + path);

    m_scanThread = new ScannerThread(path, this);
    connect(m_scanThread, &ScannerThread::fileFound, this, &FileSearchWindow::onFileFound);
    connect(m_scanThread, &ScannerThread::finished, this, &FileSearchWindow::onScanFinished);
    m_scanThread->start();
}

void FileSearchWindow::onFileFound(const QString& name, const QString& path, bool isHidden) {
    m_filesData.append({name, path, isHidden});
    if (isHidden) m_hiddenCount++;
    else m_visibleCount++;

    if (m_filesData.size() % 300 == 0) {
        m_infoLabel->setText(QString("已发现 %1 个文件 (可见:%2 隐性:%3)...").arg(m_filesData.size()).arg(m_visibleCount).arg(m_hiddenCount));
    }
}

void FileSearchWindow::onScanFinished(int count) {
    m_infoLabel->setText(QString("扫描结束，共 %1 个文件 (可见:%2 隐性:%3)").arg(count).arg(m_visibleCount).arg(m_hiddenCount));
    addHistoryEntry(m_pathInput->text().trimmed());
    
    // 按文件名排序 (不按目录)
    std::sort(m_filesData.begin(), m_filesData.end(), [](const FileData& a, const FileData& b){
        return a.name.localeAwareCompare(b.name) < 0;
    });

    refreshList();
}

void FileSearchWindow::refreshList() {
    m_fileList->clear();
    QString txt = m_searchInput->text().toLower();
    QString ext = m_extInput->text().toLower().trimmed();
    if (ext.startsWith(".")) ext = ext.mid(1);

    bool showHidden = m_showHiddenCheck->isChecked();

    int limit = 500;
    int shown = 0;

    for (const auto& data : std::as_const(m_filesData)) {
        if (!showHidden && data.isHidden) continue;
        if (!ext.isEmpty() && !data.name.toLower().endsWith("." + ext)) continue;
        if (!txt.isEmpty() && !data.name.toLower().contains(txt)) continue;

        auto* item = new QListWidgetItem(data.name);
        item->setData(Qt::UserRole, data.path);
        item->setToolTip(data.path);
        m_fileList->addItem(item);
        
        shown++;
        if (shown >= limit) {
            auto* warn = new QListWidgetItem("--- 结果过多，仅显示前 500 条 ---");
            warn->setForeground(QColor(255, 170, 0));
            warn->setTextAlignment(Qt::AlignCenter);
            warn->setFlags(Qt::NoItemFlags);
            m_fileList->addItem(warn);
            break;
        }
    }
}

void FileSearchWindow::showFileContextMenu(const QPoint& pos) {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        auto* item = m_fileList->itemAt(pos);
        if (item) {
            item->setSelected(true);
            selectedItems << item;
        }
    }

    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) paths << p;
    }

    if (paths.isEmpty()) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D30; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #3E3E42; }");
    
    if (selectedItems.size() == 1) {
        QString filePath = paths.first();
        menu.addAction(IconHelper::getIcon("folder", "#F1C40F"), "定位文件夹", [filePath](){
            QDesktopServices::openUrl(QUrl::fromLocalFile(QFileInfo(filePath).absolutePath()));
        });
        menu.addAction(IconHelper::getIcon("search", "#4A90E2"), "定位文件", [filePath](){
#ifdef Q_OS_WIN
            QStringList args;
            args << "/select," << QDir::toNativeSeparators(filePath);
            QProcess::startDetached("explorer.exe", args);
#endif
        });
        menu.addAction(IconHelper::getIcon("edit", "#3498DB"), "编辑", [this](){ onEditFile(); });
        menu.addSeparator();
    }

    QString copyPathText = selectedItems.size() > 1 ? "复制选中路径" : "复制完整路径";
    menu.addAction(IconHelper::getIcon("copy", "#2ECC71"), copyPathText, [paths](){
        QApplication::clipboard()->setText(paths.join("\n"));
    });

    if (selectedItems.size() == 1) {
        QString fileName = QFileInfo(paths.first()).fileName();
        menu.addAction(IconHelper::getIcon("copy", "#F39C12"), "复制文件名", [fileName](){
            QApplication::clipboard()->setText(fileName);
            ToolTipOverlay::instance()->showText(QCursor::pos(), "✔ 已复制文件名");
        });
    }

    QString copyFileText = selectedItems.size() > 1 ? "复制选中文件" : "复制文件";
    menu.addAction(IconHelper::getIcon("file", "#4A90E2"), copyFileText, [this](){ copySelectedFiles(); });

    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并选中内容", [this](){ onMergeSelectedFiles(); });

    menu.addSeparator();

    menu.addAction(IconHelper::getIcon("star", "#F1C40F"), "加入收藏", [this](){
        auto selectedItems = m_fileList->selectedItems();
        for (auto* item : selectedItems) {
            QString p = item->data(Qt::UserRole).toString();
            if (!p.isEmpty()) addCollectionItem(p);
        }
    });

    menu.addSeparator();
    menu.addAction(IconHelper::getIcon("cut", "#E67E22"), "剪切", [this](){ onCutFile(); });
    menu.addAction(IconHelper::getIcon("trash", "#E74C3C"), "删除", [this](){ onDeleteFile(); });

    menu.exec(m_fileList->mapToGlobal(pos));
}

void FileSearchWindow::onEditFile() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 请先选择要操作的内容</b>");
        return;
    }

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) paths << p;
    }
    if (paths.isEmpty()) return;

    QSettings settings("RapidNotes", "ExternalEditor");
    QString editorPath = settings.value("EditorPath").toString();

    // 尝试寻找 Notepad++
    if (editorPath.isEmpty() || !QFile::exists(editorPath)) {
        QStringList commonPaths = {
            "C:/Program Files/Notepad++/notepad++.exe",
            "C:/Program Files (x86)/Notepad++/notepad++.exe"
        };
        for (const QString& p : commonPaths) {
            if (QFile::exists(p)) {
                editorPath = p;
                break;
            }
        }
    }

    // 如果还没找到，让用户选择
    if (editorPath.isEmpty() || !QFile::exists(editorPath)) {
        editorPath = QFileDialog::getOpenFileName(this, "选择编辑器 (推荐 Notepad++)", "C:/Program Files", "Executable (*.exe)");
        if (editorPath.isEmpty()) return;
        settings.setValue("EditorPath", editorPath);
    }

    for (const QString& filePath : paths) {
        QProcess::startDetached(editorPath, { QDir::toNativeSeparators(filePath) });
    }
}

void FileSearchWindow::copySelectedFiles() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 请先选择要操作的内容</b>");
        return;
    }

    QList<QUrl> urls;
    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) {
            urls << QUrl::fromLocalFile(p);
            paths << p;
        }
    }
    if (urls.isEmpty()) return;

    QMimeData* mimeData = new QMimeData();
    mimeData->setUrls(urls);
    mimeData->setText(paths.join("\n"));

    QApplication::clipboard()->setMimeData(mimeData);

    QString msg = selectedItems.size() > 1 ? QString("✔ 已复制 %1 个文件").arg(selectedItems.size()) : "✔ 已复制到剪贴板";
    ToolTipOverlay::instance()->showText(QCursor::pos(), msg);
}

void FileSearchWindow::onCutFile() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 请先选择要操作的内容</b>");
        return;
    }

    QList<QUrl> urls;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) urls << QUrl::fromLocalFile(p);
    }
    if (urls.isEmpty()) return;

    QMimeData* mimeData = new QMimeData();
    mimeData->setUrls(urls);
    
#ifdef Q_OS_WIN
    // 设置 Preferred DropEffect 为 2 (DROPEFFECT_MOVE)，通知资源管理器这是“剪切”操作
    QByteArray data;
    data.resize(4);
    data[0] = 2; // DROPEFFECT_MOVE
    data[1] = 0;
    data[2] = 0;
    data[3] = 0;
    mimeData->setData("Preferred DropEffect", data);
#endif

    QApplication::clipboard()->setMimeData(mimeData);

    QString msg = selectedItems.size() > 1 ? QString("✔ 已剪切 %1 个文件").arg(selectedItems.size()) : "✔ 已剪切到剪贴板";
    ToolTipOverlay::instance()->showText(QCursor::pos(), msg);
}

void FileSearchWindow::onDeleteFile() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 请先选择要操作的内容</b>");
        return;
    }

    int successCount = 0;
    for (auto* item : std::as_const(selectedItems)) {
        QString filePath = item->data(Qt::UserRole).toString();
        if (filePath.isEmpty()) continue;

        if (QFile::moveToTrash(filePath)) {
            successCount++;
            // 从内存数据中移除
            for (int i = 0; i < m_filesData.size(); ++i) {
                if (m_filesData[i].path == filePath) {
                    m_filesData.removeAt(i);
                    break;
                }
            }
            delete item; // 从界面移除 (QListWidget 负责管理内存)
        }
    }

    if (successCount > 0) {
        QString msg = selectedItems.size() > 1 ? QString("✔ %1 个文件已移至回收站").arg(successCount) : "✔ 文件已移至回收站";
        ToolTipOverlay::instance()->showText(QCursor::pos(), msg);
        m_infoLabel->setText(msg);
    } else if (!selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 无法删除文件，请检查是否被占用</b>");
    }
}

void FileSearchWindow::onMergeFiles(const QStringList& filePaths, const QString& rootPath, bool useCombineDir) {
    if (filePaths.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 没有可合并的文件</b>");
        return;
    }

    QString targetDir = rootPath;
    if (useCombineDir) {
        // 获取程序运行目录下的 Combine 文件夹
        targetDir = QCoreApplication::applicationDirPath() + "/Combine";
        QDir dir(targetDir);
        if (!dir.exists()) dir.mkpath(".");
    }

    QString ts = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
    QString outName = QString("%1_code_export.md").arg(ts);
    QString outPath = QDir(targetDir).filePath(outName);

    QFile outFile(outPath);
    if (!outFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 无法创建输出文件</b>");
        return;
    }

    QTextStream out(&outFile);
    out.setEncoding(QStringConverter::Utf8);

    out << "# 代码导出结果 - " << ts << "\n\n";
    out << "**项目路径**: `" << rootPath << "`\n\n";
    out << "**文件总数**: " << filePaths.size() << "\n\n";

    QMap<QString, int> fileStats;
    for (const QString& fp : filePaths) {
        QString lang = getFileLanguage(fp);
        fileStats[lang]++;
    }

    out << "## 文件类型统计\n\n";
    QStringList langs = fileStats.keys();
    std::sort(langs.begin(), langs.end(), [&](const QString& a, const QString& b){
        return fileStats.value(a) > fileStats.value(b);
    });
    for (const QString& lang : std::as_const(langs)) {
        out << "- **" << lang << "**: " << fileStats.value(lang) << " 个文件\n";
    }
    out << "\n---\n\n";

    for (const QString& fp : filePaths) {
        QString relPath = QDir(rootPath).relativeFilePath(fp);
        QString lang = getFileLanguage(fp);

        out << "## 文件: `" << relPath << "`\n\n";
        out << "```" << lang << "\n";

        QFile inFile(fp);
        if (inFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QByteArray content = inFile.readAll();
            out << QString::fromUtf8(content);
            if (!content.endsWith('\n')) out << "\n";
        } else {
            out << "# 读取文件失败\n";
        }
        out << "```\n\n";
    }

    outFile.close();
    
    QString msg = QString("✔ 已保存: %1 (%2个文件)").arg(outName).arg(filePaths.size());
    ToolTipOverlay::instance()->showText(QCursor::pos(), msg);
}

void FileSearchWindow::onMergeSelectedFiles() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty() && isSupportedFile(p)) {
            paths << p;
        }
    }
    
    if (paths.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 选中项中没有支持的文件类型</b>");
        return;
    }

    QString rootPath = m_pathInput->text().trimmed();
    if (!QDir(rootPath).exists()) {
        rootPath = QFileInfo(paths.first()).absolutePath();
    }

    onMergeFiles(paths, rootPath);
}

void FileSearchWindow::onMergeFolderContent() {
    QListWidgetItem* item = m_sidebar->currentItem();
    if (!item) return;

    QString folderPath = item->data(Qt::UserRole).toString();
    if (!QDir(folderPath).exists()) return;

    QStringList filePaths;
    QDirIterator it(folderPath, QDir::Files | QDir::NoDotAndDotDot, QDirIterator::Subdirectories);
    while (it.hasNext()) {
        QString fp = it.next();
        if (isSupportedFile(fp)) {
            filePaths << fp;
        }
    }

    if (filePaths.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 文件夹中没有支持的文件类型</b>");
        return;
    }

    onMergeFiles(filePaths, folderPath);
}

void FileSearchWindow::updateShortcuts() {
    auto& sm = ShortcutManager::instance();
    if (m_actionSelectAll) m_actionSelectAll->setShortcut(sm.getShortcut("fs_select_all"));
    if (m_actionCopy) m_actionCopy->setShortcut(sm.getShortcut("fs_copy"));
    if (m_actionDelete) m_actionDelete->setShortcut(sm.getShortcut("fs_delete"));
    if (m_actionScan) m_actionScan->setShortcut(sm.getShortcut("fs_scan"));
}

void FileSearchWindow::resizeEvent(QResizeEvent* event) {
    FramelessDialog::resizeEvent(event);
    if (m_resizeHandle) {
        m_resizeHandle->move(width() - 20, height() - 20);
    }
}

// ----------------------------------------------------------------------------
// 历史记录与收藏夹 逻辑实现
// ----------------------------------------------------------------------------
void FileSearchWindow::addHistoryEntry(const QString& path) {
    if (path.isEmpty() || !QDir(path).exists()) return;
    QSettings settings("RapidNotes", "FileSearchHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(path);
    history.prepend(path);
    while (history.size() > 10) history.removeLast();
    settings.setValue("list", history);
}

QStringList FileSearchWindow::getHistory() const {
    QSettings settings("RapidNotes", "FileSearchHistory");
    return settings.value("list").toStringList();
}

void FileSearchWindow::clearHistory() {
    QSettings settings("RapidNotes", "FileSearchHistory");
    settings.setValue("list", QStringList());
}

void FileSearchWindow::removeHistoryEntry(const QString& path) {
    QSettings settings("RapidNotes", "FileSearchHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(path);
    settings.setValue("list", history);
}

void FileSearchWindow::addSearchHistoryEntry(const QString& text) {
    if (text.isEmpty()) return;
    QSettings settings("RapidNotes", "FileSearchFilenameHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(text);
    history.prepend(text);
    while (history.size() > 10) history.removeLast();
    settings.setValue("list", history);
}

QStringList FileSearchWindow::getSearchHistory() const {
    QSettings settings("RapidNotes", "FileSearchFilenameHistory");
    return settings.value("list").toStringList();
}

void FileSearchWindow::removeSearchHistoryEntry(const QString& text) {
    QSettings settings("RapidNotes", "FileSearchFilenameHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(text);
    settings.setValue("list", history);
}

void FileSearchWindow::clearSearchHistory() {
    QSettings settings("RapidNotes", "FileSearchFilenameHistory");
    settings.setValue("list", QStringList());
}

void FileSearchWindow::useHistoryPath(const QString& path) {
    m_pathInput->setText(path);
    startScan(path);
}

void FileSearchWindow::onSidebarItemClicked(QListWidgetItem* item) {
    if (!item) return;
    QString path = item->data(Qt::UserRole).toString();
    m_pathInput->setText(path);
    startScan(path);
}

void FileSearchWindow::showSidebarContextMenu(const QPoint& pos) {
    QListWidgetItem* item = m_sidebar->itemAt(pos);
    if (!item) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #252526; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #37373D; }");
    
    QAction* pinAct = menu.addAction(IconHelper::getIcon("pin", "#F1C40F"), "置顶文件夹");
    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并文件夹内容", [this](){ onMergeFolderContent(); });
    QAction* removeAct = menu.addAction(IconHelper::getIcon("close", "#E74C3C"), "取消收藏");
    
    QAction* selected = menu.exec(m_sidebar->mapToGlobal(pos));
    if (selected == pinAct) {
        int row = m_sidebar->row(item);
        if (row > 0) {
            QListWidgetItem* taken = m_sidebar->takeItem(row);
            m_sidebar->insertItem(0, taken);
            m_sidebar->setCurrentItem(taken);
            saveFavorites();
        }
    } else if (selected == removeAct) {
        delete m_sidebar->takeItem(m_sidebar->row(item));
        saveFavorites();
    }
}

void FileSearchWindow::addFavorite(const QString& path) {
    // 检查是否已存在
    for (int i = 0; i < m_sidebar->count(); ++i) {
        if (m_sidebar->item(i)->data(Qt::UserRole).toString() == path) return;
    }

    QFileInfo fi(path);
    QString displayName = fi.fileName();
    // [CRITICAL] 修复根目录（如 C:/）显示为空的问题：如果 fileName 为空，则显示本地化的完整路径。
    if (displayName.isEmpty()) displayName = QDir::toNativeSeparators(fi.absoluteFilePath());
    
    auto* item = new QListWidgetItem(IconHelper::getIcon("folder", "#F1C40F"), displayName);
    item->setData(Qt::UserRole, path);
    item->setToolTip(path);
    m_sidebar->addItem(item);
    saveFavorites();
}

void FileSearchWindow::loadFavorites() {
    QSettings settings("RapidNotes", "FileSearchFavorites");
    QStringList favs = settings.value("list").toStringList();
    for (const QString& path : std::as_const(favs)) {
        if (QDir(path).exists()) {
            QFileInfo fi(path);
            QString displayName = fi.fileName();
            // [CRITICAL] 同步修复加载时根目录显示为空的问题
            if (displayName.isEmpty()) displayName = QDir::toNativeSeparators(fi.absoluteFilePath());

            auto* item = new QListWidgetItem(IconHelper::getIcon("folder", "#F1C40F"), displayName);
            item->setData(Qt::UserRole, path);
            item->setToolTip(path);
            m_sidebar->addItem(item);
        }
    }
}

void FileSearchWindow::saveFavorites() {
    QStringList favs;
    for (int i = 0; i < m_sidebar->count(); ++i) {
        favs << m_sidebar->item(i)->data(Qt::UserRole).toString();
    }
    QSettings settings("RapidNotes", "FileSearchFavorites");
    settings.setValue("list", favs);
}

bool FileSearchWindow::eventFilter(QObject* watched, QEvent* event) {
    if (event->type() == QEvent::MouseButtonDblClick) {
        if (watched == m_pathInput) {
            auto* popup = new FileSearchHistoryPopup(this, m_pathInput, FileSearchHistoryPopup::Path);
            popup->showAnimated();
            return true;
        } else if (watched == m_searchInput) {
            auto* popup = new FileSearchHistoryPopup(this, m_searchInput, FileSearchHistoryPopup::Filename);
            popup->showAnimated();
            return true;
        }
    }
    return FramelessDialog::eventFilter(watched, event);
}

void FileSearchWindow::onCollectionItemClicked(QListWidgetItem* item) {
    // 默认点击可以实现定位文件或其他逻辑，这里目前保持选中即可
}

void FileSearchWindow::showCollectionContextMenu(const QPoint& pos) {
    auto selectedItems = m_collectionSidebar->selectedItems();
    if (selectedItems.isEmpty()) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #252526; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #37373D; }");
    
    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并选中内容", [this](){
        QStringList paths;
        for (auto* item : m_collectionSidebar->selectedItems()) {
            paths << item->data(Qt::UserRole).toString();
        }
        onMergeFiles(paths, "", true); // 使用 Combine 目录
    });

    menu.addAction(IconHelper::getIcon("close", "#E74C3C"), "取消收藏", [this](){
        for (auto* item : m_collectionSidebar->selectedItems()) {
            delete item;
        }
        saveCollection();
    });
    
    menu.exec(m_collectionSidebar->mapToGlobal(pos));
}

void FileSearchWindow::addCollectionItem(const QString& path) {
    // 检查是否已存在
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        if (m_collectionSidebar->item(i)->data(Qt::UserRole).toString() == path) return;
    }

    QFileInfo fi(path);
    auto* item = new QListWidgetItem(IconHelper::getIcon("file", "#2ECC71"), fi.fileName());
    item->setData(Qt::UserRole, path);
    item->setToolTip(path);
    m_collectionSidebar->addItem(item);
    saveCollection();
}

void FileSearchWindow::loadCollection() {
    QSettings settings("RapidNotes", "FileSearchCollection");
    QStringList coll = settings.value("list").toStringList();
    for (const QString& path : std::as_const(coll)) {
        if (QFile::exists(path)) {
            QFileInfo fi(path);
            auto* item = new QListWidgetItem(IconHelper::getIcon("file", "#2ECC71"), fi.fileName());
            item->setData(Qt::UserRole, path);
            item->setToolTip(path);
            m_collectionSidebar->addItem(item);
        }
    }
}

void FileSearchWindow::saveCollection() {
    QStringList coll;
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        coll << m_collectionSidebar->item(i)->data(Qt::UserRole).toString();
    }
    QSettings settings("RapidNotes", "FileSearchCollection");
    settings.setValue("list", coll);
}

void FileSearchWindow::onMergeCollectionFiles() {
    QStringList paths;
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        paths << m_collectionSidebar->item(i)->data(Qt::UserRole).toString();
    }
    if (paths.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 收藏夹为空</b>");
        return;
    }
    onMergeFiles(paths, "", true); // 使用 Combine 目录
}

#include "FileSearchWindow.moc"
```

## 文件: `src/ui/FileSearchWindow.h`

```cpp
#ifndef FILESEARCHWINDOW_H
#define FILESEARCHWINDOW_H

#include "FramelessDialog.h"
#include "ResizeHandle.h"
#include <QListWidget>
#include <QLineEdit>
#include <QPushButton>
#include <QCheckBox>
#include <QThread>
#include <QPair>
#include <QSplitter>
#include <atomic>

class FileSearchHistoryPopup;

/**
 * @brief 扫描线程：实现增量扫描与目录剪枝
 */
class ScannerThread : public QThread {
    Q_OBJECT
public:
    explicit ScannerThread(const QString& folderPath, QObject* parent = nullptr);
    void stop();

signals:
    void fileFound(const QString& name, const QString& path, bool isHidden);
    void finished(int count);

protected:
    void run() override;

private:
    QString m_folderPath;
    std::atomic<bool> m_isRunning{true};
};

/**
 * @brief 收藏侧边栏列表 (支持拖拽和多选)
 */
class FileCollectionListWidget : public QListWidget {
    Q_OBJECT
public:
    explicit FileCollectionListWidget(QWidget* parent = nullptr);
signals:
    void filesDropped(const QStringList& paths);
protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
};

/**
 * @brief 文件查找窗口：新增侧边栏收藏与路径历史记录
 */
class FileSearchWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit FileSearchWindow(QWidget* parent = nullptr);
    ~FileSearchWindow();

    // 历史记录操作接口 (供 Popup 调用)
    void addHistoryEntry(const QString& path);
    QStringList getHistory() const;
    void clearHistory();
    void removeHistoryEntry(const QString& path);
    void useHistoryPath(const QString& path);

    // 文件名搜索历史相关
    void addSearchHistoryEntry(const QString& text);
    QStringList getSearchHistory() const;
    void removeSearchHistoryEntry(const QString& text);
    void clearSearchHistory();

private slots:
    void selectFolder();
    void onPathReturnPressed();
    void startScan(const QString& path);
    void onFileFound(const QString& name, const QString& path, bool isHidden);
    void onScanFinished(int count);
    void refreshList();
    void showFileContextMenu(const QPoint& pos);
    void copySelectedFiles();
    void onEditFile();
    void onCutFile();
    void onDeleteFile();
    void onMergeSelectedFiles();
    void onMergeFolderContent();
    void onMergeCollectionFiles();
    
    // 侧边栏相关
    void onSidebarItemClicked(QListWidgetItem* item);
    void showSidebarContextMenu(const QPoint& pos);
    void addFavorite(const QString& path);

    // 收藏侧边栏 (右侧)
    void onCollectionItemClicked(QListWidgetItem* item);
    void showCollectionContextMenu(const QPoint& pos);
    void addCollectionItem(const QString& path);

protected:
    void resizeEvent(QResizeEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

private:
    void initUI();
    void setupStyles();
    void loadFavorites();
    void saveFavorites();
    void loadCollection();
    void saveCollection();
    void onMergeFiles(const QStringList& filePaths, const QString& rootPath, bool useCombineDir = false);
    void updateShortcuts();

    QListWidget* m_sidebar;
    FileCollectionListWidget* m_collectionSidebar;
    QAction* m_actionSelectAll = nullptr;
    QAction* m_actionCopy = nullptr;
    QAction* m_actionDelete = nullptr;
    QAction* m_actionScan = nullptr;
    QLineEdit* m_pathInput;
    QLineEdit* m_searchInput;
    QLineEdit* m_extInput;
    QLabel* m_infoLabel;
    QCheckBox* m_showHiddenCheck;
    QListWidget* m_fileList;
    
    ResizeHandle* m_resizeHandle;
    ScannerThread* m_scanThread = nullptr;
    FileSearchHistoryPopup* m_historyPopup = nullptr;
    
    struct FileData {
        QString name;
        QString path;
        bool isHidden;
    };
    QList<FileData> m_filesData;
    int m_visibleCount = 0;
    int m_hiddenCount = 0;
};

#endif // FILESEARCHWINDOW_H
```

## 文件: `src/ui/FileStorageWindow.cpp`

```cpp
#include "FileStorageWindow.h"
#include "IconHelper.h"
#include "../core/DatabaseManager.h"
#include <QDragEnterEvent>
#include <QDragLeaveEvent>
#include <QDropEvent>
#include <QMouseEvent>
#include <QMimeData>
#include <QFileInfo>
#include <QFile>
#include <QDir>
#include <utility>
#include <QApplication>
#include <QCoreApplication>
#include <QGraphicsDropShadowEffect>
#include <QHBoxLayout>
#include <QPushButton>
#include <QFrame>
#include <QFileDialog>
#include <QMenu>
#include <QToolTip>
#include <QDateTime>
#include <QDebug>

FileStorageWindow::FileStorageWindow(QWidget* parent) : FramelessDialog("存储文件", parent) {
    setObjectName("FileStorageWindow");
    loadWindowSettings();
    setAcceptDrops(true);
    resize(450, 430);

    initUI();
}

void FileStorageWindow::initUI() {
    auto* contentLayout = new QVBoxLayout(m_contentArea);
    contentLayout->setContentsMargins(20, 10, 20, 20);
    contentLayout->setSpacing(10);

    // Drop Area
    m_dropHint = new QPushButton("拖拽文件或文件夹到这里\n数据将完整拷贝至存储库");
    m_dropHint->setObjectName("DropArea");
    m_dropHint->setStyleSheet("QPushButton#DropArea { color: #888; font-size: 12px; border: 2px dashed #444; border-radius: 8px; padding: 20px; background: #181818; outline: none; } "
                               "QPushButton#DropArea:hover { border-color: #f1c40f; color: #f1c40f; background-color: rgba(241, 196, 15, 0.05); }");
    m_dropHint->setFixedHeight(100);
    connect(m_dropHint, &QPushButton::clicked, this, &FileStorageWindow::onSelectItems);
    contentLayout->addWidget(m_dropHint);

    // Status List
    m_statusList = new QListWidget();
    m_statusList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_statusList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_statusList->setStyleSheet("QListWidget { background-color: #252526; border: 1px solid #333; border-radius: 6px; color: #BBB; padding: 5px; font-size: 11px; } "
                                "QListWidget::item { padding: 4px; border-bottom: 1px solid #2d2d2d; }");
    contentLayout->addWidget(m_statusList);

    auto* tipLabel = new QLabel("文件将直接复制到 attachments 文件夹");
    tipLabel->setStyleSheet("color: #666; font-size: 10px;");
    tipLabel->setAlignment(Qt::AlignCenter);
    contentLayout->addWidget(tipLabel);
}

// ==========================================
// 1. 辅助工具函数
// ==========================================

QString FileStorageWindow::getStorageRoot() {
    QString path = QCoreApplication::applicationDirPath() + "/attachments";
    QDir dir(path);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    return path;
}

QString FileStorageWindow::getUniqueFilePath(const QString& dirPath, const QString& fileName) {
    QDir dir(dirPath);
    QString baseName = QFileInfo(fileName).completeBaseName();
    QString suffix = QFileInfo(fileName).suffix();
    if (!suffix.isEmpty()) suffix = "." + suffix;

    QString finalName = fileName;
    int counter = 1;

    while (dir.exists(finalName)) {
        finalName = QString("%1_%2%3").arg(baseName).arg(counter).arg(suffix);
        counter++;
    }
    return dir.filePath(finalName);
}

bool FileStorageWindow::copyRecursively(const QString& srcStr, const QString& dstStr) {
    QDir srcDir(srcStr);
    if (!srcDir.exists()) return false;

    QDir dstDir(dstStr);
    if (!dstDir.exists()) {
        dstDir.mkpath(".");
    }

    // 1. 复制所有文件
    for (const QString& file : srcDir.entryList(QDir::Files)) {
        QString srcFile = srcDir.filePath(file);
        QString dstFile = dstDir.filePath(file);
        if (!QFile::copy(srcFile, dstFile)) {
            return false;
        }
    }

    // 2. 递归复制子文件夹
    for (const QString& dir : srcDir.entryList(QDir::Dirs | QDir::NoDotAndDotDot)) {
        QString srcSub = srcDir.filePath(dir);
        QString dstSub = dstDir.filePath(dir);
        if (!copyRecursively(srcSub, dstSub)) {
            return false;
        }
    }
    return true;
}

// ==========================================
// 2. 核心存储逻辑
// ==========================================

void FileStorageWindow::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls()) {
        event->acceptProposedAction();
        m_dropHint->setStyleSheet("QPushButton#DropArea { color: #f1c40f; font-size: 12px; border: 2px dashed #f1c40f; border-radius: 8px; padding: 20px; background-color: rgba(241, 196, 15, 0.05); }");
    }
}

void FileStorageWindow::dragLeaveEvent(QDragLeaveEvent* event) {
    Q_UNUSED(event);
    m_dropHint->setStyleSheet("QPushButton#DropArea { color: #888; font-size: 12px; border: 2px dashed #444; border-radius: 8px; padding: 20px; background: #181818; outline: none; }");
}

void FileStorageWindow::dropEvent(QDropEvent* event) {
    const QMimeData* mimeData = event->mimeData();
    if (mimeData->hasUrls()) {
        QStringList paths;
        for (const QUrl& url : mimeData->urls()) {
            if (url.isLocalFile()) paths << url.toLocalFile();
        }
        
        if (!paths.isEmpty()) {
            processStorage(paths);
        }
    }
    m_dropHint->setStyleSheet("QPushButton#DropArea { color: #888; font-size: 12px; border: 2px dashed #444; border-radius: 8px; padding: 20px; background: #181818; outline: none; }");
}

void FileStorageWindow::processStorage(const QStringList& paths) {
    m_statusList->clear();
    if (paths.isEmpty()) return;

    if (paths.size() == 1) {
        QFileInfo info(paths.first());
        if (info.isDir()) {
            storeFolder(paths.first());
        } else {
            storeFile(paths.first());
        }
    } else {
        storeArchive(paths);
    }
}

void FileStorageWindow::storeFile(const QString& path) {
    QFileInfo info(path);
    QString storageDir = getStorageRoot();
    QString destPath = getUniqueFilePath(storageDir, info.fileName());
    
    if (QFile::copy(path, destPath)) {
        QFileInfo destInfo(destPath);
        QString relativePath = "attachments/" + destInfo.fileName();

        bool ok = DatabaseManager::instance().addNote(
            info.fileName(),
            relativePath,
            {"文件链接"},
            "#2c3e50",
            m_categoryId,
            "local_file",
            QByteArray(),
            "FileStorage",
            info.absoluteFilePath()
        );

        if (ok) {
            m_statusList->addItem("✅ 已归档: " + info.fileName());
        } else {
            m_statusList->addItem("❌ 数据库错误: " + info.fileName());
            QFile::remove(destPath);
        }
    } else {
        m_statusList->addItem("❌ 复制失败: 权限不足或文件被占用");
    }
}

void FileStorageWindow::storeFolder(const QString& path) {
    QFileInfo info(path);
    QString storageDir = getStorageRoot();
    QString destDir = getUniqueFilePath(storageDir, info.fileName());
    
    m_statusList->addItem("📂 正在导入文件夹: " + info.fileName() + "...");
    QApplication::processEvents();

    if (copyRecursively(path, destDir)) {
        QDir d(destDir);
        QString relativePath = "attachments/" + d.dirName();

        bool ok = DatabaseManager::instance().addNote(
            info.fileName(),
            relativePath,
            {"文件夹链接"},
            "#8e44ad",
            m_categoryId,
            "local_folder",
            QByteArray(),
            "FileStorage",
            info.absoluteFilePath()
        );

        if (ok) {
            m_statusList->addItem("✅ 文件夹归档成功");
        } else {
            m_statusList->addItem("❌ 数据库错误");
            QDir(destDir).removeRecursively();
        }
    } else {
        m_statusList->addItem("❌ 文件夹复制失败");
    }
}

void FileStorageWindow::storeArchive(const QStringList& paths) {
    QString timestamp = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
    QString folderName = "批量导入_" + timestamp;
    
    QString storageRoot = getStorageRoot();
    QString destDir = storageRoot + "/" + folderName;
    
    if (!QDir().mkpath(destDir)) {
        m_statusList->addItem("❌ 无法创建存储目录");
        return;
    }

    int successCount = 0;
    m_statusList->addItem("📦 正在处理 " + QString::number(paths.size()) + " 个项目...");
    QApplication::processEvents();

    for (const QString& srcPath : std::as_const(paths)) {
        QFileInfo srcInfo(srcPath);
        QString destPath = destDir + "/" + srcInfo.fileName();

        bool copyOk = false;
        if (srcInfo.isDir()) {
            copyOk = copyRecursively(srcPath, destPath);
        } else {
            copyOk = QFile::copy(srcPath, destPath);
        }

        if (copyOk) successCount++;
    }

    if (successCount > 0) {
        QString relativePath = "attachments/" + folderName;
        
        // 构建描述性标题：[数量个项目] 文件1, 文件2...
        QStringList names;
        for (const QString& p : paths) {
            names << QFileInfo(p).fileName();
        }
        QString descriptiveTitle = QString("[%1个项目] %2").arg(paths.size()).arg(names.join(", "));
        if (descriptiveTitle.length() > 120) {
            descriptiveTitle = descriptiveTitle.left(117) + "...";
        }

        bool ok = DatabaseManager::instance().addNote(
            descriptiveTitle,
            relativePath,
            {"批量导入"},
            "#34495e",
            m_categoryId,
            "local_batch",
            QByteArray(),
            "FileStorage",
            ""
        );

        if (ok) {
            m_statusList->addItem(QString("✅ 成功归档 %1/%2 个项目").arg(successCount).arg(paths.size()));
        } else {
            m_statusList->addItem("❌ 数据库写入失败");
        }
    } else {
        m_statusList->addItem("❌ 所有项目导入失败");
        QDir(destDir).removeRecursively();
    }
}


void FileStorageWindow::onSelectItems() {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       "QMenu::item { padding: 6px 20px; border-radius: 3px; } "
                       "QMenu::item:selected { background-color: #f1c40f; color: #1a1a1a; }");

    menu.addAction("选择并存入文件...", [this]() {
        QStringList files = QFileDialog::getOpenFileNames(this, "选择文件", "", "所有文件 (*.*)");
        if (!files.isEmpty()) {
            processStorage(files);
        }
    });

    menu.addAction("选择并存入文件夹...", [this]() {
        QString dir = QFileDialog::getExistingDirectory(this, "选择文件夹", "");
        if (!dir.isEmpty()) {
            processStorage({dir});
        }
    });

    menu.exec(QCursor::pos());
}
```

## 文件: `src/ui/FileStorageWindow.h`

```cpp
#ifndef FILESTORAGEWINDOW_H
#define FILESTORAGEWINDOW_H

#include "FramelessDialog.h"
#include <QLabel>
#include <QListWidget>
#include <QVBoxLayout>
#include <QPoint>

class QDragEnterEvent;
class QDragLeaveEvent;
class QDropEvent;
class QMouseEvent;
class QPushButton;

class FileStorageWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit FileStorageWindow(QWidget* parent = nullptr);
    void setCurrentCategory(int catId) { m_categoryId = catId; }

protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragLeaveEvent(QDragLeaveEvent* event) override;
    void dropEvent(QDropEvent* event) override;

private slots:
    void onSelectItems();

private:
    void initUI();
    void processStorage(const QStringList& paths);
    void storeFile(const QString& path);
    void storeFolder(const QString& path);
    void storeArchive(const QStringList& paths);

    QString getStorageRoot(); // 获取存储根目录
    QString getUniqueFilePath(const QString& dirPath, const QString& fileName); // 获取不重复的文件名
    bool copyRecursively(const QString& srcStr, const QString& dstStr); // 递归复制文件夹

    QPushButton* m_dropHint;
    QListWidget* m_statusList;
    QPoint m_dragPos;
    int m_categoryId = -1;
};

#endif // FILESTORAGEWINDOW_H
```

## 文件: `src/ui/FilterPanel.cpp`

```cpp
#include "FilterPanel.h"
#include "../core/DatabaseManager.h"
#include "IconHelper.h"
#include <QHBoxLayout>
#include <QHeaderView>
#include <QPainter>
#include <QApplication>
#include <QTimer>

FilterPanel::FilterPanel(QWidget* parent) : QWidget(parent) {
    setAttribute(Qt::WA_StyledBackground, true);
    setMouseTracking(true);
    setMinimumSize(230, 350);
    initUI();
    setupTree();
}

void FilterPanel::initUI() {
    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    // 内容容器
    auto* contentWidget = new QWidget();
    contentWidget->setStyleSheet(
        "QWidget { "
        "  background-color: transparent; "
        "  border: none; "
        "  border-bottom-left-radius: 0px; "
        "  border-bottom-right-radius: 0px; "
        "}"
    );
    auto* contentLayout = new QVBoxLayout(contentWidget);
    contentLayout->setContentsMargins(10, 8, 10, 10);
    contentLayout->setSpacing(8);

    // 树形筛选器
    m_tree = new QTreeWidget();
    m_tree->setHeaderHidden(true);
    m_tree->setIndentation(0);
    m_tree->setFocusPolicy(Qt::NoFocus);
    m_tree->setRootIsDecorated(false);
    m_tree->setUniformRowHeights(true);
    m_tree->setAnimated(true);
    m_tree->setAllColumnsShowFocus(true);
    m_tree->setStyleSheet(
        "QTreeWidget {"
        "  background-color: transparent;"
        "  color: #ddd;"
        "  border: none;"
        "  font-size: 12px;"
        "}"
        "QTreeWidget::branch { image: none; border: none; width: 0px; }"
        "QTreeWidget::item {"
        "  height: 28px;"
        "  border-radius: 4px;"
        "  margin-left: 10px;"
        "  margin-right: 10px;"
        "  padding-left: 2px;"
        "}"
        "QTreeWidget::item:hover { background-color: #2a2d2e; }"
        "QTreeWidget::item:selected { background-color: #37373d; color: white; }"
        "QTreeWidget::indicator {"
        "  width: 14px;"
        "  height: 14px;"
        "  margin-left: 20px;"
        "}"
        "QScrollBar:vertical { border: none; background: transparent; width: 6px; margin: 0px; }"
        "QScrollBar::handle:vertical { background: #444; border-radius: 3px; min-height: 20px; }"
        "QScrollBar::handle:vertical:hover { background: #555; }"
        "QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }"
        "QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { background: none; }"
    );
    connect(m_tree, &QTreeWidget::itemChanged, this, &FilterPanel::onItemChanged);
    connect(m_tree, &QTreeWidget::itemClicked, this, &FilterPanel::onItemClicked);
    m_tree->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    contentLayout->addWidget(m_tree);

    // 底部区域
    auto* bottomLayout = new QHBoxLayout();
    bottomLayout->setContentsMargins(0, 0, 0, 0);
    bottomLayout->setSpacing(4);

    m_btnReset = new QPushButton(" 重置");
    m_btnReset->setIcon(IconHelper::getIcon("refresh", "white"));
    m_btnReset->setCursor(Qt::PointingHandCursor);
    m_btnReset->setFixedWidth(80);
    m_btnReset->setStyleSheet(
        "QPushButton {"
        "  background-color: #252526;"
        "  border: 1px solid #444;"
        "  color: #888;"
        "  border-radius: 6px;"
        "  padding: 8px;"
        "  font-size: 12px;"
        "}"
        "QPushButton:hover { color: #ddd; background-color: #333; }"
    );
    connect(m_btnReset, &QPushButton::clicked, this, &FilterPanel::resetFilters);
    bottomLayout->addWidget(m_btnReset);
    bottomLayout->addStretch();

    contentLayout->addLayout(bottomLayout);
    mainLayout->addWidget(contentWidget);
}

void FilterPanel::setupTree() {
    struct Section {
        QString key;
        QString label;
        QString icon;
        QString color;
    };

    QList<Section> sections = {
        {"date_create", "创建时间", "today", "#2ecc71"},
        {"stars", "评级", "star_filled", "#f39c12"},
        {"colors", "颜色", "palette", "#e91e63"},
        {"types", "类型", "folder", "#3498db"},
        {"tags", "标签", "tag", "#e67e22"}
    };

    QFont headerFont = m_tree->font();
    headerFont.setBold(true);

    for (const auto& sec : sections) {
        auto* item = new QTreeWidgetItem(m_tree);
        item->setText(0, sec.label);
        item->setIcon(0, IconHelper::getIcon(sec.icon, sec.color));
        item->setExpanded(true);
        item->setFlags(Qt::ItemIsEnabled);
        item->setFont(0, headerFont);
        item->setForeground(0, QBrush(Qt::gray));
        m_roots[sec.key] = item;
    }

    addFixedDateOptions("date_create");
}

void FilterPanel::addFixedDateOptions(const QString& key) {
    if (!m_roots.contains(key)) return;
    auto* root = m_roots[key];

    struct Option {
        QString id;
        QString label;
        QString icon;
    };

    QList<Option> options = {
        {"today", "今日", "today"},
        {"yesterday", "昨日", "clock"},
        {"week", "本周", "today"},
        {"month", "本月", "today"}
    };

    m_blockItemClick = true;
    for (const auto& opt : options) {
        auto* item = new QTreeWidgetItem(root);
        item->setText(0, QString("%1 (0)").arg(opt.label));
        item->setData(0, Qt::UserRole, opt.id);
        item->setFlags(Qt::ItemIsUserCheckable | Qt::ItemIsEnabled | Qt::ItemIsSelectable);
        item->setCheckState(0, Qt::Unchecked);
    }
    m_blockItemClick = false;
}

void FilterPanel::updateStats(const QString& keyword, const QString& type, const QVariant& value) {
    m_tree->blockSignals(true);
    m_blockItemClick = true;

    QVariantMap stats = DatabaseManager::instance().getFilterStats(keyword, type, value);

    // 1. 评级
    QList<QVariantMap> starData;
    QVariantMap starStats = stats["stars"].toMap();
    for (int i = 5; i >= 1; --i) {
        int count = starStats[QString::number(i)].toInt();
        if (count > 0) {
            QVariantMap item;
            item["key"] = QString::number(i);
            item["label"] = QString(i, QChar(0x2605)); // ★
            item["count"] = count;
            starData.append(item);
        }
    }
    if (starStats["0"].toInt() > 0) {
        QVariantMap item;
        item["key"] = "0";
        item["label"] = "无评级";
        item["count"] = starStats["0"].toInt();
        starData.append(item);
    }
    refreshNode("stars", starData);

    // 2. 颜色
    QList<QVariantMap> colorData;
    QVariantMap colorStats = stats["colors"].toMap();
    for (auto it = colorStats.begin(); it != colorStats.end(); ++it) {
        int count = it.value().toInt();
        if (count > 0) {
            QVariantMap item;
            item["key"] = it.key();
            item["label"] = it.key();
            item["count"] = count;
            colorData.append(item);
        }
    }
    refreshNode("colors", colorData, true);

    // 3. 类型
    QMap<QString, QString> typeMap = {{"text", "文本"}, {"image", "图片"}, {"file", "文件"}};
    QList<QVariantMap> typeData;
    QVariantMap typeStats = stats["types"].toMap();
    for (auto it = typeStats.begin(); it != typeStats.end(); ++it) {
        int count = it.value().toInt();
        if (count > 0) {
            QVariantMap item;
            item["key"] = it.key();
            item["label"] = typeMap.value(it.key(), it.key());
            item["count"] = count;
            typeData.append(item);
        }
    }
    refreshNode("types", typeData);

    // 4. 标签
    QList<QVariantMap> tagData;
    QVariantMap tagStats = stats["tags"].toMap();
    for (auto it = tagStats.begin(); it != tagStats.end(); ++it) {
        QVariantMap item;
        item["key"] = it.key();
        item["label"] = it.key();
        item["count"] = it.value().toInt();
        tagData.append(item);
    }
    refreshNode("tags", tagData);

    // 5. 固定日期节点
    updateFixedNode("date_create", stats["date_create"].toMap());

    m_blockItemClick = false;
    m_tree->blockSignals(false);
}

void FilterPanel::refreshNode(const QString& key, const QList<QVariantMap>& items, bool isCol) {
    if (!m_roots.contains(key)) return;
    auto* root = m_roots[key];

    // 建立现有的 key -> item 映射
    QMap<QString, QTreeWidgetItem*> existingItems;
    for (int i = 0; i < root->childCount(); ++i) {
        auto* child = root->child(i);
        existingItems[child->data(0, Qt::UserRole).toString()] = child;
    }

    QSet<QString> currentKeys;
    for (const auto& data : items) {
        QString itemKey = data["key"].toString();
        QString label = data["label"].toString();
        int count = data["count"].toInt();
        currentKeys.insert(itemKey);

        QString newText = QString("%1 (%2)").arg(label).arg(count);
        if (existingItems.contains(itemKey)) {
            auto* child = existingItems[itemKey];
            if (child->text(0) != newText) {
                child->setText(0, newText);
            }
        } else {
            auto* child = new QTreeWidgetItem(root);
            child->setText(0, newText);
            child->setData(0, Qt::UserRole, itemKey);
            child->setFlags(Qt::ItemIsUserCheckable | Qt::ItemIsEnabled | Qt::ItemIsSelectable);
            child->setCheckState(0, Qt::Unchecked);
            
            if (isCol) {
                child->setIcon(0, IconHelper::getIcon("circle_filled", itemKey)); // 颜色项仍保留颜色圆点
            }
        }
    }

    // 移除不再需要的项目
    for (int i = root->childCount() - 1; i >= 0; --i) {
        auto* child = root->child(i);
        if (!currentKeys.contains(child->data(0, Qt::UserRole).toString())) {
            delete root->takeChild(i);
        }
    }
}

void FilterPanel::updateFixedNode(const QString& key, const QVariantMap& stats) {
    if (!m_roots.contains(key)) return;
    auto* root = m_roots[key];
    QMap<QString, QString> labels = {{"today", "今日"}, {"yesterday", "昨日"}, {"week", "本周"}, {"month", "本月"}};
    
    for (int i = 0; i < root->childCount(); ++i) {
        auto* child = root->child(i);
        QString val = child->data(0, Qt::UserRole).toString();
        int count = stats.value(val).toInt();
        QString baseLabel = labels.value(val, val);
        QString newText = QString("%1 (%2)").arg(baseLabel).arg(count);
        if (child->text(0) != newText) {
            child->setText(0, newText);
        }
    }
}

QVariantMap FilterPanel::getCheckedCriteria() const {
    QVariantMap criteria;
    for (auto it = m_roots.begin(); it != m_roots.end(); ++it) {
        QStringList checked;
        for (int i = 0; i < it.value()->childCount(); ++i) {
            auto* item = it.value()->child(i);
            if (item->checkState(0) == Qt::Checked) {
                checked << item->data(0, Qt::UserRole).toString();
            }
        }
        if (!checked.isEmpty()) {
            criteria[it.key()] = checked;
        }
    }
    return criteria;
}

void FilterPanel::resetFilters() {
    m_tree->blockSignals(true);
    for (auto* root : m_roots) {
        for (int i = 0; i < root->childCount(); ++i) {
            root->child(i)->setCheckState(0, Qt::Unchecked);
        }
    }
    m_tree->blockSignals(false);
    emit filterChanged();
}

void FilterPanel::onItemChanged(QTreeWidgetItem* item, int column) {
    if (m_blockItemClick) return;
    
    // 记录最近改变的项，用于防止 onItemClicked 重复处理
    m_lastChangedItem = item;
    QTimer::singleShot(100, [this]() { m_lastChangedItem = nullptr; });
    
    emit filterChanged();
}

void FilterPanel::onItemClicked(QTreeWidgetItem* item, int column) {
    if (!item) return;

    // 如果该项刚刚由 Qt 原生机制改变了状态（点击了复选框），则忽略此次点击事件
    if (m_lastChangedItem == item) return;

    if (item->parent() == nullptr) {
        item->setExpanded(!item->isExpanded());
    } else if (item->flags() & Qt::ItemIsUserCheckable) {
        m_blockItemClick = true;
        Qt::CheckState state = item->checkState(0);
        item->setCheckState(0, (state == Qt::Checked) ? Qt::Unchecked : Qt::Checked);
        m_blockItemClick = false;
        emit filterChanged();
    }
}
```

## 文件: `src/ui/FilterPanel.h`

```cpp
#ifndef FILTERPANEL_H
#define FILTERPANEL_H

#include <QWidget>
#include <QVariantMap>
#include <QVBoxLayout>
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QPushButton>
#include <QLabel>
#include <QMouseEvent>
#include <QGraphicsDropShadowEffect>

class FilterPanel : public QWidget {
    Q_OBJECT
public:
    explicit FilterPanel(QWidget* parent = nullptr);
    void updateStats(const QString& keyword, const QString& type, const QVariant& value);
    QVariantMap getCheckedCriteria() const;
    void resetFilters();

signals:
    void filterChanged();

private:
    void initUI();
    void setupTree();
    void addFixedDateOptions(const QString& key);
    void onItemChanged(QTreeWidgetItem* item, int column);
    void onItemClicked(QTreeWidgetItem* item, int column);
    void refreshNode(const QString& key, const QList<QVariantMap>& items, bool isCol = false);
    void updateFixedNode(const QString& key, const QVariantMap& stats);

    QWidget* m_container;
    QTreeWidget* m_tree;
    QPushButton* m_btnReset;

    QMap<QString, QTreeWidgetItem*> m_roots;
    bool m_blockItemClick = false;
    QTreeWidgetItem* m_lastChangedItem = nullptr;
};

#endif // FILTERPANEL_H
```

## 文件: `src/ui/FireworksOverlay.cpp`

```cpp
#include "FireworksOverlay.h"
#include <QPainter>
#include <QGuiApplication>
#include <QScreen>
#include <QRandomGenerator>
#include <cmath>
#include <QDebug>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Helper to get random double in range [min, max)
static double randomDouble(double min, double max) {
    return min + QRandomGenerator::global()->generateDouble() * (max - min);
}

Particle::Particle() : gravity(0), drag(0.92), size(2.0), decay(4.0), alpha(255.0), age(0), 
    index(0), total(1), rotation(0), spin(0), widthFactor(1.0), phase(0), amp(0) {}

bool Particle::update() {
    if (style == "butterfly") {
        pos += vel;
        vel.setY(vel.y() + gravity);
        vel *= drag;
        pos.setX(pos.x() + std::sin(age * 0.2 + phase) * 0.8);
        alpha -= decay;
        age++;
    } else if (style == "dna") {
        pos.setY(pos.y() + vel.y());
        age++;
        double offset = std::sin((pos.y() * 0.05) + phase) * amp;
        pos.setX(initialPos.x() + offset);
        alpha = (offset > 0) ? 255.0 : 100.0;
        if (age > 60) alpha = 0;
    } else if (style == "lightning") {
        alpha -= decay;
    } else if (style == "confetti") {
        pos += vel;
        vel.setY(vel.y() + gravity);
        vel *= drag;
        rotation += spin;
        widthFactor = std::abs(std::cos(rotation));
        alpha -= 2.0;
    } else if (style == "void") {
        if (mode == "suck") {
            pos += vel;
            double dist = std::sqrt(std::pow(pos.x() - initialPos.x(), 2) + std::pow(pos.y() - initialPos.y(), 2));
            if (dist < 5) {
                mode = "boom";
                double angle = randomDouble(0, M_PI * 2);
                double speed = randomDouble(2.0, 8.0);
                vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
                color = Qt::white;
            }
        } else {
            pos += vel;
            alpha -= 5.0;
        }
    } else if (style == "phoenix") {
        pos += vel;
        vel.setY(vel.y() + gravity);
        vel *= drag;
        if (age > 10 && color.green() > 5) {
            color.setGreen(color.green() - 5);
        }
        alpha -= decay;
        age++;
    } else {
        pos += vel;
        vel.setY(vel.y() + gravity);
        vel *= drag;
        alpha -= decay;
    }
    return alpha > 0;
}

FireworksOverlay* FireworksOverlay::m_instance = nullptr;

FireworksOverlay::FireworksOverlay(QWidget* parent) : QWidget(parent) {
    setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool | Qt::WindowTransparentForInput);
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_ShowWithoutActivating);
    
    m_timer = new QTimer(this);
    connect(m_timer, &QTimer::timeout, this, &FireworksOverlay::animate);
    
    // Resize to cover all screens
    QRect totalRect;
    for (QScreen* screen : QGuiApplication::screens()) {
        totalRect = totalRect.united(screen->geometry());
    }
    setGeometry(totalRect);
}

FireworksOverlay* FireworksOverlay::instance() {
    if (!m_instance) {
        m_instance = new FireworksOverlay();
    }
    return m_instance;
}

void FireworksOverlay::explode(const QPoint& pos) {
    // Ensure we cover the current screen configuration
    QRect totalRect;
    for (QScreen* screen : QGuiApplication::screens()) {
        totalRect = totalRect.united(screen->geometry());
    }
    if (geometry() != totalRect) {
        setGeometry(totalRect);
    }
    
    show();
    QPoint lp = mapFromGlobal(pos);

    QStringList styles = {"neon", "gold", "butterfly", "quantum", "heart", "galaxy", "frozen", "phoenix", 
                          "matrix", "dna", "lightning", "void", "confetti", "chaos"};
    QString style = styles.at(QRandomGenerator::global()->bounded(styles.size()));

    int count = 40;
    if (style == "matrix") count = 15;
    else if (style == "dna" || style == "lightning" || style == "butterfly") count = 30;
    else if (style == "heart" || style == "galaxy") count = 60;

    for (int i = 0; i < count; ++i) {
        Particle p;
        initParticle(p, lp, style, i, count);
        m_particles.append(p);
    }

    if (!m_timer->isActive()) {
        m_timer->start(16);
    }
}

void FireworksOverlay::initParticle(Particle& p, const QPoint& pos, const QString& style, int index, int total) {
    p.pos = pos;
    p.initialPos = pos;
    p.style = style;
    p.index = index;
    p.total = total;
    
    if (style == "butterfly") {
        double angle = randomDouble(0, M_PI * 2);
        double speed = randomDouble(1.0, 3.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = 0.01;
        p.drag = 0.96;
        p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(360), 220, 255);
        p.size = randomDouble(3.0, 5.0);
        p.decay = 2.0;
        p.phase = randomDouble(0, M_PI);
    } else if (style == "matrix") {
        static QString chars = "01COPYX";
        p.character = chars.at(QRandomGenerator::global()->bounded(chars.length()));
        p.vel = QPointF(0, randomDouble(3.0, 6.0));
        p.color = QColor(0, 255, 70);
        p.size = QRandomGenerator::global()->bounded(8, 12);
        p.decay = 5.0;
    } else if (style == "dna") {
        p.vel = QPointF(0, -randomDouble(1.0, 3.0));
        p.phase = (double(index) / total) * 4 * M_PI;
        p.amp = randomDouble(10.0, 15.0);
        p.decay = 3.0;
        p.color = (index % 2 == 0) ? QColor(0, 200, 255) : QColor(255, 0, 150);
    } else if (style == "lightning") {
        double angle = randomDouble(0, M_PI * 2);
        double dist = randomDouble(20.0, 60.0);
        QPointF target(pos.x() + std::cos(angle) * dist, pos.y() + std::sin(angle) * dist);
        int steps = 4;
        for (int i = 0; i < steps; ++i) {
            double t = double(i + 1) / steps;
            QPointF next(pos.x() + (target.x() - pos.x()) * t + randomDouble(-10.0, 10.0),
                         pos.y() + (target.y() - pos.y()) * t + randomDouble(-10.0, 10.0));
            p.lightningPoints.append(next);
        }
        p.color = QColor(220, 220, 255);
        p.decay = 20.0;
    } else if (style == "confetti") {
        double angle = randomDouble(0, M_PI * 2);
        double speed = randomDouble(2.0, 6.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = 0.2;
        p.drag = 0.92;
        p.spin = randomDouble(-0.2, 0.2);
        p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(360), 200, 255);
        p.size = randomDouble(4.0, 7.0);
    } else if (style == "void") {
        double angle = randomDouble(0, M_PI * 2);
        double dist = randomDouble(40.0, 80.0);
        p.pos = QPointF(pos.x() + std::cos(angle) * dist, pos.y() + std::sin(angle) * dist);
        p.vel = (QPointF(pos) - p.pos) * 0.15;
        p.color = QColor(150, 0, 255);
        p.mode = "suck";
        p.decay = 0;
    } else if (style == "heart") {
        double t = (double(index) / total) * 2 * M_PI;
        double scale = randomDouble(1.0, 1.8);
        p.vel = QPointF((16 * std::pow(std::sin(t), 3)) * 0.1 * scale,
                        -(13 * std::cos(t) - 5 * std::cos(2*t) - 2 * std::cos(3*t) - std::cos(4*t)) * 0.1 * scale);
        p.gravity = 0.02;
        p.color = QColor(255, 80, 150);
        p.decay = 3.0;
    } else if (style == "galaxy") {
        int arm = index % 3;
        double angle = (arm * 2.09) + (double(index) / total) + randomDouble(-0.2, 0.2);
        double speed = randomDouble(1.0, 3.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(200, 301), 220, 255);
        p.decay = 4.0;
    } else if (style == "frozen") {
        double angle = randomDouble(0, M_PI * 2);
        double speed = randomDouble(5.0, 12.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = 0.05;
        p.drag = 0.80;
        p.color = QColor(200, 255, 255);
        p.decay = 5.0;
    } else if (style == "phoenix") {
        double angle = randomDouble(M_PI + 0.5, 2 * M_PI - 0.5);
        double speed = randomDouble(1.0, 4.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = -0.1;
        p.color = QColor(255, int(randomDouble(150, 256)), 50);
        p.decay = 4.0;
    } else if (style == "chaos") {
        p.vel = QPointF(randomDouble(-2.0, 2.0), randomDouble(-2.0, 2.0));
        p.drag = 0.98;
        p.color = QColor(255, 50, 50);
        p.decay = 6.0;
    } else {
        double angle = randomDouble(0, M_PI * 2);
        double speed = randomDouble(1.0, 5.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = 0.15;
        if (style == "gold") {
            p.color = QColor(255, 235, 100);
            p.gravity = 0.25;
        } else {
            p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(360), 220, 255);
        }
        if (style == "quantum") {
            p.decay = 5.0;
        }
    }
}

void FireworksOverlay::animate() {
    if (m_particles.isEmpty()) {
        m_timer->stop();
        hide();
        return;
    }
    
    for (int i = m_particles.size() - 1; i >= 0; --i) {
        if (!m_particles[i].update()) {
            m_particles.removeAt(i);
        }
    }
    update();
}

void FireworksOverlay::paintEvent(QPaintEvent* event) {
    if (m_particles.isEmpty()) return;
    
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);
    painter.setCompositionMode(QPainter::CompositionMode_Plus);
    
    for (const Particle& pt : m_particles) {
        int alphaVal = int(pt.alpha);
        // Shimmer logic
        if (pt.style != "matrix") {
            double flicker = randomDouble(0.6, 1.0);
            alphaVal = int(pt.alpha * flicker);
        }
        
        QColor c = pt.color;
        c.setAlpha(std::max(0, std::min(255, alphaVal)));
        painter.setPen(Qt::NoPen);
        painter.setBrush(c);
        
        if (pt.style == "butterfly") {
            double flap = std::abs(std::sin(pt.age * 0.3 + pt.phase));
            painter.save();
            painter.translate(pt.pos);
            double angle = std::atan2(pt.vel.y(), pt.vel.x());
            painter.rotate(angle * 180.0 / M_PI + 90);
            double w = pt.size * flap;
            double h = pt.size;
            painter.drawEllipse(QPointF(-w, 0), w, h);
            painter.drawEllipse(QPointF(w, 0), w, h);
            painter.restore();
        } else if (pt.style == "matrix") {
            painter.setPen(c);
            QFont f("Consolas", int(pt.size));
            f.setBold(true);
            painter.setFont(f);
            painter.drawText(pt.pos, QString(pt.character));
        } else if (pt.style == "lightning") {
            painter.setPen(QPen(c, 1.5));
            QPainterPath path;
            path.moveTo(pt.initialPos);
            for (const QPointF& pnt : pt.lightningPoints) {
                path.lineTo(pnt);
            }
            painter.drawPath(path);
        } else if (pt.style == "confetti") {
            painter.save();
            painter.translate(pt.pos);
            painter.rotate(pt.rotation * 180.0 / M_PI);
            double w = 6 * pt.widthFactor;
            double h = 10;
            painter.drawRect(QRectF(-w / 2, -h / 2, w, h));
            painter.restore();
        } else if (pt.style == "quantum") {
            double s = pt.size * (pt.alpha / 255.0);
            painter.drawRect(QRectF(pt.pos.x() - s / 2, pt.pos.y() - s / 2, s, s));
        } else if (pt.style == "gold") {
            painter.setPen(QPen(c, pt.size));
            painter.drawLine(pt.pos, pt.pos - pt.vel);
        } else {
            painter.drawEllipse(pt.pos, pt.size, pt.size);
        }
    }
}
```

## 文件: `src/ui/FireworksOverlay.h`

```cpp
#ifndef FIREWORKSOVERLAY_H
#define FIREWORKSOVERLAY_H

#include <QWidget>
#include <QTimer>
#include <QColor>
#include <QList>
#include <QPointF>
#include <QPainterPath>

struct Particle {
    QPointF pos;
    QPointF initialPos;
    QPointF vel;
    double gravity;
    double drag;
    double size;
    double decay;
    QColor color;
    double alpha;
    int age;
    QString style;
    int index;
    int total;
    double rotation;
    double spin;
    QChar character;
    double widthFactor;
    double phase;
    double amp;
    QList<QPointF> lightningPoints;
    QString mode; // for 'void' style

    Particle();
    bool update();
};

class FireworksOverlay : public QWidget {
    Q_OBJECT
public:
    explicit FireworksOverlay(QWidget* parent = nullptr);
    static FireworksOverlay* instance();
    
    void explode(const QPoint& pos);

protected:
    void paintEvent(QPaintEvent* event) override;

private slots:
    void animate();

private:
    void initParticle(Particle& p, const QPoint& pos, const QString& style, int index, int total);
    
    QList<Particle> m_particles;
    QTimer* m_timer;
    static FireworksOverlay* m_instance;
};

#endif // FIREWORKSOVERLAY_H
```

## 文件: `src/ui/FloatingBall.cpp`

```cpp
#include "FloatingBall.h"
#include "../core/DatabaseManager.h"
#include "IconHelper.h"
#include <QGuiApplication>
#include <QScreen>
#include <QPainterPath>
#include <QtMath>
#include <QRandomGenerator>
#include <QMouseEvent>
#include <QContextMenuEvent>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QSettings>
#include <QApplication>
#include <utility>

FloatingBall::FloatingBall(QWidget* parent) 
    : QWidget(parent, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool | Qt::X11BypassWindowManagerHint) 
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAcceptDrops(true);
    setFixedSize(120, 120); // 1:1 复刻 Python 版尺寸
    
    m_timer = new QTimer(this);
    connect(m_timer, &QTimer::timeout, this, &FloatingBall::updatePhysics);
    m_timer->start(16);

    restorePosition();
    
    QSettings settings("RapidNotes", "FloatingBall");
    QString savedSkin = settings.value("skin", "mocha").toString();
    switchSkin(savedSkin);
}

void FloatingBall::paintEvent(QPaintEvent* event) {
    Q_UNUSED(event);
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);

    float cx = width() / 2.0f;
    float cy = height() / 2.0f;

    // 1. 绘制柔和投影 (根据皮肤形状动态适配，带羽化效果)
    painter.save();
    float s = 1.0f - (m_bookY / 25.0f); // 随高度缩放
    float shadowOpacity = 40 * s;
    
    if (m_skinName == "open") {
        // 摊开手稿皮肤：较宽的柔和投影
        float sw = 84, sh = 20;
        QRadialGradient grad(cx, cy + 35, sw/2);
        grad.setColorAt(0, QColor(0, 0, 0, shadowOpacity));
        grad.setColorAt(0.8, QColor(0, 0, 0, shadowOpacity * 0.3));
        grad.setColorAt(1, Qt::transparent);
        painter.setBrush(grad);
        painter.setPen(Qt::NoPen);
        painter.drawEllipse(QRectF(cx - (sw/2)*s, cy + 30, sw*s, sh*s));
    } else {
        // 笔记本皮肤：窄长且极度羽化的投影
        float sw = 48, sh = 12;
        QRadialGradient grad(cx, cy + 42, sw/2);
        grad.setColorAt(0, QColor(0, 0, 0, shadowOpacity));
        grad.setColorAt(0.7, QColor(0, 0, 0, shadowOpacity * 0.4));
        grad.setColorAt(1, Qt::transparent);
        painter.setBrush(grad);
        painter.setPen(Qt::NoPen);
        // 严格限制宽度在本体(56px)以内，杜绝边缘露头
        painter.drawEllipse(QRectF(cx - (sw/2)*s, cy + 38, sw*s, sh*s));
    }
    painter.restore();

    // 2. 绘制粒子
    for (const auto& p : m_particles) {
        QColor c = p.color;
        c.setAlphaF(p.life);
        painter.setBrush(c);
        painter.setPen(Qt::NoPen);
        painter.drawEllipse(p.pos, p.size, p.size);
    }

    // 3. 绘制笔记本
    painter.save();
    painter.translate(cx, cy + m_bookY);
    renderBook(&painter, m_skinName, 0); // 在 paintEvent 中只有 y 偏移是 translate 处理的，book 内部绘制居中
    painter.restore();

    // 4. 绘制钢笔
    painter.save();
    // paintEvent 中 pen 的位置偏移已经在 translate 中处理了
    // 但是原始代码是 translate(cx + m_penX, cy + m_penY - 5);
    // renderPen 需要 relative 坐标吗？
    // 让我们保持 renderPen 只负责画笔本身，坐标变换在外部做。
    painter.translate(cx + m_penX, cy + m_penY - 5);
    painter.rotate(m_penAngle);
    renderPen(&painter, m_skinName, 0, 0, 0); // 坐标和旋转已在外部 Transform 中完成
    painter.restore();
}

void FloatingBall::renderBook(QPainter* p, const QString& skinName, float /*bookY*/) {
    // bookY 参数在此场景下其实不需要，因为 painter 已经 translate 了
    // 为了保持静态函数的通用性，我们保留接口
    
    p->setPen(Qt::NoPen);
    if (skinName == "open") {
        float w = 80, h = 50;
        p->rotate(-5);
        QPainterPath path;
        path.moveTo(-w/2, -h/2); path.lineTo(0, -h/2 + 4);
        path.lineTo(w/2, -h/2); path.lineTo(w/2, h/2);
        path.lineTo(0, h/2 + 4); path.lineTo(-w/2, h/2); path.closeSubpath();
        p->setBrush(QColor("#f8f8f5"));
        p->drawPath(path);
        // 中缝阴影
        QLinearGradient grad(-10, 0, 10, 0);
        grad.setColorAt(0, QColor(0,0,0,0)); grad.setColorAt(0.5, QColor(0,0,0,20)); grad.setColorAt(1, QColor(0,0,0,0));
        p->setBrush(grad);
        p->drawRect(QRectF(-5, -h/2+4, 10, h-4));
        // 横线
        p->setPen(QPen(QColor(200, 200, 200), 1));
        for (int y = (int)(-h/2)+15; y < (int)(h/2); y += 7) {
            p->drawLine(int(-w/2+5), y, -5, y+2);
            p->drawLine(5, y+2, int(w/2-5), y);
        }
    } else {
        float w = 56, h = 76;
        if (skinName == "classic") {
            p->setBrush(QColor("#ebebe6"));
            p->drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 3, 3);
            QLinearGradient grad(-w, -h, w, h);
            grad.setColorAt(0, QColor("#3c3c41")); grad.setColorAt(1, QColor("#141419"));
            p->setBrush(grad);
            p->drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3);
            p->setBrush(QColor(10, 10, 10, 200));
            p->drawRect(QRectF(w/2 - 12, -h/2, 6, h));
        } else if (skinName == "royal") {
            p->setBrush(QColor("#f0f0eb"));
            p->drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 2, 2);
            QLinearGradient grad(-w, -h, w, 0);
            grad.setColorAt(0, QColor("#282864")); grad.setColorAt(1, QColor("#0a0a32"));
            p->setBrush(grad);
            p->drawRoundedRect(QRectF(-w/2, -h/2, w, h), 2, 2);
            p->setBrush(QColor(218, 165, 32));
            float c_size = 12;
            QPolygonF poly; poly << QPointF(w/2, -h/2) << QPointF(w/2-c_size, -h/2) << QPointF(w/2, -h/2+c_size);
            p->drawPolygon(poly);
        } else if (skinName == "matcha") {
            p->setBrush(QColor("#fafaf5"));
            p->drawRoundedRect(QRectF(-w/2+5, -h/2+5, w, h), 3, 3);
            QLinearGradient grad(-w, -h, w, h);
            grad.setColorAt(0, QColor("#a0be96")); grad.setColorAt(1, QColor("#64825a"));
            p->setBrush(grad);
            p->drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3);
            p->setBrush(QColor(255, 255, 255, 200));
            p->drawRoundedRect(QRectF(-w/2+10, -20, 34, 15), 2, 2);
        } else { // mocha / default
            p->setBrush(QColor("#f5f0e1"));
            p->drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 3, 3);
            QLinearGradient grad(-w, -h, w, h);
            grad.setColorAt(0, QColor("#5a3c32")); grad.setColorAt(1, QColor("#321e19"));
            p->setBrush(grad);
            p->drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3);
            p->setBrush(QColor(120, 20, 30));
            p->drawRect(QRectF(w/2 - 15, -h/2, 8, h));
        }
    }
}

void FloatingBall::renderPen(QPainter* p, const QString& skinName, float, float, float) {
    p->setPen(Qt::NoPen);
    QColor c_light, c_mid, c_dark;
    if (skinName == "royal") {
        c_light = QColor(60, 60, 70); c_mid = QColor(20, 20, 25); c_dark = QColor(26, 26, 26);
    } else if (skinName == "classic") {
        c_light = QColor(80, 80, 80); c_mid = QColor(30, 30, 30); c_dark = QColor(10, 10, 10);
    } else if (skinName == "matcha") {
        c_light = QColor(255, 255, 250); c_mid = QColor(240, 240, 230); c_dark = QColor(200, 200, 190);
    } else {
        c_light = QColor(180, 60, 70); c_mid = QColor(140, 20, 30); c_dark = QColor(60, 5, 10);
    }

    QLinearGradient bodyGrad(-6, 0, 6, 0);
    bodyGrad.setColorAt(0.0, c_light); bodyGrad.setColorAt(0.5, c_mid); bodyGrad.setColorAt(1.0, c_dark);
    QPainterPath path_body; path_body.addRoundedRect(QRectF(-6, -23, 12, 46), 5, 5);
    p->setBrush(bodyGrad); p->drawPath(path_body);
    
    QPainterPath tipPath;
    tipPath.moveTo(-3, 23); tipPath.lineTo(3, 23); tipPath.lineTo(0, 37); tipPath.closeSubpath();
    QLinearGradient tipGrad(-5, 0, 5, 0);
    tipGrad.setColorAt(0, QColor(240, 230, 180)); tipGrad.setColorAt(1, QColor(190, 170, 100));
    p->setBrush(tipGrad); p->drawPath(tipPath);
    
    p->setBrush(QColor(220, 200, 140)); p->drawRect(QRectF(-6, 19, 12, 4));
    p->setBrush(QColor(210, 190, 130)); p->drawRoundedRect(QRectF(-1.5, -17, 3, 24), 1.5, 1.5);
}

void FloatingBall::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_pressPos = event->pos();
        m_isDragging = false; // 初始不进入拖拽，等待 move 判定
        m_penY += 3.0f; // 1:1 复刻 Python 按下弹性反馈
        update();
    }
}

void FloatingBall::mouseMoveEvent(QMouseEvent* event) {
    if (event->buttons() & Qt::LeftButton) {
        if (!m_isDragging) {
            // 只有移动距离超过系统设定的拖拽阈值才开始移动
            if ((event->pos() - m_pressPos).manhattanLength() > QApplication::startDragDistance()) {
                m_isDragging = true;
                m_offset = m_pressPos;
            }
        }
        
        if (m_isDragging) {
            QPoint newPos = event->globalPosition().toPoint() - m_offset;
            QScreen* screen = QGuiApplication::screenAt(event->globalPosition().toPoint());
            if (!screen) screen = QGuiApplication::primaryScreen();
            
            if (screen) {
                QRect ag = screen->availableGeometry();
                int x = qBound(ag.left(), newPos.x(), ag.right() - width());
                int y = qBound(ag.top(), newPos.y(), ag.bottom() - height());
                newPos = QPoint(x, y);
            }
            move(newPos);
        }
    }
}

void FloatingBall::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_isDragging = false;
        savePosition();
    }
}

void FloatingBall::mouseDoubleClickEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        emit doubleClicked();
    }
}

void FloatingBall::enterEvent(QEnterEvent* event) {
    Q_UNUSED(event);
    m_isHovering = true;
}

void FloatingBall::leaveEvent(QEvent* event) {
    Q_UNUSED(event);
    m_isHovering = false;
}

void FloatingBall::contextMenuEvent(QContextMenuEvent* event) {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet(
        "QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
        /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
        "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
        "QMenu::icon { margin-left: 6px; } "
        "QMenu::item:selected { background-color: #4a90e2; color: white; } "
        "QMenu::separator { background-color: #444; height: 1px; margin: 4px 0; }"
    );

    QMenu* skinMenu = menu.addMenu(IconHelper::getIcon("palette", "#aaaaaa", 18), "切换外观");
    skinMenu->setStyleSheet(menu.styleSheet());
    skinMenu->addAction(IconHelper::getIcon("coffee", "#BCAAA4", 18), "摩卡·勃艮第", [this](){ switchSkin("mocha"); });
    skinMenu->addAction(IconHelper::getIcon("grid", "#90A4AE", 18), "经典黑金", [this](){ switchSkin("classic"); });
    skinMenu->addAction(IconHelper::getIcon("book", "#9FA8DA", 18), "皇家蓝", [this](){ switchSkin("royal"); });
    skinMenu->addAction(IconHelper::getIcon("leaf", "#A5D6A7", 18), "抹茶绿", [this](){ switchSkin("matcha"); });
    skinMenu->addAction(IconHelper::getIcon("book_open", "#FFCC80", 18), "摊开手稿", [this](){ switchSkin("open"); });
    skinMenu->addAction("默认天蓝", [this](){ switchSkin("default"); });

    menu.addSeparator();
    menu.addAction(IconHelper::getIcon("zap", "#aaaaaa", 18), "打开快速笔记", this, &FloatingBall::requestQuickWindow);
    menu.addAction(IconHelper::getIcon("monitor", "#aaaaaa", 18), "打开主界面", this, &FloatingBall::requestMainWindow);
    menu.addAction(IconHelper::getIcon("toolbox", "#aaaaaa", 18), "打开工具箱", this, &FloatingBall::requestToolbox);
    menu.addAction(IconHelper::getIcon("add", "#aaaaaa", 18), "新建灵感", this, &FloatingBall::requestNewIdea);
    menu.addSeparator();
    menu.addAction(IconHelper::getIcon("power", "#aaaaaa", 18), "退出程序", [](){ qApp->quit(); });
    
    menu.exec(event->globalPos());
}

void FloatingBall::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasText()) {
        event->accept();
        m_isHovering = true;
    } else {
        event->ignore();
    }
}

void FloatingBall::dragLeaveEvent(QDragLeaveEvent* event) {
    Q_UNUSED(event);
    m_isHovering = false;
}

void FloatingBall::dropEvent(QDropEvent* event) {
    m_isHovering = false;
    QString text = event->mimeData()->text();
    if (!text.trimmed().isEmpty()) {
        // 提取第一个非空行作为标题
        QString title;
        QStringList lines = text.split('\n');
        for (const QString& line : std::as_const(lines)) {
            QString trimmed = line.trimmed();
            if (!trimmed.isEmpty()) {
                title = trimmed.left(40);
                if (trimmed.length() > 40) title += "...";
                break;
            }
        }

        if (title.isEmpty()) {
            title = "拖拽创建数据";
        }

        DatabaseManager::instance().addNoteAsync(title, text, {"拖拽"}, "", -1, "text");
        burstParticles();
        m_isWriting = true;
        m_writeTimer = 0;
        event->acceptProposedAction();
    }
}

QIcon FloatingBall::generateBallIcon() {
    QPixmap pixmap(120, 120);
    pixmap.fill(Qt::transparent);
    
    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);
    
    float cx = 60.0f;
    float cy = 60.0f;
    
    // 静态状态参数 (无动画)
    float bookY = 0.0f;
    float penX = 0.0f;
    float penY = 0.0f;
    float penAngle = -45.0f;
    QString skinName = "mocha";
    
    // 柔和投影 (图标模式保持静态最佳效果)
    painter.save();
    float sw = 48, sh = 12;
    QRadialGradient grad(cx, cy + 42, sw/2);
    grad.setColorAt(0, QColor(0, 0, 0, 35));
    grad.setColorAt(0.7, QColor(0, 0, 0, 15));
    grad.setColorAt(1, Qt::transparent);
    painter.setBrush(grad);
    painter.setPen(Qt::NoPen);
    painter.drawEllipse(QRectF(cx - sw/2, cy + 38, sw, sh));
    painter.restore();
    
    // 笔记本
    painter.save();
    painter.translate(cx, cy + bookY);
    renderBook(&painter, skinName, 0);
    painter.restore();
    
    // 钢笔
    painter.save();
    painter.translate(cx + penX, cy + penY - 5);
    painter.rotate(penAngle);
    renderPen(&painter, skinName, 0, 0, 0);
    painter.restore();
    
    return QIcon(pixmap);
}

void FloatingBall::switchSkin(const QString& name) {
    m_skinName = name;
    
    QSettings settings("RapidNotes", "FloatingBall");
    settings.setValue("skin", name);
    
    update();
}

void FloatingBall::burstParticles() {
    // 逻辑保持
}

void FloatingBall::updatePhysics() {
    m_timeStep += 0.05f;
    
    // 1. 待机呼吸
    float idlePenY = qSin(m_timeStep * 0.5f) * 4.0f;
    float idleBookY = qSin(m_timeStep * 0.5f - 1.0f) * 2.0f;
    
    float targetPenAngle = -45.0f;
    float targetPenX = 0.0f;
    float targetPenY = idlePenY;
    float targetBookY = idleBookY;
    
    // 2. 书写/悬停动画
    if (m_isWriting || m_isHovering) {
        m_writeTimer++;
        targetPenAngle = -65.0f;
        float writeSpeed = m_timeStep * 3.0f;
        targetPenX = qSin(writeSpeed) * 8.0f;
        targetPenY = 5.0f + qCos(writeSpeed * 2.0f) * 2.0f;
        targetBookY = -3.0f;
        
        if (m_isWriting && m_writeTimer > 90) {
            m_isWriting = false;
        }
    }
    
    // 3. 物理平滑
    float easing = 0.1f;
    m_penAngle += (targetPenAngle - m_penAngle) * easing;
    m_penX += (targetPenX - m_penX) * easing;
    m_penY += (targetPenY - m_penY) * easing;
    m_bookY += (targetBookY - m_bookY) * easing;

    updateParticles();
    update();
}

void FloatingBall::updateParticles() {
    if ((m_isWriting || m_isHovering) && m_particles.size() < 15) {
        if (QRandomGenerator::global()->generateDouble() < 0.3) {
            float rad = qDegreesToRadians(m_penAngle);
            float tipLen = 35.0f;
            Particle p;
            p.pos = QPointF(width()/2.0f + m_penX - qSin(rad)*tipLen, height()/2.0f + m_penY + qCos(rad)*tipLen);
            p.velocity = QPointF(QRandomGenerator::global()->generateDouble() - 0.5, QRandomGenerator::global()->generateDouble() + 0.5);
            p.life = 1.0;
            p.size = 1.0f + QRandomGenerator::global()->generateDouble() * 2.0f;
            p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(360), 150, 255);
            m_particles.append(p);
        }
    }
    for (int i = 0; i < m_particles.size(); ++i) {
        m_particles[i].pos += m_particles[i].velocity;
        m_particles[i].life -= 0.03;
        m_particles[i].size *= 0.96f;
        if (m_particles[i].life <= 0) {
            m_particles.removeAt(i);
            --i;
        }
    }
}

void FloatingBall::savePosition() {
    QSettings settings("RapidNotes", "FloatingBall");
    settings.setValue("pos", pos());
    settings.setValue("visible", isVisible());
}

void FloatingBall::restorePosition() {
    QSettings settings("RapidNotes", "FloatingBall");
    if (settings.value("visible", true).toBool()) {
        show();
    } else {
        hide();
    }

    if (settings.contains("pos")) {
        QPoint savedPos = settings.value("pos").toPoint();
        QScreen* screen = QGuiApplication::screenAt(savedPos);
        if (!screen) screen = QGuiApplication::primaryScreen();
        
        if (screen) {
            QRect ag = screen->availableGeometry();
            int x = qBound(ag.left(), savedPos.x(), ag.right() - width());
            int y = qBound(ag.top(), savedPos.y(), ag.bottom() - height());
            move(x, y);
        } else {
            move(savedPos);
        }
    } else {
        QScreen *screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect ag = screen->availableGeometry();
            move(ag.right() - 150, ag.top() + ag.height() / 2 - height() / 2);
        }
    }
}
```

## 文件: `src/ui/FloatingBall.h`

```cpp
#ifndef FLOATINGBALL_H
#define FLOATINGBALL_H

#include <QWidget>
#include <QPoint>
#include <QPropertyAnimation>
#include <QTimer>
#include <QPainter>
#include <QMouseEvent>
#include <QMenu>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QMimeData>
#include "WritingAnimation.h"

class FloatingBall : public QWidget {
    Q_OBJECT
    Q_PROPERTY(QPoint pos READ pos WRITE move)

public:
    explicit FloatingBall(QWidget* parent = nullptr);
    static QIcon generateBallIcon();
    void savePosition();

protected:
    void paintEvent(QPaintEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void mouseDoubleClickEvent(QMouseEvent* event) override;
    void enterEvent(QEnterEvent* event) override;
    void leaveEvent(QEvent* event) override;
    void contextMenuEvent(QContextMenuEvent* event) override;
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragLeaveEvent(QDragLeaveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
    static void renderBook(QPainter* p, const QString& skinName, float bookY);
    static void renderPen(QPainter* p, const QString& skinName, float penX, float penY, float penAngle);

private:
    void switchSkin(const QString& name);
    // drawBook 和 drawPen 已改为静态 renderBook/renderPen
    void burstParticles();
    void updatePhysics();
    void updateParticles();
    void restorePosition();

    QPoint m_pressPos;
    QPoint m_offset;
    bool m_isDragging = false;
    bool m_isHovering = false;
    bool m_isWriting = false;
    int m_writeTimer = 0;

    QTimer* m_timer;
    float m_timeStep = 0.0f;
    float m_penX = 0.0f;
    float m_penY = 0.0f;
    float m_penAngle = -45.0f;
    float m_bookY = 0.0f;

    struct Particle {
        QPointF pos;
        QPointF velocity;
        double life;
        float size;
        QColor color;
    };
    QList<Particle> m_particles;

    QString m_skinName = "mocha";

signals:
    void doubleClicked();
    void requestMainWindow();
    void requestQuickWindow();
    void requestToolbox();
    void requestNewIdea();
};

#endif // FLOATINGBALL_H
```

## 文件: `src/ui/FlowLayout.cpp`

```cpp
#include <QtWidgets>
#include "FlowLayout.h"

FlowLayout::FlowLayout(QWidget *parent, int margin, int hSpacing, int vSpacing)
    : QLayout(parent), m_hSpace(hSpacing), m_vSpace(vSpacing)
{
    setContentsMargins(margin, margin, margin, margin);
}

FlowLayout::FlowLayout(int margin, int hSpacing, int vSpacing)
    : m_hSpace(hSpacing), m_vSpace(vSpacing)
{
    setContentsMargins(margin, margin, margin, margin);
}

FlowLayout::~FlowLayout()
{
    QLayoutItem *item;
    while ((item = takeAt(0)))
        delete item;
}

void FlowLayout::addItem(QLayoutItem *item)
{
    itemList.append(item);
}

int FlowLayout::horizontalSpacing() const
{
    if (m_hSpace >= 0) {
        return m_hSpace;
    } else {
        return smartSpacing(QStyle::PM_LayoutHorizontalSpacing);
    }
}

int FlowLayout::verticalSpacing() const
{
    if (m_vSpace >= 0) {
        return m_vSpace;
    } else {
        return smartSpacing(QStyle::PM_LayoutVerticalSpacing);
    }
}

int FlowLayout::count() const
{
    return itemList.size();
}

QLayoutItem *FlowLayout::itemAt(int index) const
{
    return itemList.value(index);
}

QLayoutItem *FlowLayout::takeAt(int index)
{
    if (index >= 0 && index < itemList.size())
        return itemList.takeAt(index);
    else
        return 0;
}

Qt::Orientations FlowLayout::expandingDirections() const
{
    return { };
}

bool FlowLayout::hasHeightForWidth() const
{
    return true;
}

int FlowLayout::heightForWidth(int width) const
{
    int height = doLayout(QRect(0, 0, width, 0), true);
    return height;
}

void FlowLayout::setGeometry(const QRect &rect)
{
    QLayout::setGeometry(rect);
    doLayout(rect, false);
}

QSize FlowLayout::sizeHint() const
{
    return minimumSize();
}

QSize FlowLayout::minimumSize() const
{
    QSize size;
    QLayoutItem *item;
    foreach (item, itemList)
        size = size.expandedTo(item->minimumSize());

    size += QSize(2*contentsMargins().top(), 2*contentsMargins().top());
    return size;
}

int FlowLayout::doLayout(const QRect &rect, bool testOnly) const
{
    int left, top, right, bottom;
    getContentsMargins(&left, &top, &right, &bottom);
    QRect effectiveRect = rect.adjusted(+left, +top, -right, -bottom);
    int x = effectiveRect.x();
    int y = effectiveRect.y();
    int lineHeight = 0;

    QLayoutItem *item;
    foreach (item, itemList) {
        QWidget *wid = item->widget();
        int spaceX = horizontalSpacing();
        if (spaceX == -1)
            spaceX = wid->style()->layoutSpacing(
                QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
        int spaceY = verticalSpacing();
        if (spaceY == -1)
            spaceY = wid->style()->layoutSpacing(
                QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);
        int nextX = x + item->sizeHint().width() + spaceX;
        if (nextX - spaceX > effectiveRect.right() && lineHeight > 0) {
            x = effectiveRect.x();
            y = y + lineHeight + spaceY;
            nextX = x + item->sizeHint().width() + spaceX;
            lineHeight = 0;
        }

        if (!testOnly)
            item->setGeometry(QRect(QPoint(x, y), item->sizeHint()));

        x = nextX;
        lineHeight = qMax(lineHeight, item->sizeHint().height());
    }
    return y + lineHeight - rect.y() + bottom;
}

int FlowLayout::smartSpacing(QStyle::PixelMetric pm) const
{
    QObject *parent = this->parent();
    if (!parent) {
        return -1;
    } else if (parent->isWidgetType()) {
        QWidget *pw = static_cast<QWidget *>(parent);
        return pw->style()->pixelMetric(pm, 0, pw);
    } else {
        return static_cast<QLayout *>(parent)->spacing();
    }
}

```

## 文件: `src/ui/FlowLayout.h`

```cpp
#ifndef FLOWLAYOUT_H
#define FLOWLAYOUT_H

#include <QLayout>
#include <QRect>
#include <QStyle>

class FlowLayout : public QLayout {
    Q_OBJECT
public:
    explicit FlowLayout(QWidget *parent, int margin = -1, int hSpacing = -1, int vSpacing = -1);
    explicit FlowLayout(int margin = -1, int hSpacing = -1, int vSpacing = -1);
    ~FlowLayout();

    void addItem(QLayoutItem *item) override;
    int horizontalSpacing() const;
    int verticalSpacing() const;
    Qt::Orientations expandingDirections() const override;
    bool hasHeightForWidth() const override;
    int heightForWidth(int) const override;
    int count() const override;
    QLayoutItem *itemAt(int index) const override;
    QSize minimumSize() const override;
    void setGeometry(const QRect &rect) override;
    QSize sizeHint() const override;
    QLayoutItem *takeAt(int index) override;

private:
    int doLayout(const QRect &rect, bool testOnly) const;
    int smartSpacing(QStyle::PixelMetric pm) const;

    QList<QLayoutItem *> itemList;
    int m_hSpace;
    int m_vSpace;
};

#endif // FLOWLAYOUT_H
```

## 文件: `src/ui/FramelessDialog.cpp`

```cpp
#include "FramelessDialog.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include <QGraphicsDropShadowEffect>
#include <QSettings>
#include <QMouseEvent>
#include <QKeyEvent>
#include <QTimer>
#include <QPainter>
#include <QPen>

#ifdef Q_OS_WIN
#include <windows.h>
#endif

#include <QMenu>
#include <QCursor>
#include "AdvancedTagSelector.h"
#include "../core/DatabaseManager.h"
#include "StringUtils.h"

// ============================================================================
// FramelessDialog 基类实现
// ============================================================================
FramelessDialog::FramelessDialog(const QString& title, QWidget* parent) 
    : QDialog(parent, Qt::FramelessWindowHint | Qt::Window) 
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_AlwaysShowToolTips);
    setMinimumWidth(40);
    setWindowTitle(title);

    auto* outerLayout = new QVBoxLayout(this);
    outerLayout->setContentsMargins(20, 20, 20, 20);

    auto* container = new QWidget(this);
    container->setObjectName("DialogContainer");
    container->setAttribute(Qt::WA_StyledBackground);
    container->setStyleSheet(
        "#DialogContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-radius: 12px;"
        "} "
    );
    outerLayout->addWidget(container);

    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(20);
    shadow->setXOffset(0);
    shadow->setYOffset(4);
    shadow->setColor(QColor(0, 0, 0, 120));
    container->setGraphicsEffect(shadow);

    m_mainLayout = new QVBoxLayout(container);
    m_mainLayout->setContentsMargins(0, 0, 0, 10);
    m_mainLayout->setSpacing(0);

    // --- 标题栏 ---
    auto* titleBar = new QWidget();
    titleBar->setObjectName("TitleBar");
    titleBar->setMinimumHeight(38);
    titleBar->setStyleSheet("background-color: transparent; border-bottom: 1px solid #2D2D2D;");
    auto* titleLayout = new QHBoxLayout(titleBar);
    titleLayout->setContentsMargins(12, 0, 5, 0);
    titleLayout->setSpacing(4);

    m_titleLabel = new QLabel(title);
    m_titleLabel->setStyleSheet("color: #888; font-size: 12px; font-weight: bold; border: none;");
    titleLayout->addWidget(m_titleLabel);
    titleLayout->addStretch();

    m_btnPin = new QPushButton();
    m_btnPin->setObjectName("btnPin");
    m_btnPin->setFixedSize(28, 28);
    m_btnPin->setIconSize(QSize(18, 18));
    m_btnPin->setAutoDefault(false);
    m_btnPin->setCheckable(true);
    m_btnPin->setIcon(IconHelper::getIcon("pin_tilted", "#aaaaaa"));
    
    // 初始化同步 UI 状态
    m_btnPin->blockSignals(true);
    m_btnPin->setChecked(m_isStayOnTop); 
    if (m_isStayOnTop) {
        m_btnPin->setIcon(IconHelper::getIcon("pin_vertical", "#ffffff"));
    }
    m_btnPin->blockSignals(false);
    m_btnPin->setStyleSheet("QPushButton { border: none; background: transparent; border-radius: 4px; } "
                          "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); } "
                          "QPushButton:pressed { background-color: rgba(255, 255, 255, 0.2); } "
                          "QPushButton:checked { background-color: rgba(58, 144, 255, 0.3); }");
    m_btnPin->setToolTip("置顶");
    connect(m_btnPin, &QPushButton::toggled, this, &FramelessDialog::toggleStayOnTop);
    titleLayout->addWidget(m_btnPin);

    m_minBtn = new QPushButton();
    m_minBtn->setObjectName("minBtn");
    m_minBtn->setFixedSize(28, 28);
    m_minBtn->setIconSize(QSize(18, 18));
    m_minBtn->setIcon(IconHelper::getIcon("minimize", "#888888"));
    m_minBtn->setAutoDefault(false);
    m_minBtn->setToolTip("最小化");
    m_minBtn->setCursor(Qt::PointingHandCursor);
    m_minBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } "
        "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }"
    );
    connect(m_minBtn, &QPushButton::clicked, this, &QDialog::showMinimized);
    titleLayout->addWidget(m_minBtn);

    m_closeBtn = new QPushButton();
    m_closeBtn->setObjectName("closeBtn");
    m_closeBtn->setFixedSize(28, 28);
    m_closeBtn->setIconSize(QSize(18, 18));
    m_closeBtn->setIcon(IconHelper::getIcon("close", "#888888"));
    m_closeBtn->setAutoDefault(false);
    m_closeBtn->setToolTip("关闭");
    m_closeBtn->setCursor(Qt::PointingHandCursor);
    m_closeBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } "
        "QPushButton:hover { background-color: #E81123; }"
    );
    connect(m_closeBtn, &QPushButton::clicked, this, &QDialog::reject);
    titleLayout->addWidget(m_closeBtn);

    m_mainLayout->addWidget(titleBar);

    m_contentArea = new QWidget();
    m_contentArea->setObjectName("DialogContentArea");
    m_contentArea->setAttribute(Qt::WA_StyledBackground);
    m_contentArea->setStyleSheet("QWidget#DialogContentArea { background: transparent; border: none; }");
    m_mainLayout->addWidget(m_contentArea, 1);
}

void FramelessDialog::setStayOnTop(bool stay) {
    if (m_btnPin) m_btnPin->setChecked(stay);
}

void FramelessDialog::toggleStayOnTop(bool checked) {
    m_isStayOnTop = checked;
    saveWindowSettings();

    if (isVisible()) {
#ifdef Q_OS_WIN
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, checked ? HWND_TOPMOST : HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
        Qt::WindowFlags f = windowFlags();
        if (checked) f |= Qt::WindowStaysOnTopHint;
        else f &= ~Qt::WindowStaysOnTopHint;
        setWindowFlags(f);
        show();
#endif
    }

    if (m_btnPin) {
        m_btnPin->setIcon(IconHelper::getIcon(checked ? "pin_vertical" : "pin_tilted", checked ? "#ffffff" : "#aaaaaa"));
    }
}

void FramelessDialog::showEvent(QShowEvent* event) {
    QDialog::showEvent(event);
#ifdef Q_OS_WIN
    if (m_isStayOnTop) {
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }
#endif
}

void FramelessDialog::loadWindowSettings() {
    if (objectName().isEmpty()) return;
    QSettings settings("RapidNotes", "WindowStates");
    bool stay = settings.value(objectName() + "/StayOnTop", false).toBool();
    m_isStayOnTop = stay;
    if (m_isStayOnTop) setWindowFlag(Qt::WindowStaysOnTopHint, true);
    
    if (m_btnPin) {
        m_btnPin->blockSignals(true);
        m_btnPin->setChecked(stay);
        m_btnPin->setIcon(IconHelper::getIcon(stay ? "pin_vertical" : "pin_tilted", stay ? "#ffffff" : "#aaaaaa"));
        m_btnPin->blockSignals(false);
    }
}

void FramelessDialog::saveWindowSettings() {
    if (objectName().isEmpty()) return;
    QSettings settings("RapidNotes", "WindowStates");
    settings.setValue(objectName() + "/StayOnTop", m_isStayOnTop);
}

void FramelessDialog::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_dragPos = event->globalPosition().toPoint() - frameGeometry().topLeft();
        event->accept();
    } else if (event->button() == Qt::RightButton) {
        // [CRITICAL] 显式吃掉右键，防止穿透或触发系统默认行为
        event->accept();
    }
}

void FramelessDialog::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::RightButton) {
        event->accept();
    }
}

void FramelessDialog::mouseMoveEvent(QMouseEvent* event) {
    if (event->buttons() & Qt::LeftButton) {
        move(event->globalPosition().toPoint() - m_dragPos);
        event->accept();
    } else if (event->buttons() & Qt::RightButton) {
        // 同样在移动中拦截右键
        event->accept();
    }
}

void FramelessDialog::paintEvent(QPaintEvent* event) {
    Q_UNUSED(event);
}

void FramelessDialog::keyPressEvent(QKeyEvent* event) {
    if (event->modifiers() == Qt::ControlModifier && event->key() == Qt::Key_W) {
        reject();
    } else {
        QDialog::keyPressEvent(event);
    }
}

// ============================================================================
// FramelessInputDialog 实现
// ============================================================================
FramelessInputDialog::FramelessInputDialog(const QString& title, const QString& label, 
                                           const QString& initial, QWidget* parent)
    : FramelessDialog(title, parent) 
{
    // 保持高度，确保有足够空间让按钮沉底
    resize(500, 260);
    setMinimumSize(400, 240);
    
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(20, 15, 20, 20);
    
    // 【关键修改】将全局间距设置为 7px，确保“标签”文字和输入框紧凑
    layout->setSpacing(7);

    auto* lbl = new QLabel(label);
    lbl->setStyleSheet("color: #eee; font-size: 13px;");
    layout->addWidget(lbl);

    m_edit = new QLineEdit(initial);
    // 设置最小高度，防止截断
    m_edit->setMinimumHeight(38);
    m_edit->setStyleSheet(
        "QLineEdit {"
        "  background-color: #2D2D2D; border: 1px solid #444; border-radius: 4px;"
        "  padding: 0px 10px; color: white; selection-background-color: #4a90e2;"
        "  font-size: 14px;"
        "}"
        "QLineEdit:focus { border: 1px solid #4a90e2; }"
    );
    layout->addWidget(m_edit);

    // 使用 PlaceholderText 显示提示
    if (title.contains("标签") || label.contains("标签")) {
        m_edit->setPlaceholderText("双击调出历史标签"); 
        m_edit->installEventFilter(this);
    }

    connect(m_edit, &QLineEdit::returnPressed, this, &QDialog::accept);

    // 【关键】增加 Stretch，强制将下方的按钮布局挤到底部
    // 这样输入框和上面的文字间距是 7px，而输入框和按钮的间距会自动拉大
    layout->addStretch();

    auto* btnLayout = new QHBoxLayout();
    btnLayout->addStretch();
    
    auto* btnOk = new QPushButton("确定");
    btnOk->setAutoDefault(false);
    btnOk->setCursor(Qt::PointingHandCursor);
    btnOk->setStyleSheet("QPushButton { background-color: #4a90e2; color: white; border: none; border-radius: 4px; padding: 6px 20px; font-weight: bold; } QPushButton:hover { background-color: #357abd; }");
    connect(btnOk, &QPushButton::clicked, this, &QDialog::accept);
    btnLayout->addWidget(btnOk);

    layout->addLayout(btnLayout);

    m_edit->setFocus();
    m_edit->selectAll();
}

bool FramelessInputDialog::eventFilter(QObject* watched, QEvent* event) {
    if (watched == m_edit && event->type() == QEvent::MouseButtonDblClick) {
        auto* selector = new AdvancedTagSelector(this);
        
        auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
        QStringList allTags = DatabaseManager::instance().getAllTags();
        QStringList selected = m_edit->text().split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
        for(QString& s : selected) s = s.trimmed();

        selector->setup(recentTags, allTags, selected);
        
        connect(selector, &AdvancedTagSelector::tagsConfirmed, [this](const QStringList& tags){
            if (!tags.isEmpty()) {
                m_edit->setText(tags.join(", "));
                m_edit->setFocus();
            }
        });

        selector->showAtCursor();
        return true;
    }
    return FramelessDialog::eventFilter(watched, event);
}

void FramelessInputDialog::showEvent(QShowEvent* event) {
    FramelessDialog::showEvent(event);
    QTimer::singleShot(100, m_edit, qOverload<>(&QWidget::setFocus));
}

// ============================================================================
// FramelessMessageBox 实现
// ============================================================================
FramelessMessageBox::FramelessMessageBox(const QString& title, const QString& text, QWidget* parent)
    : FramelessDialog(title, parent)
{
    resize(500, 220);
    setMinimumSize(400, 200);

    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(25, 20, 25, 25);
    layout->setSpacing(20);

    auto* lbl = new QLabel(text);
    lbl->setWordWrap(true);
    lbl->setStyleSheet("color: #eee; font-size: 14px; line-height: 150%;");
    layout->addWidget(lbl);

    auto* btnLayout = new QHBoxLayout();
    btnLayout->addStretch();

    auto* btnCancel = new QPushButton("取消");
    btnCancel->setAutoDefault(false);
    btnCancel->setCursor(Qt::PointingHandCursor);
    btnCancel->setStyleSheet("QPushButton { background-color: transparent; color: #888; border: 1px solid #555; border-radius: 4px; padding: 6px 15px; } QPushButton:hover { color: #eee; border-color: #888; }");
    connect(btnCancel, &QPushButton::clicked, this, [this](){ emit cancelled(); reject(); });
    btnLayout->addWidget(btnCancel);

    auto* btnOk = new QPushButton("确定");
    btnOk->setAutoDefault(false);
    btnOk->setCursor(Qt::PointingHandCursor);
    btnOk->setStyleSheet("QPushButton { background-color: #e74c3c; color: white; border: none; border-radius: 4px; padding: 6px 20px; font-weight: bold; } QPushButton:hover { background-color: #c0392b; }");
    connect(btnOk, &QPushButton::clicked, this, [this](){ emit confirmed(); accept(); });
    btnLayout->addWidget(btnOk);

    layout->addLayout(btnLayout);
}
```

## 文件: `src/ui/FramelessDialog.h`

```cpp
#ifndef FRAMELESSDIALOG_H
#define FRAMELESSDIALOG_H

#include <QDialog>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QLabel>
#include <QLineEdit>
#include <QFrame>

/**
 * @brief 无边框对话框基类，自带标题栏、关闭按钮、阴影、置顶
 */
class FramelessDialog : public QDialog {
    Q_OBJECT
public:
    explicit FramelessDialog(const QString& title, QWidget* parent = nullptr);
    virtual ~FramelessDialog() = default;

    void setStayOnTop(bool stay);

private slots:
    void toggleStayOnTop(bool checked);

protected:
    void showEvent(QShowEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void paintEvent(QPaintEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

    QWidget* m_contentArea;
    QVBoxLayout* m_mainLayout;
    QLabel* m_titleLabel;
    QPushButton* m_btnPin;
    QPushButton* m_minBtn;
    QPushButton* m_closeBtn;

    virtual void loadWindowSettings();
    virtual void saveWindowSettings();

private:
    QPoint m_dragPos;
    bool m_isStayOnTop = false; // 默认改为 false，支持记忆功能
    bool m_firstShow = true;
};

/**
 * @brief 无边框文本输入对话框
 */
class FramelessInputDialog : public FramelessDialog {
    Q_OBJECT
public:
    explicit FramelessInputDialog(const QString& title, const QString& label, 
                                  const QString& initial = "", QWidget* parent = nullptr);
    QString text() const { return m_edit->text().trimmed(); }
    void setEchoMode(QLineEdit::EchoMode mode) { m_edit->setEchoMode(mode); }

protected:
    void showEvent(QShowEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

private:
    QLineEdit* m_edit;
};

/**
 * @brief 无边框确认提示框
 */
class FramelessMessageBox : public FramelessDialog {
    Q_OBJECT
public:
    explicit FramelessMessageBox(const QString& title, const QString& text, QWidget* parent = nullptr);

signals:
    void confirmed();
    void cancelled();
};

#endif // FRAMELESSDIALOG_H
```

## 文件: `src/ui/HeaderBar.cpp`

```cpp
#include "HeaderBar.h"
#include "StringUtils.h"

#include "IconHelper.h"
#include <QHBoxLayout>
#include <QSettings>
#include <QMouseEvent>
#include <QApplication>
#include <QWindow>
#include <QIntValidator>

HeaderBar::HeaderBar(QWidget* parent) : QWidget(parent) {
    setFixedHeight(41); // 40 + 1px 线
    setStyleSheet("background-color: #252526; border: none;");

    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    // 顶部内容区
    auto* topContent = new QWidget();
    auto* layout = new QHBoxLayout(topContent);
    layout->setContentsMargins(10, 0, 10, 0);
    layout->setSpacing(0);
    
    // 1. Logo & Title
    QLabel* appLogo = new QLabel();
    appLogo->setFixedSize(18, 18);
    appLogo->setPixmap(IconHelper::getIcon("zap", "#4a90e2", 18).pixmap(18, 18));
    layout->addWidget(appLogo);
    layout->addSpacing(6);

    QLabel* titleLabel = new QLabel("快速笔记");
    titleLabel->setStyleSheet("font-size: 13px; font-weight: bold; color: #4a90e2; border: none; background: transparent;");
    layout->addWidget(titleLabel);
    layout->addSpacing(15);

    // 2. Search Box
    m_searchEdit = new SearchLineEdit();
    m_searchEdit->setPlaceholderText("搜索灵感 (双击查看历史)");
    m_searchEdit->setFixedWidth(280);
    m_searchEdit->setFixedHeight(28);
    m_searchEdit->setStyleSheet(
        "SearchLineEdit { "
        "  background-color: #1e1e1e; "
        "  border: 1px solid #444; "
        "  border-radius: 14px; "
        "  padding: 5px 15px; "
        "  color: white; "
        "  font-size: 13px; "
        "} "
        "SearchLineEdit:focus { border: 1px solid #4a90e2; background-color: #181818; }"
    );
    connect(m_searchEdit, &QLineEdit::textChanged, this, &HeaderBar::searchChanged);
    connect(m_searchEdit, &QLineEdit::returnPressed, [this](){
        m_searchEdit->addHistoryEntry(m_searchEdit->text().trimmed());
    });
    layout->addWidget(m_searchEdit);
    layout->addSpacing(15);

    // 3. Pagination Controls (保持原有逻辑)
    QString pageBtnStyle = 
        "QPushButton {"
        "    background-color: transparent;"
        "    border: 1px solid #555;"
        "    border-radius: 12px;"
        "    min-width: 24px;"
        "    max-width: 24px;"
        "    min-height: 24px;"
        "    max-height: 24px;"
        "    padding: 0px;"
        "}"
        "QPushButton:hover { background-color: #333; border-color: #777; }"
        "QPushButton:disabled { border-color: #333; }";

    auto createPageBtn = [&](const QString& icon, const QString& tip) {
        QPushButton* btn = new QPushButton();
        btn->setIcon(IconHelper::getIcon(icon, "#aaaaaa", 16));
        btn->setToolTip(tip);
        btn->setStyleSheet(pageBtnStyle);
        return btn;
    };

    QPushButton* btnFirst = createPageBtn("nav_first", "第一页");
    connect(btnFirst, &QPushButton::clicked, [this](){ emit pageChanged(1); });
    layout->addWidget(btnFirst);
    layout->addSpacing(6);

    QPushButton* btnPrev = createPageBtn("nav_prev", "上一页");
    connect(btnPrev, &QPushButton::clicked, [this](){ if(m_currentPage > 1) emit pageChanged(m_currentPage - 1); });
    layout->addWidget(btnPrev);
    layout->addSpacing(8);

    m_pageInput = new QLineEdit("1");
    m_pageInput->setFixedWidth(40);
    m_pageInput->setFixedHeight(24);
    m_pageInput->setAlignment(Qt::AlignCenter);
    m_pageInput->setValidator(new QIntValidator(1, 9999, this));
    m_pageInput->setStyleSheet(
        "QLineEdit {"
        "    background-color: #2D2D2D;"
        "    border: 1px solid #555;"
        "    border-radius: 12px;"
        "    color: #eee;"
        "    font-size: 11px;"
        "    padding: 0px;"
        "}"
        "QLineEdit:focus { border: 1px solid #4a90e2; }"
    );
    connect(m_pageInput, &QLineEdit::returnPressed, [this](){
        emit pageChanged(m_pageInput->text().toInt());
    });
    layout->addWidget(m_pageInput);
    layout->addSpacing(6);

    m_totalPageLabel = new QLabel("/ 1");
    m_totalPageLabel->setStyleSheet("color: #888; font-size: 12px; margin-left: 2px; margin-right: 5px; border: none; background: transparent;");
    layout->addWidget(m_totalPageLabel);
    layout->addSpacing(10);

    QPushButton* btnNext = createPageBtn("nav_next", "下一页");
    connect(btnNext, &QPushButton::clicked, [this](){ if(m_currentPage < m_totalPages) emit pageChanged(m_currentPage + 1); });
    layout->addWidget(btnNext);
    layout->addSpacing(6);

    QPushButton* btnLast = createPageBtn("nav_last", "最后一页");
    connect(btnLast, &QPushButton::clicked, [this](){ emit pageChanged(m_totalPages); });
    layout->addWidget(btnLast);
    layout->addSpacing(10);

    QPushButton* btnRefresh = createPageBtn("refresh", "刷新 (F5)");
    connect(btnRefresh, &QPushButton::clicked, this, &HeaderBar::refreshRequested);
    layout->addWidget(btnRefresh);
    layout->addSpacing(10);

    // 标准功能按钮样式 (32x32, 无边框)
    QString funcBtnStyle = 
        "QPushButton {"
        "    background-color: transparent;"
        "    border: none;"
        "    outline: none;"
        "    border-radius: 5px;"
        "    width: 32px;"
        "    height: 32px;"
        "    padding: 0px;"
        "}"
        "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }"
        "QPushButton:pressed { background-color: rgba(255, 255, 255, 0.2); }";

    // 迁移：新建笔记 (+) 和 工具箱 按钮移至中间组，保留其原有 32x32 风格
    QPushButton* btnAddCenter = new QPushButton();
    btnAddCenter->setIcon(IconHelper::getIcon("add", "#ffffff", 20));
    btnAddCenter->setIconSize(QSize(20, 20));
    btnAddCenter->setToolTip("新建笔记 (Ctrl+N)");
    btnAddCenter->setStyleSheet(funcBtnStyle);
    connect(btnAddCenter, &QPushButton::clicked, this, &HeaderBar::newNoteRequested);
    layout->addWidget(btnAddCenter);
    layout->addSpacing(4);

    QPushButton* btnTool = new QPushButton();
    btnTool->setIcon(IconHelper::getIcon("toolbox", "#aaaaaa", 20));
    btnTool->setIconSize(QSize(20, 20));
    btnTool->setToolTip("工具箱 (右键快捷设置)");
    btnTool->setStyleSheet(funcBtnStyle);
    btnTool->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(btnTool, &QPushButton::clicked, this, &HeaderBar::toolboxRequested);
    connect(btnTool, &QPushButton::customContextMenuRequested, this, [this, btnTool](const QPoint& pos){
        emit toolboxContextMenuRequested(btnTool->mapToGlobal(pos));
    });
    layout->addWidget(btnTool);
    layout->addSpacing(4);

    QPushButton* btnLock = new QPushButton();
    btnLock->setIcon(IconHelper::getIcon("lock", "#aaaaaa", 20));
    btnLock->setIconSize(QSize(20, 20));
    btnLock->setToolTip("全局锁定");
    btnLock->setStyleSheet(funcBtnStyle);
    connect(btnLock, &QPushButton::clicked, this, &HeaderBar::globalLockRequested);
    layout->addWidget(btnLock);

    layout->addStretch();

    // 4. Functional Buttons
    m_btnStayOnTop = new QPushButton();
    m_btnStayOnTop->setObjectName("btnStayOnTop");
    m_btnStayOnTop->setIcon(IconHelper::getIcon("pin_tilted", "#aaaaaa", 20));
    m_btnStayOnTop->setIconSize(QSize(20, 20));
    m_btnStayOnTop->setToolTip("始终最前 (自动置顶)");
    m_btnStayOnTop->setCheckable(true);
    m_btnStayOnTop->setStyleSheet(funcBtnStyle + " QPushButton:checked { background-color: #3A90FF; }");
    connect(m_btnStayOnTop, &QPushButton::toggled, this, [this](bool checked){
        m_btnStayOnTop->setIcon(IconHelper::getIcon(checked ? "pin_vertical" : "pin_tilted", checked ? "#ffffff" : "#aaaaaa", 20));
        emit stayOnTopRequested(checked);
    });
    layout->addWidget(m_btnStayOnTop);
    layout->addSpacing(4);

    m_btnMeta = new QPushButton();
    m_btnMeta->setIcon(IconHelper::getIcon("sidebar_right", "#aaaaaa", 20));
    m_btnMeta->setIconSize(QSize(20, 20));
    m_btnMeta->setToolTip("元数据面板 (Ctrl+I)");
    m_btnMeta->setCheckable(true);
    m_btnMeta->setStyleSheet(funcBtnStyle + " QPushButton:checked { background-color: #4a90e2; }");
    connect(m_btnMeta, &QPushButton::toggled, this, &HeaderBar::metadataToggled);
    layout->addWidget(m_btnMeta);
    layout->addSpacing(4);

    m_btnFilter = new QPushButton();
    m_btnFilter->setIcon(IconHelper::getIcon("filter", "#ffffff", 20));
    m_btnFilter->setIconSize(QSize(20, 20));
    m_btnFilter->setToolTip("高级筛选 (Ctrl+G)");
    m_btnFilter->setStyleSheet(funcBtnStyle + " QPushButton:checked { background-color: #4a90e2; }");
    m_btnFilter->setCheckable(true);
    connect(m_btnFilter, &QPushButton::clicked, this, &HeaderBar::filterRequested);
    layout->addWidget(m_btnFilter);

    // 5. Window Controls
    QWidget* winCtrlWidget = new QWidget();
    winCtrlWidget->setStyleSheet("background: transparent;");
    QHBoxLayout* winCtrlLayout = new QHBoxLayout(winCtrlWidget);
    winCtrlLayout->setContentsMargins(0, 0, 0, 0);
    winCtrlLayout->setSpacing(0);

    auto addWinBtn = [&](const QString& icon, const QString& hoverColor, auto signal) {
        QPushButton* btn = new QPushButton();
        btn->setIcon(IconHelper::getIcon(icon, "#aaaaaa", 20));
        btn->setIconSize(QSize(20, 20));
        btn->setFixedSize(32, 32);
        btn->setStyleSheet(QString("QPushButton { background: transparent; border: none; border-radius: 5px; } QPushButton:hover { background: %1; }").arg(hoverColor));
        connect(btn, &QPushButton::clicked, this, signal);
        winCtrlLayout->addWidget(btn);
    };

    addWinBtn("minimize", "rgba(255,255,255,0.1)", &HeaderBar::windowMinimize);
    addWinBtn("maximize", "rgba(255,255,255,0.1)", &HeaderBar::windowMaximize);
    addWinBtn("close", "#e81123", &HeaderBar::windowClose);
    layout->addWidget(winCtrlWidget);

    mainLayout->addWidget(topContent);

    // 【关键修复】实体的 1px 全宽分割线
    auto* bottomLine = new QFrame();
    bottomLine->setFrameShape(QFrame::HLine);
    bottomLine->setFixedHeight(1);
    bottomLine->setStyleSheet("background-color: #333333; border: none; margin: 0px;");
    mainLayout->addWidget(bottomLine);
}

void HeaderBar::updatePagination(int current, int total) {
    m_currentPage = current;
    m_totalPages = total;
    m_pageInput->setText(QString::number(current));
    m_totalPageLabel->setText(QString("/ %1").arg(total));
}

void HeaderBar::setFilterActive(bool active) {
    m_btnFilter->setChecked(active);
}

void HeaderBar::setMetadataActive(bool active) {
    m_btnMeta->setChecked(active);
}

void HeaderBar::focusSearch() {
    m_searchEdit->setFocus();
    m_searchEdit->selectAll();
}

void HeaderBar::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        if (auto* win = window()) {
            if (auto* handle = win->windowHandle()) {
                handle->startSystemMove();
            }
        }
        event->accept();
    }
}

void HeaderBar::mouseMoveEvent(QMouseEvent* event) {
    QWidget::mouseMoveEvent(event);
}

void HeaderBar::mouseDoubleClickEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        emit windowMaximize();
        event->accept();
    }
}
```

## 文件: `src/ui/HeaderBar.h`

```cpp
#ifndef HEADERBAR_H
#define HEADERBAR_H

#include <QWidget>
#include <QPushButton>
#include <QLabel>
#include <QMenu>
#include "SearchLineEdit.h"

class HeaderBar : public QWidget {
    Q_OBJECT
public:
    explicit HeaderBar(QWidget* parent = nullptr);

signals:
    void searchChanged(const QString& text);
    void newNoteRequested();
    void toggleSidebar();
    void pageChanged(int page);
    void toolboxRequested();
    void globalLockRequested();
    void toolboxContextMenuRequested(const QPoint& pos);
    void metadataToggled(bool checked);
    void refreshRequested();
    void filterRequested();
    void stayOnTopRequested(bool checked);
    void windowClose();
    void windowMinimize();
    void windowMaximize();

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseDoubleClickEvent(QMouseEvent* event) override;

public:
    void updatePagination(int current, int total);
    void setFilterActive(bool active);
    void setMetadataActive(bool active);
    void focusSearch();

private:
    SearchLineEdit* m_searchEdit;
    QLineEdit* m_pageInput;
    QLabel* m_totalPageLabel;
    QPushButton* m_btnFilter;
    QPushButton* m_btnMeta;
    QPushButton* m_btnStayOnTop;

    int m_currentPage = 1;
    int m_totalPages = 1;
    QPoint m_dragPos;
};

#endif // HEADERBAR_H
```

## 文件: `src/ui/HelpWindow.cpp`

```cpp
#include "HelpWindow.h"
#include "StringUtils.h"
#include <QVBoxLayout>
#include <QScrollArea>

HelpWindow::HelpWindow(QWidget* parent) : FramelessDialog("使用说明", parent) {
    setObjectName("HelpWindow");
    loadWindowSettings();
    setFixedSize(500, 600);
    initUI();
}

void HelpWindow::initUI() {
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(15, 5, 15, 15);
    layout->setSpacing(0);

    QScrollArea* scroll = new QScrollArea();
    scroll->setWidgetResizable(true);
    scroll->setFrameShape(QFrame::NoFrame);
    scroll->setStyleSheet("QScrollArea { background: transparent; } "
                          "QScrollBar:vertical { width: 8px; background: transparent; } "
                          "QScrollBar::handle:vertical { background: #555; border-radius: 4px; } "
                          "QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }");

    QLabel* contentLabel = new QLabel();
    contentLabel->setWordWrap(true);
    contentLabel->setTextFormat(Qt::RichText);
    contentLabel->setText(getHelpHtml());
    contentLabel->setStyleSheet("color: #DDD; line-height: 1.6; font-size: 13px;");
    contentLabel->setAlignment(Qt::AlignTop | Qt::AlignLeft);

    scroll->setWidget(contentLabel);
    layout->addWidget(scroll);
}

QString HelpWindow::getHelpHtml() {
    return R"html(
<style>
    h2 { color: #4FACFE; margin-top: 25px; border-bottom: 1px solid #333; padding-bottom: 8px; font-size: 18px; }
    b { color: #F1C40F; font-weight: bold; }
    .key { background: #444; padding: 2px 8px; border-radius: 4px; font-family: 'Consolas', monospace; color: #FFF; font-weight: bold; font-size: 12px; border: 1px solid #555; }
    .section { margin-bottom: 30px; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 8px; }
    ul { margin-left: -15px; list-style-type: none; }
    li { margin-bottom: 12px; line-height: 1.6; }
    .sub-title { color: #1abc9c; font-weight: bold; margin-top: 15px; display: block; font-size: 14px; border-left: 3px solid #1abc9c; padding-left: 8px; }
    .desc { color: #BBB; font-size: 13px; display: block; margin-top: 4px; }
    .cmd { color: #3498db; font-family: monospace; font-weight: bold; }
</style>

<div class="section">
    <h2>一、全局系统热键</h2>
    <ul>
        <li><span class="key">Alt + Space</span> : <b>呼出/隐藏极速窗口</b> <br/> <span class="desc">默认快捷键，可在设置中自定义。实现即用即走的极速交互体验。</span></li>
        <li><span class="key">Ctrl + Shift + S</span> : <b>浏览器智能采集</b> <br/> <span class="desc">仅限浏览器环境，自动提取所选文字的【标题】与【正文】并智能入库。</span></li>
        <li><span class="key">Ctrl + Alt + A</span> : <b>全能截屏/OCR</b> <br/> <span class="desc">支持识图取字、画笔标注、马赛克及【屏幕贴图】功能。</span></li>
        <li><span class="key">Ctrl + Shift + E</span> : <b>一键收藏最后捕获</b> <br/> <span class="desc">将剪贴板最后一条自动生成的灵感快速加入收藏夹。</span></li>
        <li><span class="key">快捷键 5 (需设置)</span> : <b>全局应用锁定</b> <br/> <span class="desc">一键进入 Eagle 风格的启动锁界面，保护数据隐私。</span></li>
    </ul>
</div>

<div class="section">
    <h2>二、极速窗口交互指南</h2>
    <span class="sub-title">搜索与内容处理</span>
    <ul>
        <li><b>智能搜索</b>：输入即过滤。无结果时按 <span class="key">Enter</span> 存入历史。双击搜索框查看历史。</li>
        <li><b>自动上屏</b>：选中项按 <span class="key">Enter</span> 或 <b>左键双击</b>，自动粘贴内容至目标软件。</li>
        <li><b>格式清洗</b>：按 <span class="key">Ctrl + T</span> 提取选中项的纯文本内容至剪贴板。</li>
        <li><b>快速预览</b>：按 <span class="key">Space</span> 呼出/关闭浮动预览大窗。</li>
    </ul>
    
    <span class="sub-title">高效管理快捷键</span>
    <ul>
        <li><b>分级标记</b>：<span class="key">Ctrl + 1~5</span> 设置评分；<span class="key">Ctrl + E</span> 收藏；<span class="key">Ctrl + P</span> 置顶。</li>
        <li><b>隐私控制</b>：<span class="key">Ctrl + S</span> 锁定单条记录；<span class="key">Ctrl + Shift + L</span> 立即锁定当前分类。</li>
        <li><b>标签系统</b>：底部框 <b>左键双击</b> 打开高级标签选择器。支持 <span class="key">Ctrl + Shift + C/V</span> 批量同步标签。</li>
        <li><b>翻页导航</b>：<span class="key">Alt + S</span> 上一页；<span class="key">Alt + X</span> 下一页。</li>
    </ul>

    <span class="sub-title">窗口与布局手势</span>
    <ul>
        <li><b>切换主界面</b>：按 <span class="key">Alt + W</span> 快速切换至主管理模式。</li>
        <li><b>侧边栏联动</b>：按 <span class="key">Ctrl + Q</span> 开关分类导航。支持 <b>拖拽列表项</b> 至侧边栏进行分类移动。</li>
        <li><b>置顶切换</b>：按 <span class="key">Alt + D</span> 切换窗口【始终最前】状态。</li>
    </ul>
</div>

<div class="section">
    <h2>三、主界面 (深度管理模式)</h2>
    <ul>
        <li><b>高级筛选面板</b> (<span class="key">Ctrl + G</span>)：支持类型（图片/链接/本地文件）、日期及评分的多维复合筛选。</li>
        <li><b>元数据/批量面板</b> (<span class="key">Ctrl + I</span>)：支持多选笔记后，一键批量修改标签。</li>
        <li><b>面板自由重组</b>：在各面板标题栏 <b>右键单击</b>，可选择【向左/向右移动】自定义布局顺序。</li>
        <li><b>分类管理</b>：侧边栏支持 <span class="key">Ctrl + Up/Down</span> 进行排序；<span class="key">Ctrl + Shift + Up/Down</span> 置顶/置底。</li>
    </ul>
</div>

<div class="section">
    <h2>四、编辑器与高级特性</h2>
    <ul>
        <li><b>扩展编辑</b>：在详情页 <b>左键双击标题栏</b>，可呼出无边框长标题编辑器。</li>
        <li><b>快捷保存</b>：编辑模式下 <span class="key">Ctrl + S</span> 立即保存修改；<span class="key">Ctrl + F</span> 开启内容内查找。</li>
        <li><b>自动化设置</b>：工具箱菜单中可开启【剪贴板自动归档】，捕获内容将自动归类至当前活跃分区。</li>
        <li><b>动态特效</b>：系统实时监听剪贴板，检测到新内容时将在鼠标位置触发【烟花动效】反馈。</li>
    </ul>
</div>

<div class="section">
    <h2>💡 进阶贴士</h2>
    <ul>
        <li><b>回收站保护</b>：<span class="key">Del</span> 进入回收站（可还原）；<span class="key">Ctrl + Shift + Del</span> 彻底销毁。</li>
        <li><b>多选模式</b>：列表支持标准的 <span class="key">Ctrl/Shift + 点击</span> 批量操作。</li>
    </ul>
</div>
<br/>
)html";
}
```

## 文件: `src/ui/HelpWindow.h`

```cpp
#ifndef HELPWINDOW_H
#define HELPWINDOW_H

#include "FramelessDialog.h"
#include <QScrollArea>
#include <QLabel>

class HelpWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit HelpWindow(QWidget* parent = nullptr);

private:
    void initUI();
    QString getHelpHtml();
};

#endif // HELPWINDOW_H
```

## 文件: `src/core/HotkeyManager.cpp`

```cpp
#include "HotkeyManager.h"
#include <QCoreApplication>
#include <QDebug>
#include <QSettings>

HotkeyManager& HotkeyManager::instance() {
    static HotkeyManager inst;
    return inst;
}

HotkeyManager::HotkeyManager(QObject* parent) : QObject(parent) {
    qApp->installNativeEventFilter(this);
}

HotkeyManager::~HotkeyManager() {
    // 退出时取消所有注册
}

bool HotkeyManager::registerHotkey(int id, uint modifiers, uint vk) {
#ifdef Q_OS_WIN
    if (RegisterHotKey(nullptr, id, modifiers, vk)) {
        return true;
    }
    
    QString keyDesc = QString("ID=%1").arg(id);
    if (id == 1) keyDesc = "Alt+Space (快速窗口)";
    else if (id == 2) keyDesc = "Ctrl+Shift+E (全局收藏)";
    else if (id == 3) keyDesc = "Ctrl+Alt+A (全局截屏)";
    else if (id == 4) keyDesc = "Ctrl+Shift+S (全局采集)";
    else if (id == 5) keyDesc = "Ctrl+Shift+L (全局锁定)";
    else if (id == 6) keyDesc = "Ctrl+Alt+Q (截图取文)";

    qWarning().noquote() << QString("[HotkeyManager] 注册热键失败: %1 (错误代码: %2). 该快捷键可能已被系统或其他软件占用。")
                            .arg(keyDesc).arg(GetLastError());
#endif
    return false;
}

void HotkeyManager::unregisterHotkey(int id) {
#ifdef Q_OS_WIN
    UnregisterHotKey(nullptr, id);
#endif
}

void HotkeyManager::reapplyHotkeys() {
    QSettings hotkeys("RapidNotes", "Hotkeys");
    
    // 注销旧热键
    unregisterHotkey(1);
    unregisterHotkey(2);
    unregisterHotkey(3);
    unregisterHotkey(4);
    unregisterHotkey(5);
    unregisterHotkey(6);
    
    // 注册新热键（带默认值）
    uint q_mods = hotkeys.value("quickWin_mods", 0x0001).toUInt();  // Alt
    uint q_vk   = hotkeys.value("quickWin_vk", 0x20).toUInt();     // Space
    registerHotkey(1, q_mods, q_vk);
    
    uint f_mods = hotkeys.value("favorite_mods", 0x0002 | 0x0004).toUInt(); // Ctrl+Shift
    uint f_vk   = hotkeys.value("favorite_vk", 0x45).toUInt();              // E
    registerHotkey(2, f_mods, f_vk);
    
    uint s_mods = hotkeys.value("screenshot_mods", 0x0002 | 0x0001).toUInt(); // Ctrl+Alt
    uint s_vk   = hotkeys.value("screenshot_vk", 0x41).toUInt();               // A
    registerHotkey(3, s_mods, s_vk);

    uint a_mods = hotkeys.value("acquire_mods", 0x0002 | 0x0004).toUInt();  // Ctrl+Shift
    uint a_vk   = hotkeys.value("acquire_vk", 0x53).toUInt();               // S
    registerHotkey(4, a_mods, a_vk);

    uint l_mods = hotkeys.value("lock_mods", 0x0002 | 0x0004).toUInt();     // Ctrl+Shift
    uint l_vk   = hotkeys.value("lock_vk", 0x4C).toUInt();                  // L
    registerHotkey(5, l_mods, l_vk);

    uint ocr_mods = hotkeys.value("ocr_mods", 0x0002 | 0x0001).toUInt();    // Ctrl+Alt
    uint ocr_vk   = hotkeys.value("ocr_vk", 0x51).toUInt();                 // Q
    registerHotkey(6, ocr_mods, ocr_vk);
    
    qDebug() << "[HotkeyManager] 热键配置已更新。";
}

bool HotkeyManager::nativeEventFilter(const QByteArray &eventType, void *message, qintptr *result) {
#ifdef Q_OS_WIN
    if (eventType == "windows_generic_MSG") {
        MSG* msg = static_cast<MSG*>(message);
        if (msg->message == WM_HOTKEY) {
            emit hotkeyPressed(static_cast<int>(msg->wParam));
            return true;
        }
    }
#endif
    return false;
}
```

## 文件: `src/core/HotkeyManager.h`

```cpp
#ifndef HOTKEYMANAGER_H
#define HOTKEYMANAGER_H

#include <QObject>
#include <QAbstractNativeEventFilter>

#ifdef Q_OS_WIN
#include <windows.h>
#endif

class HotkeyManager : public QObject, public QAbstractNativeEventFilter {
    Q_OBJECT
public:
    static HotkeyManager& instance();
    
    bool registerHotkey(int id, uint modifiers, uint vk);
    void unregisterHotkey(int id);
    void reapplyHotkeys();

    bool nativeEventFilter(const QByteArray &eventType, void *message, qintptr *result) override;

signals:
    void hotkeyPressed(int id);

private:
    HotkeyManager(QObject* parent = nullptr);
    ~HotkeyManager();
};

#endif // HOTKEYMANAGER_H
```

## 文件: `src/ui/IconHelper.h`

```cpp
#ifndef ICONHELPER_H
#define ICONHELPER_H

#include <QIcon>
#include <QMenu>
#include <QSvgRenderer>
#include <QPainter>
#include <QPixmap>
#include "SvgIcons.h"

class IconHelper {
public:
    static QIcon getIcon(const QString& name, const QString& color = "#cccccc", int size = 64) {
        if (!SvgIcons::icons.contains(name)) return QIcon();

        QString svgData = SvgIcons::icons[name];
        svgData.replace("currentColor", color);
        // 如果 svg 中没有 currentColor，强制替换所有可能的 stroke/fill 颜色（简易实现）
        // 这里假设 SVG 字符串格式标准，仅替换 stroke="currentColor" 或 fill="currentColor"
        // 实际上 Python 版是直接全量 replace "currentColor"

        QByteArray bytes = svgData.toUtf8();
        QSvgRenderer renderer(bytes);
        
        QPixmap pixmap(size, size);
        pixmap.fill(Qt::transparent);
        QPainter painter(&pixmap);
        renderer.render(&painter);
        
        QIcon icon;
        icon.addPixmap(pixmap, QIcon::Normal, QIcon::On);
        icon.addPixmap(pixmap, QIcon::Normal, QIcon::Off);
        icon.addPixmap(pixmap, QIcon::Active, QIcon::On);
        icon.addPixmap(pixmap, QIcon::Active, QIcon::Off);
        icon.addPixmap(pixmap, QIcon::Selected, QIcon::On);
        icon.addPixmap(pixmap, QIcon::Selected, QIcon::Off);
        return icon;
    }

    // 统一设置 QMenu 样式,移除系统原生直角阴影
    static void setupMenu(QMenu* menu) {
        if (!menu) return;
        // 移除系统原生阴影,使用自定义圆角
        menu->setAttribute(Qt::WA_TranslucentBackground);
        menu->setWindowFlags(menu->windowFlags() | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint);
    }
};

#endif // ICONHELPER_H
```

## 文件: `src/core/IPlatformSystem.h`

```cpp
#ifndef IPLATFORMSYSTEM_H
#define IPLATFORMSYSTEM_H

#include <QString>
#include <QImage>

class IPlatformSystem {
public:
    virtual ~IPlatformSystem() = default;

    // 进程与窗口
    virtual bool isBrowserActive() = 0;
    virtual QString getForegroundAppPath() = 0;

    // 输入模拟
    virtual void simulateCopy() = 0;
    virtual void simulateSelectAll() = 0;
    virtual void simulateKeyStroke(int vk, bool alt = false, bool ctrl = false, bool shift = false) = 0;

    // 系统热键与钩子底层支持 (可选，如果想彻底隔离 HotkeyManager)
    virtual bool registerGlobalHotkey(int id, uint modifiers, uint vk) = 0;
    virtual bool unregisterGlobalHotkey(int id) = 0;
};

#endif // IPLATFORMSYSTEM_H
```

## 文件: `src/core/KeyboardHook.cpp`

```cpp
#include "KeyboardHook.h"
#include <QDebug>

#ifdef Q_OS_WIN
HHOOK g_hHook = nullptr;
#endif

KeyboardHook& KeyboardHook::instance() {
    static KeyboardHook inst;
    return inst;
}

KeyboardHook::KeyboardHook() {}

KeyboardHook::~KeyboardHook() {
    stop();
}

void KeyboardHook::start() {
#ifdef Q_OS_WIN
    if (g_hHook) return;
    g_hHook = SetWindowsHookEx(WH_KEYBOARD_LL, HookProc, GetModuleHandle(NULL), 0);
    if (g_hHook) {
        m_active = true;
        qDebug() << "Keyboard hook started";
    }
#endif
}

void KeyboardHook::stop() {
#ifdef Q_OS_WIN
    if (g_hHook) {
        UnhookWindowsHookEx(g_hHook);
        g_hHook = nullptr;
        m_active = false;
        qDebug() << "Keyboard hook stopped";
    }
#endif
}

#ifdef Q_OS_WIN
LRESULT CALLBACK KeyboardHook::HookProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION) {
        KBDLLHOOKSTRUCT* pKey = (KBDLLHOOKSTRUCT*)lParam;
        
        // 忽略所有模拟按键，防止无限循环
        if (pKey->flags & LLKHF_INJECTED) {
            return CallNextHookEx(g_hHook, nCode, wParam, lParam);
        }

        bool isKeyDown = (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN);

        // 监听回车键/Ctrl+回车键 (仅限非本应用窗口)
        if (isKeyDown && pKey->vkCode == VK_RETURN) {
            HWND foreground = GetForegroundWindow();
            DWORD pid;
            GetWindowThreadProcessId(foreground, &pid);
            if (pid != GetCurrentProcessId()) {
                bool ctrl = (GetKeyState(VK_CONTROL) & 0x8000);
                bool shift = (GetKeyState(VK_SHIFT) & 0x8000);
                bool alt = (GetKeyState(VK_MENU) & 0x8000);
                emit KeyboardHook::instance().enterPressedInOtherApp(ctrl, shift, alt);
                return 1; // 拦截回车，交给处理器稍后重新模拟
            }
        }

        // 工具箱数字拦截 (仅在使能时触发)
        if (KeyboardHook::instance().m_digitInterceptEnabled) {
            if (pKey->vkCode >= 0x30 && pKey->vkCode <= 0x39) {
                if (isKeyDown) {
                    int digit = pKey->vkCode - 0x30;
                    qDebug() << "Digit pressed:" << digit;
                    emit KeyboardHook::instance().digitPressed(digit);
                }
                // 按下和弹起都拦截
                return 1;
            }
        }
    }
    return CallNextHookEx(g_hHook, nCode, wParam, lParam);
}
#endif
```

## 文件: `src/core/KeyboardHook.h`

```cpp
#ifndef KEYBOARDHOOK_H
#define KEYBOARDHOOK_H

#include <QObject>
#ifdef Q_OS_WIN
#include <windows.h>
#endif

class KeyboardHook : public QObject {
    Q_OBJECT
public:
    static KeyboardHook& instance();
    void start();
    void stop();
    bool isActive() const { return m_active; }

    void setDigitInterceptEnabled(bool enabled) { m_digitInterceptEnabled = enabled; }

signals:
    void digitPressed(int digit);
    void f4PressedInExplorer();
    void enterPressedInOtherApp(bool ctrl, bool shift, bool alt);

private:
    bool m_digitInterceptEnabled = false;
    KeyboardHook();
    ~KeyboardHook();
    bool m_active = false;

#ifdef Q_OS_WIN
    static LRESULT CALLBACK HookProc(int nCode, WPARAM wParam, LPARAM lParam);
#endif
};

#endif // KEYBOARDHOOK_H
```

## 文件: `src/ui/KeywordSearchWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "KeywordSearchWindow.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include "../core/ShortcutManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QFileDialog>
#include <QDirIterator>
#include <utility>
#include <QTextStream>
#include <QRegularExpression>
#include <QDateTime>
#include <QProcess>
#include <QDesktopServices>
#include <QUrl>
#include <QtConcurrent>
#include <QScrollBar>
#include <QToolTip>
#include <QSettings>
#include <QMenu>
#include <QSet>
#include <QMap>
#include <QFileInfo>
#include <QGraphicsDropShadowEffect>
#include <QPropertyAnimation>
#include <QScrollArea>
#include <QCheckBox>
#include <QProgressBar>
#include <QTextBrowser>
#include <QToolButton>
#include <QApplication>
#include <QClipboard>

#include <QMimeData>
#include <QDragEnterEvent>
#include <QDropEvent>

// ----------------------------------------------------------------------------
// 合并逻辑相关常量与辅助函数 (复刻自 FileSearchWindow)
// ----------------------------------------------------------------------------
static const QSet<QString> SUPPORTED_EXTENSIONS = {
    ".py", ".pyw", ".cpp", ".cc", ".cxx", ".c", ".h", ".hpp", ".hxx",
    ".java", ".js", ".jsx", ".ts", ".tsx", ".cs", ".go", ".rs", ".swift",
    ".kt", ".kts", ".php", ".rb", ".lua", ".r", ".m", ".scala", ".sh",
    ".bash", ".zsh", ".ps1", ".bat", ".cmd", ".html", ".htm", ".css",
    ".scss", ".sass", ".less", ".xml", ".svg", ".vue", ".json", ".yaml",
    ".yml", ".toml", ".ini", ".cfg", ".conf", ".env", ".properties",
    ".cmake", ".gradle", ".make", ".mk", ".dockerfile", ".md", ".markdown",
    ".txt", ".rst", ".qml", ".qrc", ".qss", ".ui", ".sql", ".graphql",
    ".gql", ".proto", ".asm", ".s", ".v", ".vh", ".vhdl", ".vhd"
};

static const QSet<QString> SPECIAL_FILENAMES = {
    "Makefile", "makefile", "Dockerfile", "dockerfile", "CMakeLists.txt",
    "Rakefile", "Gemfile", ".gitignore", ".dockerignore", ".editorconfig",
    ".eslintrc", ".prettierrc"
};

static QString getFileLanguage(const QString& filePath) {
    QFileInfo fi(filePath);
    QString basename = fi.fileName();
    QString ext = "." + fi.suffix().toLower();
    
    static const QMap<QString, QString> specialMap = {
        {"Makefile", "makefile"}, {"makefile", "makefile"},
        {"Dockerfile", "dockerfile"}, {"dockerfile", "dockerfile"},
        {"CMakeLists.txt", "cmake"}
    };
    if (specialMap.contains(basename)) return specialMap[basename];

    static const QMap<QString, QString> extMap = {
        {".py", "python"}, {".pyw", "python"}, {".cpp", "cpp"}, {".cc", "cpp"},
        {".cxx", "cpp"}, {".c", "c"}, {".h", "cpp"}, {".hpp", "cpp"},
        {".hxx", "cpp"}, {".java", "java"}, {".js", "javascript"},
        {".jsx", "jsx"}, {".ts", "typescript"}, {".tsx", "tsx"},
        {".cs", "csharp"}, {".go", "go"}, {".rs", "rust"}, {".swift", "swift"},
        {".kt", "kotlin"}, {".kts", "kotlin"}, {".php", "php"}, {".rb", "ruby"},
        {".lua", "lua"}, {".r", "r"}, {".m", "objectivec"}, {".scala", "scala"},
        {".sh", "bash"}, {".bash", "bash"}, {".zsh", "zsh"}, {".ps1", "powershell"},
        {".bat", "batch"}, {".cmd", "batch"}, {".html", "html"}, {".htm", "html"},
        {".css", "css"}, {".scss", "scss"}, {".sass", "sass"}, {".less", "less"},
        {".xml", "xml"}, {".svg", "svg"}, {".vue", "vue"}, {".json", "json"},
        {".yaml", "yaml"}, {".yml", "yaml"}, {".toml", "toml"}, {".ini", "ini"},
        {".cfg", "ini"}, {".conf", "conf"}, {".env", "bash"},
        {".properties", "properties"}, {".cmake", "cmake"}, {".gradle", "gradle"},
        {".make", "makefile"}, {".mk", "makefile"}, {".dockerfile", "dockerfile"},
        {".md", "markdown"}, {".markdown", "markdown"}, {".txt", "text"},
        {".rst", "restructuredtext"}, {".qml", "qml"}, {".qrc", "xml"},
        {".qss", "css"}, {".ui", "xml"}, {".sql", "sql"}, {".graphql", "graphql"},
        {".gql", "graphql"}, {".proto", "protobuf"}, {".asm", "asm"},
        {".s", "asm"}, {".v", "verilog"}, {".vh", "verilog"}, {".vhdl", "vhdl"},
        {".vhd", "vhdl"}
    };
    return extMap.value(ext, ext.mid(1).isEmpty() ? "text" : ext.mid(1));
}

static bool isSupportedFile(const QString& filePath) {
    QFileInfo fi(filePath);
    if (SPECIAL_FILENAMES.contains(fi.fileName())) return true;
    return SUPPORTED_EXTENSIONS.contains("." + fi.suffix().toLower());
}

// ----------------------------------------------------------------------------
// Sidebar ListWidget subclass for Drag & Drop
// ----------------------------------------------------------------------------
class KeywordSidebarListWidget : public QListWidget {
    Q_OBJECT
public:
    explicit KeywordSidebarListWidget(QWidget* parent = nullptr) : QListWidget(parent) {
        setAcceptDrops(true);
    }
signals:
    void folderDropped(const QString& path);
protected:
    void dragEnterEvent(QDragEnterEvent* event) override {
        if (event->mimeData()->hasUrls() || event->mimeData()->hasText()) {
            event->acceptProposedAction();
        }
    }
    void dragMoveEvent(QDragMoveEvent* event) override {
        event->acceptProposedAction();
    }
    void dropEvent(QDropEvent* event) override {
        QString path;
        if (event->mimeData()->hasUrls()) {
            path = event->mimeData()->urls().at(0).toLocalFile();
        } else if (event->mimeData()->hasText()) {
            path = event->mimeData()->text();
        }
        
        if (!path.isEmpty() && QDir(path).exists()) {
            emit folderDropped(path);
            event->acceptProposedAction();
        }
    }
};

// ----------------------------------------------------------------------------
// KeywordSearchHistory 相关辅助类 (复刻 FileSearchHistoryPopup 逻辑)
// ----------------------------------------------------------------------------
class KeywordChip : public QFrame {
    Q_OBJECT
public:
    KeywordChip(const QString& text, QWidget* parent = nullptr) : QFrame(parent), m_text(text) {
        setAttribute(Qt::WA_StyledBackground);
        setCursor(Qt::PointingHandCursor);
        setObjectName("KeywordChip");
        
        auto* layout = new QHBoxLayout(this);
        layout->setContentsMargins(10, 6, 10, 6);
        layout->setSpacing(10);
        
        auto* lbl = new QLabel(text);
        lbl->setStyleSheet("border: none; background: transparent; color: #DDD; font-size: 13px;");
        layout->addWidget(lbl);
        layout->addStretch();
        
        auto* btnDel = new QPushButton();
        btnDel->setIcon(IconHelper::getIcon("close", "#666", 16));
        btnDel->setIconSize(QSize(10, 10));
        btnDel->setFixedSize(16, 16);
        btnDel->setCursor(Qt::PointingHandCursor);
        btnDel->setStyleSheet(
            "QPushButton { background-color: transparent; border-radius: 4px; padding: 0px; }"
            "QPushButton:hover { background-color: #E74C3C; }"
        );
        
        connect(btnDel, &QPushButton::clicked, this, [this](){ emit deleted(m_text); });
        layout->addWidget(btnDel);

        setStyleSheet(
            "#KeywordChip { background-color: transparent; border: none; border-radius: 4px; }"
            "#KeywordChip:hover { background-color: #3E3E42; }"
        );
    }
    
    void mousePressEvent(QMouseEvent* e) override { 
        if(e->button() == Qt::LeftButton) emit clicked(m_text); 
        QFrame::mousePressEvent(e);
    }

signals:
    void clicked(const QString& text);
    void deleted(const QString& text);
private:
    QString m_text;
};

class KeywordSearchHistoryPopup : public QWidget {
    Q_OBJECT
public:
    enum Type { Path, Keyword, Replace };

    explicit KeywordSearchHistoryPopup(KeywordSearchWidget* widget, QLineEdit* edit, Type type) 
        : QWidget(widget->window(), Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint) 
    {
        m_widget = widget;
        m_edit = edit;
        m_type = type;
        setAttribute(Qt::WA_TranslucentBackground);
        
        auto* rootLayout = new QVBoxLayout(this);
        rootLayout->setContentsMargins(12, 12, 12, 12);
        
        auto* container = new QFrame();
        container->setObjectName("PopupContainer");
        container->setStyleSheet(
            "#PopupContainer { background-color: #252526; border: 1px solid #444; border-radius: 10px; }"
        );
        rootLayout->addWidget(container);

        auto* shadow = new QGraphicsDropShadowEffect(container);
        shadow->setBlurRadius(20); shadow->setXOffset(0); shadow->setYOffset(5);
        shadow->setColor(QColor(0, 0, 0, 120));
        container->setGraphicsEffect(shadow);

        auto* layout = new QVBoxLayout(container);
        layout->setContentsMargins(12, 12, 12, 12);
        layout->setSpacing(10);

        auto* top = new QHBoxLayout();
        auto* icon = new QLabel();
        icon->setPixmap(IconHelper::getIcon("clock", "#888").pixmap(14, 14));
        icon->setStyleSheet("border: none; background: transparent;");
        top->addWidget(icon);

        QString titleStr = "最近记录";
        if (m_type == Path) titleStr = "最近扫描路径";
        else if (m_type == Keyword) titleStr = "最近查找内容";
        else if (m_type == Replace) titleStr = "最近替换内容";

        auto* title = new QLabel(titleStr);
        title->setStyleSheet("color: #888; font-weight: bold; font-size: 11px; background: transparent; border: none;");
        top->addWidget(title);
        top->addStretch();
        auto* clearBtn = new QPushButton("清空");
        clearBtn->setCursor(Qt::PointingHandCursor);
        clearBtn->setStyleSheet("QPushButton { background: transparent; color: #666; border: none; font-size: 11px; } QPushButton:hover { color: #E74C3C; }");
        connect(clearBtn, &QPushButton::clicked, [this](){
            clearAllHistory();
            refreshUI();
        });
        top->addWidget(clearBtn);
        layout->addLayout(top);

        auto* scroll = new QScrollArea();
        scroll->setWidgetResizable(true);
        scroll->setStyleSheet(
            "QScrollArea { background-color: transparent; border: none; }"
            "QScrollArea > QWidget > QWidget { background-color: transparent; }"
        );
        scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

        m_chipsWidget = new QWidget();
        m_chipsWidget->setStyleSheet("background-color: transparent;");
        m_vLayout = new QVBoxLayout(m_chipsWidget);
        m_vLayout->setContentsMargins(0, 0, 0, 0);
        m_vLayout->setSpacing(2);
        m_vLayout->addStretch();
        scroll->setWidget(m_chipsWidget);
        layout->addWidget(scroll);

        m_opacityAnim = new QPropertyAnimation(this, "windowOpacity");
        m_opacityAnim->setDuration(200);
    }

    void clearAllHistory() {
        QString key = "keywordList";
        if (m_type == Path) key = "pathList";
        else if (m_type == Replace) key = "replaceList";

        QSettings settings("RapidNotes", "KeywordSearchHistory");
        settings.setValue(key, QStringList());
    }

    void removeEntry(const QString& text) {
        QString key = "keywordList";
        if (m_type == Path) key = "pathList";
        else if (m_type == Replace) key = "replaceList";

        QSettings settings("RapidNotes", "KeywordSearchHistory");
        QStringList history = settings.value(key).toStringList();
        history.removeAll(text);
        settings.setValue(key, history);
    }

    QStringList getHistory() const {
        QString key = "keywordList";
        if (m_type == Path) key = "pathList";
        else if (m_type == Replace) key = "replaceList";

        QSettings settings("RapidNotes", "KeywordSearchHistory");
        return settings.value(key).toStringList();
    }

    void refreshUI() {
        QLayoutItem* item;
        while ((item = m_vLayout->takeAt(0))) {
            if(item->widget()) item->widget()->deleteLater();
            delete item;
        }
        m_vLayout->addStretch();
        
        QStringList history = getHistory();
        if(history.isEmpty()) {
            auto* lbl = new QLabel("暂无历史记录");
            lbl->setAlignment(Qt::AlignCenter);
            lbl->setStyleSheet("color: #555; font-style: italic; margin: 20px; border: none;");
            m_vLayout->insertWidget(0, lbl);
        } else {
            for(const QString& val : history) {
                auto* chip = new KeywordChip(val);
                chip->setFixedHeight(32);
                connect(chip, &KeywordChip::clicked, this, [this](const QString& v){ 
                    m_edit->setText(v);
                    close(); 
                });
                connect(chip, &KeywordChip::deleted, this, [this](const QString& v){ 
                    removeEntry(v);
                    refreshUI(); 
                });
                m_vLayout->insertWidget(m_vLayout->count() - 1, chip);
            }
        }
        
        int targetWidth = m_edit->width();
        int contentHeight = qMin(410, (int)history.size() * 34 + 60);
        resize(targetWidth + 24, contentHeight);
    }

    void showAnimated() {
        refreshUI();
        QPoint pos = m_edit->mapToGlobal(QPoint(0, m_edit->height()));
        move(pos.x() - 12, pos.y() - 7);
        setWindowOpacity(0);
        show();
        m_opacityAnim->setStartValue(0);
        m_opacityAnim->setEndValue(1);
        m_opacityAnim->start();
    }

private:
    KeywordSearchWidget* m_widget;
    QLineEdit* m_edit;
    Type m_type;
    QWidget* m_chipsWidget;
    QVBoxLayout* m_vLayout;
    QPropertyAnimation* m_opacityAnim;
};

// ----------------------------------------------------------------------------
// KeywordCollectionListWidget 实现 (复刻自 FileSearchWindow)
// ----------------------------------------------------------------------------
KeywordCollectionListWidget::KeywordCollectionListWidget(QWidget* parent) : QListWidget(parent) {
    setAcceptDrops(true);
    setSelectionMode(QAbstractItemView::ExtendedSelection);
}

void KeywordCollectionListWidget::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls() || event->mimeData()->hasText()) {
        event->acceptProposedAction();
    }
}

void KeywordCollectionListWidget::dragMoveEvent(QDragMoveEvent* event) {
    event->acceptProposedAction();
}

void KeywordCollectionListWidget::dropEvent(QDropEvent* event) {
    QStringList paths;
    if (event->mimeData()->hasUrls()) {
        for (const QUrl& url : event->mimeData()->urls()) {
            QString p = url.toLocalFile();
            if (!p.isEmpty() && QFileInfo(p).isFile()) paths << p;
        }
    } else if (event->mimeData()->hasText()) {
        QStringList texts = event->mimeData()->text().split("\n", Qt::SkipEmptyParts);
        for (const QString& t : texts) {
            QString p = t.trimmed();
            if (!p.isEmpty() && QFileInfo(p).isFile()) paths << p;
        }
    }
    
    if (!paths.isEmpty()) {
        emit filesDropped(paths);
        event->acceptProposedAction();
    } else if (event->source() && event->source() != this) {
        QListWidget* sourceList = qobject_cast<QListWidget*>(event->source());
        if (sourceList) {
            QStringList sourcePaths;
            for (auto* item : sourceList->selectedItems()) {
                QString p = item->data(Qt::UserRole).toString();
                if (!p.isEmpty()) sourcePaths << p;
            }
            if (!sourcePaths.isEmpty()) {
                emit filesDropped(sourcePaths);
                event->acceptProposedAction();
            }
        }
    }
}

// ----------------------------------------------------------------------------
// KeywordResultItem: 用于在列表中左右对齐显示结果
// ----------------------------------------------------------------------------
class KeywordResultItem : public QWidget {
    Q_OBJECT
public:
    KeywordResultItem(const QString& name, const QString& badge, const QColor& badgeColor, QWidget* parent = nullptr) 
        : QWidget(parent) 
    {
        auto* layout = new QHBoxLayout(this);
        layout->setContentsMargins(10, 0, 10, 0);
        layout->setSpacing(10);

        auto* nameLabel = new QLabel(name);
        nameLabel->setStyleSheet("color: #CCCCCC; font-size: 13px; border: none; background: transparent;");
        layout->addWidget(nameLabel);

        layout->addStretch();

        auto* badgeLabel = new QLabel(badge);
        badgeLabel->setFixedWidth(120); // 扩大感应范围，鼠标进入此区域即显示提示
        badgeLabel->setAlignment(Qt::AlignRight | Qt::AlignVCenter);
        badgeLabel->setStyleSheet(QString("color: %1; font-size: 12px; font-weight: bold; border: none; background: transparent;").arg(badgeColor.name()));
        
        // 为右侧数字或状态添加悬浮提示
        if (badge == "已修改") {
            badgeLabel->setToolTip("文件已修改");
        } else if (badge == "已恢复") {
            badgeLabel->setToolTip("文件已恢复");
        } else {
            badgeLabel->setToolTip("匹配次数");
        }

        layout->addWidget(badgeLabel);
    }
protected:
    // 忽略鼠标事件以便让底层的 QListWidget 处理选中和点击
    void mousePressEvent(QMouseEvent* event) override { event->ignore(); }
    void mouseReleaseEvent(QMouseEvent* event) override { event->ignore(); }
    void mouseDoubleClickEvent(QMouseEvent* event) override { event->ignore(); }
};

// ----------------------------------------------------------------------------
// KeywordSearchWidget 实现
// ----------------------------------------------------------------------------
KeywordSearchWidget::KeywordSearchWidget(QWidget* parent) : QWidget(parent) {
    m_ignoreDirs = {".git", ".svn", ".idea", ".vscode", "__pycache__", "node_modules", "dist", "build", "venv"};
    setupStyles();
    initUI();
    loadFavorites();
    loadCollection();
}

KeywordSearchWidget::~KeywordSearchWidget() {
}

void KeywordSearchWidget::setupStyles() {
    setStyleSheet(R"(
        QWidget {
            font-family: "Microsoft YaHei", "Segoe UI", sans-serif;
            font-size: 14px;
            color: #E0E0E0;
            outline: none;
        }
        QSplitter::handle {
            background-color: #333;
        }
        QListWidget {
            background-color: #252526; 
            border: 1px solid #333333;
            border-radius: 6px;
            padding: 4px;
        }
        QListWidget::item {
            min-height: 20px;
            max-height: 20px;
            padding-left: 8px;
            border-radius: 4px;
            color: #CCCCCC;
        }
        QListWidget::item:selected {
            background-color: #37373D;
            border-left: 3px solid #007ACC;
            color: #FFFFFF;
        }
        #SidebarList::item:selected {
            background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #007ACC, stop:0.015 #007ACC, stop:0.016 #37373D, stop:1 #37373D);
            color: #FFFFFF;
            border-radius: 4px;
        }
        QListWidget::item:hover {
            background-color: #2A2D2E;
        }
        QLineEdit {
            background-color: #333333;
            border: 1px solid #444444;
            color: #FFFFFF;
            border-radius: 6px;
            padding: 8px;
            selection-background-color: #264F78;
        }
        QLineEdit:focus {
            border: 1px solid #007ACC;
            background-color: #2D2D2D;
        }
        QScrollBar:vertical {
            background: transparent;
            width: 8px;
            margin: 0px;
        }
        QScrollBar::handle:vertical {
            background: #555555;
            min-height: 20px;
            border-radius: 4px;
        }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
            height: 0px;
        }
    )");
}

void KeywordSearchWidget::initUI() {
    auto* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(10, 10, 10, 10);
    mainLayout->setSpacing(0);

    auto* splitter = new QSplitter(Qt::Horizontal);
    mainLayout->addWidget(splitter);

    // --- 左侧边栏 ---
    auto* sidebarWidget = new QWidget();
    auto* sidebarLayout = new QVBoxLayout(sidebarWidget);
    sidebarLayout->setContentsMargins(0, 0, 10, 0);
    sidebarLayout->setSpacing(10);

    auto* headerLayout = new QHBoxLayout();
    headerLayout->setSpacing(5);
    auto* sidebarIcon = new QLabel();
    sidebarIcon->setPixmap(IconHelper::getIcon("folder", "#888").pixmap(14, 14));
    sidebarIcon->setStyleSheet("border: none; background: transparent;");
    headerLayout->addWidget(sidebarIcon);

    auto* sidebarHeader = new QLabel("收藏夹 (可拖入)");
    sidebarHeader->setStyleSheet("color: #888; font-weight: bold; font-size: 12px; border: none; background: transparent;");
    headerLayout->addWidget(sidebarHeader);
    headerLayout->addStretch();
    sidebarLayout->addLayout(headerLayout);

    m_sidebar = new KeywordSidebarListWidget();
    m_sidebar->setObjectName("SidebarList");
    m_sidebar->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_sidebar->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_sidebar->setMinimumWidth(200);
    m_sidebar->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(static_cast<KeywordSidebarListWidget*>(m_sidebar), &KeywordSidebarListWidget::folderDropped, this, &KeywordSearchWidget::addFavorite);
    connect(m_sidebar, &QListWidget::itemClicked, this, &KeywordSearchWidget::onSidebarItemClicked);
    connect(m_sidebar, &QListWidget::customContextMenuRequested, this, &KeywordSearchWidget::showSidebarContextMenu);
    sidebarLayout->addWidget(m_sidebar);

    auto* btnAddFav = new QPushButton("收藏当前路径");
    btnAddFav->setFixedHeight(32);
    btnAddFav->setCursor(Qt::PointingHandCursor);
    btnAddFav->setStyleSheet(
        "QPushButton { background-color: #2D2D30; border: 1px solid #444; color: #AAA; border-radius: 4px; font-size: 12px; }"
        "QPushButton:hover { background-color: #3E3E42; color: #FFF; border-color: #666; }"
    );
    connect(btnAddFav, &QPushButton::clicked, this, [this](){
        QString p = m_pathEdit->text().trimmed();
        if (QDir(p).exists()) addFavorite(p);
    });
    sidebarLayout->addWidget(btnAddFav);

    splitter->addWidget(sidebarWidget);

    // --- 中间内容区域 ---
    auto* midWidget = new QWidget();
    auto* midLayout = new QVBoxLayout(midWidget);
    midLayout->setContentsMargins(10, 0, 10, 0);
    midLayout->setSpacing(15);

    // --- 配置区域 ---
    auto* configGroup = new QWidget();
    auto* configLayout = new QGridLayout(configGroup);
    configLayout->setContentsMargins(0, 0, 0, 0);
    configLayout->setHorizontalSpacing(10); 
    configLayout->setVerticalSpacing(10);
    configLayout->setColumnStretch(1, 1);
    configLayout->setColumnStretch(0, 0);
    configLayout->setColumnStretch(2, 0);

    auto createLabel = [](const QString& text) {
        auto* lbl = new QLabel(text);
        lbl->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);
        lbl->setStyleSheet("color: #AAA; font-weight: bold; border: none; background: transparent;");
        return lbl;
    };

    auto setEditStyle = [](QLineEdit* edit) {
        edit->setClearButtonEnabled(true);
        edit->setStyleSheet(
            "QLineEdit { background: #252526; border: 1px solid #333; border-radius: 4px; padding: 6px; color: #EEE; }"
            "QLineEdit:focus { border-color: #007ACC; }"
        );
    };

    // 1. 搜索目录
    configLayout->addWidget(createLabel("搜索目录:"), 0, 0);
    m_pathEdit = new ClickableLineEdit();
    m_pathEdit->setPlaceholderText("选择搜索根目录 (双击查看历史)...");
    setEditStyle(m_pathEdit);
    connect(m_pathEdit, &QLineEdit::returnPressed, this, &KeywordSearchWidget::onSearch);
    connect(m_pathEdit, &ClickableLineEdit::doubleClicked, this, &KeywordSearchWidget::onShowHistory);
    configLayout->addWidget(m_pathEdit, 0, 1);

    auto* browseBtn = new QPushButton();
    browseBtn->setFixedSize(38, 32);
    browseBtn->setIcon(IconHelper::getIcon("folder", "#EEE", 18));
    browseBtn->setToolTip("浏览文件夹");
    browseBtn->setAutoDefault(false);
    browseBtn->setCursor(Qt::PointingHandCursor);
    browseBtn->setStyleSheet("QPushButton { background: #3E3E42; border: none; border-radius: 4px; } QPushButton:hover { background: #4E4E52; }");
    connect(browseBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onBrowseFolder);
    configLayout->addWidget(browseBtn, 0, 2);

    // 2. 文件过滤
    configLayout->addWidget(createLabel("文件过滤:"), 1, 0);
    m_filterEdit = new QLineEdit();
    m_filterEdit->setPlaceholderText("例如: *.py, *.txt (留空则扫描所有文本文件)");
    setEditStyle(m_filterEdit);
    connect(m_filterEdit, &QLineEdit::returnPressed, this, &KeywordSearchWidget::onSearch);
    configLayout->addWidget(m_filterEdit, 1, 1, 1, 2);

    // 3. 查找内容
    configLayout->addWidget(createLabel("查找内容:"), 2, 0);
    m_searchEdit = new ClickableLineEdit();
    m_searchEdit->setPlaceholderText("输入要查找的内容 (双击查看历史)...");
    setEditStyle(m_searchEdit);
    connect(m_searchEdit, &QLineEdit::returnPressed, this, &KeywordSearchWidget::onSearch);
    connect(m_searchEdit, &ClickableLineEdit::doubleClicked, this, &KeywordSearchWidget::onShowHistory);
    configLayout->addWidget(m_searchEdit, 2, 1);

    // 4. 替换内容
    configLayout->addWidget(createLabel("替换内容:"), 3, 0);
    m_replaceEdit = new ClickableLineEdit();
    m_replaceEdit->setPlaceholderText("替换为 (双击查看历史)...");
    setEditStyle(m_replaceEdit);
    connect(m_replaceEdit, &QLineEdit::returnPressed, this, &KeywordSearchWidget::onSearch);
    connect(m_replaceEdit, &ClickableLineEdit::doubleClicked, this, &KeywordSearchWidget::onShowHistory);
    configLayout->addWidget(m_replaceEdit, 3, 1);

    // 交换按钮 (跨越查找和替换行)
    auto* swapBtn = new QPushButton();
    swapBtn->setFixedSize(32, 74); 
    swapBtn->setCursor(Qt::PointingHandCursor);
    swapBtn->setToolTip("交换查找与替换内容");
    swapBtn->setIcon(IconHelper::getIcon("swap", "#AAA", 20));
    swapBtn->setAutoDefault(false);
    swapBtn->setStyleSheet("QPushButton { background: #3E3E42; border: none; border-radius: 4px; } QPushButton:hover { background: #4E4E52; }");
    connect(swapBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onSwapSearchReplace);
    configLayout->addWidget(swapBtn, 2, 2, 2, 1);

    // 选项
    m_caseCheck = new QCheckBox("区分大小写");
    m_caseCheck->setStyleSheet("QCheckBox { color: #AAA; }");
    configLayout->addWidget(m_caseCheck, 4, 1, 1, 2);

    midLayout->addWidget(configGroup);

    // --- 按钮区域 ---
    auto* btnLayout = new QHBoxLayout();
    auto* searchBtn = new QPushButton(" 智能搜索");
    searchBtn->setAutoDefault(false);
    searchBtn->setIcon(IconHelper::getIcon("find_keyword", "#FFF", 16));
    searchBtn->setStyleSheet("QPushButton { background: #007ACC; border: none; border-radius: 4px; padding: 8px 20px; color: #FFF; font-weight: bold; } QPushButton:hover { background: #0098FF; }");
    connect(searchBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onSearch);

    auto* replaceBtn = new QPushButton(" 执行替换");
    replaceBtn->setAutoDefault(false);
    replaceBtn->setIcon(IconHelper::getIcon("edit", "#FFF", 16));
    replaceBtn->setStyleSheet("QPushButton { background: #D32F2F; border: none; border-radius: 4px; padding: 8px 20px; color: #FFF; font-weight: bold; } QPushButton:hover { background: #F44336; }");
    connect(replaceBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onReplace);

    auto* undoBtn = new QPushButton(" 撤销替换");
    undoBtn->setAutoDefault(false);
    undoBtn->setIcon(IconHelper::getIcon("undo", "#EEE", 16));
    undoBtn->setStyleSheet("QPushButton { background: #3E3E42; border: none; border-radius: 4px; padding: 8px 20px; color: #EEE; } QPushButton:hover { background: #4E4E52; }");
    connect(undoBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onUndo);

    auto* clearBtn = new QPushButton(" 清空日志");
    clearBtn->setAutoDefault(false);
    clearBtn->setIcon(IconHelper::getIcon("trash", "#EEE", 16));
    clearBtn->setStyleSheet("QPushButton { background: #3E3E42; border: none; border-radius: 4px; padding: 8px 20px; color: #EEE; } QPushButton:hover { background: #4E4E52; }");
    connect(clearBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onClearLog);

    btnLayout->addWidget(searchBtn);
    btnLayout->addWidget(replaceBtn);
    btnLayout->addWidget(undoBtn);
    btnLayout->addWidget(clearBtn);
    btnLayout->addStretch();
    midLayout->addLayout(btnLayout);

    // --- 结果列表展示区域 ---
    auto* listHeaderLayout = new QHBoxLayout();
    auto* listTitle = new QLabel("搜索结果");
    listTitle->setStyleSheet("color: #888; font-size: 11px; font-weight: bold; border: none; background: transparent;");
    listHeaderLayout->addWidget(listTitle);
    listHeaderLayout->addStretch();
    
    auto* btnCopyAll = new QToolButton();
    btnCopyAll->setIcon(IconHelper::getIcon("copy", "#1abc9c", 14));
    btnCopyAll->setToolTip("复制所有结果的路径");
    btnCopyAll->setFixedSize(20, 20);
    btnCopyAll->setCursor(Qt::PointingHandCursor);
    btnCopyAll->setStyleSheet("QToolButton { border: none; background: transparent; padding: 2px; }"
                               "QToolButton:hover { background-color: #3E3E42; border-radius: 4px; }");
    connect(btnCopyAll, &QToolButton::clicked, this, &KeywordSearchWidget::copySelectedPaths);
    listHeaderLayout->addWidget(btnCopyAll);
    midLayout->addLayout(listHeaderLayout);

    m_resultList = new QListWidget();
    m_resultList->setObjectName("FileList");
    m_resultList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_resultList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_resultList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    m_resultList->setContextMenuPolicy(Qt::CustomContextMenu);
    m_resultList->setDragEnabled(true);
    m_resultList->setDragDropMode(QAbstractItemView::DragOnly);
    connect(m_resultList, &QListWidget::customContextMenuRequested, this, &KeywordSearchWidget::showResultContextMenu);
    midLayout->addWidget(m_resultList, 1);

    // --- 状态栏 ---
    auto* statusLayout = new QVBoxLayout();
    m_progressBar = new QProgressBar();
    m_progressBar->setFixedHeight(4);
    m_progressBar->setTextVisible(false);
    m_progressBar->setStyleSheet("QProgressBar { background: #252526; border: none; } QProgressBar::chunk { background: #007ACC; }");
    m_progressBar->hide();
    
    m_statusLabel = new QLabel("就绪");
    m_statusLabel->setStyleSheet("color: #888; font-size: 11px;");
    
    statusLayout->addWidget(m_progressBar);
    statusLayout->addWidget(m_statusLabel);
    midLayout->addLayout(statusLayout);

    splitter->addWidget(midWidget);

    // --- 右侧边栏 (文件收藏) ---
    auto* collectionWidget = new QWidget();
    auto* collectionLayout = new QVBoxLayout(collectionWidget);
    collectionLayout->setContentsMargins(10, 0, 0, 0);
    collectionLayout->setSpacing(10);

    auto* collHeaderLayout = new QHBoxLayout();
    collHeaderLayout->setSpacing(5);
    auto* collIcon = new QLabel();
    collIcon->setPixmap(IconHelper::getIcon("file", "#888").pixmap(14, 14));
    collIcon->setStyleSheet("border: none; background: transparent;");
    collHeaderLayout->addWidget(collIcon);

    auto* collHeader = new QLabel("文件收藏 (可多选/拖入)");
    collHeader->setStyleSheet("color: #888; font-weight: bold; font-size: 12px; border: none; background: transparent;");
    collHeaderLayout->addWidget(collHeader);
    collHeaderLayout->addStretch();
    collectionLayout->addLayout(collHeaderLayout);

    m_collectionSidebar = new KeywordCollectionListWidget();
    m_collectionSidebar->setObjectName("SidebarList");
    m_collectionSidebar->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_collectionSidebar->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_collectionSidebar->setMinimumWidth(200);
    m_collectionSidebar->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_collectionSidebar, &KeywordCollectionListWidget::filesDropped, this, [this](const QStringList& paths){
        for(const QString& p : paths) addCollectionItem(p);
    });
    connect(m_collectionSidebar, &QListWidget::itemClicked, this, &KeywordSearchWidget::onCollectionItemClicked);
    connect(m_collectionSidebar, &QListWidget::customContextMenuRequested, this, &KeywordSearchWidget::showCollectionContextMenu);
    collectionLayout->addWidget(m_collectionSidebar);

    auto* btnMergeColl = new QPushButton("合并收藏内容");
    btnMergeColl->setFixedHeight(32);
    btnMergeColl->setCursor(Qt::PointingHandCursor);
    btnMergeColl->setStyleSheet(
        "QPushButton { background-color: #2D2D30; border: 1px solid #444; color: #AAA; border-radius: 4px; font-size: 12px; }"
        "QPushButton:hover { background-color: #3E3E42; color: #FFF; border-color: #666; }"
    );
    connect(btnMergeColl, &QPushButton::clicked, this, &KeywordSearchWidget::onMergeCollectionFiles);
    collectionLayout->addWidget(btnMergeColl);

    splitter->addWidget(collectionWidget);

    splitter->setStretchFactor(0, 0);
    splitter->setStretchFactor(1, 1);
    splitter->setStretchFactor(2, 0);

    // 快捷键支持
    m_actionSearch = new QAction(this);
    connect(m_actionSearch, &QAction::triggered, this, &KeywordSearchWidget::onSearch);
    addAction(m_actionSearch);

    m_actionReplace = new QAction(this);
    connect(m_actionReplace, &QAction::triggered, this, &KeywordSearchWidget::onReplace);
    addAction(m_actionReplace);

    m_actionUndo = new QAction(this);
    connect(m_actionUndo, &QAction::triggered, this, &KeywordSearchWidget::onUndo);
    addAction(m_actionUndo);

    m_actionSwap = new QAction(this);
    connect(m_actionSwap, &QAction::triggered, this, &KeywordSearchWidget::onSwapSearchReplace);
    addAction(m_actionSwap);

    m_actionSelectAll = new QAction(this);
    connect(m_actionSelectAll, &QAction::triggered, [this](){ m_resultList->selectAll(); });
    m_resultList->addAction(m_actionSelectAll);

    m_actionCopyPaths = new QAction(this);
    connect(m_actionCopyPaths, &QAction::triggered, this, &KeywordSearchWidget::copySelectedPaths);
    m_resultList->addAction(m_actionCopyPaths);

    m_actionCopyFiles = new QAction(this);
    connect(m_actionCopyFiles, &QAction::triggered, this, &KeywordSearchWidget::copySelectedFiles);
    m_resultList->addAction(m_actionCopyFiles);

    updateShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &KeywordSearchWidget::updateShortcuts);
}

void KeywordSearchWidget::updateShortcuts() {
    auto& sm = ShortcutManager::instance();
    if (m_actionSearch) m_actionSearch->setShortcut(sm.getShortcut("ks_search"));
    if (m_actionReplace) m_actionReplace->setShortcut(sm.getShortcut("ks_replace"));
    if (m_actionUndo) m_actionUndo->setShortcut(sm.getShortcut("ks_undo"));
    if (m_actionSwap) m_actionSwap->setShortcut(sm.getShortcut("ks_swap"));
    if (m_actionSelectAll) m_actionSelectAll->setShortcut(sm.getShortcut("fs_select_all"));
    if (m_actionCopyPaths) m_actionCopyPaths->setShortcut(sm.getShortcut("fs_copy"));
}

void KeywordSearchWidget::onSidebarItemClicked(QListWidgetItem* item) {
    if (!item) return;
    QString path = item->data(Qt::UserRole).toString();
    m_pathEdit->setText(path);
}

void KeywordSearchWidget::showSidebarContextMenu(const QPoint& pos) {
    QListWidgetItem* item = m_sidebar->itemAt(pos);
    if (!item) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #252526; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #37373D; }");
    
    QAction* pinAct = menu.addAction(IconHelper::getIcon("pin", "#F1C40F"), "置顶文件夹");
    QAction* removeAct = menu.addAction(IconHelper::getIcon("close", "#E74C3C"), "取消收藏");
    
    QAction* selected = menu.exec(m_sidebar->mapToGlobal(pos));
    if (selected == pinAct) {
        int row = m_sidebar->row(item);
        if (row > 0) {
            QListWidgetItem* taken = m_sidebar->takeItem(row);
            m_sidebar->insertItem(0, taken);
            m_sidebar->setCurrentItem(taken);
            saveFavorites();
        }
    } else if (selected == removeAct) {
        delete m_sidebar->takeItem(m_sidebar->row(item));
        saveFavorites();
    }
}

void KeywordSearchWidget::addFavorite(const QString& path) {
    // 检查是否已存在
    for (int i = 0; i < m_sidebar->count(); ++i) {
        if (m_sidebar->item(i)->data(Qt::UserRole).toString() == path) return;
    }

    QFileInfo fi(path);
    auto* item = new QListWidgetItem(IconHelper::getIcon("folder", "#F1C40F"), fi.fileName());
    item->setData(Qt::UserRole, path);
    item->setToolTip(path);
    m_sidebar->addItem(item);
    saveFavorites();
}

void KeywordSearchWidget::loadFavorites() {
    QSettings settings("RapidNotes", "KeywordSearchFavorites");
    QStringList favs = settings.value("list").toStringList();
    for (const QString& path : std::as_const(favs)) {
        if (QDir(path).exists()) {
            QFileInfo fi(path);
            auto* item = new QListWidgetItem(IconHelper::getIcon("folder", "#F1C40F"), fi.fileName());
            item->setData(Qt::UserRole, path);
            item->setToolTip(path);
            m_sidebar->addItem(item);
        }
    }
}

void KeywordSearchWidget::saveFavorites() {
    QStringList favs;
    for (int i = 0; i < m_sidebar->count(); ++i) {
        favs << m_sidebar->item(i)->data(Qt::UserRole).toString();
    }
    QSettings settings("RapidNotes", "KeywordSearchFavorites");
    settings.setValue("list", favs);
}

void KeywordSearchWidget::onBrowseFolder() {
    QString folder = QFileDialog::getExistingDirectory(this, "选择搜索目录");
    if (!folder.isEmpty()) {
        m_pathEdit->setText(folder);
    }
}

bool KeywordSearchWidget::isTextFile(const QString& filePath) {
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) return false;
    
    QByteArray chunk = file.read(1024);
    file.close();

    if (chunk.isEmpty()) return true;
    if (chunk.contains('\0')) return false;

    return true;
}

void KeywordSearchWidget::onSearch() {
    QString rootDir = m_pathEdit->text().trimmed();
    QString keyword = m_searchEdit->text().trimmed();
    QString replaceText = m_replaceEdit->text().trimmed();
    if (rootDir.isEmpty() || keyword.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 目录和查找内容不能为空!</b>");
        return;
    }

    // 保存历史记录
    addHistoryEntry(Path, rootDir);
    addHistoryEntry(Keyword, keyword);
    if (!replaceText.isEmpty()) {
        addHistoryEntry(Replace, replaceText);
    }

    m_resultList->clear();
    m_resultsData.clear();
    m_progressBar->show();
    m_progressBar->setRange(0, 0);
    m_statusLabel->setText("正在搜索...");

    QString filter = m_filterEdit->text();
    bool caseSensitive = m_caseCheck->isChecked();

    (void)QtConcurrent::run([this, rootDir, keyword, filter, caseSensitive]() {
        int scannedFiles = 0;
        struct TmpMatch { QString path; int count; };
        QList<TmpMatch> matches;

        QStringList filters;
        if (!filter.isEmpty()) {
            filters = filter.split(QRegularExpression("[,\\s;]+"), Qt::SkipEmptyParts);
        }

        QDirIterator it(rootDir, QDir::Files, QDirIterator::Subdirectories);
        while (it.hasNext()) {
            QString filePath = it.next();
            
            // 过滤目录
            bool skip = false;
            for (const QString& ignore : m_ignoreDirs) {
                if (filePath.contains("/" + ignore + "/") || filePath.contains("\\" + ignore + "\\")) {
                    skip = true;
                    break;
                }
            }
            if (skip) continue;

            // 过滤文件名
            if (!filters.isEmpty()) {
                bool matchFilter = false;
                QString fileName = QFileInfo(filePath).fileName();
                for (const QString& f : filters) {
                    QRegularExpression re(QRegularExpression::wildcardToRegularExpression(f));
                    if (re.match(fileName).hasMatch()) {
                        matchFilter = true;
                        break;
                    }
                }
                if (!matchFilter) continue;
            }

            if (!isTextFile(filePath)) continue;

            scannedFiles++;
            QFile file(filePath);
            if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
                QTextStream in(&file);
                QString content = in.readAll();
                file.close();

                Qt::CaseSensitivity cs = caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive;
                if (content.contains(keyword, cs)) {
                    int count = content.count(keyword, cs);
                    matches.append({filePath, count});
                }
            }
        }

        QMetaObject::invokeMethod(this, [this, scannedFiles, matches, keyword]() {
            for(const auto& m : matches) {
                m_resultsData.append({m.path, m.count});
                QString fileName = QFileInfo(m.path).fileName();
                auto* item = new QListWidgetItem("");
                item->setData(Qt::UserRole, m.path);
                item->setToolTip(m.path);
                m_resultList->addItem(item);

                auto* widget = new KeywordResultItem(fileName, QString::number(m.count), QColor("#007ACC"));
                m_resultList->setItemWidget(item, widget);
            }

            m_statusLabel->setText(QString("扫描 %1 个文件，找到 %2 个匹配").arg(scannedFiles).arg(matches.size()));
            m_progressBar->hide();
        });
    });
}

void KeywordSearchWidget::onReplace() {
    QString rootDir = m_pathEdit->text().trimmed();
    QString keyword = m_searchEdit->text().trimmed();
    QString replaceText = m_replaceEdit->text().trimmed();
    if (rootDir.isEmpty() || keyword.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 目录和查找内容不能为空!</b>");
        return;
    }

    // 保存历史记录
    addHistoryEntry(Path, rootDir);
    addHistoryEntry(Keyword, keyword);
    if (!replaceText.isEmpty()) {
        addHistoryEntry(Replace, replaceText);
    }

    m_resultList->clear();
    m_resultsData.clear();
    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #007acc;'>ℹ 正在开始批量替换...</b>");

    m_progressBar->show();
    m_progressBar->setRange(0, 0);
    m_statusLabel->setText("正在替换...");

    QString filter = m_filterEdit->text();
    bool caseSensitive = m_caseCheck->isChecked();

    (void)QtConcurrent::run([this, rootDir, keyword, replaceText, filter, caseSensitive]() {
        int modifiedFiles = 0;
        QString timestamp = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
        QString backupDirName = "_backup_" + timestamp;
        QDir root(rootDir);
        root.mkdir(backupDirName);
        m_lastBackupPath = root.absoluteFilePath(backupDirName);

        QStringList filters;
        if (!filter.isEmpty()) {
            filters = filter.split(QRegularExpression("[,\\s;]+"), Qt::SkipEmptyParts);
        }

        QDirIterator it(rootDir, QDir::Files, QDirIterator::Subdirectories);
        while (it.hasNext()) {
            QString filePath = it.next();
            if (filePath.contains(backupDirName)) continue;

            // 过滤目录和文件名（逻辑同搜索）
            bool skip = false;
            for (const QString& ignore : m_ignoreDirs) {
                if (filePath.contains("/" + ignore + "/") || filePath.contains("\\" + ignore + "\\")) {
                    skip = true;
                    break;
                }
            }
            if (skip) continue;

            if (!filters.isEmpty()) {
                bool matchFilter = false;
                QString fileName = QFileInfo(filePath).fileName();
                for (const QString& f : filters) {
                    QRegularExpression re(QRegularExpression::wildcardToRegularExpression(f));
                    if (re.match(fileName).hasMatch()) {
                        matchFilter = true;
                        break;
                    }
                }
                if (!matchFilter) continue;
            }

            if (!isTextFile(filePath)) continue;

            QFile file(filePath);
            if (file.open(QIODevice::ReadWrite | QIODevice::Text)) {
                QTextStream in(&file);
                QString content = in.readAll();
                
                Qt::CaseSensitivity cs = caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive;
                if (content.contains(keyword, cs)) {
                    // 备份
                    QString fileName = QFileInfo(filePath).fileName();
                    QFile::copy(filePath, m_lastBackupPath + "/" + fileName + ".bak");

                    // 替换
                    QString newContent;
                    if (caseSensitive) {
                        newContent = content.replace(keyword, replaceText);
                    } else {
                        newContent = content.replace(QRegularExpression(QRegularExpression::escape(keyword), QRegularExpression::CaseInsensitiveOption), replaceText);
                    }

                    file.resize(0);
                    in << newContent;
                    modifiedFiles++;
                    
                    QMetaObject::invokeMethod(this, [this, filePath]() {
                        QString fileName = QFileInfo(filePath).fileName();
                        auto* item = new QListWidgetItem("");
                        item->setData(Qt::UserRole, filePath);
                        item->setToolTip(filePath);
                        m_resultList->addItem(item);

                        auto* widget = new KeywordResultItem(fileName, "已修改", QColor("#6A9955"));
                        m_resultList->setItemWidget(item, widget);
                    });
                }
                file.close();
            }
        }

        QMetaObject::invokeMethod(this, [this, modifiedFiles]() {
            m_statusLabel->setText(QString("替换完成: 修改了 %1 个文件").arg(modifiedFiles));
            m_progressBar->hide();
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已修改 %1 个文件 (备份于 %2)").arg(modifiedFiles).arg(m_lastBackupPath));
        });
    });
}

void KeywordSearchWidget::onUndo() {
    if (m_lastBackupPath.isEmpty() || !QDir(m_lastBackupPath).exists()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 未找到有效的备份目录！</b>");
        return;
    }

    int restored = 0;
    QDir backupDir(m_lastBackupPath);
    QStringList baks = backupDir.entryList({"*.bak"});
    
    QString rootDir = m_pathEdit->text();

    m_resultList->clear();
    for (const QString& bak : baks) {
        QString origName = bak.left(bak.length() - 4);
        
        // 在根目录下寻找原始文件（简化策略：找同名文件）
        QDirIterator it(rootDir, {origName}, QDir::Files, QDirIterator::Subdirectories);
        if (it.hasNext()) {
            QString targetPath = it.next();
            if (QFile::remove(targetPath)) {
                if (QFile::copy(backupDir.absoluteFilePath(bak), targetPath)) {
                    restored++;
                    auto* item = new QListWidgetItem("");
                    item->setData(Qt::UserRole, targetPath);
                    item->setToolTip(targetPath);
                    m_resultList->addItem(item);

                    auto* widget = new KeywordResultItem(origName, "已恢复", QColor("#007ACC"));
                    m_resultList->setItemWidget(item, widget);
                }
            }
        }
    }

    m_statusLabel->setText(QString("撤销完成，已恢复 %1 个文件").arg(restored));
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已恢复 %1 个文件").arg(restored));
}

void KeywordSearchWidget::onClearLog() {
    m_resultList->clear();
    m_resultsData.clear();
    m_statusLabel->setText("就绪");
}

void KeywordSearchWidget::showResultContextMenu(const QPoint& pos) {
    auto selectedItems = m_resultList->selectedItems();
    if (selectedItems.isEmpty()) {
        auto* item = m_resultList->itemAt(pos);
        if (item) {
            item->setSelected(true);
            selectedItems << item;
        }
    }

    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) paths << p;
    }

    if (paths.isEmpty()) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D30; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #3E3E42; }");
    
    if (selectedItems.size() == 1) {
        QString filePath = paths.first();
        menu.addAction(IconHelper::getIcon("folder", "#F1C40F"), "定位文件夹", [filePath](){
            QDesktopServices::openUrl(QUrl::fromLocalFile(QFileInfo(filePath).absolutePath()));
        });
        menu.addAction(IconHelper::getIcon("search", "#4A90E2"), "定位文件", [filePath](){
#ifdef Q_OS_WIN
            QStringList args;
            args << "/select," << QDir::toNativeSeparators(filePath);
            QProcess::startDetached("explorer.exe", args);
#endif
        });
        menu.addAction(IconHelper::getIcon("edit", "#3498DB"), "编辑", [this](){ onEditFile(); });
        menu.addSeparator();
    }

    QString copyPathText = selectedItems.size() > 1 ? "复制选中路径" : "复制完整路径";
    menu.addAction(IconHelper::getIcon("copy", "#2ECC71"), copyPathText, [this](){ copySelectedPaths(); });

    if (selectedItems.size() == 1) {
        QString fileName = QFileInfo(paths.first()).fileName();
        menu.addAction(IconHelper::getIcon("copy", "#F39C12"), "复制文件名", [fileName](){
            QApplication::clipboard()->setText(fileName);
            ToolTipOverlay::instance()->showText(QCursor::pos(), "✔ 已复制文件名");
        });
    }

    QString copyFileText = selectedItems.size() > 1 ? "复制选中文件" : "复制文件";
    menu.addAction(IconHelper::getIcon("file", "#4A90E2"), copyFileText, [this](){ copySelectedFiles(); });

    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并选中内容", [this](){ onMergeSelectedFiles(); });

    menu.addSeparator();

    menu.addAction(IconHelper::getIcon("star", "#F1C40F"), "加入收藏", [this](){
        auto selectedItems = m_resultList->selectedItems();
        for (auto* item : selectedItems) {
            QString p = item->data(Qt::UserRole).toString();
            if (!p.isEmpty()) addCollectionItem(p);
        }
    });

    menu.exec(m_resultList->mapToGlobal(pos));
}

void KeywordSearchWidget::onEditFile() {
    auto selectedItems = m_resultList->selectedItems();
    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) paths << p;
    }
    if (paths.isEmpty()) return;

    QSettings settings("RapidNotes", "ExternalEditor");
    QString editorPath = settings.value("EditorPath").toString();

    if (editorPath.isEmpty() || !QFile::exists(editorPath)) {
        QStringList commonPaths = {
            "C:/Program Files/Notepad++/notepad++.exe",
            "C:/Program Files (x86)/Notepad++/notepad++.exe"
        };
        for (const QString& p : commonPaths) {
            if (QFile::exists(p)) {
                editorPath = p;
                break;
            }
        }
    }

    if (editorPath.isEmpty() || !QFile::exists(editorPath)) {
        editorPath = QFileDialog::getOpenFileName(this, "选择编辑器 (推荐 Notepad++)", "C:/Program Files", "Executable (*.exe)");
        if (editorPath.isEmpty()) return;
        settings.setValue("EditorPath", editorPath);
    }

    for (const QString& filePath : paths) {
        QProcess::startDetached(editorPath, { QDir::toNativeSeparators(filePath) });
    }
}

void KeywordSearchWidget::copySelectedPaths() {
    auto selectedItems = m_resultList->selectedItems();
    QStringList paths;
    if (selectedItems.isEmpty()) {
        for (int i = 0; i < m_resultList->count(); ++i) {
            paths << m_resultList->item(i)->data(Qt::UserRole).toString();
        }
    } else {
        for (auto* item : selectedItems) {
            paths << item->data(Qt::UserRole).toString();
        }
    }

    if (paths.isEmpty()) return;
    QApplication::clipboard()->setText(paths.join("\n"));
    ToolTipOverlay::instance()->showText(QCursor::pos(), "✔ 已复制路径到剪贴板");
}

void KeywordSearchWidget::copySelectedFiles() {
    auto selectedItems = m_resultList->selectedItems();
    if (selectedItems.isEmpty()) return;

    QList<QUrl> urls;
    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) {
            urls << QUrl::fromLocalFile(p);
            paths << p;
        }
    }
    if (urls.isEmpty()) return;

    QMimeData* mimeData = new QMimeData();
    mimeData->setUrls(urls);
    mimeData->setText(paths.join("\n"));
    QApplication::clipboard()->setMimeData(mimeData);

    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已复制 %1 个文件").arg(urls.size()));
}

void KeywordSearchWidget::onMergeFiles(const QStringList& filePaths, const QString& rootPath, bool useCombineDir) {
    if (filePaths.isEmpty()) return;

    QString targetDir = rootPath;
    if (useCombineDir) {
        targetDir = QCoreApplication::applicationDirPath() + "/Combine";
        QDir dir(targetDir);
        if (!dir.exists()) dir.mkpath(".");
    }

    QString ts = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
    QString outName = QString("%1_keyword_export.md").arg(ts);
    QString outPath = QDir(targetDir).filePath(outName);

    QFile outFile(outPath);
    if (!outFile.open(QIODevice::WriteOnly | QIODevice::Text)) return;

    QTextStream out(&outFile);
    out.setEncoding(QStringConverter::Utf8);

    out << "# 关键字搜索导出结果 - " << ts << "\n\n";
    out << "**项目路径**: `" << rootPath << "`\n\n";
    out << "**文件总数**: " << filePaths.size() << "\n\n";

    for (const QString& fp : filePaths) {
        QString relPath = rootPath.isEmpty() ? fp : QDir(rootPath).relativeFilePath(fp);
        QString lang = getFileLanguage(fp);

        out << "## 文件: `" << relPath << "`\n\n";
        out << "```" << lang << "\n";

        QFile inFile(fp);
        if (inFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
            out << inFile.readAll();
        }
        out << "\n```\n\n";
    }

    outFile.close();
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已保存: %1").arg(outName));
}

void KeywordSearchWidget::onMergeSelectedFiles() {
    auto selectedItems = m_resultList->selectedItems();
    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty() && isSupportedFile(p)) paths << p;
    }
    
    if (paths.isEmpty()) return;
    onMergeFiles(paths, m_pathEdit->text().trimmed());
}

void KeywordSearchWidget::onMergeCollectionFiles() {
    QStringList paths;
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        paths << m_collectionSidebar->item(i)->data(Qt::UserRole).toString();
    }
    if (paths.isEmpty()) return;
    onMergeFiles(paths, "", true);
}

void KeywordSearchWidget::onCollectionItemClicked(QListWidgetItem* item) {
}

void KeywordSearchWidget::showCollectionContextMenu(const QPoint& pos) {
    auto selectedItems = m_collectionSidebar->selectedItems();
    if (selectedItems.isEmpty()) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #252526; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #37373D; }");
    
    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并选中内容", [this](){
        QStringList paths;
        for (auto* item : m_collectionSidebar->selectedItems()) {
            paths << item->data(Qt::UserRole).toString();
        }
        onMergeFiles(paths, "", true);
    });

    menu.addAction(IconHelper::getIcon("close", "#E74C3C"), "取消收藏", [this](){
        for (auto* item : m_collectionSidebar->selectedItems()) {
            delete item;
        }
        saveCollection();
    });
    
    menu.exec(m_collectionSidebar->mapToGlobal(pos));
}

void KeywordSearchWidget::addCollectionItem(const QString& path) {
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        if (m_collectionSidebar->item(i)->data(Qt::UserRole).toString() == path) return;
    }

    QFileInfo fi(path);
    auto* item = new QListWidgetItem(IconHelper::getIcon("file", "#2ECC71"), fi.fileName());
    item->setData(Qt::UserRole, path);
    item->setToolTip(path);
    m_collectionSidebar->addItem(item);
    saveCollection();
}

void KeywordSearchWidget::loadCollection() {
    QSettings settings("RapidNotes", "KeywordSearchCollection");
    QStringList coll = settings.value("list").toStringList();
    for (const QString& path : std::as_const(coll)) {
        if (QFile::exists(path)) {
            QFileInfo fi(path);
            auto* item = new QListWidgetItem(IconHelper::getIcon("file", "#2ECC71"), fi.fileName());
            item->setData(Qt::UserRole, path);
            item->setToolTip(path);
            m_collectionSidebar->addItem(item);
        }
    }
}

void KeywordSearchWidget::saveCollection() {
    QStringList coll;
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        coll << m_collectionSidebar->item(i)->data(Qt::UserRole).toString();
    }
    QSettings settings("RapidNotes", "KeywordSearchCollection");
    settings.setValue("list", coll);
}

void KeywordSearchWidget::onSwapSearchReplace() {
    QString searchTxt = m_searchEdit->text();
    QString replaceTxt = m_replaceEdit->text();
    m_searchEdit->setText(replaceTxt);
    m_replaceEdit->setText(searchTxt);
}

void KeywordSearchWidget::addHistoryEntry(HistoryType type, const QString& text) {
    if (text.isEmpty()) return;
    QString key = "keywordList";
    if (type == Path) key = "pathList";
    else if (type == Replace) key = "replaceList";

    QSettings settings("RapidNotes", "KeywordSearchHistory");
    QStringList history = settings.value(key).toStringList();
    history.removeAll(text);
    history.prepend(text);
    while (history.size() > 10) history.removeLast();
    settings.setValue(key, history);
}

void KeywordSearchWidget::onShowHistory() {
    auto* edit = qobject_cast<ClickableLineEdit*>(sender());
    if (!edit) return;

    KeywordSearchHistoryPopup::Type type = KeywordSearchHistoryPopup::Keyword;
    if (edit == m_pathEdit) type = KeywordSearchHistoryPopup::Path;
    else if (edit == m_replaceEdit) type = KeywordSearchHistoryPopup::Replace;
    
    auto* popup = new KeywordSearchHistoryPopup(this, edit, type);
    popup->setAttribute(Qt::WA_DeleteOnClose);
    popup->showAnimated();
}

// ----------------------------------------------------------------------------
// KeywordSearchWindow 实现
// ----------------------------------------------------------------------------
KeywordSearchWindow::KeywordSearchWindow(QWidget* parent) : FramelessDialog("查找关键字", parent) {
    setObjectName("KeywordSearchWindow");
    loadWindowSettings();
    resize(1200, 700);
    m_searchWidget = new KeywordSearchWidget(m_contentArea);
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->addWidget(m_searchWidget);
    m_resizeHandle = new ResizeHandle(this, this);
    m_resizeHandle->raise();
}

KeywordSearchWindow::~KeywordSearchWindow() {
}

void KeywordSearchWindow::hideEvent(QHideEvent* event) {
    FramelessDialog::hideEvent(event);
}

void KeywordSearchWindow::resizeEvent(QResizeEvent* event) {
    FramelessDialog::resizeEvent(event);
    if (m_resizeHandle) {
        m_resizeHandle->move(width() - 20, height() - 20);
    }
}

#include "KeywordSearchWindow.moc"
```

## 文件: `src/ui/KeywordSearchWindow.h`

```cpp
#ifndef KEYWORDSEARCHWINDOW_H
#define KEYWORDSEARCHWINDOW_H

#include "FramelessDialog.h"
#include "ClickableLineEdit.h"
#include "ResizeHandle.h"
#include <QLineEdit>
#include <QPushButton>
#include <QCheckBox>
#include <QTextBrowser>
#include <QProgressBar>
#include <QLabel>
#include <QListWidget>
#include <QSplitter>

class KeywordSidebarListWidget;

/**
 * @brief 收藏侧边栏列表 (支持拖拽和多选) - 复刻自 FileSearchWindow
 */
class KeywordCollectionListWidget : public QListWidget {
    Q_OBJECT
public:
    explicit KeywordCollectionListWidget(QWidget* parent = nullptr);
signals:
    void filesDropped(const QStringList& paths);
protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
};

/**
 * @brief 关键字搜索核心组件
 */
class KeywordSearchWidget : public QWidget {
    Q_OBJECT
public:
    explicit KeywordSearchWidget(QWidget* parent = nullptr);
    ~KeywordSearchWidget();

private slots:
    void onBrowseFolder();
    void onSidebarItemClicked(QListWidgetItem* item);
    void showSidebarContextMenu(const QPoint& pos);
    void addFavorite(const QString& path);
    void onSearch();
    void onReplace();
    void onUndo();
    void onClearLog();
    void onShowHistory();
    void onSwapSearchReplace();
    void updateShortcuts();

    // 结果列表相关 slots
    void showResultContextMenu(const QPoint& pos);
    void onEditFile();
    void onMergeSelectedFiles();
    void onMergeCollectionFiles();
    void copySelectedPaths();
    void copySelectedFiles();

    // 收藏相关
    void onCollectionItemClicked(QListWidgetItem* item);
    void showCollectionContextMenu(const QPoint& pos);
    void addCollectionItem(const QString& path);

private:
    void initUI();
    void setupStyles();
    void loadFavorites();
    void saveFavorites();
    void loadCollection();
    void saveCollection();
    void onMergeFiles(const QStringList& filePaths, const QString& rootPath, bool useCombineDir = false);
    
    // 历史记录管理
    enum HistoryType { Path, Keyword, Replace };
    void addHistoryEntry(HistoryType type, const QString& text);
    bool isTextFile(const QString& filePath);

    QListWidget* m_sidebar;
    KeywordCollectionListWidget* m_collectionSidebar;
    QAction* m_actionSearch = nullptr;
    QAction* m_actionReplace = nullptr;
    QAction* m_actionUndo = nullptr;
    QAction* m_actionSwap = nullptr;
    QAction* m_actionCopyPaths = nullptr;
    QAction* m_actionCopyFiles = nullptr;
    QAction* m_actionSelectAll = nullptr;

    ClickableLineEdit* m_pathEdit;
    QLineEdit* m_filterEdit;
    ClickableLineEdit* m_searchEdit;
    ClickableLineEdit* m_replaceEdit;
    QCheckBox* m_caseCheck;
    QListWidget* m_resultList;
    QProgressBar* m_progressBar;
    QLabel* m_statusLabel;

    QString m_lastBackupPath;
    QStringList m_ignoreDirs;

    struct MatchData {
        QString path;
        int count;
    };
    QList<MatchData> m_resultsData;
};

/**
 * @brief 关键字搜索窗口：封装了 KeywordSearchWidget
 */
class KeywordSearchWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit KeywordSearchWindow(QWidget* parent = nullptr);
    ~KeywordSearchWindow();

protected:
    void hideEvent(QHideEvent* event) override;
    void resizeEvent(QResizeEvent* event) override;

private:
    KeywordSearchWidget* m_searchWidget;
    ResizeHandle* m_resizeHandle;
};

#endif // KEYWORDSEARCHWINDOW_H
```

## 文件: `src/main.cpp`

```cpp
#include <QSettings>
#include <QApplication>
#include <QThread>
#include <QFile>
#include <QToolTip>
#include <QCursor>
#include <QMessageBox>
#include <QCoreApplication>
#include <QDir>
#include <QDebug>
#include <QDateTime>
#include <QFileInfo>
#include <QBuffer>
#include <QUrl>
#include <QTimer>
#include <QLocalServer>
#include <QLocalSocket>
#include <QPointer>
#include <QRegularExpression>
#include <QKeyEvent>
#include <QLineEdit>
#include <QTextEdit>
#include <QPlainTextEdit>
#include <QTextCursor>
#include <QTextDocument>
#include <functional>
#include <utility>
#include "core/DatabaseManager.h"
#include "core/HotkeyManager.h"
#include "core/ClipboardMonitor.h"
#include "core/OCRManager.h"
#include "ui/MainWindow.h"
#include "ui/FloatingBall.h"
#include "ui/QuickWindow.h"
#include "ui/SystemTray.h"
#include "ui/Toolbox.h"

#include <QAbstractItemView>
#include <QHelpEvent>
#include <QModelIndex>

/**
 * @brief 全局 ToolTip 拦截器
 * [IMPORTANT] 本项目杜绝采用原生 QToolTip。
 * 拦截所有 QEvent::ToolTip 事件，并将其转发至自定义的 ToolTipOverlay。
 * 支持普通 Widget 的 toolTip() 属性，以及 QAbstractItemView 的 Item-level (ToolTipRole) 提示。
 */
/**
 * @brief 全局输入框按键拦截器
 * [CRITICAL] 核心交互增强：
 * 1. 单行输入框 (QLineEdit)：重定义上下键为“直接跳到开头/结尾”。
 * 2. 多行编辑器 (QTextEdit/QPlainTextEdit)：采用“边缘触发”逻辑。
 *    - 如果在第一行按“上”，跳至全文开头；如果在最后一行按“下”，跳至全文末尾。
 *    - 其它情况保持原生行间移动行为，不干扰正常编辑。
 */
class GlobalInputKeyFilter : public QObject {
public:
    explicit GlobalInputKeyFilter(QObject* parent = nullptr) : QObject(parent) {}
protected:
    bool eventFilter(QObject* watched, QEvent* event) override {
        if (event->type() == QEvent::KeyPress) {
            QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
            int key = keyEvent->key();

            // 1. 处理单行输入框 (QLineEdit)
            if (QLineEdit* lineEdit = qobject_cast<QLineEdit*>(watched)) {
                if (key == Qt::Key_Up) {
                    lineEdit->home(false);
                    return true;
                } else if (key == Qt::Key_Down) {
                    lineEdit->end(false);
                    return true;
                }
            }
            
            // 2. 处理多行编辑器 (QTextEdit)
            if (QTextEdit* textEdit = qobject_cast<QTextEdit*>(watched)) {
                if (key == Qt::Key_Up) {
                    // 如果当前已经在第一段，则触发“跳到开头”
                    if (textEdit->textCursor().blockNumber() == 0) {
                        textEdit->moveCursor(QTextCursor::Start);
                        return true;
                    }
                } else if (key == Qt::Key_Down) {
                    // 如果当前已经在最后一段，则触发“跳到结尾”
                    if (textEdit->textCursor().blockNumber() == textEdit->document()->blockCount() - 1) {
                        textEdit->moveCursor(QTextCursor::End);
                        return true;
                    }
                }
            }

            // 3. 处理多行编辑器 (QPlainTextEdit)
            if (QPlainTextEdit* plainTextEdit = qobject_cast<QPlainTextEdit*>(watched)) {
                if (key == Qt::Key_Up) {
                    if (plainTextEdit->textCursor().blockNumber() == 0) {
                        plainTextEdit->moveCursor(QTextCursor::Start);
                        return true;
                    }
                } else if (key == Qt::Key_Down) {
                    if (plainTextEdit->textCursor().blockNumber() == plainTextEdit->document()->blockCount() - 1) {
                        plainTextEdit->moveCursor(QTextCursor::End);
                        return true;
                    }
                }
            }
        }
        return QObject::eventFilter(watched, event);
    }
};

class GlobalToolTipFilter : public QObject {
public:
    explicit GlobalToolTipFilter(QObject* parent = nullptr) : QObject(parent) {}
protected:
    bool eventFilter(QObject* watched, QEvent* event) override {
        if (event->type() == QEvent::ToolTip) {
            QHelpEvent* helpEvent = static_cast<QHelpEvent*>(event);
            QWidget* widget = qobject_cast<QWidget*>(watched);
            if (widget) {
                QString tip = widget->toolTip();
                
                // [CRITICAL] 针对列表/树形视图的深度拦截逻辑
                // QAbstractItemView 的 ToolTip 事件通常发送给其 viewport() 部件。
                QAbstractItemView* view = qobject_cast<QAbstractItemView*>(widget);
                if (!view && widget->parentWidget()) {
                    view = qobject_cast<QAbstractItemView*>(widget->parentWidget());
                }

                if (view) {
                    QModelIndex index = view->indexAt(view->mapFromGlobal(helpEvent->globalPos()));
                    if (index.isValid()) {
                        tip = index.data(Qt::ToolTipRole).toString();
                    }
                }

                if (!tip.isEmpty()) {
                    ToolTipOverlay::instance()->showText(helpEvent->globalPos(), tip, 0);
                    return true; // 拦截默认 ToolTip
                }
            }
        } else if (event->type() == QEvent::Leave || event->type() == QEvent::MouseButtonPress || 
                   event->type() == QEvent::WindowDeactivate || event->type() == QEvent::FocusOut) {
            ToolTipOverlay::hideTip();
        }
        return QObject::eventFilter(watched, event);
    }
};

#include "ui/TimePasteWindow.h"
#include "ui/PasswordGeneratorWindow.h"
#include "ui/OCRWindow.h"
#include "ui/OCRResultWindow.h"
#include "ui/KeywordSearchWindow.h"
#include "ui/FileStorageWindow.h"
#include "ui/TagManagerWindow.h"
#include "ui/FileSearchWindow.h"
#include "ui/ColorPickerWindow.h"
#include "ui/PixelRulerOverlay.h"
#include "ui/HelpWindow.h"
#include "ui/FireworksOverlay.h"
#include "ui/ScreenshotTool.h"
#include "ui/SettingsWindow.h"
#include "ui/StringUtils.h"
#include "core/KeyboardHook.h"
#include "core/MessageCaptureHandler.h"
#include "core/FileCryptoHelper.h"

#ifdef Q_OS_WIN
#include <windows.h>
#include <psapi.h>
#endif

#ifdef Q_OS_WIN
/**
 * @brief 判定当前活跃窗口是否为浏览器
 */
static bool isBrowserActive() {
    HWND hwnd = GetForegroundWindow();
    if (!hwnd) return false;

    DWORD pid;
    GetWindowThreadProcessId(hwnd, &pid);
    
    HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (!process) return false;

    wchar_t buffer[MAX_PATH];
    // 使用 GetModuleFileNameExW 获取完整路径
    if (GetModuleFileNameExW(process, NULL, buffer, MAX_PATH)) {
        QString exePath = QString::fromWCharArray(buffer).toLower();
        QString exeName = QFileInfo(exePath).fileName();
        qDebug() << "[Acquire] 当前活跃窗口进程:" << exeName;

        static const QStringList browserExes = {
            "chrome.exe", "msedge.exe", "firefox.exe", "brave.exe", 
            "opera.exe", "iexplore.exe", "vivaldi.exe", "safari.exe"
        };
        
        CloseHandle(process);
        return browserExes.contains(exeName);
    }

    CloseHandle(process);
    return false;
}
#endif

int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    // [CRITICAL] 安装全局过滤器
    a.installEventFilter(new GlobalToolTipFilter(&a));
    a.installEventFilter(new GlobalInputKeyFilter(&a));
    
    a.setApplicationName("RapidNotes");
    a.setOrganizationName("RapidDev");
    a.setQuitOnLastWindowClosed(false);

    // 单实例运行保护
    QString serverName = "RapidNotes_SingleInstance_Server";
    QLocalSocket socket;
    socket.connectToServer(serverName);
    if (socket.waitForConnected(500)) {
        // 如果已经运行，发送 SHOW 信号并退出当前进程
        socket.write("SHOW");
        socket.waitForBytesWritten(1000);
        return 0;
    }
    QLocalServer::removeServer(serverName);
    QLocalServer server;
    if (!server.listen(serverName)) {
        qWarning() << "无法启动单实例服务器";
    }

    // 加载全局样式表
    QFile styleFile(":/qss/dark_style.qss");
    if (styleFile.open(QFile::ReadOnly)) {
        a.setStyleSheet(styleFile.readAll());
    }

    // 1. 初始化数据库 (外壳文件名改为 inspiration.db)
    QString dbPath = QCoreApplication::applicationDirPath() + "/inspiration.db";
    qDebug() << "[Main] 数据库外壳路径:" << dbPath;

    if (!DatabaseManager::instance().init(dbPath)) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            "<b style='color: #e74c3c;'>❌ 启动失败</b><br>无法初始化数据库！请检查写入权限或 SQLite 驱动。", 5000, QColor("#e74c3c"));
        QThread::msleep(3000); // 留出时间显示提示
        return -1;
    }


    // 1.1 试用期与使用次数检查
    QVariantMap trialStatus = DatabaseManager::instance().getTrialStatus();
    if (trialStatus["expired"].toBool() || trialStatus["usage_limit_reached"].toBool()) {
        QString reason = trialStatus["expired"].toBool() ? "您的 30 天试用期已结束。" : "您的 100 次使用额度已用完。";
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            QString("<b style='color: #f39c12;'>⚠️ 试用结束</b><br>%1<br>感谢您体验 RapidNotes！如需继续使用，请联系开发者。").arg(reason), 6000, QColor("#f39c12"));
        
        QThread::msleep(4000);
        DatabaseManager::instance().closeAndPack();
        return 0;
    }

    // 2. 初始化核心 UI 组件 (极速窗口与悬浮球)
    QuickWindow* quickWin = new QuickWindow();
    quickWin->setObjectName("QuickWindow");
    quickWin->showAuto();

    // 3. 初始化特效层与悬浮球
    FireworksOverlay::instance(); 
    FloatingBall* ball = new FloatingBall();
    ball->setObjectName("FloatingBall");

    a.setWindowIcon(FloatingBall::generateBallIcon());

    // 4. 子窗口延迟加载策略
    MainWindow* mainWin = nullptr;
    Toolbox* toolbox = nullptr;
    TimePasteWindow* timePasteWin = nullptr;
    PasswordGeneratorWindow* passwordGenWin = nullptr;
    OCRWindow* ocrWin = nullptr;
    KeywordSearchWindow* keywordSearchWin = nullptr;
    TagManagerWindow* tagMgrWin = nullptr;
    FileStorageWindow* fileStorageWin = nullptr;
    FileSearchWindow* fileSearchWin = nullptr;
    ColorPickerWindow* colorPickerWin = nullptr;
    HelpWindow* helpWin = nullptr;

    auto toggleWindow = [](QWidget* win, QWidget* parentWin = nullptr) {
        if (!win) return;
        
        // [CRITICAL] 修复首次点击无法激活窗口的 Bug。
        // 原因：如果窗口在构造函数中因应用置顶设置而触发了内部 show()，
        // 那么在此处 isVisible() 会返回 true，导致第一次点击反而执行了 hide()。
        // 我们通过 hasBeenToggled 属性确保第一次点击总是执行“显示”逻辑。
        bool hasBeenToggled = win->property("hasBeenToggled").toBool();
        
        if (win->isVisible() && hasBeenToggled) {
            win->hide();
        } else {
            if (parentWin && win->objectName() != "ToolboxLauncher") {
                if (parentWin->objectName() == "QuickWindow") {
                    win->move(parentWin->x() - win->width() - 10, parentWin->y());
                } else {
                    win->move(parentWin->geometry().center() - win->rect().center());
                }
            }
            win->show();
            win->raise();
            win->activateWindow();
            win->setProperty("hasBeenToggled", true);
        }
    };

    auto checkLockAndExecute = [&](std::function<void()> func) {
        if (quickWin->isLocked()) {
            quickWin->showAuto();
            return;
        }
        func();
    };

    std::function<void()> showMainWindow;
    std::function<void()> startScreenshot;
    std::function<void()> startImmediateOCR;

    auto getToolbox = [&]() -> Toolbox* {
        if (!toolbox) {
            toolbox = new Toolbox();
            toolbox->setObjectName("ToolboxLauncher");
            
            QObject::connect(toolbox, &Toolbox::showTimePasteRequested, [=, &timePasteWin](){
                if (!timePasteWin) {
                    timePasteWin = new TimePasteWindow();
                    timePasteWin->setObjectName("TimePasteWindow");
                }
                toggleWindow(timePasteWin);
            });
            QObject::connect(toolbox, &Toolbox::showPasswordGeneratorRequested, [=, &passwordGenWin](){
                if (!passwordGenWin) {
                    passwordGenWin = new PasswordGeneratorWindow();
                    passwordGenWin->setObjectName("PasswordGeneratorWindow");
                }
                toggleWindow(passwordGenWin);
            });
            QObject::connect(toolbox, &Toolbox::showOCRRequested, [=, &ocrWin](){
                if (!ocrWin) {
                    ocrWin = new OCRWindow();
                    ocrWin->setObjectName("OCRWindow");
                }
                toggleWindow(ocrWin);
            });
            QObject::connect(toolbox, &Toolbox::showKeywordSearchRequested, [=, &keywordSearchWin](){
                if (!keywordSearchWin) {
                    keywordSearchWin = new KeywordSearchWindow();
                    keywordSearchWin->setObjectName("KeywordSearchWindow");
                }
                toggleWindow(keywordSearchWin);
            });
            QObject::connect(toolbox, &Toolbox::showTagManagerRequested, [=, &tagMgrWin](){
                if (!tagMgrWin) {
                    tagMgrWin = new TagManagerWindow();
                    tagMgrWin->setObjectName("TagManagerWindow");
                }
                tagMgrWin->refreshData();
                toggleWindow(tagMgrWin);
            });
            QObject::connect(toolbox, &Toolbox::showFileStorageRequested, [=, &fileStorageWin, &mainWin, &quickWin](){
                if (!fileStorageWin) {
                    fileStorageWin = new FileStorageWindow();
                    fileStorageWin->setObjectName("FileStorageWindow");
                }
                int catId = -1;
                if (quickWin->isVisible()) catId = quickWin->getCurrentCategoryId();
                else if (mainWin && mainWin->isVisible()) catId = mainWin->getCurrentCategoryId();
                fileStorageWin->setCurrentCategory(catId);
                toggleWindow(fileStorageWin);
            });
            QObject::connect(toolbox, &Toolbox::showFileSearchRequested, [=, &fileSearchWin](){
                if (!fileSearchWin) {
                    fileSearchWin = new FileSearchWindow();
                    fileSearchWin->setObjectName("FileSearchWindow");
                }
                toggleWindow(fileSearchWin);
            });
            QObject::connect(toolbox, &Toolbox::showColorPickerRequested, [=, &colorPickerWin](){
                if (!colorPickerWin) {
                    colorPickerWin = new ColorPickerWindow();
                    colorPickerWin->setObjectName("ColorPickerWindow");
                }
                toggleWindow(colorPickerWin);
            });
            QObject::connect(toolbox, &Toolbox::startColorPickerRequested, [=, &colorPickerWin](){
                if (!colorPickerWin) {
                    colorPickerWin = new ColorPickerWindow();
                    colorPickerWin->setObjectName("ColorPickerWindow");
                }
                colorPickerWin->startScreenPicker();
            });
            QObject::connect(toolbox, &Toolbox::showPixelRulerRequested, [](){
                auto* ruler = new PixelRulerOverlay(nullptr);
                ruler->setAttribute(Qt::WA_DeleteOnClose);
                ruler->show();
            });
            QObject::connect(toolbox, &Toolbox::showHelpRequested, [=, &helpWin](){
                if (!helpWin) {
                    helpWin = new HelpWindow();
                    helpWin->setObjectName("HelpWindow");
                }
                toggleWindow(helpWin);
            });

            QObject::connect(toolbox, &Toolbox::showMainWindowRequested, [=](){ showMainWindow(); });
            QObject::connect(toolbox, &Toolbox::showQuickWindowRequested, [=](){ quickWin->showAuto(); });
            QObject::connect(toolbox, &Toolbox::screenshotRequested, [=](){ startScreenshot(); });
            QObject::connect(toolbox, &Toolbox::startOCRRequested, [=](){ startImmediateOCR(); });
        }
        return toolbox;
    };

    showMainWindow = [=, &mainWin, &checkLockAndExecute, &getToolbox, &fileStorageWin, &quickWin]() {
        checkLockAndExecute([=, &mainWin, &getToolbox, &fileStorageWin, &quickWin](){
            if (!mainWin) {
                mainWin = new MainWindow();
                QObject::connect(mainWin, &MainWindow::toolboxRequested, [=](){ toggleWindow(getToolbox(), mainWin); });
                QObject::connect(mainWin, &MainWindow::fileStorageRequested, [=, &mainWin, &fileStorageWin](){
                    if (!fileStorageWin) {
                        fileStorageWin = new FileStorageWindow();
                        fileStorageWin->setObjectName("FileStorageWindow");
                    }
                    fileStorageWin->setCurrentCategory(mainWin->getCurrentCategoryId());
                    toggleWindow(fileStorageWin, mainWin);
                });
            }
            mainWin->showNormal();
            mainWin->activateWindow();
            mainWin->raise();
        });
    };

    startImmediateOCR = [=, &checkLockAndExecute]() {
        static bool isScreenshotActive = false;
        if (isScreenshotActive) return;

        checkLockAndExecute([&](){
            isScreenshotActive = true;
            auto* tool = new ScreenshotTool();
            tool->setAttribute(Qt::WA_DeleteOnClose);
            tool->setImmediateOCRMode(true);
            
            QObject::connect(tool, &ScreenshotTool::destroyed, [=](){
                isScreenshotActive = false;
            });
            
            QObject::connect(tool, &ScreenshotTool::screenshotCaptured, [=](const QImage& img, bool isOcrRequest){
                QSettings settings("RapidNotes", "OCR");
                bool autoCopy = settings.value("autoCopy", false).toBool();
                
                // 1. 先存入数据库，确保产生历史记录
                QByteArray ba;
                QBuffer buffer(&ba);
                buffer.open(QIODevice::WriteOnly);
                img.save(&buffer, "PNG");
                QString title = "[截图取文] " + QDateTime::currentDateTime().toString("MMdd_HHmm");
                // [CRITICAL] 明确指定类型为 ocr_text，以便在 QuickWindow 列表中显示专用蓝色扫描图标
                int noteId = DatabaseManager::instance().addNote(title, "[正在识别文本...]", QStringList() << "截屏" << "截图取文", "", -1, "ocr_text", ba);

                // 2. 使用 noteId 进行识别，这样全局监听器会自动更新数据库内容
                auto* resWin = new OCRResultWindow(img, noteId);
                QObject::connect(&OCRManager::instance(), &OCRManager::recognitionFinished, 
                                 resWin, &OCRResultWindow::setRecognizedText);
                
                if (autoCopy) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "⏳ 正在识别文字...");
                } else {
                    resWin->show();
                }
                OCRManager::instance().recognizeAsync(img, noteId);
            });
            tool->show();
        });
    };

    startScreenshot = [=, &checkLockAndExecute]() {
        static bool isNormalScreenshotActive = false;
        if (isNormalScreenshotActive) return;

        checkLockAndExecute([&](){
            isNormalScreenshotActive = true;
            auto* tool = new ScreenshotTool();
            tool->setAttribute(Qt::WA_DeleteOnClose);
            QObject::connect(tool, &ScreenshotTool::destroyed, [=](){ isNormalScreenshotActive = false; });
            QObject::connect(tool, &ScreenshotTool::screenshotCaptured, [=](const QImage& img, bool isOcrRequest){
                if (!isOcrRequest) QApplication::clipboard()->setImage(img);
                
                QByteArray ba;
                QBuffer buffer(&ba);
                buffer.open(QIODevice::WriteOnly);
                img.save(&buffer, "PNG");
                
                QString title = (isOcrRequest ? "[截图取文] " : "[截屏] ") + QDateTime::currentDateTime().toString("MMdd_HHmm");
                QStringList tags = isOcrRequest ? (QStringList() << "截屏" << "截图取文") : (QStringList() << "截屏");
                int noteId = DatabaseManager::instance().addNote(title, "[正在进行文字识别...]", tags, "", -1, "image", ba);
                
                if (isOcrRequest) {
                    QSettings settings("RapidNotes", "OCR");
                    bool autoCopy = settings.value("autoCopy", false).toBool();
                    auto* resWin = new OCRResultWindow(img, noteId);
                    QObject::connect(&OCRManager::instance(), &OCRManager::recognitionFinished, 
                                     resWin, &OCRResultWindow::setRecognizedText);
                    
                    if (autoCopy) {
                        ToolTipOverlay::instance()->showText(QCursor::pos(), "⏳ 正在识别文字...");
                    } else {
                        resWin->show();
                    }
                }
                
                OCRManager::instance().recognizeAsync(img, noteId);
            });
            tool->show();
        });
    };

    QObject::connect(quickWin, &QuickWindow::toolboxRequested, [=, &getToolbox](){ toggleWindow(getToolbox(), quickWin); });
    QObject::connect(quickWin, &QuickWindow::toggleMainWindowRequested, [=, &showMainWindow](){ showMainWindow(); });

    // 5. 开启全局键盘钩子 (支持快捷键重映射)
    KeyboardHook::instance().start();
    MessageCaptureHandler::instance().init();

    // 6. 注册全局热键 (从配置加载)
    HotkeyManager::instance().reapplyHotkeys();
    
    QObject::connect(&HotkeyManager::instance(), &HotkeyManager::hotkeyPressed, [&](int id){
        if (id == 1) {
            if (quickWin->isVisible() && quickWin->isActiveWindow()) {
                quickWin->hide();
            } else {
                quickWin->showAuto();
            }
        } else if (id == 2) {
            checkLockAndExecute([&](){
                // 收藏最后一条灵感
                auto notes = DatabaseManager::instance().searchNotes("");
                if (!notes.isEmpty()) {
                    int lastId = notes.first()["id"].toInt();
                    DatabaseManager::instance().updateNoteState(lastId, "is_favorite", 1);
                    qDebug() << "[Main] 已收藏最新灵感 ID:" << lastId;
                }
            });
        } else if (id == 3) {
            startScreenshot();
        } else if (id == 4) {
            checkLockAndExecute([&](){
                // 全局采集：仅限浏览器 -> 清空剪贴板 -> 模拟 Ctrl+C -> 获取剪贴板 -> 智能拆分 -> 入库
#ifdef Q_OS_WIN
                if (!isBrowserActive()) {
                    qDebug() << "[Acquire] 当前非浏览器窗口，忽略采集指令。";
                    return;
                }

                // 1. 务必清空剪贴板，防止残留
                QApplication::clipboard()->clear();
                // 屏蔽监听器的下一次捕获，防止重复入库
                ClipboardMonitor::instance().skipNext();

                // 2. 模拟 Ctrl+C
                // 关键修复：由于热键是 Ctrl+Shift+S，此时物理 Shift 和 S 键很可能仍被按下。
                // 如果不显式释放 Shift，Ctrl+C 会变成 Ctrl+Shift+C (在浏览器中通常是打开开发者工具而非复制)。
                keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
                keybd_event('S', 0, KEYEVENTF_KEYUP, 0);

                keybd_event(VK_CONTROL, 0, 0, 0);
                keybd_event('C', 0, 0, 0);
                keybd_event('C', 0, KEYEVENTF_KEYUP, 0);
                // 这里不要立即抬起 Control，因为抬起太快可能导致目标窗口还没来得及接收到组合键
#endif
                // 增加延迟至 300ms，为浏览器处理复制请求提供更充裕的时间
                QTimer::singleShot(300, [=](){
                    // 此时再彻底释放 Ctrl (可选，防止干扰后续操作)
#ifdef Q_OS_WIN
                    keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
#endif
                    QString text = QApplication::clipboard()->text();
                    if (text.trimmed().isEmpty()) {
                        qWarning() << "[Acquire] 剪贴板为空，采集失败。";
                        ToolTipOverlay::instance()->showText(QCursor::pos(), "✖ 未能采集到内容，请确保已选中浏览器中的文本");
                        return;
                    }

                    auto pairs = StringUtils::smartSplitPairs(text);
                    if (pairs.isEmpty()) return;

                    int catId = -1;
                    if (quickWin && quickWin->isVisible()) {
                        catId = quickWin->getCurrentCategoryId();
                    }

                    for (const auto& pair : std::as_const(pairs)) {
                        DatabaseManager::instance().addNoteAsync(pair.first, pair.second, {"采集"}, "", catId, "text");
                    }
                    
                    // 成功反馈 (ToolTip)
                    QString feedback = pairs.size() > 1 
                        ? QString("✔ 已批量采集 %1 条灵感").arg(pairs.size())
                        : "✔ 已采集灵感: " + (pairs[0].first.length() > 20 ? pairs[0].first.left(17) + "..." : pairs[0].first);

                    ToolTipOverlay::instance()->showText(QCursor::pos(), feedback);
                });
            });
        } else if (id == 5) {
            // 全局锁定
            quickWin->doGlobalLock();
        } else if (id == 6) {
            // 截图取文
            startImmediateOCR();
        }
    });

    // 监听 OCR 完成信号并更新笔记内容
    // 必须指定 context 对象 (&DatabaseManager::instance()) 确保回调在正确的线程执行
    QObject::connect(&OCRManager::instance(), &OCRManager::recognitionFinished, &DatabaseManager::instance(), [](const QString& text, int noteId){
        if (noteId > 0) {
            DatabaseManager::instance().updateNoteState(noteId, "content", text);
        }
    });

    // 7. 系统托盘
    QObject::connect(&server, &QLocalServer::newConnection, [&](){
        QLocalSocket* conn = server.nextPendingConnection();
        if (conn->waitForReadyRead(500)) {
            QByteArray data = conn->readAll();
            if (data == "SHOW") {
                quickWin->showAuto();
            }
            conn->disconnectFromServer();
        }
    });

    SystemTray* tray = new SystemTray(&a);
    QObject::connect(tray, &SystemTray::showMainWindow, showMainWindow);
    QObject::connect(tray, &SystemTray::showQuickWindow, quickWin, &QuickWindow::showAuto);
    
    // 初始化托盘菜单中悬浮球的状态
    tray->updateBallAction(ball->isVisible());
    QObject::connect(tray, &SystemTray::toggleFloatingBall, [=](bool visible){
        if (visible) ball->show();
        else ball->hide();
        ball->savePosition(); // 立即记忆状态
        tray->updateBallAction(visible);
    });

    QObject::connect(tray, &SystemTray::showHelpRequested, [=, &helpWin](){
        checkLockAndExecute([=, &helpWin](){
            if (!helpWin) {
                helpWin = new HelpWindow();
                helpWin->setObjectName("HelpWindow");
            }
            toggleWindow(helpWin);
        });
    });
    QObject::connect(tray, &SystemTray::showSettings, [=](){
        checkLockAndExecute([=](){
            static QPointer<SettingsWindow> settingsWin;
            if (settingsWin) {
                settingsWin->showNormal();
                settingsWin->raise();
                settingsWin->activateWindow();
                return;
            }

            settingsWin = new SettingsWindow();
            settingsWin->setObjectName("SettingsWindow");
            settingsWin->setAttribute(Qt::WA_DeleteOnClose);
            
            // 核心修复：先计算位置并移动，确保窗口 show() 的那一刻就在正确的位置，杜绝闪烁
            QScreen *screen = QGuiApplication::primaryScreen();
            if (screen) {
                QRect screenGeom = screen->geometry();
                settingsWin->move(screenGeom.center() - settingsWin->rect().center());
            }
            
            settingsWin->show();
            settingsWin->raise();
            settingsWin->activateWindow();
        });
    });
    QObject::connect(tray, &SystemTray::quitApp, &a, &QApplication::quit);
    tray->show();

    QObject::connect(ball, &FloatingBall::doubleClicked, [&](){
        quickWin->showAuto();
    });
    QObject::connect(ball, &FloatingBall::requestMainWindow, showMainWindow);
    QObject::connect(ball, &FloatingBall::requestQuickWindow, quickWin, &QuickWindow::showAuto);
    QObject::connect(ball, &FloatingBall::requestToolbox, [=, &getToolbox](){
        checkLockAndExecute([=, &getToolbox](){ toggleWindow(getToolbox()); });
    });
    QObject::connect(ball, &FloatingBall::requestNewIdea, [=](){
        checkLockAndExecute([=](){
            NoteEditWindow* win = new NoteEditWindow();
            QObject::connect(win, &NoteEditWindow::noteSaved, quickWin, &QuickWindow::refreshData);
            win->show();
        });
    });

    // 8. 监听剪贴板 (智能标题与自动分类)
    QObject::connect(&ClipboardMonitor::instance(), &ClipboardMonitor::clipboardChanged, [=](){
        // 触发烟花爆炸特效
        FireworksOverlay::instance()->explode(QCursor::pos());
    });

    QObject::connect(&ClipboardMonitor::instance(), &ClipboardMonitor::newContentDetected, 
        [=](const QString& content, const QString& type, const QByteArray& data,
            const QString& sourceApp, const QString& sourceTitle){
        qDebug() << "[Main] 接收到剪贴板信号:" << type << "来自:" << sourceApp;
        
        QString title;
        QString finalContent = content;
        QString finalType = type;

        if (type == "image") {
            title = "[图片] " + QDateTime::currentDateTime().toString("MMdd_HHmm");
        } else if (type == "file") {
            QStringList files = content.split(";", Qt::SkipEmptyParts);
            if (!files.isEmpty()) {
                QFileInfo info(files.first());
                title = info.fileName();
                if (files.size() > 1) title += QString(" 等 %1 个文件").arg(files.size());
            } else {
                title = "[未知文件]";
            }
        } else {
            // 文本：取第一行
            QString firstLine = content.section('\n', 0, 0).trimmed();
            if (firstLine.isEmpty()) title = "无标题灵感";
            else {
                title = firstLine.left(40);
                if (firstLine.length() > 40) title += "...";
            }
        }

        // 自动归档逻辑
        int catId = -1;
        if (quickWin && quickWin->isAutoCategorizeEnabled()) {
            catId = quickWin->getCurrentCategoryId();
        }

        // 自动生成类型标签与类型修正 (解耦逻辑)
        QStringList tags;
        
        if (type == "text") {
            QString trimmed = content.trimmed();

            // 颜色码识别逻辑
            static QRegularExpression hexRegex("^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$");
            static QRegularExpression rgbRegex(R"(^(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})$)");

            QRegularExpressionMatch hexMatch = hexRegex.match(trimmed);
            bool isColor = false;
            if (hexMatch.hasMatch()) {
                if (!tags.contains("HEX")) tags << "HEX";
                isColor = true;
            } else {
                QRegularExpressionMatch rgbMatch = rgbRegex.match(trimmed);
                if (rgbMatch.hasMatch()) {
                    int r = rgbMatch.captured(1).toInt();
                    int g = rgbMatch.captured(2).toInt();
                    int b = rgbMatch.captured(3).toInt();
                    if (r <= 255 && g <= 255 && b <= 255) {
                        if (!tags.contains("RGB")) tags << "RGB";
                        isColor = true;
                    }
                }
            }

            if (isColor) {
                for (const QString& t : {"色码", "色值", "颜值", "颜色码"}) {
                    if (!tags.contains(t)) tags << t;
                }
            }

            // 恢复后的网址识别与域名提取逻辑
            if (trimmed.startsWith("http://") || trimmed.startsWith("https://") || trimmed.startsWith("www.")) {
                finalType = "link";
                tags << "链接" << "网址";

                // 提取二级域名作为标题和标签 (例如: https://www.google.com -> Google)
                QUrl url(trimmed.startsWith("www.") ? "http://" + trimmed : trimmed);
                QString host = url.host();
                if (host.startsWith("www.")) host = host.mid(4);
                QStringList hostParts = host.split('.');
                if (hostParts.size() >= 2) {
                    QString sld = hostParts[hostParts.size() - 2];
                    if (!sld.isEmpty()) {
                        sld[0] = sld[0].toUpper();
                        title = sld;
                        if (!tags.contains(sld)) tags << sld;
                    }
                }
            }
        }
        
        DatabaseManager::instance().addNoteAsync(title, finalContent, tags, "", catId, finalType, data, sourceApp, sourceTitle);
    });

    int result = a.exec();
    
    // 退出前合壳并加密数据库
    DatabaseManager::instance().closeAndPack();
    
    return result;
}
```

## 文件: `src/viewmodels/MainNoteViewModel.cpp`

```cpp
#include "MainNoteViewModel.h"
#include "../core/ServiceLocator.h"

#include "../core/DatabaseManager.h"
#include <algorithm>

MainNoteViewModel::MainNoteViewModel(QObject* parent) : QObject(parent) {}

void MainNoteViewModel::refreshData(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page, int pageSize, const QVariantMap& criteria) {
    m_currentFilterType = filterType;
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;

    auto notes = db->searchNotes(keyword, filterType, filterValue, page, pageSize, criteria);
    int totalCount = db->getNotesCount(keyword, filterType, filterValue, criteria);
    int totalPages = (totalCount + pageSize - 1) / pageSize;
    if (totalPages < 1) totalPages = 1;

    emit dataRefreshed(notes, totalCount, totalPages);
}

void MainNoteViewModel::deleteNotes(const QList<int>& ids, bool physical) {
    if (ids.isEmpty()) return;
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;

    if (physical || m_currentFilterType == "trash") {
        db->deleteNotesBatch(ids);
        emit statusMessageRequested(QString("✔ 已永久删除 %1 条数据").arg(ids.count()));
    } else {
        db->softDeleteNotes(ids);
        emit statusMessageRequested(QString("✔ 已移至回收站 %1 条数据").arg(ids.count()));
    }
}

void MainNoteViewModel::toggleFavorite(const QList<int>& ids) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->toggleNoteState(id, "is_favorite");
    }
}

void MainNoteViewModel::togglePin(const QList<int>& ids) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->toggleNoteState(id, "is_pinned");
    }
}

void MainNoteViewModel::setRating(const QList<int>& ids, int rating) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->updateNoteState(id, "rating", rating);
    }
}

void MainNoteViewModel::moveToCategory(const QList<int>& ids, int catId) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    db->moveNotesToCategory(ids, catId);
}
```

## 文件: `src/viewmodels/MainNoteViewModel.h`

```cpp
#ifndef MAINNOTEVIEWMODEL_H
#define MAINNOTEVIEWMODEL_H

#include <QObject>
#include <QVariantMap>
#include <QList>
#include <QString>
#include <QVariant>

class MainNoteViewModel : public QObject {
    Q_OBJECT
public:
    explicit MainNoteViewModel(QObject* parent = nullptr);

    void refreshData(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page, int pageSize, const QVariantMap& criteria);
    void deleteNotes(const QList<int>& ids, bool physical);
    void toggleFavorite(const QList<int>& ids);
    void togglePin(const QList<int>& ids);
    void setRating(const QList<int>& ids, int rating);
    void moveToCategory(const QList<int>& ids, int catId);

signals:
    void dataRefreshed(const QList<QVariantMap>& notes, int totalCount, int totalPages);
    void statusMessageRequested(const QString& message);

private:
    QString m_currentFilterType;
};

#endif // MAINNOTEVIEWMODEL_H
```

## 文件: `src/ui/MainWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "MainWindow.h"
#include "StringUtils.h"
#include "../core/DatabaseManager.h"
#include "../core/ClipboardMonitor.h"
#include "NoteDelegate.h"
#include "CategoryDelegate.h"
#include "IconHelper.h"
#include <QHBoxLayout>
#include <utility>
#include <QVBoxLayout>
#include <QHeaderView>
#include <QLabel>
#include <QSplitter>
#include <QMenu>
#include <QAction>
#include <QElapsedTimer>
#include <QToolTip>
#include <QCursor>
#include <QKeyEvent>
#include <QMouseEvent>
#include <QCloseEvent>
#include <QShortcut>
#include <QItemSelection>
#include <QActionGroup>
#include <QInputDialog>
#include <QColorDialog>
#include <QSet>
#include <QSettings>
#include <QRandomGenerator>
#include <QLineEdit>
#include <QTextEdit>
#include <QToolTip>
#include <QDateTime>
#include <QRegularExpression>
#include <QTimer>
#include <QGraphicsDropShadowEffect>
#include <QDesktopServices>
#include <QUrl>
#include <QApplication>
#include <QFile>
#include <QCoreApplication>
#include <QClipboard>
#include <QMimeData>
#include <QPlainTextEdit>
#include "CleanListView.h"
#include "NoteEditWindow.h"
#include "StringUtils.h"
#include "FramelessDialog.h"
#include "CategoryPasswordDialog.h"
#include "SettingsWindow.h"
#include "OCRResultWindow.h"
#include "../core/ShortcutManager.h"
#include "../core/OCRManager.h"
#include <functional>
#include <QVariant>
#include <QtGlobal>

#ifdef Q_OS_WIN
#include <windows.h>
#include <windowsx.h>
#define RESIZE_MARGIN 10
#endif

MainWindow::MainWindow(QWidget* parent) : QMainWindow(parent, Qt::FramelessWindowHint) {
    setWindowTitle("RapidNotes");
    resize(1200, 800);
    setMouseTracking(true);
    setAttribute(Qt::WA_Hover);
    initUI();

    m_searchTimer = new QTimer(this);
    m_searchTimer->setSingleShot(true);
    connect(m_searchTimer, &QTimer::timeout, this, &MainWindow::refreshData);

    m_refreshTimer = new QTimer(this);
    m_refreshTimer->setSingleShot(true);
    m_refreshTimer->setInterval(300);
    connect(m_refreshTimer, &QTimer::timeout, this, &MainWindow::refreshData);

    refreshData();

    // 【关键修改】区分两种信号
    // 1. 增量更新：添加新笔记时不刷新全表
    connect(&DatabaseManager::instance(), &DatabaseManager::noteAdded, this, &MainWindow::onNoteAdded);
    
    // 2. 全量刷新：修改、删除、分类变化（锁定状态）时才刷新全表 (通过 scheduleRefresh 节流)
    connect(&DatabaseManager::instance(), &DatabaseManager::noteUpdated, this, &MainWindow::scheduleRefresh);
    connect(&DatabaseManager::instance(), &DatabaseManager::categoriesChanged, this, &MainWindow::scheduleRefresh, Qt::QueuedConnection);

    restoreLayout(); // 恢复布局
    setupShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &MainWindow::updateShortcuts);
}

void MainWindow::initUI() {
    auto* centralWidget = new QWidget(this);
    centralWidget->setObjectName("CentralWidget");
    centralWidget->setMouseTracking(true);
    centralWidget->setAttribute(Qt::WA_StyledBackground, true);
    centralWidget->setStyleSheet("#CentralWidget { background-color: #1E1E1E; }");
    setCentralWidget(centralWidget);
    auto* mainLayout = new QVBoxLayout(centralWidget);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    // 1. HeaderBar
    m_header = new HeaderBar(this);
    connect(m_header, &HeaderBar::searchChanged, this, [this](const QString& text){
        m_currentKeyword = text;
        m_currentPage = 1;
        m_searchTimer->start(300);
    });
    connect(m_header, &HeaderBar::pageChanged, this, [this](int page){
        m_currentPage = page;
        refreshData();
    });
    connect(m_header, &HeaderBar::refreshRequested, this, &MainWindow::refreshData);
    connect(m_header, &HeaderBar::stayOnTopRequested, this, [this](bool checked){
        if (auto* win = window()) {
            if (win->isVisible()) {
#ifdef Q_OS_WIN
                HWND hwnd = (HWND)win->winId();
                SetWindowPos(hwnd, checked ? HWND_TOPMOST : HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
                Qt::WindowFlags f = win->windowFlags();
                if (checked) f |= Qt::WindowStaysOnTopHint;
                else f &= ~Qt::WindowStaysOnTopHint;
                win->setWindowFlags(f);
                win->show();
#endif
            }
        }
    });
    connect(m_header, &HeaderBar::filterRequested, this, [this](){
        bool visible = !m_filterWrapper->isVisible();
        m_filterWrapper->setVisible(visible);
        m_header->setFilterActive(visible);
        if (visible) {
            m_filterPanel->updateStats(m_currentKeyword, m_currentFilterType, m_currentFilterValue);
        }
    });
    connect(m_header, &HeaderBar::newNoteRequested, this, [this](){
        NoteEditWindow* win = new NoteEditWindow();
        connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
        win->show();
    });
    connect(m_header, &HeaderBar::toggleSidebar, this, [this](){
        m_sidebarContainer->setVisible(!m_sidebarContainer->isVisible());
    });
    connect(m_header, &HeaderBar::toolboxRequested, this, &MainWindow::toolboxRequested);
    connect(m_header, &HeaderBar::toolboxContextMenuRequested, this, &MainWindow::showToolboxMenu);
    connect(m_header, &HeaderBar::metadataToggled, this, [this](bool checked){
        m_metaPanel->setVisible(checked);
    });
    connect(m_header, &HeaderBar::windowClose, this, &MainWindow::close);
    connect(m_header, &HeaderBar::windowMinimize, this, &MainWindow::showMinimized);
    connect(m_header, &HeaderBar::windowMaximize, this, [this](){
        if (isMaximized()) showNormal();
        else showMaximized();
    });
    mainLayout->addWidget(m_header);

    // 核心内容容器：管理 5px 全局边距
    auto* contentWidget = new QWidget(centralWidget);
    contentWidget->setAttribute(Qt::WA_StyledBackground, true);
    contentWidget->setStyleSheet("background: transparent; border: none;");
    auto* contentLayout = new QVBoxLayout(contentWidget);
    contentLayout->setContentsMargins(5, 5, 5, 5); // 确保顶栏下方及窗口四周均有 5px 留白
    contentLayout->setSpacing(0);

    auto* splitter = new QSplitter(Qt::Horizontal);
    splitter->setHandleWidth(5); // 统一横向板块间的物理缝隙为 5px
    splitter->setChildrenCollapsible(false);
    splitter->setAttribute(Qt::WA_StyledBackground, true);
    splitter->setStyleSheet("QSplitter { background: transparent; border: none; } QSplitter::handle { background: transparent; }");

    // 1. 左侧侧边栏包装容器 (固定 230px)
    auto* sidebarWrapper = new QWidget();
    sidebarWrapper->setMinimumWidth(230);
    auto* sidebarWrapperLayout = new QVBoxLayout(sidebarWrapper);
    sidebarWrapperLayout->setContentsMargins(0, 0, 0, 0); // 彻底消除偏移边距，由全局 Layout 和 Splitter 控制

    m_sidebarContainer = new QFrame();
    m_sidebarContainer->setMinimumWidth(230);
    m_sidebarContainer->setObjectName("SidebarContainer");
    m_sidebarContainer->setAttribute(Qt::WA_StyledBackground, true);
    m_sidebarContainer->setStyleSheet(
        "#SidebarContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );

    auto* sidebarShadow = new QGraphicsDropShadowEffect(m_sidebarContainer);
    sidebarShadow->setBlurRadius(10);
    sidebarShadow->setXOffset(0);
    sidebarShadow->setYOffset(4);
    sidebarShadow->setColor(QColor(0, 0, 0, 150));
    m_sidebarContainer->setGraphicsEffect(sidebarShadow);

    auto* sidebarContainerLayout = new QVBoxLayout(m_sidebarContainer);
    sidebarContainerLayout->setContentsMargins(0, 0, 0, 0); 
    sidebarContainerLayout->setSpacing(0);

    // 侧边栏标题栏 (全宽下划线方案)
    auto* sidebarHeader = new QWidget();
    sidebarHeader->setFixedHeight(32);
    sidebarHeader->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #333;"
    );
    auto* sidebarHeaderLayout = new QHBoxLayout(sidebarHeader);
    sidebarHeaderLayout->setContentsMargins(15, 0, 15, 0);
    auto* sbIcon = new QLabel();
    sbIcon->setPixmap(IconHelper::getIcon("category", "#3498db").pixmap(18, 18));
    sidebarHeaderLayout->addWidget(sbIcon);
    auto* sbTitle = new QLabel("数据分类");
    sbTitle->setStyleSheet("color: #3498db; font-size: 13px; font-weight: bold; background: transparent; border: none;");
    sidebarHeaderLayout->addWidget(sbTitle);
    sidebarHeaderLayout->addStretch();
    
    sidebarHeader->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(sidebarHeader, &QWidget::customContextMenuRequested, this, [this, splitter, sidebarHeader](const QPoint& pos){
        QMenu menu;
        IconHelper::setupMenu(&menu);
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #3E3E42; }");
        menu.addAction(IconHelper::getIcon("nav_prev", "#aaaaaa", 18), "向左移动", [this, splitter](){
            int index = splitter->indexOf(m_sidebarContainer);
            if (index > 0) splitter->insertWidget(index - 1, m_sidebarContainer);
        });
        menu.addAction("向右移动", [this, splitter](){
            int index = splitter->indexOf(m_sidebarContainer);
            if (index < splitter->count() - 1) splitter->insertWidget(index + 1, m_sidebarContainer);
        });
        menu.exec(sidebarHeader->mapToGlobal(pos));
    });
    
    sidebarContainerLayout->addWidget(sidebarHeader);

    // 内容容器
    auto* sbContent = new QWidget();
    sbContent->setAttribute(Qt::WA_StyledBackground, true);
    sbContent->setStyleSheet("background: transparent; border: none;");
    auto* sbContentLayout = new QVBoxLayout(sbContent);
    sbContentLayout->setContentsMargins(8, 8, 8, 8);
    sbContentLayout->setSpacing(0);

    QString treeStyle = R"(
        QTreeView { background-color: transparent; border: none; color: #CCC; outline: none; }
        QTreeView::branch { image: none; border: none; width: 0px; }
        QTreeView::item { height: 22px; padding-left: 10px; }
    )";

    m_systemTree = new DropTreeView();
    m_systemTree->setStyleSheet(treeStyle);
    m_systemTree->setItemDelegate(new CategoryDelegate(this));
    m_systemModel = new CategoryModel(CategoryModel::System, this);
    m_systemTree->setModel(m_systemModel);
    m_systemTree->setHeaderHidden(true);
    m_systemTree->setRootIsDecorated(false);
    m_systemTree->setIndentation(12);
    m_systemTree->setFixedHeight(176); // 8 items * 22px = 176px
    m_systemTree->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_systemTree->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_systemTree->setContextMenuPolicy(Qt::CustomContextMenu);

    m_partitionTree = new DropTreeView();
    m_partitionTree->setStyleSheet(treeStyle);
    m_partitionTree->setItemDelegate(new CategoryDelegate(this));
    m_partitionModel = new CategoryModel(CategoryModel::User, this);
    m_partitionTree->setModel(m_partitionModel);
    m_partitionTree->setHeaderHidden(true);
    m_partitionTree->setRootIsDecorated(false);
    m_partitionTree->setIndentation(12);
    m_partitionTree->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_partitionTree->setDragEnabled(true);
    m_partitionTree->setAcceptDrops(true);
    m_partitionTree->setDropIndicatorShown(true);
    m_partitionTree->setDragDropMode(QAbstractItemView::InternalMove);
    m_partitionTree->setDefaultDropAction(Qt::MoveAction);
    m_partitionTree->expandAll();
    m_partitionTree->setContextMenuPolicy(Qt::CustomContextMenu);
    
    sbContentLayout->addWidget(m_systemTree);
    sbContentLayout->addWidget(m_partitionTree);
    sidebarContainerLayout->addWidget(sbContent);

    // 直接放入 Splitter (移除 Wrapper)
    splitter->addWidget(m_sidebarContainer);

    auto onSidebarMenu = [this](const QPoint& pos){
        auto* tree = qobject_cast<QTreeView*>(sender());
        if (!tree) return;
        QModelIndex index = tree->indexAt(pos);
        QMenu menu(this);
        IconHelper::setupMenu(&menu);
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #4a90e2; color: white; }");

        if (!index.isValid() || index.data().toString() == "我的分区") {
            menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建分组", [this]() {
                auto* dlg = new FramelessInputDialog("新建分组", "组名称:", "", this);
                connect(dlg, &FramelessInputDialog::accepted, [this, dlg](){
                    QString text = dlg->text();
                    if (!text.isEmpty()) {
                        DatabaseManager::instance().addCategory(text);
                        refreshData();
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.exec(tree->mapToGlobal(pos));
            return;
        }

        QString type = index.data(CategoryModel::TypeRole).toString();
        if (type == "category") {
            int catId = index.data(CategoryModel::IdRole).toInt();
            QString currentName = index.data(CategoryModel::NameRole).toString();

            menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建数据", [this, catId]() {
                auto* win = new NoteEditWindow();
                win->setDefaultCategory(catId);
                connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
                win->show();
            });
            menu.addSeparator();
            menu.addAction(IconHelper::getIcon("palette", "#e67e22", 18), "设置颜色", [this, catId]() {
                auto* dlg = new QColorDialog(Qt::gray, this);
                dlg->setWindowTitle("选择分类颜色");
                dlg->setWindowFlags(dlg->windowFlags() | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);
                connect(dlg, &QColorDialog::colorSelected, [this, catId](const QColor& color){
                    if (color.isValid()) {
                        DatabaseManager::instance().setCategoryColor(catId, color.name());
                        refreshData();
                    }
                });
                connect(dlg, &QColorDialog::finished, dlg, &QObject::deleteLater);
                dlg->show();
            });
            menu.addAction(IconHelper::getIcon("random_color", "#FF6B9D", 18), "随机颜色", [this, catId]() {
                static const QStringList palette = {
                    "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEEAD",
                    "#D4A5A5", "#9B59B6", "#3498DB", "#E67E22", "#2ECC71",
                    "#E74C3C", "#F1C40F", "#1ABC9C", "#34495E", "#95A5A6"
                };
                QString chosenColor = palette.at(QRandomGenerator::global()->bounded(palette.size()));
                DatabaseManager::instance().setCategoryColor(catId, chosenColor);
                refreshData();
            });
            menu.addAction(IconHelper::getIcon("tag", "#FFAB91", 18), "设置预设标签", [this, catId]() {
                QString currentTags = DatabaseManager::instance().getCategoryPresetTags(catId);
                auto* dlg = new FramelessInputDialog("设置预设标签", "标签 (逗号分隔):", currentTags, this);
                connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                    DatabaseManager::instance().setCategoryPresetTags(catId, dlg->text());
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.addSeparator();
            menu.addAction(IconHelper::getIcon("add", "#aaaaaa", 18), "新建分组", [this]() {
                auto* dlg = new FramelessInputDialog("新建分组", "组名称:", "", this);
                connect(dlg, &FramelessInputDialog::accepted, [this, dlg](){
                    QString text = dlg->text();
                    if (!text.isEmpty()) {
                        DatabaseManager::instance().addCategory(text);
                        refreshData();
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建子分区", [this, catId]() {
                auto* dlg = new FramelessInputDialog("新建子分区", "区名称:", "", this);
                connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                    QString text = dlg->text();
                    if (!text.isEmpty()) {
                        DatabaseManager::instance().addCategory(text, catId);
                        refreshData();
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.addSeparator();

            menu.addAction(IconHelper::getIcon("edit", "#aaaaaa", 18), "重命名分类", [this, catId, currentName]() {
                auto* dlg = new FramelessInputDialog("重命名分类", "新名称:", currentName, this);
                connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                    QString text = dlg->text();
                    if (!text.isEmpty()) {
                        DatabaseManager::instance().renameCategory(catId, text);
                        refreshData();
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "删除分类", [this, catId]() {
                auto* dlg = new FramelessMessageBox("确认删除", "确定要删除此分类吗？内容将移至未分类。", this);
                connect(dlg, &FramelessMessageBox::confirmed, [this, catId](){
                    DatabaseManager::instance().deleteCategory(catId);
                    refreshData();
                });
                dlg->show();
            });

            menu.addSeparator();
            auto* sortMenu = menu.addMenu(IconHelper::getIcon("list_ol", "#aaaaaa", 18), "排列");
            sortMenu->setStyleSheet(menu.styleSheet());

            int parentId = -1;
            QModelIndex parentIdx = index.parent();
            if (parentIdx.isValid() && parentIdx.data(CategoryModel::TypeRole).toString() == "category") {
                parentId = parentIdx.data(CategoryModel::IdRole).toInt();
            }

            sortMenu->addAction("标题(当前层级) (A→Z)", [this, parentId]() {
                if (DatabaseManager::instance().reorderCategories(parentId, true))
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 排列已完成</b>");
            });
            sortMenu->addAction("标题(当前层级) (Z→A)", [this, parentId]() {
                if (DatabaseManager::instance().reorderCategories(parentId, false))
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 排列已完成</b>");
            });
            sortMenu->addAction("标题(全部) (A→Z)", [this]() {
                if (DatabaseManager::instance().reorderAllCategories(true))
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 全部排列已完成</b>");
            });
            sortMenu->addAction("标题(全部) (Z→A)", [this]() {
                if (DatabaseManager::instance().reorderAllCategories(false))
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 全部排列已完成</b>");
            });

            menu.addSeparator();
            auto* pwdMenu = menu.addMenu(IconHelper::getIcon("lock", "#aaaaaa", 18), "密码保护");
            pwdMenu->setStyleSheet(menu.styleSheet());
            
            pwdMenu->addAction("设置", [this, catId]() {
                QTimer::singleShot(0, [this, catId]() {
                    auto* dlg = new CategoryPasswordDialog("设置密码", this);
                    connect(dlg, &QDialog::accepted, [this, catId, dlg]() {
                        DatabaseManager::instance().setCategoryPassword(catId, dlg->password(), dlg->passwordHint());
                        refreshData();
                    });
                    dlg->show();
                    dlg->activateWindow();
                    dlg->raise();
                });
            });
            pwdMenu->addAction("修改", [this, catId]() {
                QTimer::singleShot(0, [this, catId]() {
                    auto* verifyDlg = new FramelessInputDialog("验证旧密码", "请输入当前密码:", "", this);
                    verifyDlg->setEchoMode(QLineEdit::Password);
                    connect(verifyDlg, &FramelessInputDialog::accepted, [this, catId, verifyDlg]() {
                        if (DatabaseManager::instance().verifyCategoryPassword(catId, verifyDlg->text())) {
                            auto* dlg = new CategoryPasswordDialog("修改密码", this);
                            QString currentHint;
                            auto cats = DatabaseManager::instance().getAllCategories();
                            for(const auto& c : std::as_const(cats)) if(c.value("id").toInt() == catId) currentHint = c.value("password_hint").toString();
                            dlg->setInitialData(currentHint);
                            connect(dlg, &QDialog::accepted, [this, catId, dlg]() {
                                DatabaseManager::instance().setCategoryPassword(catId, dlg->password(), dlg->passwordHint());
                                refreshData();
                            });
                            dlg->show();
                            dlg->activateWindow();
                            dlg->raise();
                        } else {
                            ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 旧密码验证失败</b>");
                        }
                    });
                    verifyDlg->show();
                    verifyDlg->activateWindow();
                    verifyDlg->raise();
                });
            });
            pwdMenu->addAction("移除", [this, catId]() {
                QTimer::singleShot(0, [this, catId]() {
                    auto* dlg = new FramelessInputDialog("验证密码", "请输入当前密码以移除保护:", "", this);
                    dlg->setEchoMode(QLineEdit::Password);
                    connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg]() {
                        if (DatabaseManager::instance().verifyCategoryPassword(catId, dlg->text())) {
                            DatabaseManager::instance().removeCategoryPassword(catId);
                            refreshData();
                        } else {
                            ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 密码错误</b>");
                        }
                    });
                    dlg->show();
                    dlg->activateWindow();
                    dlg->raise();
                });
            });
            pwdMenu->addAction("立即锁定", [this, catId]() {
                DatabaseManager::instance().lockCategory(catId);
                refreshData();
            })->setShortcut(QKeySequence("Ctrl+Shift+L"));
        } else if (type == "trash") {
            menu.addAction(IconHelper::getIcon("refresh", "#2ecc71", 18), "全部恢复 (到未分类)", [this](){
                DatabaseManager::instance().restoreAllFromTrash();
                refreshData();
            });
            menu.addSeparator();
            menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "清空回收站", [this]() {
                auto* dlg = new FramelessMessageBox("确认清空", "确定要永久删除回收站中的所有内容吗？\n(此操作不可逆)", this);
                connect(dlg, &FramelessMessageBox::confirmed, [this](){
                    DatabaseManager::instance().emptyTrash();
                    refreshData();
                });
                dlg->show();
            });
        }
        menu.exec(tree->mapToGlobal(pos));
    };

    connect(m_systemTree, &QTreeView::customContextMenuRequested, this, onSidebarMenu);
    connect(m_partitionTree, &QTreeView::customContextMenuRequested, this, onSidebarMenu);

    auto onSelection = [this](QTreeView* tree, const QModelIndex& index) {
        if (!index.isValid()) return;
        if (tree == m_systemTree) {
            m_partitionTree->selectionModel()->clearSelection();
            m_partitionTree->setCurrentIndex(QModelIndex());
        } else {
            m_systemTree->selectionModel()->clearSelection();
            m_systemTree->setCurrentIndex(QModelIndex());
        }
        onTagSelected(index);
    };

    connect(m_systemTree, &QTreeView::clicked, this, [this, onSelection](const QModelIndex& idx){ onSelection(m_systemTree, idx); });
    connect(m_partitionTree, &QTreeView::clicked, this, [this, onSelection](const QModelIndex& idx){ onSelection(m_partitionTree, idx); });
    
    // 连接拖拽信号 (使用 Model 定义的枚举)
    auto onNotesDropped = [this](const QList<int>& ids, const QModelIndex& targetIndex){
        if (!targetIndex.isValid()) return;
        QString type = targetIndex.data(CategoryModel::TypeRole).toString();
        for (int id : ids) {
            if (type == "category") {
                int catId = targetIndex.data(CategoryModel::IdRole).toInt();
                DatabaseManager::instance().updateNoteState(id, "category_id", catId);
            } else if (targetIndex.data().toString() == "收藏" || type == "bookmark") { 
                DatabaseManager::instance().updateNoteState(id, "is_favorite", 1);
            } else if (type == "trash") {
                DatabaseManager::instance().updateNoteState(id, "is_deleted", 1);
            } else if (type == "uncategorized") {
                DatabaseManager::instance().updateNoteState(id, "category_id", QVariant());
            }
        }
        refreshData();
    };

    connect(m_systemTree, &DropTreeView::notesDropped, this, onNotesDropped);
    connect(m_partitionTree, &DropTreeView::notesDropped, this, onNotesDropped);

    // 3. 中间列表卡片容器
    auto* listContainer = new QFrame();
    listContainer->setMinimumWidth(230); // 对齐 MetadataPanel
    listContainer->setObjectName("ListContainer");
    listContainer->setAttribute(Qt::WA_StyledBackground, true);
    listContainer->setStyleSheet(
        "#ListContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );

    auto* listShadow = new QGraphicsDropShadowEffect(listContainer);
    listShadow->setBlurRadius(10);
    listShadow->setXOffset(0);
    listShadow->setYOffset(4);
    listShadow->setColor(QColor(0, 0, 0, 150));
    listContainer->setGraphicsEffect(listShadow);

    auto* listContainerLayout = new QVBoxLayout(listContainer);
    listContainerLayout->setContentsMargins(0, 0, 0, 0); 
    listContainerLayout->setSpacing(0);

    // 列表标题栏 (锁定 32px, 统一配色与分割线)
    auto* listHeader = new QWidget();
    listHeader->setFixedHeight(32);
    listHeader->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #333;" 
    );
    auto* listHeaderLayout = new QHBoxLayout(listHeader);
    listHeaderLayout->setContentsMargins(15, 0, 15, 0); 
    auto* listIcon = new QLabel();
    listIcon->setPixmap(IconHelper::getIcon("list_ul", "#2ecc71").pixmap(18, 18));
    listHeaderLayout->addWidget(listIcon);
    auto* listHeaderTitle = new QLabel("笔记列表");
    listHeaderTitle->setStyleSheet("color: #2ecc71; font-size: 13px; font-weight: bold; background: transparent; border: none;");
    listHeaderLayout->addWidget(listHeaderTitle);
    listHeaderLayout->addStretch();
    
    listHeader->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(listHeader, &QWidget::customContextMenuRequested, this, [this, listContainer, splitter, listHeader](const QPoint& pos){
        QMenu menu;
        IconHelper::setupMenu(&menu);
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #3E3E42; }");
        menu.addAction("向左移动", [this, listContainer, splitter](){
            int index = splitter->indexOf(listContainer);
            if (index > 0) splitter->insertWidget(index - 1, listContainer);
        });
        menu.addAction("向右移动", [this, listContainer, splitter](){
            int index = splitter->indexOf(listContainer);
            if (index < splitter->count() - 1) splitter->insertWidget(index + 1, listContainer);
        });
        menu.exec(listHeader->mapToGlobal(pos));
    });
    
    listContainerLayout->addWidget(listHeader);

    // 内容容器
    auto* listContent = new QWidget();
    listContent->setAttribute(Qt::WA_StyledBackground, true);
    listContent->setStyleSheet("background: transparent; border: none;");
    auto* listContentLayout = new QVBoxLayout(listContent);
    // 恢复垂直边距为 8，保留水平边距 15 以对齐宽度
    listContentLayout->setContentsMargins(15, 8, 15, 8);
    
    m_noteList = new CleanListView();
    m_noteList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_noteList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_noteModel = new NoteModel(this);
    m_noteList->setModel(m_noteModel);
    m_noteList->setItemDelegate(new NoteDelegate(m_noteList));
    m_noteList->setContextMenuPolicy(Qt::CustomContextMenu);
    m_noteList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    connect(m_noteList, &QListView::customContextMenuRequested, this, &MainWindow::showContextMenu);
    
    // 恢复垂直间距为 5，垂直 Padding 为 5；仅水平 Padding 设为 0
    m_noteList->setSpacing(5); 
    m_noteList->setStyleSheet("QListView { background: transparent; border: none; padding-top: 5px; padding-bottom: 5px; padding-left: 0px; padding-right: 0px; }");
    
    // 基础拖拽使能 (其余复杂逻辑已由 CleanListView 实现)
    m_noteList->setDragEnabled(true);

    connect(m_noteList->selectionModel(), &QItemSelectionModel::selectionChanged, this, &MainWindow::onSelectionChanged);
    connect(m_noteList, &QListView::doubleClicked, this, [this](const QModelIndex& index){
        if (!index.isValid()) return;
        int id = index.data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        QString type = note.value("item_type").toString();
        
        if (type == "local_file" || type == "local_folder" || type == "local_batch") {
            QString relativePath = note.value("content").toString();
            QString fullPath = QCoreApplication::applicationDirPath() + "/" + relativePath;
            
            if (QFile::exists(fullPath)) {
                QDesktopServices::openUrl(QUrl::fromLocalFile(fullPath));
            } else {
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 文件已丢失：<br></b>" + fullPath);
            }
            return;
        }

        NoteEditWindow* win = new NoteEditWindow(id);
        connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
        win->show();
    });

    listContentLayout->addWidget(m_noteList);

    m_lockWidget = new CategoryLockWidget(this);
    m_lockWidget->setVisible(false);
    connect(m_lockWidget, &CategoryLockWidget::unlocked, this, [this](){
        refreshData();
    });
    listContentLayout->addWidget(m_lockWidget);

    listContainerLayout->addWidget(listContent);
    splitter->addWidget(listContainer);
    
    // 4. 编辑器容器 (Card) - 独立出来
    auto* editorContainer = new QFrame();
    editorContainer->setMinimumWidth(230);
    editorContainer->setObjectName("EditorContainer");
    editorContainer->setAttribute(Qt::WA_StyledBackground, true);
    editorContainer->setStyleSheet(
        "#EditorContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );

    auto* editorShadow = new QGraphicsDropShadowEffect(editorContainer);
    editorShadow->setBlurRadius(10);
    editorShadow->setXOffset(0);
    editorShadow->setYOffset(4);
    editorShadow->setColor(QColor(0, 0, 0, 150));
    editorContainer->setGraphicsEffect(editorShadow);

    auto* editorContainerLayout = new QVBoxLayout(editorContainer);
    editorContainerLayout->setContentsMargins(0, 0, 0, 0);
    editorContainerLayout->setSpacing(0);

    // 编辑器标题栏 (全宽贯穿线)
    auto* editorHeader = new QWidget();
    editorHeader->setFixedHeight(32);
    editorHeader->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #555;"
    );
    auto* editorHeaderLayout = new QHBoxLayout(editorHeader);
    editorHeaderLayout->setContentsMargins(15, 0, 15, 0);
    auto* edIcon = new QLabel();
    edIcon->setPixmap(IconHelper::getIcon("eye", "#e67e22").pixmap(18, 18));
    editorHeaderLayout->addWidget(edIcon);
    auto* edTitle = new QLabel("预览数据"); // 保护用户修改的标题内容
    edTitle->setStyleSheet("color: #e67e22; font-size: 13px; font-weight: bold; background: transparent; border: none;");
    editorHeaderLayout->addWidget(edTitle);
    editorHeaderLayout->addStretch();

    // 编辑锁定/解锁按钮
    m_editLockBtn = new QPushButton();
    m_editLockBtn->setFixedSize(24, 24);
    m_editLockBtn->setCursor(Qt::PointingHandCursor);
    m_editLockBtn->setCheckable(true);
    m_editLockBtn->setEnabled(false); // 初始禁用
    m_editLockBtn->setToolTip("请先选择一条笔记以启用编辑");
    m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#555555")); // 初始灰色
    m_editLockBtn->setStyleSheet(
        "QPushButton { background: transparent; border: none; border-radius: 4px; }"
        "QPushButton:hover:enabled { background-color: rgba(255, 255, 255, 0.1); }"
        "QPushButton:checked { background-color: rgba(74, 144, 226, 0.2); }"
        "QPushButton:disabled { opacity: 0.5; }"
    );
    editorHeaderLayout->addWidget(m_editLockBtn);
    
    editorHeader->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(editorHeader, &QWidget::customContextMenuRequested, this, [this, editorContainer, splitter, editorHeader](const QPoint& pos){
        QMenu menu;
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #3E3E42; }");
        menu.addAction("向左移动", [this, editorContainer, splitter](){
            int index = splitter->indexOf(editorContainer);
            if (index > 0) splitter->insertWidget(index - 1, editorContainer);
        });
        menu.addAction("向右移动", [this, editorContainer, splitter](){
            int index = splitter->indexOf(editorContainer);
            if (index < splitter->count() - 1) splitter->insertWidget(index + 1, editorContainer);
        });
        menu.exec(editorHeader->mapToGlobal(pos));
    });

    editorContainerLayout->addWidget(editorHeader);

    // --- 编辑器工具栏 (同步 NoteEditWindow) ---
    m_editorToolbar = new QWidget();
    m_editorToolbar->setVisible(false);
    m_editorToolbar->setStyleSheet("background-color: #252526; border-bottom: 1px solid #333;");
    auto* toolBarLayout = new QHBoxLayout(m_editorToolbar);
    toolBarLayout->setContentsMargins(10, 2, 10, 2);
    toolBarLayout->setSpacing(0);

    QString toolBtnStyle = "QPushButton { background: transparent; border: none; border-radius: 4px; padding: 4px; } "
                           "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); } "
                           "QPushButton:checked { background-color: rgba(74, 144, 226, 0.2); }";

    auto addTool = [&](const QString& iconName, const QString& tip, std::function<void()> callback) {
        QPushButton* btn = new QPushButton();
        btn->setIcon(IconHelper::getIcon(iconName, "#aaaaaa", 18));
        btn->setIconSize(QSize(18, 18));
        btn->setToolTip(tip);
        btn->setFixedSize(28, 28);
        btn->setCursor(Qt::PointingHandCursor);
        btn->setStyleSheet(toolBtnStyle);
        connect(btn, &QPushButton::clicked, callback);
        toolBarLayout->addWidget(btn);
        return btn;
    };

    addTool("undo", "撤销 (Ctrl+Z)", [this](){ m_editor->undo(); });
    addTool("redo", "重做 (Ctrl+Y)", [this](){ m_editor->redo(); });
    
    auto* sep1 = new QFrame();
    sep1->setFixedWidth(1); sep1->setFixedHeight(16); sep1->setStyleSheet("background-color: #444; margin: 0 4px;");
    toolBarLayout->addWidget(sep1);

    addTool("list_ul", "无序列表", [this](){ m_editor->toggleList(false); });
    addTool("list_ol", "有序列表", [this](){ m_editor->toggleList(true); });
    addTool("todo", "插入待办", [this](){ m_editor->insertTodo(); });
    
    auto* btnPre = addTool("eye", "Markdown 预览", nullptr);
    btnPre->setCheckable(true);
    connect(btnPre, &QPushButton::toggled, [this](bool checked){ m_editor->togglePreview(checked); });

    addTool("edit_clear", "清除格式", [this](){ m_editor->clearFormatting(); });

    auto* sep2 = new QFrame();
    sep2->setFixedWidth(1); sep2->setFixedHeight(16); sep2->setStyleSheet("background-color: #444; margin: 0 4px;");
    toolBarLayout->addWidget(sep2);

    // 高亮颜色
    QStringList hColors = {"#c0392b", "#f1c40f", "#27ae60", "#2980b9"};
    for (const auto& color : hColors) {
        QPushButton* hBtn = new QPushButton();
        hBtn->setFixedSize(18, 18);
        hBtn->setStyleSheet(QString("QPushButton { background-color: %1; border-radius: 4px; margin: 2px; } QPushButton:hover { border: 1px solid white; }").arg(color));
        connect(hBtn, &QPushButton::clicked, [this, color](){ m_editor->highlightSelection(QColor(color)); });
        toolBarLayout->addWidget(hBtn);
    }

    // 清除高亮按钮
    QPushButton* btnNoColor = new QPushButton();
    btnNoColor->setIcon(IconHelper::getIcon("no_color", "#aaaaaa", 14));
    btnNoColor->setIconSize(QSize(14, 14));
    btnNoColor->setFixedSize(22, 22);
    btnNoColor->setToolTip("清除高亮");
    btnNoColor->setStyleSheet("QPushButton { background: transparent; border: 1px solid #444; border-radius: 4px; margin-left: 4px; } "
                              "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); border-color: #888; }");
    btnNoColor->setCursor(Qt::PointingHandCursor);
    connect(btnNoColor, &QPushButton::clicked, [this](){ m_editor->highlightSelection(Qt::transparent); });
    toolBarLayout->addWidget(btnNoColor);

    toolBarLayout->addStretch();
    
    auto* btnSave = addTool("save", "保存修改 (Ctrl+S)", [this](){ saveCurrentNote(); });
    btnSave->setIcon(IconHelper::getIcon("save", "#2ecc71", 18));

    editorContainerLayout->addWidget(m_editorToolbar);

    // --- 编辑器搜索栏 ---
    m_editorSearchBar = new QWidget();
    m_editorSearchBar->setVisible(false);
    m_editorSearchBar->setStyleSheet("background-color: #2D2D30; border-bottom: 1px solid #333;");
    auto* esLayout = new QHBoxLayout(m_editorSearchBar);
    esLayout->setContentsMargins(15, 4, 15, 4);
    
    m_editorSearchEdit = new QLineEdit();
    m_editorSearchEdit->setPlaceholderText("在内容中查找...");
    m_editorSearchEdit->setStyleSheet("border: none; background: transparent; color: #fff; font-size: 12px;");
    connect(m_editorSearchEdit, &QLineEdit::returnPressed, [this](){ m_editor->findText(m_editorSearchEdit->text()); });
    
    auto* btnPrev = new QPushButton();
    btnPrev->setIcon(IconHelper::getIcon("nav_prev", "#ccc", 14));
    btnPrev->setFixedSize(24, 24);
    btnPrev->setStyleSheet("background: transparent; border: none;");
    connect(btnPrev, &QPushButton::clicked, [this](){ m_editor->findText(m_editorSearchEdit->text(), true); });
    
    auto* btnNext = new QPushButton();
    btnNext->setIcon(IconHelper::getIcon("nav_next", "#ccc", 14));
    btnNext->setFixedSize(24, 24);
    btnNext->setStyleSheet("background: transparent; border: none;");
    connect(btnNext, &QPushButton::clicked, [this](){ m_editor->findText(m_editorSearchEdit->text(), false); });

    auto* btnCloseSearch = new QPushButton();
    btnCloseSearch->setIcon(IconHelper::getIcon("close", "#888", 14));
    btnCloseSearch->setFixedSize(24, 24);
    btnCloseSearch->setStyleSheet("background: transparent; border: none;");
    connect(btnCloseSearch, &QPushButton::clicked, [this](){ m_editorSearchBar->hide(); });

    esLayout->addWidget(m_editorSearchEdit);
    esLayout->addWidget(btnPrev);
    esLayout->addWidget(btnNext);
    esLayout->addWidget(btnCloseSearch);
    editorContainerLayout->addWidget(m_editorSearchBar);

    // 内容容器
    auto* editorContent = new QWidget();
    editorContent->setAttribute(Qt::WA_StyledBackground, true);
    editorContent->setStyleSheet("background: transparent; border: none;");
    auto* editorContentLayout = new QVBoxLayout(editorContent);
    editorContentLayout->setContentsMargins(2, 2, 2, 2); // 编辑器保留微量对齐边距

    m_editor = new Editor();
    m_editor->togglePreview(false);
    m_editor->setReadOnly(true); // 默认不可编辑

    connect(m_editLockBtn, &QPushButton::toggled, this, [this](bool checked){
        m_editor->setReadOnly(!checked);
        m_editorToolbar->setVisible(checked);
        if (!checked) m_editorSearchBar->hide();

        // 核心修复：切换模式时重新同步内容，防止预览标题污染正文
        QModelIndex index = m_noteList->currentIndex();
        if (index.isValid()) {
            int id = index.data(NoteModel::IdRole).toInt();
            QVariantMap note = DatabaseManager::instance().getNoteById(id);
            // 模式切换：编辑模式不带标题(false)，预览模式带标题(true)
            m_editor->setNote(note, !checked);
        }

        if (checked) {
            m_editLockBtn->setIcon(IconHelper::getIcon("eye", "#4a90e2"));
            m_editLockBtn->setToolTip("当前：编辑模式 (点击切回预览)");
        } else {
            m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#aaaaaa"));
            m_editLockBtn->setToolTip("当前：锁定模式 (点击解锁编辑)");
        }
    });
    
    editorContentLayout->addWidget(m_editor);
    editorContainerLayout->addWidget(editorContent);
    
    // 直接放入 Splitter
    splitter->addWidget(editorContainer);

    // 5. 元数据面板 - 独立出来
    m_metaPanel = new MetadataPanel(this);
    m_metaPanel->setMinimumWidth(230);
    connect(m_metaPanel, &MetadataPanel::noteUpdated, this, &MainWindow::refreshData);
    connect(m_metaPanel, &MetadataPanel::closed, this, [this](){
        m_header->setMetadataActive(false);
    });
    connect(m_metaPanel, &MetadataPanel::tagAdded, this, [this](const QStringList& tags){
        QModelIndexList indices = m_noteList->selectionModel()->selectedIndexes();
        if (indices.isEmpty()) return;
        for (const auto& index : std::as_const(indices)) {
            int id = index.data(NoteModel::IdRole).toInt();
            DatabaseManager::instance().addTagsToNote(id, tags);
        }
        refreshData();
    });
    
    // 给元数据面板添加右键移动菜单
    auto* metaHeader = m_metaPanel->findChild<QWidget*>("MetadataHeader");
    if (metaHeader) {
        metaHeader->setContextMenuPolicy(Qt::CustomContextMenu);
        connect(metaHeader, &QWidget::customContextMenuRequested, this, [this, splitter, metaHeader](const QPoint& pos){
            QMenu menu;
            IconHelper::setupMenu(&menu);
            menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                               /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                               "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                               "QMenu::icon { margin-left: 6px; } "
                               "QMenu::item:selected { background-color: #3E3E42; }");
            menu.addAction("向左移动", [this, splitter](){
                int index = splitter->indexOf(m_metaPanel);
                if (index > 0) splitter->insertWidget(index - 1, m_metaPanel);
            });
            menu.addAction("向右移动", [this, splitter](){
                int index = splitter->indexOf(m_metaPanel);
                if (index < splitter->count() - 1) splitter->insertWidget(index + 1, m_metaPanel);
            });
            menu.exec(metaHeader->mapToGlobal(pos));
        });
    }

    splitter->addWidget(m_metaPanel);

    // 6. 高级筛选器卡片容器
    auto* filterContainer = new QFrame();
    filterContainer->setMinimumWidth(230);
    filterContainer->setObjectName("FilterContainer");
    filterContainer->setAttribute(Qt::WA_StyledBackground, true);
    filterContainer->setStyleSheet(
        "#FilterContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );

    auto* filterShadow = new QGraphicsDropShadowEffect(filterContainer);
    filterShadow->setBlurRadius(10);
    filterShadow->setXOffset(0);
    filterShadow->setYOffset(4);
    filterShadow->setColor(QColor(0, 0, 0, 150));
    filterContainer->setGraphicsEffect(filterShadow);

    auto* filterContainerLayout = new QVBoxLayout(filterContainer);
    filterContainerLayout->setContentsMargins(0, 0, 0, 0);
    filterContainerLayout->setSpacing(0);

    // 筛选器标题栏
    auto* filterHeader = new QWidget();
    filterHeader->setFixedHeight(32);
    filterHeader->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #333;"
    );
    auto* filterHeaderLayout = new QHBoxLayout(filterHeader);
    filterHeaderLayout->setContentsMargins(15, 0, 15, 0);
    auto* fiIcon = new QLabel();
    fiIcon->setPixmap(IconHelper::getIcon("filter", "#f1c40f").pixmap(18, 18));
    filterHeaderLayout->addWidget(fiIcon);
    auto* fiTitle = new QLabel("高级筛选");
    fiTitle->setStyleSheet("color: #f1c40f; font-size: 13px; font-weight: bold; background: transparent; border: none;");
    filterHeaderLayout->addWidget(fiTitle);
    filterHeaderLayout->addStretch();

    auto* filterCloseBtn = new QPushButton();
    filterCloseBtn->setIcon(IconHelper::getIcon("close", "#888888"));
    filterCloseBtn->setFixedSize(24, 24);
    filterCloseBtn->setCursor(Qt::PointingHandCursor);
    filterCloseBtn->setStyleSheet(
        "QPushButton { background-color: transparent; border: none; border-radius: 4px; }"
        "QPushButton:hover { background-color: #e74c3c; }"
    );
    connect(filterCloseBtn, &QPushButton::clicked, this, [this](){
        m_filterWrapper->hide();
        m_header->setFilterActive(false);
    });
    filterHeaderLayout->addWidget(filterCloseBtn);
    
    filterHeader->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(filterHeader, &QWidget::customContextMenuRequested, this, [this, filterContainer, splitter, filterHeader](const QPoint& pos){
        QMenu menu;
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #3E3E42; }");
        menu.addAction("向左移动", [this, filterContainer, splitter](){
            int index = splitter->indexOf(filterContainer);
            if (index > 0) splitter->insertWidget(index - 1, filterContainer);
        });
        menu.addAction("向右移动", [this, filterContainer, splitter](){
            int index = splitter->indexOf(filterContainer);
            if (index < splitter->count() - 1) splitter->insertWidget(index + 1, filterContainer);
        });
        menu.exec(filterHeader->mapToGlobal(pos));
    });
    
    filterContainerLayout->addWidget(filterHeader);

    // 内容容器
    auto* filterContent = new QWidget();
    filterContent->setAttribute(Qt::WA_StyledBackground, true);
    filterContent->setStyleSheet("background: transparent; border: none;");
    auto* filterContentLayout = new QVBoxLayout(filterContent);
    filterContentLayout->setContentsMargins(0, 0, 10, 10);

    m_filterPanel = new FilterPanel(this);
    m_filterPanel->setStyleSheet("background: transparent; border: none;");
    connect(m_filterPanel, &FilterPanel::filterChanged, this, &MainWindow::refreshData);
    filterContentLayout->addWidget(m_filterPanel);
    filterContainerLayout->addWidget(filterContent);

    m_filterWrapper = filterContainer;
    splitter->addWidget(m_filterWrapper);



    splitter->setStretchFactor(0, 1); 
    splitter->setStretchFactor(1, 2); 
    splitter->setStretchFactor(2, 8); 
    splitter->setStretchFactor(3, 1); 
    splitter->setStretchFactor(4, 1);
    
    // 显式设置初始大小比例
    splitter->setSizes({230, 230, 600, 230, 230});

    contentLayout->addWidget(splitter);
    mainLayout->addWidget(contentWidget);

    m_partitionTree->installEventFilter(this);

    m_quickPreview = new QuickPreview(this);
    connect(m_quickPreview, &QuickPreview::editRequested, this, [this](int id){
        NoteEditWindow* win = new NoteEditWindow(id);
        connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
        win->show();
    });
    connect(m_quickPreview, &QuickPreview::prevRequested, this, [this](){
        QModelIndex current = m_noteList->currentIndex();
        if (!current.isValid() || m_noteModel->rowCount() == 0) return;

        int catId = current.data(NoteModel::CategoryIdRole).toInt();
        int row = current.row();
        int count = m_noteModel->rowCount();
        
        // 循环向上查找相同分类
        for (int i = 1; i <= count; ++i) {
            int prevRow = (row - i + count) % count;
            QModelIndex idx = m_noteModel->index(prevRow, 0);
            if (idx.data(NoteModel::CategoryIdRole).toInt() == catId) {
                m_noteList->setCurrentIndex(idx);
                m_noteList->scrollTo(idx);
                updatePreviewContent();
                if (prevRow > row) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "已回环至列表末尾相同分类");
                }
                return;
            }
        }
    });
    connect(m_quickPreview, &QuickPreview::nextRequested, this, [this](){
        QModelIndex current = m_noteList->currentIndex();
        if (!current.isValid() || m_noteModel->rowCount() == 0) return;

        int catId = current.data(NoteModel::CategoryIdRole).toInt();
        int row = current.row();
        int count = m_noteModel->rowCount();

        // 循环向下查找相同分类
        for (int i = 1; i <= count; ++i) {
            int nextRow = (row + i) % count;
            QModelIndex idx = m_noteModel->index(nextRow, 0);
            if (idx.data(NoteModel::CategoryIdRole).toInt() == catId) {
                m_noteList->setCurrentIndex(idx);
                m_noteList->scrollTo(idx);
                updatePreviewContent();
                if (nextRow < row) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "已回环至列表起始相同分类");
                }
                return;
            }
        }
    });
    connect(m_quickPreview, &QuickPreview::historyNavigationRequested, this, [this](int id){
        // 在模型中查找此 ID 的行
        for (int i = 0; i < m_noteModel->rowCount(); ++i) {
            QModelIndex idx = m_noteModel->index(i, 0);
            if (idx.data(NoteModel::IdRole).toInt() == id) {
                m_noteList->setCurrentIndex(idx);
                m_noteList->scrollTo(idx);
                // 注意：setCurrentIndex 会触发 onSelectionChanged -> updatePreviewContent
                return;
            }
        }
        // 如果在当前列表中没找到（可能被过滤了），则直接更新预览内容而不切换列表选中项
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        if (!note.isEmpty()) {
            m_quickPreview->showPreview(
                id,
                note.value("title").toString(),
                note.value("content").toString(),
                note.value("item_type").toString(),
                note.value("data_blob").toByteArray(),
                m_quickPreview->pos(),
                "" // 分类名暂时留空或根据需要查询
            );
        }
    });

    m_noteList->installEventFilter(this);
}

void MainWindow::showEvent(QShowEvent* event) {
    QMainWindow::showEvent(event);
    // 从 HeaderBar 获取按钮状态
    if (m_header) {
        auto* btn = m_header->findChild<QPushButton*>("btnStayOnTop");
        if (btn && btn->isChecked()) {
#ifdef Q_OS_WIN
            HWND hwnd = (HWND)winId();
            SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
            Qt::WindowFlags f = windowFlags();
            f |= Qt::WindowStaysOnTopHint;
            setWindowFlags(f);
            show();
#endif
        }
    }
}

#ifdef Q_OS_WIN
bool MainWindow::nativeEvent(const QByteArray &eventType, void *message, qintptr *result) {
    MSG* msg = static_cast<MSG*>(message);
    if (msg->message == WM_NCHITTEST) {
        int x = GET_X_LPARAM(msg->lParam);
        int y = GET_Y_LPARAM(msg->lParam);
        
        QPoint pos = mapFromGlobal(QPoint(x, y));
        int margin = RESIZE_MARGIN;
        int w = width();
        int h = height();

        bool left = pos.x() < margin;
        bool right = pos.x() > w - margin;
        bool top = pos.y() < margin;
        bool bottom = pos.y() > h - margin;

        if (top && left) *result = HTTOPLEFT;
        else if (top && right) *result = HTTOPRIGHT;
        else if (bottom && left) *result = HTBOTTOMLEFT;
        else if (bottom && right) *result = HTBOTTOMRIGHT;
        else if (top) *result = HTTOP;
        else if (bottom) *result = HTBOTTOM;
        else if (left) *result = HTLEFT;
        else if (right) *result = HTRIGHT;
        else return QMainWindow::nativeEvent(eventType, message, result);

        return true;
    }
    return QMainWindow::nativeEvent(eventType, message, result);
}
#endif

void MainWindow::onNoteAdded(const QVariantMap& note) {
    m_noteModel->prependNote(note);
    m_noteList->scrollToTop();
}

void MainWindow::scheduleRefresh() {
    m_refreshTimer->start();
}

void MainWindow::refreshData() {
    // 保存当前选中项状态以供恢复
    QString selectedType;
    QVariant selectedValue;
    QModelIndex sysIdx = m_systemTree->currentIndex();
    QModelIndex partIdx = m_partitionTree->currentIndex();
    
    // 记忆当前选中的笔记 ID 列表，以便在刷新后恢复多选状态
    QSet<int> selectedNoteIds;
    auto selectedIndices = m_noteList->selectionModel()->selectedIndexes();
    for (const auto& idx : selectedIndices) {
        selectedNoteIds.insert(idx.data(NoteModel::IdRole).toInt());
    }
    int lastCurrentNoteId = m_noteList->currentIndex().data(NoteModel::IdRole).toInt();

    if (sysIdx.isValid()) {
        selectedType = sysIdx.data(CategoryModel::TypeRole).toString();
        selectedValue = sysIdx.data(CategoryModel::NameRole);
    } else if (partIdx.isValid()) {
        selectedType = partIdx.data(CategoryModel::TypeRole).toString();
        selectedValue = partIdx.data(CategoryModel::IdRole);
    }

    QSet<QString> expandedPaths;
    std::function<void(const QModelIndex&)> checkChildren = [&](const QModelIndex& parent) {
        for (int j = 0; j < m_partitionModel->rowCount(parent); ++j) {
            QModelIndex child = m_partitionModel->index(j, 0, parent);
            if (m_partitionTree->isExpanded(child)) {
                QString type = child.data(CategoryModel::TypeRole).toString();
                if (type == "category") {
                    expandedPaths.insert("cat_" + QString::number(child.data(CategoryModel::IdRole).toInt()));
                } else {
                    expandedPaths.insert(child.data(CategoryModel::NameRole).toString());
                }
            }
            if (m_partitionModel->rowCount(child) > 0) checkChildren(child);
        }
    };

    for (int i = 0; i < m_partitionModel->rowCount(); ++i) {
        QModelIndex index = m_partitionModel->index(i, 0);
        if (m_partitionTree->isExpanded(index)) {
            expandedPaths.insert(index.data(CategoryModel::NameRole).toString());
        }
        checkChildren(index);
    }

    QVariantMap criteria = m_filterPanel->getCheckedCriteria();
    auto notes = DatabaseManager::instance().searchNotes(m_currentKeyword, m_currentFilterType, m_currentFilterValue, m_currentPage, m_pageSize, criteria);
    int totalCount = DatabaseManager::instance().getNotesCount(m_currentKeyword, m_currentFilterType, m_currentFilterValue, criteria);

    // 检查当前分类是否锁定
    bool isLocked = false;
    if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
        int catId = m_currentFilterValue.toInt();
        if (DatabaseManager::instance().isCategoryLocked(catId)) {
            isLocked = true;
            QString hint;
            auto cats = DatabaseManager::instance().getAllCategories();
            for(const auto& c : std::as_const(cats)) if(c.value("id").toInt() == catId) hint = c.value("password_hint").toString();
            m_lockWidget->setCategory(catId, hint);
        }
    }

    m_noteList->setVisible(!isLocked);
    m_lockWidget->setVisible(isLocked);

    if (isLocked) {
        m_editor->setPlainText("");
        m_metaPanel->clearSelection();
    }

    m_noteModel->setNotes(isLocked ? QList<QVariantMap>() : notes);

    // 恢复笔记选中状态 (支持多选恢复)
    if (!selectedNoteIds.isEmpty()) {
        QItemSelection selection;
        for (int i = 0; i < m_noteModel->rowCount(); ++i) {
            QModelIndex idx = m_noteModel->index(i, 0);
            int id = idx.data(NoteModel::IdRole).toInt();
            if (selectedNoteIds.contains(id)) {
                selection.select(idx, idx);
            }
            if (id == lastCurrentNoteId) {
                m_noteList->setCurrentIndex(idx);
            }
        }
        if (!selection.isEmpty()) {
            m_noteList->selectionModel()->select(selection, QItemSelectionModel::Select | QItemSelectionModel::Rows);
        }
    }

    m_systemModel->refresh();
    m_partitionModel->refresh();

    int totalPages = (totalCount + m_pageSize - 1) / m_pageSize;
    if (totalPages < 1) totalPages = 1;
    m_header->updatePagination(m_currentPage, totalPages);

    // 恢复系统项选中
    if (!selectedType.isEmpty() && selectedType != "category") {
        for (int i = 0; i < m_systemModel->rowCount(); ++i) {
            QModelIndex idx = m_systemModel->index(i, 0);
            if (idx.data(CategoryModel::TypeRole).toString() == selectedType &&
                idx.data(CategoryModel::NameRole) == selectedValue) {
                m_systemTree->setCurrentIndex(idx);
                break;
            }
        }
    }

    // 恢复分区选中与展开
    for (int i = 0; i < m_partitionModel->rowCount(); ++i) {
        QModelIndex index = m_partitionModel->index(i, 0);
        QString name = index.data(CategoryModel::NameRole).toString();

        if (name == "我的分区" || expandedPaths.contains(name)) {
            m_partitionTree->setExpanded(index, true);
        }
        
        std::function<void(const QModelIndex&)> restoreChildren = [&](const QModelIndex& parent) {
            for (int j = 0; j < m_partitionModel->rowCount(parent); ++j) {
                QModelIndex child = m_partitionModel->index(j, 0, parent);
                QString cType = child.data(CategoryModel::TypeRole).toString();
                QString cName = child.data(CategoryModel::NameRole).toString();
                
                // 恢复选中
                if (!selectedType.isEmpty() && cType == "category" && child.data(CategoryModel::IdRole) == selectedValue) {
                    m_partitionTree->setCurrentIndex(child);
                }

                QString identifier = (cType == "category") ? 
                    ("cat_" + QString::number(child.data(CategoryModel::IdRole).toInt())) : cName;

                if (expandedPaths.contains(identifier) || (parent.data(CategoryModel::NameRole).toString() == "我的分区")) {
                    m_partitionTree->setExpanded(child, true);
                }
                if (m_partitionModel->rowCount(child) > 0) restoreChildren(child);
            }
        };
        restoreChildren(index);
    }

    if (!m_filterWrapper->isHidden()) {
        m_filterPanel->updateStats(m_currentKeyword, m_currentFilterType, m_currentFilterValue);
    }
}

void MainWindow::onNoteSelected(const QModelIndex& index) {
}

void MainWindow::onSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected) {
    QModelIndexList indices = m_noteList->selectionModel()->selectedIndexes();
    if (indices.isEmpty()) {
        m_metaPanel->clearSelection();
        m_editor->setPlainText("");
        m_editLockBtn->setEnabled(false);
        m_editLockBtn->setChecked(false);
        m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#555555"));
        m_editLockBtn->setToolTip("请先选择一条笔记以启用编辑");
    } else if (indices.size() == 1) {
        int id = indices.first().data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        
        // 记录访问
        DatabaseManager::instance().recordAccess(id);

        m_editor->setNote(note, true);
        m_metaPanel->setNote(note);
        m_editLockBtn->setEnabled(true);
        // 切换笔记时自动退出编辑模式，防止误操作或内容丢失
        m_editLockBtn->setChecked(false);
        m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#aaaaaa"));
        m_editLockBtn->setToolTip("点击进入编辑模式");

        // 联动更新预览窗口
        if (m_quickPreview->isVisible()) {
            updatePreviewContent();
        }
    } else {
        m_metaPanel->setMultipleNotes(indices.size());
        m_editor->setPlainText(QString("已选中 %1 条笔记").arg(indices.size()));
        m_editLockBtn->setEnabled(false);
        m_editLockBtn->setChecked(false);
        m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#555555"));
        m_editLockBtn->setToolTip("多选状态下不可直接编辑");
    }
}

void MainWindow::setupShortcuts() {
    auto add = [&](const QString& id, std::function<void()> func) {
        auto* sc = new QShortcut(ShortcutManager::instance().getShortcut(id), this, func);
        sc->setProperty("id", id);
    };

    add("mw_filter", [this](){ emit m_header->filterRequested(); });
    // [CRITICAL] 使用 ApplicationShortcut 确保在子窗口（如预览窗）获得焦点时也能触发
    auto* previewSc = new QShortcut(ShortcutManager::instance().getShortcut("mw_preview"), this, [this](){ doPreview(); }, Qt::ApplicationShortcut);
    previewSc->setProperty("id", "mw_preview");
    add("mw_meta", [this](){ 
        bool current = m_metaPanel->isVisible();
        emit m_header->metadataToggled(!current); 
    });
    add("mw_refresh", [this](){ refreshData(); });
    add("mw_search", [this](){ m_header->focusSearch(); });
    add("mw_new", [this](){ doNewIdea(); });
    add("mw_favorite", [this](){ doToggleFavorite(); });
    add("mw_pin", [this](){ doTogglePin(); });
    add("mw_save", [this](){ 
        if(m_editLockBtn->isChecked()) saveCurrentNote(); 
        else doLockSelected();
    });
    add("mw_edit", [this](){ doEditSelected(); });
    add("mw_extract", [this](){ doExtractContent(); });
    add("mw_lock_cat", [this](){
        if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
            DatabaseManager::instance().lockCategory(m_currentFilterValue.toInt());
            refreshData();
        }
    });
    add("mw_delete_soft", [this](){ doDeleteSelected(false); });
    add("mw_delete_hard", [this](){ doDeleteSelected(true); });
    add("mw_copy_tags", [this](){ doCopyTags(); });
    add("mw_paste_tags", [this](){ doPasteTags(); });
    add("mw_close", [this](){ close(); });

    for (int i = 0; i <= 5; ++i) {
        add(QString("mw_rating_%1").arg(i), [this, i](){ doSetRating(i); });
    }
}

void MainWindow::updateShortcuts() {
    // Note: m_shortcutActions was partially used in old version, but we should use QShortcut list
    // Let's fix the member variable usage to match NoteEditWindow/QuickWindow style
    auto shortcuts = findChildren<QShortcut*>();
    for (auto* sc : shortcuts) {
        QString id = sc->property("id").toString();
        if (!id.isEmpty()) {
            sc->setKey(ShortcutManager::instance().getShortcut(id));
        }
    }
}

void MainWindow::keyPressEvent(QKeyEvent* event) {
    QMainWindow::keyPressEvent(event);
}

bool MainWindow::eventFilter(QObject* watched, QEvent* event) {
    if (watched == m_partitionTree && event->type() == QEvent::KeyPress) {
        QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
        int key = keyEvent->key();
        auto modifiers = keyEvent->modifiers();

        if ((key == Qt::Key_Up || key == Qt::Key_Down) && (modifiers & Qt::ControlModifier)) {
            QModelIndex current = m_partitionTree->currentIndex();
            if (current.isValid() && current.data(CategoryModel::TypeRole).toString() == "category") {
                int catId = current.data(CategoryModel::IdRole).toInt();
                DatabaseManager::MoveDirection dir;
                
                if (key == Qt::Key_Up) {
                    dir = (modifiers & Qt::ShiftModifier) ? DatabaseManager::Top : DatabaseManager::Up;
                } else {
                    dir = (modifiers & Qt::ShiftModifier) ? DatabaseManager::Bottom : DatabaseManager::Down;
                }

                if (DatabaseManager::instance().moveCategory(catId, dir)) {
                    refreshData();
                    // 重新选中该分类 (refreshData 会刷新整个模型)
                    // 注意：refreshData 内部有恢复选中的逻辑，但它是基于 NameRole 的。
                    // 既然 sort_order 变了，我们需要确保它还在选中状态。
                    return true;
                }
            }
        }
    }

    return QMainWindow::eventFilter(watched, event);
}

void MainWindow::onTagSelected(const QModelIndex& index) {
    m_currentFilterType = index.data(CategoryModel::TypeRole).toString();
    if (m_currentFilterType == "category") {
        m_currentFilterValue = index.data(CategoryModel::IdRole).toInt();
        StringUtils::recordRecentCategory(m_currentFilterValue.toInt());
    } else {
        m_currentFilterValue = -1;
    }
    m_currentPage = 1;
    refreshData();
}

void MainWindow::showContextMenu(const QPoint& pos) {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) {
        QModelIndex index = m_noteList->indexAt(pos);
        if (index.isValid()) {
            m_noteList->setCurrentIndex(index);
            selected << index;
        } else {
            return;
        }
    }

    int selCount = selected.size();
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    if (selCount == 1) {
        menu.addAction(IconHelper::getIcon("eye", "#1abc9c", 18), "预览 (Space)", this, &MainWindow::doPreview);
        
        QString type = selected.first().data(NoteModel::TypeRole).toString();
        if (type == "image") {
            menu.addAction(IconHelper::getIcon("screenshot_ocr", "#3498db", 18), "从图提取文字", this, &MainWindow::doOCR);
        }
    }
    
    menu.addAction(IconHelper::getIcon("copy", "#1abc9c", 18), QString("复制内容 (%1)").arg(selCount), this, &MainWindow::doExtractContent);
    menu.addSeparator();

    if (selCount == 1) {
        menu.addAction(IconHelper::getIcon("edit", "#4a90e2", 18), "编辑 (Ctrl+B)", this, &MainWindow::doEditSelected);
        menu.addSeparator();
    }

    auto* ratingMenu = menu.addMenu(IconHelper::getIcon("star", "#f39c12", 18), QString("设置星级 (%1)").arg(selCount));
    ratingMenu->setStyleSheet(menu.styleSheet());
    auto* starGroup = new QActionGroup(this);
    int currentRating = (selCount == 1) ? selected.first().data(NoteModel::RatingRole).toInt() : -1;
    
    for (int i = 1; i <= 5; ++i) {
        QString stars = QString("★").repeated(i);
        QAction* action = ratingMenu->addAction(stars, [this, i]() { doSetRating(i); });
        action->setCheckable(true);
        if (i == currentRating) action->setChecked(true);
        starGroup->addAction(action);
    }
    ratingMenu->addSeparator();
    ratingMenu->addAction("清除评级", [this]() { doSetRating(0); });

    bool isFavorite = (selCount == 1) && selected.first().data(NoteModel::FavoriteRole).toBool();
    menu.addAction(IconHelper::getIcon(isFavorite ? "bookmark_filled" : "bookmark", "#ff6b81", 18), 
                   isFavorite ? "取消书签" : "添加书签 (Ctrl+E)", this, &MainWindow::doToggleFavorite);

    bool isPinned = (selCount == 1) && selected.first().data(NoteModel::PinnedRole).toBool();
    menu.addAction(IconHelper::getIcon(isPinned ? "pin_vertical" : "pin_tilted", isPinned ? "#3A90FF" : "#aaaaaa", 18), 
                   isPinned ? "取消置顶" : "置顶选中项 (Ctrl+P)", this, &MainWindow::doTogglePin);
    
    bool isLocked = (selCount == 1) && selected.first().data(NoteModel::LockedRole).toBool();
    menu.addAction(IconHelper::getIcon("lock", isLocked ? "#aaaaaa" : "#888888", 18), 
                   isLocked ? "解锁选中项" : "锁定选中项 (Ctrl+S)", this, &MainWindow::doLockSelected);
    
    menu.addSeparator();

    auto* catMenu = menu.addMenu(IconHelper::getIcon("branch", "#cccccc", 18), QString("移动选中项到分类 (%1)").arg(selCount));
    catMenu->setStyleSheet(menu.styleSheet());
    catMenu->addAction(IconHelper::getIcon("uncategorized", "#e67e22", 18), "未分类", [this]() { doMoveToCategory(-1); });
    
    QVariantList recentCats = StringUtils::getRecentCategories();
    auto allCategories = DatabaseManager::instance().getAllCategories();
    QMap<int, QVariantMap> catMap;
    for (const auto& cat : std::as_const(allCategories)) catMap[cat.value("id").toInt()] = cat;

    int count = 0;
    for (const auto& v : std::as_const(recentCats)) {
        if (count >= 10) break;
        int cid = v.toInt();
        if (catMap.contains(cid)) {
            const auto& cat = catMap.value(cid);
            catMenu->addAction(IconHelper::getIcon("branch", cat.value("color").toString(), 18), cat.value("name").toString(), [this, cid]() {
                doMoveToCategory(cid);
            });
            count++;
        }
    }

    menu.addSeparator();
    if (m_currentFilterType == "trash") {
        menu.addAction(IconHelper::getIcon("refresh", "#2ecc71", 18), "恢复 (还原到未分类)", [this, selected](){
            QList<int> ids;
            for (const auto& index : selected) ids << index.data(NoteModel::IdRole).toInt();
            DatabaseManager::instance().moveNotesToCategory(ids, -1);
            refreshData();
        });
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "彻底删除 (不可逆)", [this](){ doDeleteSelected(true); });
    } else {
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "移至回收站 (Delete)", [this](){ doDeleteSelected(false); });
    }

    menu.exec(QCursor::pos());
}

void MainWindow::closeEvent(QCloseEvent* event) {
    saveLayout();
    QMainWindow::closeEvent(event);
}

void MainWindow::saveLayout() {
    QSettings settings("RapidNotes", "MainWindow");
    settings.setValue("geometry", saveGeometry());
    settings.setValue("windowState", saveState());

    if (m_header) {
        auto* btn = m_header->findChild<QPushButton*>("btnStayOnTop");
        if (btn) {
            settings.setValue("stayOnTop", btn->isChecked());
        }
    }
    
    QSplitter* splitter = findChild<QSplitter*>();
    if (splitter) {
        settings.setValue("splitterState", splitter->saveState());
    }

    // 保存面板可见性
    settings.setValue("showFilter", m_filterWrapper->isVisible());
    settings.setValue("showMetadata", m_metaPanel->isVisible());
}

void MainWindow::restoreLayout() {
    QSettings settings("RapidNotes", "MainWindow");
    if (settings.contains("geometry")) {
        restoreGeometry(settings.value("geometry").toByteArray());
    }
    if (settings.contains("windowState")) {
        restoreState(settings.value("windowState").toByteArray());
    }
    
    QSplitter* splitter = findChild<QSplitter*>();
    if (splitter && settings.contains("splitterState")) {
        splitter->restoreState(settings.value("splitterState").toByteArray());
    }

    // 恢复面板可见性
    bool showFilter = settings.value("showFilter", true).toBool();
    bool showMetadata = settings.value("showMetadata", true).toBool();
    
    m_filterWrapper->setVisible(showFilter);
    m_header->setFilterActive(showFilter);
    
    m_metaPanel->setVisible(showMetadata);
    m_header->setMetadataActive(showMetadata);

    bool stayOnTop = settings.value("stayOnTop", false).toBool();
    auto* btnStay = m_header->findChild<QPushButton*>("btnStayOnTop");
    if (btnStay) {
        btnStay->setChecked(stayOnTop);
        // 手动应用图标 (HeaderBar 不会自动切换图标，除非触发 toggled 信号)
        btnStay->setIcon(IconHelper::getIcon(stayOnTop ? "pin_vertical" : "pin_tilted", stayOnTop ? "#ffffff" : "#aaaaaa", 20));
        
        if (stayOnTop) {
            #ifdef Q_OS_WIN
            HWND hwnd = (HWND)winId();
            SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
            #else
            setWindowFlag(Qt::WindowStaysOnTopHint, true);
            #endif
        }
    }

    QSettings globalSettings("RapidNotes", "QuickWindow");
    m_autoCategorizeClipboard = globalSettings.value("autoCategorizeClipboard", false).toBool();
}

void MainWindow::showToolboxMenu(const QPoint& pos) {
    // 每次打开前刷新设置，确保与 QuickWindow 同步
    QSettings globalSettings("RapidNotes", "QuickWindow");
    m_autoCategorizeClipboard = globalSettings.value("autoCategorizeClipboard", false).toBool();

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    QString iconName = m_autoCategorizeClipboard ? "switch_on" : "switch_off";
    QString iconColor = m_autoCategorizeClipboard ? "#00A650" : "#000000";
    QAction* autoCatAction = menu.addAction(IconHelper::getIcon(iconName, iconColor, 18), "剪贴板自动归档到当前分类");
    autoCatAction->setCheckable(true);
    autoCatAction->setChecked(m_autoCategorizeClipboard);
    connect(autoCatAction, &QAction::triggered, [this](bool checked){
        m_autoCategorizeClipboard = checked;
        QSettings settings("RapidNotes", "QuickWindow");
        settings.setValue("autoCategorizeClipboard", m_autoCategorizeClipboard);
        ToolTipOverlay::instance()->showText(QCursor::pos(), m_autoCategorizeClipboard ? "✅ 剪贴板自动归档已开启" : "❌ 剪贴板自动归档已关闭");
    });

    menu.addSeparator();
    
    menu.addAction(IconHelper::getIcon("save", "#aaaaaa", 18), "存储文件 (拖拽入库)", [this]() {
        emit fileStorageRequested();
    });

    menu.addAction(IconHelper::getIcon("settings", "#aaaaaa", 18), "更多设置...", [this]() {
        auto* dlg = new SettingsWindow(this);
        dlg->setAttribute(Qt::WA_DeleteOnClose);
        // 预定位：居中于主窗口
        dlg->move(this->geometry().center() - dlg->rect().center());
        dlg->exec();
    });

    menu.exec(pos);
}

void MainWindow::doPreview() {
    // 增加防抖保护，防止由于快捷键冲突（子窗口与主窗口同时响应）导致的“双重触发”现象
    // 这种现象表现为：按下空格后预览窗刚隐藏又被立即打开，看起来没反应
    static QElapsedTimer timer;
    if (timer.isValid() && timer.elapsed() < 200) {
        return;
    }
    timer.restart();

    QWidget* focusWidget = QApplication::focusWidget();
    // 保护：如果焦点在输入框，空格键应保留其原始打字功能
    // 但如果焦点在预览窗口内部（例如预览只读文本框），则不视为正在输入，允许切换预览
    if (focusWidget && (qobject_cast<QLineEdit*>(focusWidget) || 
                        qobject_cast<QTextEdit*>(focusWidget) ||
                        qobject_cast<QPlainTextEdit*>(focusWidget))) {
        if (focusWidget != m_quickPreview && !m_quickPreview->isAncestorOf(focusWidget)) {
            return;
        }
    }

    if (m_quickPreview->isVisible()) {
        m_quickPreview->hide();
        return;
    }
    
    updatePreviewContent();
    
    m_quickPreview->raise();
    m_quickPreview->activateWindow();
}

void MainWindow::updatePreviewContent() {
    QModelIndex index = m_noteList->currentIndex();
    if (!index.isValid()) return;
    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    
    QPoint pos;
    if (m_quickPreview->isVisible()) {
        pos = m_quickPreview->pos();
    } else {
        pos = m_noteList->mapToGlobal(m_noteList->rect().center()) - QPoint(250, 300);
    }

    m_quickPreview->showPreview(
        id,
        note.value("title").toString(), 
        note.value("content").toString(), 
        note.value("item_type").toString(),
        note.value("data_blob").toByteArray(),
        pos,
        index.data(NoteModel::CategoryNameRole).toString()
    );
}

void MainWindow::doDeleteSelected(bool physical) {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    bool inTrash = (m_currentFilterType == "trash");
    
    if (physical || inTrash) {
        QString title = inTrash ? "清空项目" : "彻底删除";
        QString text = QString("确定要永久删除选中的 %1 条数据吗？\n此操作不可逆，数据将无法找回。").arg(selected.count());
        
        auto* msg = new FramelessMessageBox(title, text, this);
        QList<int> idsToDelete;
        for (const auto& index : std::as_const(selected)) idsToDelete << index.data(NoteModel::IdRole).toInt();
        
        connect(msg, &FramelessMessageBox::confirmed, this, [this, idsToDelete]() {
            if (idsToDelete.isEmpty()) return;
            DatabaseManager::instance().deleteNotesBatch(idsToDelete);
            refreshData();
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已永久删除 %1 条数据").arg(idsToDelete.size()));
        });
        msg->show();
    } else {
        QList<int> ids;
        for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().softDeleteNotes(ids);
        refreshData();
    }
}

void MainWindow::doToggleFavorite() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().toggleNoteState(id, "is_favorite");
    }
    refreshData();
}

void MainWindow::doTogglePin() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().toggleNoteState(id, "is_pinned");
    }
    refreshData();
}

void MainWindow::doLockSelected() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    
    bool firstState = selected.first().data(NoteModel::LockedRole).toBool();
    bool targetState = !firstState;

    QList<int> ids;
    for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
    
    DatabaseManager::instance().updateNoteStateBatch(ids, "is_locked", targetState);
    refreshData();
}

void MainWindow::doNewIdea() {
    NoteEditWindow* win = new NoteEditWindow();
    connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
    win->show();
}

void MainWindow::doOCR() {
    QModelIndex index = m_noteList->currentIndex();
    if (!index.isValid()) return;

    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    if (note.value("item_type").toString() != "image") return;

    QByteArray data = note.value("data_blob").toByteArray();
    QImage img;
    img.loadFromData(data);
    if (img.isNull()) return;

    auto* resWin = new OCRResultWindow(img, id);
    connect(&OCRManager::instance(), &OCRManager::recognitionFinished, resWin, &OCRResultWindow::setRecognizedText);
    
    QSettings settings("RapidNotes", "OCR");
    if (settings.value("autoCopy", false).toBool()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "⏳ 正在识别文字...");
    } else {
        resWin->show();
    }
    
    OCRManager::instance().recognizeAsync(img, id);
}

void MainWindow::doExtractContent() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    QStringList texts;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        QString type = note.value("item_type").toString();
        if (type == "text" || type.isEmpty()) {
            QString content = note.value("content").toString();
            texts << StringUtils::htmlToPlainText(content);
        }
    }
    if (!texts.isEmpty()) {
        ClipboardMonitor::instance().skipNext();
        QApplication::clipboard()->setText(texts.join("\n---\n"));
    }
}

void MainWindow::doEditSelected() {
    QModelIndex index = m_noteList->currentIndex();
    if (!index.isValid()) return;
    int id = index.data(NoteModel::IdRole).toInt();
    NoteEditWindow* win = new NoteEditWindow(id);
    connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
    win->show();
}

void MainWindow::doSetRating(int rating) {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().updateNoteState(id, "rating", rating);
    }
    refreshData();
}

void MainWindow::doMoveToCategory(int catId) {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QList<int> ids;
    for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
    
    DatabaseManager::instance().moveNotesToCategory(ids, catId);
    
    if (catId != -1) {
        StringUtils::recordRecentCategory(catId);
    }
    refreshData();
}

void MainWindow::saveCurrentNote() {
    QModelIndex index = m_noteList->currentIndex();
    if (!index.isValid()) return;
    int id = index.data(NoteModel::IdRole).toInt();
    
    QString content = m_editor->toHtml();
    
    // 保存前锁定剪贴板监控，防止自触发 (虽然 updateNoteState 不直接操作剪贴板，但为了严谨性)
    // 实际上 updateNoteState 会触发 noteUpdated，不会引起剪贴板变化。
    
    DatabaseManager::instance().updateNoteState(id, "content", content);
    DatabaseManager::instance().recordAccess(id);
    
    // 退出编辑模式
    m_editLockBtn->setChecked(false);
    refreshData();
    ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 内容已保存");
}

void MainWindow::toggleSearchBar() {
    m_editorSearchBar->setVisible(!m_editorSearchBar->isVisible());
    if (m_editorSearchBar->isVisible()) {
        m_editorSearchEdit->setFocus();
        m_editorSearchEdit->selectAll();
    }
}

void MainWindow::doCopyTags() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    // 获取选中的第一个项的标签
    int id = selected.first().data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    QString tagsStr = note.value("tags").toString();
    QStringList tags = tagsStr.split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
    for (QString& t : tags) t = t.trimmed();

    DatabaseManager::setTagClipboard(tags);
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✅ 已复制 %1 个标签").arg(tags.size()));
}

void MainWindow::doPasteTags() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QStringList tagsToPaste = DatabaseManager::getTagClipboard();
    if (tagsToPaste.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "❌ 标签剪贴板为空");
        return;
    }

    // 直接覆盖标签 (符合粘贴语义)
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().updateNoteState(id, "tags", tagsToPaste.join(", "));
    }

    // 刷新数据以显示新标签
    refreshData();
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✅ 已覆盖粘贴标签至 %1 条数据").arg(selected.size()));
}
```

## 文件: `src/ui/MainWindow.h`

```cpp
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QTreeView>
#include <QListView>
#include <QSplitter>
#include <QStandardItemModel>
#include <QTimer>
#include <QFileInfo>
#include "../models/NoteModel.h"
#include "../models/CategoryModel.h"
#include "Editor.h"
#include "NoteEditWindow.h"
#include "HeaderBar.h"
#include "MetadataPanel.h"
#include "QuickPreview.h"
#include "DropTreeView.h"
#include "FilterPanel.h"
#include "CategoryLockWidget.h"
#include "FileStorageWindow.h"

#ifdef Q_OS_WIN
#include <windows.h>
#include <windowsx.h>
#endif

class MainWindow : public QMainWindow {
    Q_OBJECT
public:
    explicit MainWindow(QWidget* parent = nullptr);
    int getCurrentCategoryId() const {
        if (m_currentFilterType == "category") return m_currentFilterValue.toInt();
        return -1;
    }

signals:
    void toolboxRequested();
    void fileStorageRequested();
    void globalLockRequested();

private slots:
    void onNoteSelected(const QModelIndex& index);
    void onSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected);
    void onTagSelected(const QModelIndex& index);
    void showContextMenu(const QPoint& pos);
    
    // Layout persistence
    void saveLayout();
    void restoreLayout();
    void updateShortcuts();

    // 【新增】处理单条笔记添加，不刷新全表
    void onNoteAdded(const QVariantMap& note);
    
    void refreshData();
    void scheduleRefresh();
    void doPreview();
    void updatePreviewContent();
    void showToolboxMenu(const QPoint& pos);

    // 快捷键处理与操作逻辑 (同步 QuickWindow)
    void doDeleteSelected(bool physical = false);
    void doToggleFavorite();
    void doTogglePin();
    void doLockSelected();
    void doNewIdea();
    void doExtractContent();
    void doOCR();
    void doEditSelected();
    void doSetRating(int rating);
    void doMoveToCategory(int catId);
    void saveCurrentNote();
    void toggleSearchBar();
    void doCopyTags();
    void doPasteTags();

protected:
#ifdef Q_OS_WIN
    bool nativeEvent(const QByteArray &eventType, void *message, qintptr *result) override;
#endif
    void showEvent(QShowEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void closeEvent(QCloseEvent* event) override;

private:
    void initUI();
    void setupShortcuts();
    
    DropTreeView* m_systemTree;
    CategoryModel* m_systemModel;
    DropTreeView* m_partitionTree;
    CategoryModel* m_partitionModel;
    QWidget* m_sidebarContainer;
    
    QListView* m_noteList;
    NoteModel* m_noteModel;

    HeaderBar* m_header;
    MetadataPanel* m_metaPanel;
    QuickPreview* m_quickPreview;
    FilterPanel* m_filterPanel;
    QWidget* m_filterWrapper;
    
    Editor* m_editor;
    CategoryLockWidget* m_lockWidget;
    QPushButton* m_editLockBtn;
    QWidget* m_editorToolbar;
    QWidget* m_editorSearchBar;
    QLineEdit* m_editorSearchEdit;

    QString m_currentKeyword;
    QString m_currentFilterType = "all";
    QVariant m_currentFilterValue = -1;
    int m_currentPage = 1;
    int m_pageSize = 100;
    bool m_autoCategorizeClipboard = false;
    QTimer* m_searchTimer;
    QTimer* m_refreshTimer;
};

#endif // MAINWINDOW_H
```

## 文件: `src/core/MessageCaptureHandler.cpp`

```cpp
#include "MessageCaptureHandler.h"
#include "KeyboardHook.h"
#include "DatabaseManager.h"
#include "ClipboardMonitor.h"
#include "Win32System.h"
#include <QClipboard>
#include <QApplication>
#include <QDebug>
#include <QDateTime>
#include <QTimer>
#include <QFileInfo>

#ifdef Q_OS_WIN
#include <windows.h>
#include <psapi.h>
#endif

MessageCaptureHandler& MessageCaptureHandler::instance() {
    static MessageCaptureHandler inst;
    return inst;
}

MessageCaptureHandler::MessageCaptureHandler(QObject* parent) : QObject(parent) {}

void MessageCaptureHandler::init() {
    connect(&KeyboardHook::instance(), &KeyboardHook::enterPressedInOtherApp, this, &MessageCaptureHandler::onEnterPressed);
    qDebug() << "[MessageCaptureHandler] 初始化完成，开始监听外部应用回车键";
}

void MessageCaptureHandler::onEnterPressed(bool ctrl, bool shift, bool alt) {
    // 简单的频率限制，防止长按回车或高频重复触发 (500ms 内仅一次)
    qint64 currentTime = QDateTime::currentMSecsSinceEpoch();
    if (currentTime - m_lastTriggerTime < 500) return;
    m_lastTriggerTime = currentTime;

    qDebug() << "[Capture] 触发捕获，C:" << ctrl << " S:" << shift << " A:" << alt;

    // 使用定时器序列，避免在 Hook 回调中执行过长的阻塞操作
    QTimer::singleShot(0, [this, ctrl, shift, alt]() {
        Win32System sys;
        
        // 告知剪贴板监控器跳过接下来的变更，由我们手动处理
        ClipboardMonitor::instance().skipNext();

        // 1. 模拟全选
        sys.simulateSelectAll();
        
        QTimer::singleShot(50, [this, ctrl, shift, alt]() {
            Win32System sys;
            // 2. 模拟复制
            sys.simulateCopy();
            
            QTimer::singleShot(150, [this, ctrl, shift, alt]() {
                QString text = QApplication::clipboard()->text().trimmed();
                
                Win32System sys;
                // 3. 模拟按下 END 键以取消全选状态，防止回车键删除选中的文字
                sys.simulateKeyStroke(VK_END);

                // 4. 补发原始回车键（带上原来的修饰键状态）
                sys.simulateKeyStroke(VK_RETURN, alt, ctrl, shift);

                if (text.isEmpty()) {
                    qDebug() << "[Capture] 捕获文本为空，取消保存";
                    return;
                }

                // 4. 获取来源应用信息
                QString sourceApp = "未知应用";
                QString sourceTitle = "未知窗口";
#ifdef Q_OS_WIN
                HWND hwnd = GetForegroundWindow();
                if (hwnd) {
                    wchar_t title[512];
                    if (GetWindowTextW(hwnd, title, 512)) {
                        sourceTitle = QString::fromWCharArray(title);
                    }
                    DWORD pid;
                    GetWindowThreadProcessId(hwnd, &pid);
                    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
                    if (hProcess) {
                        wchar_t exePath[MAX_PATH];
                        if (GetModuleFileNameExW(hProcess, NULL, exePath, MAX_PATH)) {
                            sourceApp = QFileInfo(QString::fromWCharArray(exePath)).baseName();
                        }
                        CloseHandle(hProcess);
                    }
                }
#endif

                // 5. 保存到数据库
                // 取第一行作为标题
                QString firstLine = text.section('\n', 0, 0).trimmed();
                QString title;
                if (firstLine.isEmpty()) {
                    title = "自动捕获消息";
                } else {
                    title = firstLine.left(40);
                    if (firstLine.length() > 40) title += "...";
                }
                
                // 使用特定的 item_type: captured_message
                DatabaseManager::instance().addNoteAsync(title, text, {"自动捕获"}, "", -1, "captured_message", QByteArray(), sourceApp, sourceTitle);
                qDebug() << "[Capture] 已保存捕获的消息:" << title;
            });
        });
    });
}
```

## 文件: `src/core/MessageCaptureHandler.h`

```cpp
#ifndef MESSAGECAPTUREHANDLER_H
#define MESSAGECAPTUREHANDLER_H

#include <QObject>

class MessageCaptureHandler : public QObject {
    Q_OBJECT
public:
    static MessageCaptureHandler& instance();
    void init();

private slots:
    void onEnterPressed(bool ctrl, bool shift, bool alt);

private:
    MessageCaptureHandler(QObject* parent = nullptr);
    qint64 m_lastTriggerTime = 0;
};

#endif // MESSAGECAPTUREHANDLER_H
```

## 文件: `src/ui/MetadataPanel.cpp`

```cpp
#include "MetadataPanel.h"
#include "AdvancedTagSelector.h"
#include "TitleEditorDialog.h"
#include "../core/DatabaseManager.h"
#include "IconHelper.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QFrame>
#include <QGraphicsDropShadowEffect>
#include <QApplication>
#include <QTextEdit>
#include <QDialog>
#include <QCursor>


// ==========================================
// MetadataPanel
// ==========================================
MetadataPanel::MetadataPanel(QWidget* parent) : QWidget(parent) {
    setMinimumWidth(230); // 最小宽度 230px，可拉伸
    setAttribute(Qt::WA_StyledBackground, true);
    setStyleSheet("background: transparent; border: none; outline: none;");
    initUI();
}

void MetadataPanel::initUI() {
    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0); // 移除外部边距，由 MainWindow 的 Splitter 统一控制

    // 内部卡片容器
    auto* container = new QFrame(this);
    container->setObjectName("MetadataContainer");
    container->setStyleSheet(
        "#MetadataContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );
    container->setAttribute(Qt::WA_StyledBackground, true);

    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(10);
    shadow->setXOffset(0);
    shadow->setYOffset(4);
    shadow->setColor(QColor(0, 0, 0, 150));
    container->setGraphicsEffect(shadow);

    auto* containerLayout = new QVBoxLayout(container);
    containerLayout->setContentsMargins(0, 0, 0, 0); // 设为 0 以允许标题栏拉伸到边缘
    containerLayout->setSpacing(0);

    // 1. 顶部标题栏 (锁定 32px，标准配色)
    auto* titleBar = new QWidget();
    titleBar->setObjectName("MetadataHeader");
    titleBar->setFixedHeight(32);
    titleBar->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #333;" // 统一通过 border 实现分割线
    );
    auto* titleLayout = new QHBoxLayout(titleBar);
    titleLayout->setContentsMargins(15, 0, 10, 0);
    titleLayout->setSpacing(8);

    auto* icon = new QLabel();
    icon->setPixmap(IconHelper::getIcon("all_data", "#4a90e2", 18).pixmap(18, 18));
    auto* lbl = new QLabel("元数据");
    lbl->setStyleSheet("font-size: 13px; font-weight: bold; color: #4a90e2; background: transparent; border: none;");
    titleLayout->addWidget(icon);
    titleLayout->addWidget(lbl);
    titleLayout->addStretch();

    auto* closeBtn = new QPushButton();
    closeBtn->setIcon(IconHelper::getIcon("close", "#888888"));
    closeBtn->setFixedSize(24, 24);
    closeBtn->setCursor(Qt::PointingHandCursor);
    closeBtn->setStyleSheet(
        "QPushButton { background-color: transparent; border: none; border-radius: 4px; }"
        "QPushButton:hover { background-color: #e74c3c; }"
    );
    connect(closeBtn, &QPushButton::clicked, this, [this](){
        hide();
        emit closed();
    });
    titleLayout->addWidget(closeBtn);
    containerLayout->addWidget(titleBar);

    // 3. 内容包裹容器 (带边距)
    auto* contentWidget = new QWidget();
    contentWidget->setStyleSheet(
        "QWidget { "
        "  background-color: transparent; "
        "  border: none; "
        "  border-bottom-left-radius: 0px; "
        "  border-bottom-right-radius: 0px; "
        "}"
    );
    auto* innerLayout = new QVBoxLayout(contentWidget);
    innerLayout->setContentsMargins(15, 10, 15, 15);
    innerLayout->setSpacing(10);

    m_stack = new QStackedWidget(this);
    m_stack->setStyleSheet("background-color: transparent;");
    
    m_stack->addWidget(createInfoWidget("select", "未选择项目", "请选择一个项目以查看其元数据"));
    m_stack->addWidget(createInfoWidget("all_data", "已选择多个项目", "请仅选择一项以查看其元数据"));
    
    m_metadataDisplayWidget = createMetadataDisplay();
    m_stack->addWidget(m_metadataDisplayWidget);
    
    innerLayout->addWidget(m_stack);

    // 标题输入框 (仅单选显示)
    m_titleEdit = new ClickableLineEdit();
    m_titleEdit->setPlaceholderText("标题");
    m_titleEdit->setStyleSheet(
        "background-color: rgba(255, 255, 255, 0.05); "
        "border: 1px solid rgba(255, 255, 255, 0.1); "
        "border-radius: 10px; "
        "color: #EEE; "
        "font-size: 13px; "
        "font-weight: bold; "
        "padding: 8px 12px; "
        "margin-top: 10px;"
    );
    connect(m_titleEdit, &QLineEdit::editingFinished, [this](){
        if(m_currentNoteId != -1) {
            DatabaseManager::instance().updateNoteState(m_currentNoteId, "title", m_titleEdit->text());
            emit noteUpdated();
        }
    });
    connect(m_titleEdit, &QLineEdit::returnPressed, m_titleEdit, &QWidget::clearFocus);
    connect(m_titleEdit, &ClickableLineEdit::doubleClicked, this, &MetadataPanel::openExpandedTitleEditor);
    innerLayout->addWidget(m_titleEdit);

    innerLayout->addStretch(1);

    m_separatorLine = new QFrame();
    m_separatorLine->setFrameShape(QFrame::HLine);
    m_separatorLine->setFrameShadow(QFrame::Plain);
    m_separatorLine->setStyleSheet("background-color: #505050; border: none; max-height: 1px; margin-bottom: 5px;");
    innerLayout->addWidget(m_separatorLine);

    // 标签输入框 (双击更多)
    m_tagEdit = new ClickableLineEdit();
    m_tagEdit->setPlaceholderText("输入标签添加... (双击更多)");
    m_tagEdit->setStyleSheet(
        "QLineEdit { background-color: rgba(255, 255, 255, 0.05); "
        "border: 1px solid rgba(255, 255, 255, 0.1); "
        "border-radius: 10px; "
        "padding: 8px 12px; "
        "font-size: 12px; "
        "color: #EEE; } "
        "QLineEdit:focus { border-color: #4a90e2; background-color: rgba(255, 255, 255, 0.08); } "
        "QLineEdit:disabled { background-color: transparent; border: 1px solid #333; color: #666; }"
    );
    connect(m_tagEdit, &QLineEdit::returnPressed, this, &MetadataPanel::handleTagInput);
    connect(m_tagEdit, &ClickableLineEdit::doubleClicked, this, &MetadataPanel::openTagSelector);
    innerLayout->addWidget(m_tagEdit);

    containerLayout->addWidget(contentWidget);
    mainLayout->addWidget(container);

    // 初始状态
    clearSelection();
}

QWidget* MetadataPanel::createInfoWidget(const QString& icon, const QString& title, const QString& subtitle) {
    auto* w = new QWidget();
    auto* layout = new QVBoxLayout(w);
    layout->setContentsMargins(20, 40, 20, 20);
    layout->setSpacing(15);
    layout->setAlignment(Qt::AlignCenter);

    auto* iconLabel = new QLabel();
    iconLabel->setPixmap(IconHelper::getIcon(icon, "#555", 64).pixmap(64, 64));
    iconLabel->setAlignment(Qt::AlignCenter);
    layout->addWidget(iconLabel);

    auto* titleLabel = new QLabel(title);
    titleLabel->setAlignment(Qt::AlignCenter);
    titleLabel->setStyleSheet("font-size: 14px; font-weight: bold; color: #e0e0e0;");
    layout->addWidget(titleLabel);

    auto* subLabel = new QLabel(subtitle);
    subLabel->setAlignment(Qt::AlignCenter);
    subLabel->setStyleSheet("font-size: 12px; color: #888;");
    subLabel->setWordWrap(true);
    layout->addWidget(subLabel);

    layout->addStretch();
    return w;
}

QWidget* MetadataPanel::createMetadataDisplay() {
    auto* w = new QWidget();
    auto* layout = new QVBoxLayout(w);
    layout->setContentsMargins(0, 5, 0, 5);
    layout->setSpacing(8);
    layout->setAlignment(Qt::AlignTop);

    layout->addWidget(createCapsule("创建于", "created"));
    layout->addWidget(createCapsule("更新于", "updated"));
    layout->addWidget(createCapsule("分类", "category"));
    layout->addWidget(createCapsule("状态", "status"));
    layout->addWidget(createCapsule("星级", "rating"));
    layout->addWidget(createCapsule("标签", "tags"));

    return w;
}

QWidget* MetadataPanel::createCapsule(const QString& label, const QString& key) {
    auto* row = new QWidget();
    row->setAttribute(Qt::WA_StyledBackground, true);
    auto* layout = new QHBoxLayout(row);
    layout->setContentsMargins(12, 8, 12, 8);
    layout->setSpacing(10);
    
    row->setStyleSheet(
        "QWidget { background-color: rgba(255, 255, 255, 0.05); "
        "border: 1px solid rgba(255, 255, 255, 0.1); "
        "border-radius: 10px; }"
    );
    
    auto* lbl = new QLabel(label);
    lbl->setStyleSheet("font-size: 11px; color: #AAA; border: none; min-width: 45px; background: transparent;");
    
    auto* val = new QLabel("-");
    val->setWordWrap(true);
    val->setStyleSheet("font-size: 12px; color: #FFF; border: none; font-weight: bold; background: transparent;");
    val->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);
    
    layout->addWidget(lbl);
    layout->addWidget(val);
    
    m_capsules[key] = val;
    return row;
}

void MetadataPanel::setNote(const QVariantMap& note) {
    if(note.isEmpty()) {
        clearSelection();
        return;
    }
    m_currentNoteId = note.value("id").toInt();
    m_stack->setCurrentIndex(2); // 详情页
    
    m_titleEdit->show();
    m_titleEdit->setText(note.value("title").toString());
    m_titleEdit->setCursorPosition(0);
    
    m_tagEdit->setEnabled(true);
    m_tagEdit->setPlaceholderText("输入标签添加... (双击更多)");
    m_separatorLine->show();

    m_capsules["created"]->setText(note.value("created_at").toString().left(16).replace("T", " "));
    m_capsules["updated"]->setText(note.value("updated_at").toString().left(16).replace("T", " "));
    
    int rating = note.value("rating").toInt();
    QString stars = QString("★").repeated(rating) + QString("☆").repeated(5 - rating);
    m_capsules["rating"]->setText(stars);
    
    QStringList status;
    if (note.value("is_pinned").toInt() > 0) status << "置顶";
    if (note.value("is_favorite").toInt() > 0) status << "书签";
    if (note.value("is_locked").toInt() > 0) status << "锁定";
    m_capsules["status"]->setText(status.isEmpty() ? "常规" : status.join(", "));

    // 分类
    int catId = note.value("category_id").toInt();
    if (catId > 0) {
        auto categories = DatabaseManager::instance().getAllCategories();
        for (const auto& cat : categories) {
            if (cat.value("id").toInt() == catId) {
                m_capsules["category"]->setText(cat.value("name").toString());
                break;
            }
        }
    } else {
        m_capsules["category"]->setText("未分类");
    }

    // 标签显示
    m_capsules["tags"]->setText(note.value("tags").toString().isEmpty() ? "无" : note.value("tags").toString());
}

void MetadataPanel::setMultipleNotes(int count) {
    m_currentNoteId = -1;
    m_stack->setCurrentIndex(1); // 多选页
    m_titleEdit->hide();
    m_tagEdit->setEnabled(true);
    m_tagEdit->setPlaceholderText("输入标签批量添加...");
    m_separatorLine->show();
}

void MetadataPanel::clearSelection() {
    m_currentNoteId = -1;
    m_stack->setCurrentIndex(0); // 无选择页
    m_titleEdit->hide();
    m_tagEdit->setEnabled(false);
    m_tagEdit->setPlaceholderText("请先选择一个项目");
    m_separatorLine->hide();
}

void MetadataPanel::openExpandedTitleEditor() {
    if (m_currentNoteId == -1) return;
    
    TitleEditorDialog dialog(m_titleEdit->text(), this);
    if (dialog.exec() == QDialog::Accepted) {
        QString newTitle = dialog.getText();
        if (!newTitle.isEmpty() && newTitle != m_titleEdit->text()) {
            m_titleEdit->setText(newTitle);
            DatabaseManager::instance().updateNoteState(m_currentNoteId, "title", newTitle);
            emit noteUpdated();
        }
    }
}

void MetadataPanel::handleTagInput() {
    QString text = m_tagEdit->text().trimmed();
    if (text.isEmpty()) return;
    
    QStringList tags = { text };
    emit tagAdded(tags);
    m_tagEdit->clear();
}

void MetadataPanel::openTagSelector() {
    if (m_currentNoteId == -1) return;
    
    QStringList currentTags = m_capsules["tags"]->text().split(",", Qt::SkipEmptyParts);
    for (QString& t : currentTags) t = t.trimmed();
    if (m_capsules["tags"]->text() == "无") currentTags.clear();

    auto* selector = new AdvancedTagSelector(this);
    // 获取最近使用的标签 (20个) 和全量标签
    auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
    auto allTags = DatabaseManager::instance().getAllTags();
    selector->setup(recentTags, allTags, currentTags);
    connect(selector, &AdvancedTagSelector::tagsConfirmed, [this](const QStringList& tags){
        if (m_currentNoteId != -1) {
            DatabaseManager::instance().updateNoteState(m_currentNoteId, "tags", tags.join(", "));
            emit noteUpdated();
            // 刷新本地显示
            m_capsules["tags"]->setText(tags.join(", "));
        }
    });
    selector->showAtCursor();
}
```

## 文件: `src/ui/MetadataPanel.h`

```cpp
#ifndef METADATAPANEL_H
#define METADATAPANEL_H

#include <QWidget>
#include <QLabel>
#include <QLineEdit>
#include <QVariant>
#include <QStringList>
#include <QMap>
#include <QStackedWidget>
#include <QFrame>
#include "ClickableLineEdit.h"

class MetadataPanel : public QWidget {
    Q_OBJECT
public:
    explicit MetadataPanel(QWidget* parent = nullptr);
    void setNote(const QVariantMap& note);
    void setMultipleNotes(int count);
    void clearSelection();

signals:
    void noteUpdated();
    void tagAdded(const QStringList& tags);
    void closed();

private:
    void initUI();
    QWidget* createInfoWidget(const QString& icon, const QString& title, const QString& subtitle);
    QWidget* createMetadataDisplay();
    QWidget* createCapsule(const QString& label, const QString& key);
    void openExpandedTitleEditor();
    void handleTagInput();
    void openTagSelector();

    QStackedWidget* m_stack;
    QWidget* m_metadataDisplayWidget;
    
    // Metadata Display widgets
    ClickableLineEdit* m_titleEdit;
    ClickableLineEdit* m_tagEdit;
    QFrame* m_separatorLine;
    QMap<QString, QLabel*> m_capsules;

    int m_currentNoteId = -1;
};

#endif // METADATAPANEL_H
```

## 文件: `src/ui/NoteDelegate.h`

```cpp
#ifndef NOTEDELEGATE_H
#define NOTEDELEGATE_H

#include <QStyledItemDelegate>
#include <QPainter>
#include <QPainterPath>
#include <QDateTime>
#include <QRegularExpression>
#include "../models/NoteModel.h"
#include "IconHelper.h"
#include "StringUtils.h"

class NoteDelegate : public QStyledItemDelegate {
    Q_OBJECT
public:
    explicit NoteDelegate(QObject* parent = nullptr) : QStyledItemDelegate(parent) {}

    // 定义卡片高度
    QSize sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        Q_UNUSED(index);
        return QSize(option.rect.width(), 110); // 每个卡片高度 110px
    }

    void paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        if (!index.isValid()) return;

        painter->save();
        painter->setRenderHint(QPainter::Antialiasing);

        // 1. 获取数据
        QString title = index.data(NoteModel::TitleRole).toString();
        QString content = index.data(NoteModel::ContentRole).toString();
        QString timeStr = index.data(NoteModel::TimeRole).toDateTime().toString("yyyy-MM-dd HH:mm:ss");
        bool isPinned = index.data(NoteModel::PinnedRole).toBool();
        
        // 2. 处理选中状态和背景 (更精致的配色与阴影感)
        bool isSelected = (option.state & QStyle::State_Selected);
        
        // 【关键修复】使用 QRectF 并根据笔宽调整，确保 2px 边框完全在 option.rect 内部绘制，消除选中残留伪影
        qreal penWidth = isSelected ? 2.0 : 1.0;
        QRectF rect = QRectF(option.rect).adjusted(penWidth/2.0, penWidth/2.0, -penWidth/2.0, -4.0 - penWidth/2.0);
        
        // 获取笔记自身的颜色标记作为背景
        QString colorHex = index.data(NoteModel::ColorRole).toString();
        QColor noteColor = colorHex.isEmpty() ? QColor("#1a1a1b") : QColor(colorHex);
        
        QColor bgColor = isSelected ? noteColor.lighter(115) : noteColor; 
        QColor borderColor = isSelected ? QColor("#ffffff") : QColor("#333333");
        
        // 绘制卡片背景
        QPainterPath path;
        path.addRoundedRect(rect, 8, 8);
        
        // 模拟阴影
        if (!isSelected) {
            painter->setPen(Qt::NoPen);
            painter->setBrush(QColor(0, 0, 0, 40));
            painter->drawRoundedRect(rect.translated(0, 2), 8, 8);
        }

        painter->setPen(QPen(borderColor, penWidth));
        painter->setBrush(bgColor);
        painter->drawPath(path);

        // 3. 绘制标题 (加粗，主文本色: 统一设为白色以应对多样背景卡片)
        painter->setPen(Qt::white);
        QFont titleFont("Microsoft YaHei", 10, QFont::Bold);
        painter->setFont(titleFont);
        QRectF titleRect = rect.adjusted(12, 10, -35, -70);
        painter->drawText(titleRect, Qt::AlignLeft | Qt::AlignTop, painter->fontMetrics().elidedText(title, Qt::ElideRight, titleRect.width()));

        // 4. 绘制置顶/星级标识
        if (isPinned) {
            QPixmap pin = IconHelper::getIcon("pin", "#f1c40f", 14).pixmap(14, 14);
            painter->drawPixmap(rect.right() - 25, rect.top() + 12, pin);
        }

        // 5. 绘制内容预览 (强制纯白：确保在任何背景下都有最高清晰度)
        painter->setPen(Qt::white);
        painter->setFont(QFont("Microsoft YaHei", 9));
        QRectF contentRect = rect.adjusted(12, 34, -12, -32);
        
        // 【统一优化】调用 StringUtils 剥离 HTML 标签，确保预览纯净
        QString cleanContent = StringUtils::htmlToPlainText(content).simplified();
        QString elidedContent = painter->fontMetrics().elidedText(cleanContent, Qt::ElideRight, contentRect.width() * 2);
        painter->drawText(contentRect, Qt::AlignLeft | Qt::AlignTop | Qt::TextWordWrap, elidedContent);

        // 6. 绘制底部元数据栏 (时间图标 + 时间 + 类型标签)
        QRectF bottomRect = rect.adjusted(12, 78, -12, -8);
        
        // 时间 (强制纯白)
        painter->setPen(Qt::white);
        painter->setFont(QFont("Segoe UI", 8));
        QPixmap clock = IconHelper::getIcon("clock", "#ffffff", 12).pixmap(12, 12);
        painter->drawPixmap(bottomRect.left(), bottomRect.top() + (bottomRect.height() - 12) / 2, clock);
        painter->drawText(bottomRect.adjusted(16, 0, 0, 0), Qt::AlignLeft | Qt::AlignVCenter, timeStr);

        // 绘制类型图标 (对齐 QuickWindow 风格)
        QIcon typeIcon = index.data(Qt::DecorationRole).value<QIcon>();
        if (!typeIcon.isNull()) {
            int iconSize = 18;
            QRectF iconRect(bottomRect.right() - iconSize - 4, bottomRect.top() + (bottomRect.height() - iconSize) / 2, iconSize, iconSize);
            typeIcon.paint(painter, iconRect.toRect(), Qt::AlignCenter);
        }

        painter->restore();
    }
};

#endif // NOTEDELEGATE_H
```

## 文件: `src/ui/NoteEditWindow.cpp`

```cpp
#include "NoteEditWindow.h"
#include "StringUtils.h"
#include "../core/ShortcutManager.h"
#include "AdvancedTagSelector.h"
#include "TitleEditorDialog.h"

#ifdef Q_OS_WIN
#include <windows.h>
#endif
#include "../core/DatabaseManager.h"
#include "IconHelper.h"
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QPushButton>
#include <QTextEdit>
#include <QLabel>
#include <QGridLayout>
#include <QPainter>
#include <QGraphicsDropShadowEffect>
#include <QWindow>
#include <QMouseEvent>
#include <QShortcut>
#include <QKeySequence>
#include <QApplication>
#include <QScreen>
#include <QTextListFormat>
#include <QCompleter>
#include <QStringListModel>
#include <QDialog>


NoteEditWindow::NoteEditWindow(int noteId, QWidget* parent) 
    : QWidget(parent, Qt::Window | Qt::FramelessWindowHint), m_noteId(noteId) 
{
    setObjectName("NoteEditWindow");
    setWindowTitle(m_noteId > 0 ? "编辑笔记" : "记录灵感");
    setAttribute(Qt::WA_TranslucentBackground); 
    // 增加窗口物理尺寸以容纳外围阴影，防止 UpdateLayeredWindowIndirect 参数错误
    resize(980, 680); 
    initUI();
    setupShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &NoteEditWindow::updateShortcuts);
    
    if (m_noteId > 0) {
        loadNoteData(m_noteId);
    }
}

void NoteEditWindow::setDefaultCategory(int catId) {
    m_catId = catId;
}

void NoteEditWindow::showEvent(QShowEvent* event) {
    QWidget::showEvent(event);
#ifdef Q_OS_WIN
    if (m_isStayOnTop) {
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }
#else
    Qt::WindowFlags f = windowFlags();
    if (m_isStayOnTop) f |= Qt::WindowStaysOnTopHint;
    else f &= ~Qt::WindowStaysOnTopHint;
    if (windowFlags() != f) {
        setWindowFlags(f);
        show();
    }
#endif
}

void NoteEditWindow::paintEvent(QPaintEvent* event) {
    // 由于使用了 mainContainer 承载背景和圆角，窗口本身只需保持透明
    Q_UNUSED(event);
}

void NoteEditWindow::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        if (event->pos().y() < 40) {
            m_dragPos = event->globalPosition().toPoint() - frameGeometry().topLeft();
            event->accept();
        }
    }
}

void NoteEditWindow::mouseMoveEvent(QMouseEvent* event) {
    if (event->buttons() & Qt::LeftButton) {
        if (!m_dragPos.isNull()) {
            move(event->globalPosition().toPoint() - m_dragPos);
            event->accept();
        }
    }
}

void NoteEditWindow::mouseReleaseEvent(QMouseEvent* event) {
    m_dragPos = QPoint();
}

bool NoteEditWindow::eventFilter(QObject* watched, QEvent* event) {
    if (watched->property("isCloseBtn").toBool()) {
        QPushButton* btn = qobject_cast<QPushButton*>(watched);
        if (btn) {
            if (event->type() == QEvent::Enter) {
                btn->setIcon(IconHelper::getIcon("close", "#ffffff", 20));
            } else if (event->type() == QEvent::Leave) {
                btn->setIcon(IconHelper::getIcon("close", "#aaaaaa", 20));
            }
        }
    }
    return QWidget::eventFilter(watched, event);
}

void NoteEditWindow::mouseDoubleClickEvent(QMouseEvent* event) {
    if (event->pos().y() < 40) {
        toggleMaximize();
    }
}

void NoteEditWindow::initUI() {
    auto* windowLayout = new QVBoxLayout(this);
    windowLayout->setObjectName("WindowLayout");
    windowLayout->setContentsMargins(15, 15, 15, 15); // 留出阴影空间
    windowLayout->setSpacing(0);

    // 主容器：承载圆角、背景和阴影
    auto* mainContainer = new QWidget();
    mainContainer->setObjectName("MainContainer");
    mainContainer->setStyleSheet("QWidget#MainContainer { background-color: #1E1E1E; border-radius: 12px; }");
    windowLayout->addWidget(mainContainer);

    auto* outerLayout = new QVBoxLayout(mainContainer);
    outerLayout->setContentsMargins(0, 0, 0, 0);
    outerLayout->setSpacing(0);

    // 自定义标题栏
    m_titleBar = new QWidget();
    m_titleBar->setFixedHeight(32); 
    m_titleBar->setStyleSheet("background-color: #252526; border-top-left-radius: 12px; border-top-right-radius: 12px; border-bottom: 1px solid #333;");
    auto* tbLayout = new QHBoxLayout(m_titleBar);
    tbLayout->setContentsMargins(12, 0, 0, 0); // 右边距设为 0
    tbLayout->setSpacing(0); // 按钮间距设为 0

    QLabel* titleIcon = new QLabel();
    titleIcon->setPixmap(IconHelper::getIcon("edit", "#4FACFE", 18).pixmap(18, 18));
    tbLayout->addWidget(titleIcon);

    m_winTitleLabel = new QLabel(m_noteId > 0 ? "编辑笔记" : "记录灵感");
    m_winTitleLabel->setStyleSheet("font-weight: bold; color: #ddd; font-size: 13px; margin-left: 5px;");
    tbLayout->addWidget(m_winTitleLabel);
    tbLayout->addStretch();

    // 统一控制按钮样式：32x32px（对齐主窗口），图标 20px，锁定比例以消除离谱内边距
    QString ctrlBtnStyle = "QPushButton { background: transparent; border: none; border-radius: 5px; padding: 0px; } "
                           "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }";
    
    QPushButton* btnMin = new QPushButton();
    btnMin->setIcon(IconHelper::getIcon("minimize", "#aaaaaa", 20));
    btnMin->setIconSize(QSize(20, 20));
    btnMin->setFixedSize(32, 32);
    btnMin->setStyleSheet(ctrlBtnStyle);
    connect(btnMin, &QPushButton::clicked, this, &QWidget::showMinimized);
    
    m_maxBtn = new QPushButton();
    m_maxBtn->setIcon(IconHelper::getIcon("maximize", "#aaaaaa", 20));
    m_maxBtn->setIconSize(QSize(20, 20));
    m_maxBtn->setFixedSize(32, 32);
    m_maxBtn->setStyleSheet(ctrlBtnStyle);
    connect(m_maxBtn, &QPushButton::clicked, this, &NoteEditWindow::toggleMaximize);

    m_btnStayOnTop = new QPushButton();
    m_btnStayOnTop->setIcon(IconHelper::getIcon("pin_tilted", "#aaaaaa", 20));
    m_btnStayOnTop->setIconSize(QSize(20, 20));
    m_btnStayOnTop->setFixedSize(32, 32);
    m_btnStayOnTop->setCheckable(true);
    m_btnStayOnTop->setStyleSheet(ctrlBtnStyle + " QPushButton:checked { background-color: #3A90FF; }");

    // 加载记忆状态
    QSettings settings("RapidNotes", "WindowStates");
    m_isStayOnTop = settings.value("NoteEditWindow/StayOnTop", false).toBool();
    if (m_isStayOnTop) {
        m_btnStayOnTop->setChecked(true);
        m_btnStayOnTop->setIcon(IconHelper::getIcon("pin_vertical", "#ffffff", 20));
    }

    connect(m_btnStayOnTop, &QPushButton::toggled, this, &NoteEditWindow::toggleStayOnTop);
    
    QPushButton* btnClose = new QPushButton();
    btnClose->setIcon(IconHelper::getIcon("close", "#aaaaaa", 20));
    btnClose->setIconSize(QSize(20, 20));
    btnClose->setFixedSize(32, 32);
    btnClose->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 5px; padding: 0px; } QPushButton:hover { background-color: #E81123; }");
    connect(btnClose, &QPushButton::clicked, this, &QWidget::close);

    // 为关闭按钮实现 Hover 图标变白逻辑
    btnClose->installEventFilter(this);
    btnClose->setProperty("isCloseBtn", true);

    tbLayout->addWidget(m_btnStayOnTop);
    tbLayout->addWidget(btnMin);
    tbLayout->addWidget(m_maxBtn);
    tbLayout->addWidget(btnClose);
    outerLayout->addWidget(m_titleBar);

    // 主内容区使用 Splitter
    m_splitter = new QSplitter(Qt::Horizontal);
    m_splitter->setStyleSheet("QSplitter::handle { background-color: #252526; width: 2px; } QSplitter::handle:hover { background-color: #4FACFE; }");

    // 左侧面板
    QWidget* leftContainer = new QWidget();
    auto* leftLayout = new QVBoxLayout(leftContainer);
    leftLayout->setContentsMargins(15, 15, 15, 15);
    setupLeftPanel(leftLayout);

    // 右侧面板
    QWidget* rightContainer = new QWidget();
    auto* rightLayout = new QVBoxLayout(rightContainer);
    rightLayout->setContentsMargins(10, 15, 15, 15);
    setupRightPanel(rightLayout);

    m_splitter->addWidget(leftContainer);
    m_splitter->addWidget(rightContainer);
    m_splitter->setStretchFactor(0, 0);
    m_splitter->setStretchFactor(1, 1);
    m_splitter->setSizes({300, 650});

    outerLayout->addWidget(m_splitter);

    // 阴影应用在内部容器上，确保不超出窗口边界
    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(15);
    shadow->setColor(QColor(0, 0, 0, 180));
    shadow->setOffset(0, 2);
    mainContainer->setGraphicsEffect(shadow);
}

void NoteEditWindow::setupLeftPanel(QVBoxLayout* layout) {
    QString labelStyle = "color: #888; font-size: 12px; font-weight: bold; margin-bottom: 4px;";
    QString inputStyle = "QLineEdit, QComboBox { background: #252526; border: 1px solid #333; border-radius: 4px; padding: 8px; color: #eee; font-size: 13px; } QLineEdit:focus, QComboBox:focus { border: 1px solid #4FACFE; }";

    QLabel* lblTitle = new QLabel("标题");
    lblTitle->setStyleSheet(labelStyle);
    m_titleEdit = new ClickableLineEdit();
    m_titleEdit->setPlaceholderText("请输入灵感标题...");
    m_titleEdit->setStyleSheet(inputStyle);
    m_titleEdit->setAlignment(Qt::AlignLeft);
    connect(m_titleEdit, &ClickableLineEdit::doubleClicked, this, &NoteEditWindow::openExpandedTitleEditor);
    layout->addWidget(lblTitle);
    layout->addWidget(m_titleEdit);

    QLabel* lblTags = new QLabel("标签");
    lblTags->setStyleSheet(labelStyle);
    m_tagEdit = new ClickableLineEdit();
    m_tagEdit->setPlaceholderText("使用逗号分隔，如: 工作, 待办 (双击显示历史)");
    m_tagEdit->setStyleSheet(inputStyle);
    connect(m_tagEdit, &ClickableLineEdit::doubleClicked, this, &NoteEditWindow::openTagSelector);
    
    // 智能补全标签
    QStringList allTags = DatabaseManager::instance().getAllTags();
    QCompleter* completer = new QCompleter(allTags, this);
    completer->setCaseSensitivity(Qt::CaseInsensitive);
    completer->setFilterMode(Qt::MatchContains);
    m_tagEdit->setCompleter(completer);

    layout->addWidget(lblTags);
    layout->addWidget(m_tagEdit);

    QLabel* lblColor = new QLabel("标记颜色");
    lblColor->setStyleSheet(labelStyle);
    layout->addWidget(lblColor);

    QWidget* colorGrid = new QWidget();
    QGridLayout* grid = new QGridLayout(colorGrid);
    grid->setContentsMargins(0, 10, 0, 10);
    
    m_colorGroup = new QButtonGroup(this);
    QStringList colors = {"#FF9800", "#444444", "#2196F3", "#4CAF50", "#F44336", "#9C27B0"};
    for(int i=0; i<colors.size(); ++i) {
        QPushButton* btn = createColorBtn(colors[i], i);
        grid->addWidget(btn, i/3, i%3);
        m_colorGroup->addButton(btn, i);
    }
    if(m_colorGroup->button(0)) m_colorGroup->button(0)->setChecked(true);
    
    layout->addWidget(colorGrid);
    
    m_defaultColorCheck = new QCheckBox("设为默认颜色");
    m_defaultColorCheck->setStyleSheet("QCheckBox { color: #858585; font-size: 12px; margin-top: 5px; }");
    layout->addWidget(m_defaultColorCheck);

    layout->addStretch(); 

    QPushButton* saveBtn = new QPushButton();
    saveBtn->setIcon(IconHelper::getIcon("save", "#ffffff"));
    saveBtn->setText("  保存 (Ctrl+S)");
    saveBtn->setCursor(Qt::PointingHandCursor);
    saveBtn->setFixedHeight(50);
    saveBtn->setStyleSheet("QPushButton { background-color: #4FACFE; color: white; border: none; border-radius: 6px; font-weight: bold; font-size: 13px; } QPushButton:hover { background-color: #357abd; }");
    connect(saveBtn, &QPushButton::clicked, this, &NoteEditWindow::saveNote);
    layout->addWidget(saveBtn);
}

QPushButton* NoteEditWindow::createColorBtn(const QString& color, int id) {
    QPushButton* btn = new QPushButton();
    btn->setCheckable(true);
    btn->setFixedSize(30, 30);
    btn->setProperty("color", color);
    btn->setStyleSheet(QString(
        "QPushButton { background-color: %1; border-radius: 15px; border: 2px solid transparent; }"
        "QPushButton:checked { border: 2px solid white; }"
    ).arg(color));
    return btn;
}

void NoteEditWindow::setupRightPanel(QVBoxLayout* layout) {
    QHBoxLayout* headerLayout = new QHBoxLayout();
    headerLayout->setContentsMargins(0, 0, 0, 0);
    headerLayout->setSpacing(1);

    QLabel* titleLabel = new QLabel("详细内容");
    titleLabel->setStyleSheet("color: #888; font-size: 11px; font-weight: bold;");
    headerLayout->addWidget(titleLabel);
    headerLayout->addStretch();

    QHBoxLayout* toolBar = new QHBoxLayout();
    toolBar->setContentsMargins(0, 0, 0, 0);
    toolBar->setSpacing(0); // 彻底消除按钮间距，实现紧凑布局

    // 标准化工具栏样式：对齐 HeaderBar 参数
    QString btnStyle = "QPushButton { background: transparent; border: none; border-radius: 5px; padding: 0px; } "
                       "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); } "
                       "QPushButton:checked { background-color: rgba(255, 255, 255, 0.2); }";
    
    auto addTool = [&](const QString& iconName, const QString& tip, std::function<void()> callback) {
        QPushButton* btn = new QPushButton();
        btn->setIcon(IconHelper::getIcon(iconName, "#aaaaaa", 20)); // 图标增大到 20px
        btn->setIconSize(QSize(20, 20));
        btn->setToolTip(tip);
        btn->setFixedSize(32, 32); // 尺寸标准化为 32x32
        btn->setCursor(Qt::PointingHandCursor);
        btn->setStyleSheet(btnStyle);
        connect(btn, &QPushButton::clicked, callback);
        toolBar->addWidget(btn);
        return btn;
    };

    addTool("undo", "撤销 (Ctrl+Z)", [this](){ m_contentEdit->undo(); });
    addTool("redo", "重做 (Ctrl+Y)", [this](){ m_contentEdit->redo(); });
    
    QFrame* sep1 = new QFrame();
    sep1->setFixedWidth(1);
    sep1->setFixedHeight(16);
    sep1->setStyleSheet("background-color: #333; margin-left: 2px; margin-right: 2px;");
    toolBar->addWidget(sep1);

    addTool("list_ul", "无序列表", [this](){ m_contentEdit->toggleList(false); });
    addTool("list_ol", "有序列表", [this](){ m_contentEdit->toggleList(true); });
    
    QPushButton* btnTodo = new QPushButton();
    btnTodo->setIcon(IconHelper::getIcon("todo", "#aaaaaa", 20));
    btnTodo->setIconSize(QSize(20, 20));
    btnTodo->setFixedSize(32, 32); 
    btnTodo->setToolTip("插入待办事项");
    btnTodo->setStyleSheet(btnStyle);
    btnTodo->setCursor(Qt::PointingHandCursor);
    connect(btnTodo, &QPushButton::clicked, [this](){ m_contentEdit->insertTodo(); });
    toolBar->addWidget(btnTodo);

    QPushButton* btnPre = new QPushButton();
    btnPre->setIcon(IconHelper::getIcon("eye", "#aaaaaa", 20));
    btnPre->setIconSize(QSize(20, 20));
    btnPre->setFixedSize(32, 32);
    btnPre->setToolTip("切换 Markdown 预览/编辑");
    btnPre->setStyleSheet(btnStyle);
    btnPre->setCursor(Qt::PointingHandCursor);
    btnPre->setCheckable(true);
    connect(btnPre, &QPushButton::toggled, [this](bool checked){ m_contentEdit->togglePreview(checked); });
    toolBar->addWidget(btnPre);

    addTool("edit_clear", "清除格式", [this](){ m_contentEdit->clearFormatting(); });
    
    QFrame* sep2 = new QFrame();
    sep2->setFixedWidth(1);
    sep2->setFixedHeight(16);
    sep2->setStyleSheet("background-color: #333; margin-left: 2px; margin-right: 2px;");
    toolBar->addWidget(sep2);

    // 高亮颜色
    QStringList hColors = {"#c0392b", "#f1c40f", "#27ae60", "#2980b9"};
    for (const auto& color : hColors) {
        QPushButton* hBtn = new QPushButton();
        hBtn->setFixedSize(20, 20);
        hBtn->setStyleSheet(QString("QPushButton { background-color: %1; border: 1px solid rgba(0,0,0,0.2); border-radius: 4px; } "
                                    "QPushButton:hover { border-color: white; }").arg(color));
        hBtn->setCursor(Qt::PointingHandCursor);
        connect(hBtn, &QPushButton::clicked, [this, color](){ m_contentEdit->highlightSelection(QColor(color)); });
        toolBar->addWidget(hBtn);
    }

    // 清除高亮按钮
    QPushButton* btnNoColor = new QPushButton();
    btnNoColor->setIcon(IconHelper::getIcon("no_color", "#aaaaaa", 14));
    btnNoColor->setFixedSize(24, 24);
    btnNoColor->setToolTip("清除高亮");
    btnNoColor->setStyleSheet("QPushButton { background: transparent; border: 1px solid #444; border-radius: 4px; margin-left: 4px; } "
                              "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); border-color: #888; }");
    btnNoColor->setCursor(Qt::PointingHandCursor);
    connect(btnNoColor, &QPushButton::clicked, [this](){ m_contentEdit->highlightSelection(Qt::transparent); });
    toolBar->addWidget(btnNoColor);
    
    headerLayout->addLayout(toolBar);
    layout->addLayout(headerLayout);

    // 搜索栏 (默认隐藏)
    m_searchBar = new QWidget();
    m_searchBar->setVisible(false);
    m_searchBar->setStyleSheet("background-color: #252526; border-radius: 6px; padding: 2px;");
    auto* sbLayout = new QHBoxLayout(m_searchBar);
    sbLayout->setContentsMargins(5, 2, 5, 2);
    m_searchEdit = new QLineEdit();
    m_searchEdit->setPlaceholderText("查找内容...");
    m_searchEdit->setStyleSheet("border: none; background: transparent; color: #fff;");
    connect(m_searchEdit, &QLineEdit::returnPressed, [this](){ m_contentEdit->findText(m_searchEdit->text()); });
    
    QPushButton* btnPrev = new QPushButton();
    btnPrev->setIcon(IconHelper::getIcon("nav_prev", "#ccc"));
    btnPrev->setFixedSize(24, 24);
    btnPrev->setStyleSheet("background: transparent; border: none;");
    connect(btnPrev, &QPushButton::clicked, [this](){ m_contentEdit->findText(m_searchEdit->text(), true); });
    
    QPushButton* btnNext = new QPushButton();
    btnNext->setIcon(IconHelper::getIcon("nav_next", "#ccc"));
    btnNext->setFixedSize(24, 24);
    btnNext->setStyleSheet("background: transparent; border: none;");
    connect(btnNext, &QPushButton::clicked, [this](){ m_contentEdit->findText(m_searchEdit->text(), false); });
    
    QPushButton* btnCls = new QPushButton();
    btnCls->setIcon(IconHelper::getIcon("close", "#ccc"));
    btnCls->setFixedSize(24, 24);
    btnCls->setStyleSheet("background: transparent; border: none;");
    connect(btnCls, &QPushButton::clicked, [this](){ m_searchBar->hide(); });

    sbLayout->addWidget(m_searchEdit);
    sbLayout->addWidget(btnPrev);
    sbLayout->addWidget(btnNext);
    sbLayout->addWidget(btnCls);
    layout->addWidget(m_searchBar);

    layout->addSpacing(5);
    m_contentEdit = new Editor(); 
    m_contentEdit->setPlaceholderText("在这里记录详细内容（支持 Markdown 和粘贴图片）...");
    layout->addWidget(m_contentEdit);
}

void NoteEditWindow::setupShortcuts() {
    auto add = [&](const QString& id, std::function<void()> func) {
        auto* sc = new QShortcut(ShortcutManager::instance().getShortcut(id), this, func);
        sc->setProperty("id", id);
        m_shortcutObjs.append(sc);
    };

    add("ed_save", [this](){ saveNote(); });
    add("ed_close", [this](){ close(); });
    add("ed_search", [this](){ toggleSearchBar(); });

    new QShortcut(QKeySequence("Escape"), this, SLOT(close()));
}

void NoteEditWindow::updateShortcuts() {
    for (auto* sc : m_shortcutObjs) {
        QString id = sc->property("id").toString();
        sc->setKey(ShortcutManager::instance().getShortcut(id));
    }
}

void NoteEditWindow::toggleStayOnTop() {
    m_isStayOnTop = m_btnStayOnTop->isChecked();
    m_btnStayOnTop->setIcon(IconHelper::getIcon(m_isStayOnTop ? "pin_vertical" : "pin_tilted", m_isStayOnTop ? "#ffffff" : "#aaaaaa", 20));

    QSettings settings("RapidNotes", "WindowStates");
    settings.setValue("NoteEditWindow/StayOnTop", m_isStayOnTop);

    if (isVisible()) {
#ifdef Q_OS_WIN
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, m_isStayOnTop ? HWND_TOPMOST : HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
        Qt::WindowFlags f = windowFlags();
        if (m_isStayOnTop) f |= Qt::WindowStaysOnTopHint;
        else f &= ~Qt::WindowStaysOnTopHint;
        setWindowFlags(f);
        show();
#endif
    }
}

void NoteEditWindow::toggleMaximize() {
    auto* windowLayout = findChild<QVBoxLayout*>("WindowLayout");
    auto* mainContainer = findChild<QWidget*>("MainContainer");

    if (m_isMaximized) {
        showNormal();
        if (windowLayout) windowLayout->setContentsMargins(15, 15, 15, 15);
        if (mainContainer) mainContainer->setStyleSheet("QWidget#MainContainer { background-color: #1E1E1E; border-radius: 12px; }");
        m_maxBtn->setIcon(IconHelper::getIcon("maximize", "#aaaaaa", 20));
        m_titleBar->setStyleSheet("background-color: #252526; border-top-left-radius: 12px; border-top-right-radius: 12px; border-bottom: 1px solid #333;");
    } else {
        m_normalGeometry = geometry();
        showMaximized();
        if (windowLayout) windowLayout->setContentsMargins(0, 0, 0, 0);
        if (mainContainer) mainContainer->setStyleSheet("QWidget#MainContainer { background-color: #1E1E1E; border-radius: 0px; }");
        m_maxBtn->setIcon(IconHelper::getIcon("restore", "#aaaaaa", 20));
        m_titleBar->setStyleSheet("background-color: #252526; border-radius: 0px; border-bottom: 1px solid #333;");
    }
    m_isMaximized = !m_isMaximized;
    update();
}

void NoteEditWindow::saveNote() {
    QString title = m_titleEdit->text();
    if(title.isEmpty()) title = "未命名灵感";
    QString content = m_contentEdit->toHtml();
    QString tags = m_tagEdit->text();
    int catId = m_catId;
    QString color = m_colorGroup->checkedButton() ? m_colorGroup->checkedButton()->property("color").toString() : "";
    
    if (m_noteId == 0) {
        DatabaseManager::instance().addNoteAsync(title, content, tags.split(","), color, catId);
    } else {
        DatabaseManager::instance().updateNote(m_noteId, title, content, tags.split(","), color, catId);
        DatabaseManager::instance().recordAccess(m_noteId);
    }
    emit noteSaved();
    close();
}

void NoteEditWindow::toggleSearchBar() {
    m_searchBar->setVisible(!m_searchBar->isVisible());
    if (m_searchBar->isVisible()) {
        m_searchEdit->setFocus();
        m_searchEdit->selectAll();
    }
}

void NoteEditWindow::openTagSelector() {
    QStringList currentTags = m_tagEdit->text().split(",", Qt::SkipEmptyParts);
    for (QString& t : currentTags) t = t.trimmed();

    auto* selector = new AdvancedTagSelector(this);
    auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
    auto allTags = DatabaseManager::instance().getAllTags();
    selector->setup(recentTags, allTags, currentTags);

    connect(selector, &AdvancedTagSelector::tagsConfirmed, [this](const QStringList& tags){
        m_tagEdit->setText(tags.join(", "));
    });

    selector->showAtCursor();
}

void NoteEditWindow::openExpandedTitleEditor() {
    TitleEditorDialog dialog(m_titleEdit->text(), this);
    // 设置初始位置在鼠标附近
    QPoint pos = QCursor::pos();
    dialog.move(pos.x() - 160, pos.y() - 40);
    
    if (dialog.exec() == QDialog::Accepted) {
        QString newTitle = dialog.getText();
        if (!newTitle.isEmpty() && newTitle != m_titleEdit->text()) {
            m_titleEdit->setText(newTitle);
        }
    }
}

void NoteEditWindow::loadNoteData(int id) {
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    if (!note.isEmpty()) {
        m_titleEdit->setText(note.value("title").toString());
        m_contentEdit->setNote(note, false); // 编辑模式不注入预览标题
        m_tagEdit->setText(note.value("tags").toString());
        
        m_catId = note["category_id"].toInt();
        
        QString color = note["color"].toString();
        for (int i = 0; i < m_colorGroup->buttons().size(); ++i) {
            if (m_colorGroup->button(i)->property("color").toString() == color) {
                m_colorGroup->button(i)->setChecked(true);
                break;
            }
        }
    }
}
```

## 文件: `src/ui/NoteEditWindow.h`

```cpp
#ifndef NOTEEDITWINDOW_H
#define NOTEEDITWINDOW_H

#include <QWidget>
#include <QLineEdit>
#include "ClickableLineEdit.h"
#include <QComboBox>
#include <QTextEdit>
#include <QCheckBox>
#include <QPushButton>
#include <QButtonGroup>
#include <QVBoxLayout>
#include <QSplitter>
#include <QLabel>
#include "Editor.h" 

class QShortcut;

class NoteEditWindow : public QWidget {
    Q_OBJECT
public:
    explicit NoteEditWindow(int noteId = 0, QWidget* parent = nullptr);
    void setDefaultCategory(int catId);

signals:
    void noteSaved();

protected:
    bool eventFilter(QObject* watched, QEvent* event) override;
    void showEvent(QShowEvent* event) override;
    void paintEvent(QPaintEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void mouseDoubleClickEvent(QMouseEvent* event) override;

private:
    void initUI();
    void setupShortcuts();
    void updateShortcuts();
    void loadNoteData(int id);
    void setupLeftPanel(QVBoxLayout* layout);
    void setupRightPanel(QVBoxLayout* layout);
    QPushButton* createColorBtn(const QString& color, int id);
    
private slots:
    void toggleMaximize();
    void toggleStayOnTop();
    void saveNote();
    void toggleSearchBar();
    void openTagSelector();
    void openExpandedTitleEditor();

private:
    int m_noteId;
    int m_catId = -1;
    
    // 窗口控制
    bool m_isMaximized = false;
    bool m_isStayOnTop = false;
    QRect m_normalGeometry;
    QPoint m_dragPos;
    
    // UI 控件引用
    QWidget* m_titleBar;
    QLabel* m_winTitleLabel;
    QPushButton* m_maxBtn;
    QPushButton* m_btnStayOnTop;
    QSplitter* m_splitter;
    ClickableLineEdit* m_titleEdit;
    ClickableLineEdit* m_tagEdit;
    QList<QShortcut*> m_shortcutObjs;
    QButtonGroup* m_colorGroup;
    QCheckBox* m_defaultColorCheck;
    Editor* m_contentEdit;

    // 搜索栏
    QWidget* m_searchBar;
    QLineEdit* m_searchEdit;
};

#endif // NOTEEDITWINDOW_H
```

## 文件: `src/models/NoteModel.cpp`

```cpp
#include "NoteModel.h"
#include <QDateTime>
#include <QIcon>
#include "../ui/IconHelper.h"
#include "../ui/StringUtils.h"
#include "../core/DatabaseManager.h"
#include <QFileInfo>
#include <QBuffer>
#include <QPixmap>
#include <QByteArray>
#include <QUrl>

static QString getIconHtml(const QString& name, const QString& color) {
    QIcon icon = IconHelper::getIcon(name, color, 16);
    QPixmap pixmap = icon.pixmap(16, 16);
    QByteArray ba;
    QBuffer buffer(&ba);
    buffer.open(QIODevice::WriteOnly);
    pixmap.save(&buffer, "PNG");
    return QString("<img src='data:image/png;base64,%1' width='16' height='16' style='vertical-align:middle;'>")
           .arg(QString(ba.toBase64()));
}

NoteModel::NoteModel(QObject* parent) : QAbstractListModel(parent) {
    updateCategoryMap();
}

int NoteModel::rowCount(const QModelIndex& parent) const {
    if (parent.isValid()) return 0;
    return m_notes.count();
}

QVariant NoteModel::data(const QModelIndex& index, int role) const {
    if (!index.isValid() || index.row() >= m_notes.count()) return QVariant();

    const QVariantMap& note = m_notes.at(index.row());
    switch (role) {
        case Qt::BackgroundRole:
            return QVariant(); // 强制不返回任何背景色，由 Delegate 控制
        case Qt::DecorationRole: {
            QString type = note.value("item_type").toString();
            QString content = note.value("content").toString().trimmed();
            QString iconName = "text"; // Default
            QString iconColor = "#95a5a6";

            if (type == "image") {
                int id = note.value("id").toInt();
                if (m_thumbnailCache.contains(id)) return m_thumbnailCache[id];
                
                QImage img;
                img.loadFromData(note.value("data_blob").toByteArray());
                if (!img.isNull()) {
                    QIcon thumb(QPixmap::fromImage(img.scaled(64, 64, Qt::KeepAspectRatio, Qt::SmoothTransformation)));
                    m_thumbnailCache[id] = thumb;
                    return thumb;
                }
                iconName = "image";
                iconColor = "#9b59b6";
            } else if (type == "file" || type == "files") {
                iconName = "file";
                iconColor = "#f1c40f";
            } else if (type == "ocr_text") {
                // [CRITICAL] 识别提取的文字专用图标
                iconName = "screenshot_ocr";
                iconColor = "#007ACC";
            } else if (type == "captured_message") {
                // 自动捕获的消息
                iconName = "message";
                iconColor = "#4a90e2";
            } else if (type == "local_file" || type == "local_batch") {
                iconName = "file_managed";
                iconColor = "#f1c40f";
            } else if (type == "folder") {
                iconName = "folder";
                iconColor = "#e67e22";
            } else if (type == "local_folder") {
                iconName = "folder_managed";
                iconColor = "#e67e22";
            } else if (type == "color") {
                iconName = "palette";
                iconColor = content;
            } else if (type == "pixel_ruler") {
                iconName = "pixel_ruler";
                iconColor = "#ff5722";
            } else {
                // 【核心修复】智能检测文本内容，对齐 Python 版逻辑
                QString stripped = content.trimmed();
                QString cleanPath = stripped;
                if ((cleanPath.startsWith("\"") && cleanPath.endsWith("\"")) || 
                    (cleanPath.startsWith("'") && cleanPath.endsWith("'"))) {
                    cleanPath = cleanPath.mid(1, cleanPath.length() - 2);
                }

                if (stripped.startsWith("http://") || stripped.startsWith("https://") || stripped.startsWith("www.")) {
                    iconName = "link";
                    iconColor = "#3498db";
                } else if (QRegularExpression("^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$").match(stripped).hasMatch()) {
                    // 优先识别 HEX 色码，防止被识别为代码
                    iconName = "palette";
                    iconColor = stripped;
                } else if (stripped.startsWith("#") || stripped.startsWith("import ") || stripped.startsWith("class ") || 
                           stripped.startsWith("def ") || stripped.startsWith("<") || stripped.startsWith("{") ||
                           stripped.startsWith("function") || stripped.startsWith("var ") || stripped.startsWith("const ")) {
                    iconName = "code";
                    iconColor = "#2ecc71";
                } else if (cleanPath.length() < 260 && (
                           (cleanPath.length() > 2 && cleanPath[1] == ':') || 
                           cleanPath.startsWith("\\\\") || cleanPath.startsWith("/") || 
                           cleanPath.startsWith("./") || cleanPath.startsWith("../"))) {
                    QFileInfo info(cleanPath);
                    if (info.exists()) {
                        if (info.isDir()) {
                            iconName = "folder";
                            iconColor = "#e67e22";
                        } else {
                            iconName = "file";
                            iconColor = "#f1c40f";
                        }
                    }
                }
            }
            return IconHelper::getIcon(iconName, iconColor, 32);
        }
        case Qt::ToolTipRole: {
            int id = note.value("id").toInt();
            if (m_tooltipCache.contains(id)) return m_tooltipCache[id];

            QString title = note.value("title").toString();
            QString content = note.value("content").toString();
            int catId = note.value("category_id").toInt();
            QString tags = note.value("tags").toString();
            bool pinned = note.value("is_pinned").toBool();
            bool locked = note.value("is_locked").toBool();
            bool favorite = note.value("is_favorite").toBool();
            int rating = note.value("rating").toInt();
            QString sourceApp = note.value("source_app").toString();

            QString catName = m_categoryMap.value(catId, "未分类");
            if (tags.isEmpty()) tags = "无";

            QString statusStr;
            if (pinned) statusStr += getIconHtml("pin_vertical", "#e74c3c") + " 置顶 ";
            if (locked) statusStr += getIconHtml("lock", "#aaaaaa") + " 锁定 ";
            if (favorite) statusStr += getIconHtml("bookmark_filled", "#ff6b81") + " 书签 ";
            if (statusStr.isEmpty()) statusStr = "无";

            if (sourceApp.isEmpty()) sourceApp = "未知应用";

            QString ratingStr;
            for(int i=0; i<rating; ++i) ratingStr += getIconHtml("star_filled", "#f39c12") + " ";
            if (ratingStr.isEmpty()) ratingStr = "无";

            QString preview;
            if (note.value("item_type").toString() == "image") {
                QByteArray ba = note.value("data_blob").toByteArray();
                preview = QString("<img src='data:image/png;base64,%1' width='300'>").arg(QString(ba.toBase64()));
            } else {
                // 【核心修复】剥离 HTML 标签以显示纯文本预览 (防止样式代码进入 ToolTip)
                QString plainText = StringUtils::htmlToPlainText(content);
                preview = plainText.left(400).toHtmlEscaped().replace("\n", "<br>").trimmed();
                if (plainText.length() > 400) preview += "...";
            }
            if (preview.isEmpty()) preview = title.toHtmlEscaped();

            QString html = QString("<html><body style='color: #ddd;'>"
                           "<table border='0' cellpadding='2' cellspacing='0'>"
                           "<tr><td width='22'>%1</td><td><b>分区:</b> %2</td></tr>"
                           "<tr><td width='22'>%3</td><td><b>标签:</b> %4</td></tr>"
                           "<tr><td width='22'>%5</td><td><b>评级:</b> %6</td></tr>"
                           "<tr><td width='22'>%7</td><td><b>状态:</b> %8</td></tr>"
                           "<tr><td width='22'>%9</td><td><b>来源:</b> %10</td></tr>"
                           "</table>"
                           "<hr style='border: 0; border-top: 1px solid #555; margin: 5px 0;'>"
                           "<div style='color: #ccc; font-size: 12px; line-height: 1.4;'>%11</div>"
                           "</body></html>")
                .arg(getIconHtml("branch", "#4a90e2"), catName,
                     getIconHtml("tag", "#FFAB91"), tags,
                     getIconHtml("star", "#f39c12"), ratingStr,
                     getIconHtml("pin_tilted", "#aaa"), statusStr,
                     getIconHtml("monitor", "#aaaaaa"))
                .arg(sourceApp, preview);
            
            m_tooltipCache[id] = html;
            return html;
        }
        case Qt::DisplayRole: {
            QString type = note.value("item_type").toString();
            QString title = note.value("title").toString();
            QString content = note.value("content").toString();
            if (type == "text" || type.isEmpty()) {
                QString plain = StringUtils::htmlToPlainText(content);
                QString display = plain.replace('\n', ' ').replace('\r', ' ').trimmed().left(150);
                return display.isEmpty() ? title : display;
            }
            return title;
        }
        case TitleRole:
            return note.value("title");
        case ContentRole:
            return note.value("content");
        case IdRole:
            return note.value("id");
        case TagsRole:
            return note.value("tags");
        case TimeRole:
            return note.value("updated_at");
        case PinnedRole:
            return note.value("is_pinned");
        case LockedRole:
            return note.value("is_locked");
        case FavoriteRole:
            return note.value("is_favorite");
        case TypeRole:
            return note.value("item_type");
        case RatingRole:
            return note.value("rating");
        case CategoryIdRole:
            return note.value("category_id");
        case CategoryNameRole:
            return m_categoryMap.value(note.value("category_id").toInt(), "未分类");
        case ColorRole:
            return note.value("color");
        case SourceAppRole:
            return note.value("source_app");
        case SourceTitleRole:
            return note.value("source_title");
        default:
            return QVariant();
    }
}

Qt::ItemFlags NoteModel::flags(const QModelIndex& index) const {
    if (!index.isValid()) return Qt::ItemIsEnabled;
    return QAbstractListModel::flags(index) | Qt::ItemIsDragEnabled;
}

QStringList NoteModel::mimeTypes() const {
    // 【核心修复】优先级调整：text/plain 必须放在第一位，确保浏览器等外部应用优先识别
    return {"text/plain", "text/html", "text/uri-list", "application/x-note-ids"};
}

QMimeData* NoteModel::mimeData(const QModelIndexList& indexes) const {
    QMimeData* mimeData = new QMimeData();
    QStringList ids;
    QStringList plainTexts;
    QStringList htmlTexts;
    QList<QUrl> urls;

    for (const QModelIndex& index : indexes) {
        if (index.isValid()) {
            ids << QString::number(data(index, IdRole).toInt());
            
            QString content = data(index, ContentRole).toString();
            QString type = data(index, TypeRole).toString();
            
            if (type == "text" || type.isEmpty()) {
                if (StringUtils::isHtml(content)) {
                    plainTexts << StringUtils::htmlToPlainText(content);
                    htmlTexts << content;
                } else {
                    plainTexts << content;
                    htmlTexts << content.toHtmlEscaped().replace("\n", "<br>");
                }
            } else if (type == "file" || type == "folder" || type == "files") {
                QStringList rawPaths = content.split(';', Qt::SkipEmptyParts);
                for (const QString& p : rawPaths) {
                    QString path = p.trimmed().remove('\"');
                    if (QFileInfo::exists(path)) {
                        urls << QUrl::fromLocalFile(path);
                    }
                }
                plainTexts << content;
                htmlTexts << content.toHtmlEscaped().replace("\n", "<br>");
            }
        }
    }
    
    mimeData->setData("application/x-note-ids", ids.join(",").toUtf8());
    
    if (!plainTexts.isEmpty()) {
        // 1. 设置纯文本格式 (使用 \r\n 换行)
        QString combinedPlain = plainTexts.join("\n---\n").replace("\n", "\r\n");
        mimeData->setText(combinedPlain);
        
        // 2. 仅在确实包含 HTML 内容时提供 HTML 分支，防止纯文本拖拽时出现 HTML 源码泄漏
        bool hasActualHtml = false;
        for (const QModelIndex& index : indexes) {
            if (StringUtils::isHtml(data(index, ContentRole).toString())) {
                hasActualHtml = true;
                break;
            }
        }

        if (hasActualHtml) {
            if (indexes.size() == 1) {
                mimeData->setHtml(data(indexes.first(), ContentRole).toString());
            } else {
                QString combinedHtml = htmlTexts.join("<br><hr><br>");
                mimeData->setHtml(QString(
                    "<html>"
                    "<head><meta charset='utf-8'></head>"
                    "<body>%1</body>"
                    "</html>"
                ).arg(combinedHtml));
            }
        }
    }
    
    if (!urls.isEmpty()) {
        mimeData->setUrls(urls);
    }
    
    return mimeData;
}

void NoteModel::setNotes(const QList<QVariantMap>& notes) {
    updateCategoryMap();
    m_thumbnailCache.clear();
    m_tooltipCache.clear();
    beginResetModel();
    m_notes = notes;
    endResetModel();
}

void NoteModel::updateCategoryMap() {
    auto categories = DatabaseManager::instance().getAllCategories();
    m_categoryMap.clear();
    for (const auto& cat : categories) {
        m_categoryMap[cat["id"].toInt()] = cat["name"].toString();
    }
}

// 【新增】函数的具体实现
void NoteModel::prependNote(const QVariantMap& note) {
    // 通知视图：我要在第0行插入1条数据
    beginInsertRows(QModelIndex(), 0, 0);
    m_notes.prepend(note);
    endInsertRows();
}
```

## 文件: `src/models/NoteModel.h`

```cpp
#ifndef NOTEMODEL_H
#define NOTEMODEL_H

#include <QAbstractListModel>
#include <QVariantMap>
#include <QList>
#include <QMimeData>

class NoteModel : public QAbstractListModel {
    Q_OBJECT
public:
    enum NoteRoles {
        IdRole = Qt::UserRole + 1,
        TitleRole,
        ContentRole,
        TagsRole,
        TimeRole,
        PinnedRole,
        LockedRole,
        FavoriteRole,
        TypeRole,
        RatingRole,
        CategoryIdRole,
        CategoryNameRole,
        ColorRole,
        SourceAppRole,
        SourceTitleRole
    };

    explicit NoteModel(QObject* parent = nullptr);

    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
    
    Qt::ItemFlags flags(const QModelIndex& index) const override;
    QStringList mimeTypes() const override;
    QMimeData* mimeData(const QModelIndexList& indexes) const override;

    // 全量重置
    void setNotes(const QList<QVariantMap>& notes);
    
    // 【新增】增量插入 (这就是报错缺失的函数！)
    void prependNote(const QVariantMap& note);
    void updateCategoryMap();

private:
    QList<QVariantMap> m_notes;
    QMap<int, QString> m_categoryMap;
    mutable QMap<int, QIcon> m_thumbnailCache;
    mutable QMap<int, QString> m_tooltipCache;
};

#endif // NOTEMODEL_H
```

## 文件: `src/core/OCRManager.cpp`

```cpp
#include "OCRManager.h"
#include <QtConcurrent>
#include <QThreadPool>
#include <QStringList>
#include <QTemporaryFile>
#include <QProcess>
#include <QDir>
#include <QDebug>
#include <QLocale>
#include <QCoreApplication>
#include <utility>

OCRManager& OCRManager::instance() {
    static OCRManager inst;
    return inst;
}

OCRManager::OCRManager(QObject* parent) : QObject(parent) {}

void OCRManager::setLanguage(const QString& lang) {
    m_language = lang;
}

QString OCRManager::getLanguage() const {
    return m_language;
}

void OCRManager::recognizeAsync(const QImage& image, int contextId) {
    qDebug() << "[OCRManager] recognizeAsync: 接收任务 ID:" << contextId 
             << "图片大小:" << image.width() << "x" << image.height() 
             << "主线程:" << QThread::currentThread();
    (void)QtConcurrent::run(QThreadPool::globalInstance(), [this, image, contextId]() {
        qDebug() << "[OCRManager] 工作线程开始执行 ID:" << contextId 
                 << "线程:" << QThread::currentThread();
        this->recognizeSync(image, contextId);
        qDebug() << "[OCRManager] 工作线程完成 ID:" << contextId;
    });
}

// 图像预处理函数：提高 OCR 识别准确度
QImage OCRManager::preprocessImage(const QImage& original) {
    if (original.isNull()) {
        return original;
    }
    
    // 1. 转换为灰度图 (保留 8 位深度的灰度细节，这对 Tesseract 4+ 至关重要)
    QImage processed = original.convertToFormat(QImage::Format_Grayscale8);
    
    // 2. 动态缩放策略
    // 目标：使文字像素高度达到 Tesseract 偏好的 30-35 像素。
    // 如果原图已经很大（宽度 > 2000），则不需要放大 3 倍，否则会导致内存占用过高且识别变慢
    int scale = 3;
    if (processed.width() > 2000 || processed.height() > 2000) {
        scale = 1;
    } else if (processed.width() > 1000 || processed.height() > 1000) {
        scale = 2;
    }
    
    if (scale > 1) {
        processed = processed.scaled(
            processed.width() * scale, 
            processed.height() * scale, 
            Qt::KeepAspectRatio, 
            Qt::SmoothTransformation
        );
    }
    
    // 3. 自动反色处理：Tesseract 在白底黑字下表现最好
    // 简单判断：如果四个角的像素平均值较暗，则认为可能是深色背景
    int cornerSum = 0;
    cornerSum += qGray(processed.pixel(0, 0));
    cornerSum += qGray(processed.pixel(processed.width()-1, 0));
    cornerSum += qGray(processed.pixel(0, processed.height()-1));
    cornerSum += qGray(processed.pixel(processed.width()-1, processed.height()-1));
    if (cornerSum / 4 < 128) {
        processed.invertPixels();
    }

    // 4. 增强对比度（线性拉伸）
    // 泰语等细笔画文字对二值化和过度的对比度拉伸很敏感，因此我们收窄忽略范围（从 1% 降至 0.5%）
    int histogram[256] = {0};
    for (int y = 0; y < processed.height(); ++y) {
        const uchar* line = processed.constScanLine(y);
        for (int x = 0; x < processed.width(); ++x) {
            histogram[line[x]]++;
        }
    }
    
    int totalPixels = processed.width() * processed.height();
    int minGray = 0, maxGray = 255;
    int count = 0;
    
    for (int i = 0; i < 256; ++i) {
        count += histogram[i];
        if (count > totalPixels * 0.005) {
            minGray = i;
            break;
        }
    }
    
    count = 0;
    for (int i = 255; i >= 0; --i) {
        count += histogram[i];
        if (count > totalPixels * 0.005) {
            maxGray = i;
            break;
        }
    }
    
    if (maxGray > minGray) {
        for (int y = 0; y < processed.height(); ++y) {
            uchar* line = processed.scanLine(y);
            for (int x = 0; x < processed.width(); ++x) {
                int val = line[x];
                val = (val - minGray) * 255 / (maxGray - minGray);
                val = qBound(0, val, 255);
                line[x] = static_cast<uchar>(val);
            }
        }
    }

    // 5. 简单锐化处理 (卷积)
    // 增加文字边缘对比度，有助于 Tesseract 识别彩色变灰度后的细微笔画
    QImage sharpened = processed;
    int kernel[3][3] = {
        {0, -1, 0},
        {-1, 5, -1},
        {0, -1, 0}
    };
    for (int y = 1; y < processed.height() - 1; ++y) {
        const uchar* prevLine = processed.constScanLine(y - 1);
        const uchar* currLine = processed.constScanLine(y);
        const uchar* nextLine = processed.constScanLine(y + 1);
        uchar* destLine = sharpened.scanLine(y);
        for (int x = 1; x < processed.width() - 1; ++x) {
            int sum = currLine[x] * kernel[1][1]
                    + prevLine[x] * kernel[0][1] + nextLine[x] * kernel[2][1]
                    + currLine[x-1] * kernel[1][0] + currLine[x+1] * kernel[1][2];
            destLine[x] = static_cast<uchar>(qBound(0, sum, 255));
        }
    }
    processed = sharpened;
    
    // 注意：不再手动调用 Otsu 二值化。
    // Tesseract 4.0+ 内部的二值化器（基于 Leptonica）在处理具有抗锯齿边缘的灰度图像时表现更好。
    
    return processed;
}

void OCRManager::recognizeSync(const QImage& image, int contextId) {
    qDebug() << "[OCRManager] recognizeSync: 开始识别 ID:" << contextId 
             << "线程:" << QThread::currentThread();
    QString result;

#ifdef Q_OS_WIN
    // 预处理图像以提高识别准确度
    QImage processedImage = preprocessImage(image);
    
    if (processedImage.isNull()) {
        result = "图像无效";
        emit recognitionFinished(result, contextId);
        return;
    }
    
    // 使用 BMP 格式存储临时文件，因为其写入速度最快且不涉及复杂的压缩计算，能缩短毫秒级开销
    QTemporaryFile tempFile(QDir::tempPath() + "/ocr_XXXXXX.bmp");
    tempFile.setAutoRemove(true);
    
    if (!tempFile.open()) {
        result = "无法创建临时图像文件";
        emit recognitionFinished(result, contextId);
        return;
    }
    
    QString filePath = QDir::toNativeSeparators(tempFile.fileName());
    
    // 保存预处理后的灰度图
    if (!processedImage.save(filePath, "BMP")) {
        result = "无法保存临时图像文件";
        emit recognitionFinished(result, contextId);
        return;
    }
    
    tempFile.close();

    // 路径探测逻辑：增强鲁棒性，支持从 bin 或 build 目录运行
    QString appPath = QCoreApplication::applicationDirPath();
    QString tessDataPath;
    QString tesseractPath;

    // 尝试在多个层级寻找 resources 目录
    QStringList basePaths;
    basePaths << appPath;
    basePaths << QDir(appPath).absolutePath() + "/..";
    basePaths << QDir(appPath).absolutePath() + "/../..";

    for (const QString& base : std::as_const(basePaths)) {
        // 搜索数据目录 (支持资源目录、根目录及标准安装路径)
        if (tessDataPath.isEmpty()) {
            QStringList dataPotentials;
            dataPotentials << base + "/resources/Tesseract-OCR/tessdata"
                           << base + "/Tesseract-OCR/tessdata"
                           << base + "/tessdata"
                           << "C:/Program Files/Tesseract-OCR/tessdata";
            for (const QString& p : std::as_const(dataPotentials)) {
                if (QDir(p).exists()) {
                    tessDataPath = QDir(p).absolutePath();
                    break;
                }
            }
        }
        
        // 搜索执行文件
        if (tesseractPath.isEmpty()) {
            QStringList exePotentials;
            exePotentials << base + "/resources/Tesseract-OCR/tesseract.exe"
                           << base + "/Tesseract-OCR/tesseract.exe"
                           << base + "/resources/tesseract.exe"
                           << base + "/tesseract.exe"
                           << "C:/Program Files/Tesseract-OCR/tesseract.exe";
            for (const QString& p : std::as_const(exePotentials)) {
                if (QFile::exists(p)) {
                    tesseractPath = QDir::toNativeSeparators(p);
                    break;
                }
            }
        }
        
        if (!tessDataPath.isEmpty() && !tesseractPath.isEmpty()) break;
    }

    // 系统 PATH 兜底
    if (tesseractPath.isEmpty()) tesseractPath = "tesseract";

    if (!tesseractPath.isEmpty()) {
        QProcess tesseract;
        
        // 设置 TESSDATA_PREFIX 环境变量（Tesseract 主程序所在的父目录或 tessdata 所在目录）
        QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
        if (!tessDataPath.isEmpty() && QDir(tessDataPath).exists()) {
            // TESSDATA_PREFIX 通常应该是包含 tessdata 文件夹的目录
            QDir prefixDir(tessDataPath);
            prefixDir.cdUp();
            env.insert("TESSDATA_PREFIX", QDir::toNativeSeparators(prefixDir.absolutePath()));
        }
        tesseract.setProcessEnvironment(env);
        
        // 智能语言探测：自动扫描 tessdata 目录下所有可用的训练数据
        QStringList foundLangs;
        if (!tessDataPath.isEmpty()) {
            QDir dir(tessDataPath);
            if (dir.exists()) {
            QStringList filters; filters << "*.traineddata";
            QStringList files = dir.entryList(filters, QDir::Files);
            
            // 定义优先级：优先加载中文简体和泰语，防止误识别为英文字符 (如 星号 -> BE)
            QStringList priority;
            QString systemName = QLocale::system().name();
            // 严谨判断简繁：只有明确匹配到港澳台地区或传统脚本时才视为繁体
            bool isTraditional = (systemName.contains("zh_TW") || systemName.contains("zh_HK") || 
                                 systemName.contains("zh_MO") || 
                                 QLocale::system().script() == QLocale::TraditionalChineseScript);
            
            if (isTraditional) {
                priority = {"chi_tra", "tha", "eng", "chi_sim", "jpn", "kor"};
            } else {
                priority = {"chi_sim", "tha", "eng", "chi_tra", "jpn", "kor"};
            }

            for (const QString& pLang : std::as_const(priority)) {
                if (files.contains(pLang + ".traineddata")) {
                    foundLangs << pLang;
                    files.removeAll(pLang + ".traineddata");
                }
            }
            // 其余语言按字母顺序追加，但限制总数。
            // 速度优化的关键：加载的语言模型（LSTM）越多，Tesseract 初始化越慢。
            // 将上限从 10 降至 3，可使初始化速度提升数倍。
            for (const QString& file : std::as_const(files)) {
                if (foundLangs.size() >= 3) break;
                QString name = file.left(file.lastIndexOf('.'));
                if (name != "osd" && !foundLangs.contains(name)) foundLangs << name;
            }
            }
        }

        QString currentLang = foundLangs.isEmpty() ? m_language : foundLangs.join('+');
        qDebug() << "OCR: Used tessdata path:" << tessDataPath;
        qDebug() << "OCR: Detected languages:" << foundLangs.size() << ":" << currentLang;

        QStringList args;
        // 明确指定数据目录
        if (QFile::exists(tessDataPath)) {
            args << "--tessdata-dir" << QDir::toNativeSeparators(tessDataPath);
        }
        
        args << filePath << "stdout" << "-l" << currentLang << "--oem" << "1" << "--psm" << "3";
        tesseract.start(tesseractPath, args);
        
        if (!tesseract.waitForStarted()) {
            result = "无法启动 Tesseract 引擎。路径: " + tesseractPath;
        } else if (tesseract.waitForFinished(20000)) {
            QByteArray output = tesseract.readAllStandardOutput();
            QByteArray errorOutput = tesseract.readAllStandardError();
            result = QString::fromUtf8(output).trimmed();
            
            if (!result.isEmpty()) {
                qDebug() << "Tesseract OCR succeeded using:" << tesseractPath << "with lang:" << currentLang;
                emit recognitionFinished(result, contextId);
                return;
            }
            
            if (!errorOutput.isEmpty()) {
                result = "Tesseract 错误: " + QString::fromUtf8(errorOutput).left(100);
            } else {
                result = "未识别到任何内容。请检查数据包及语言。";
            }
        } else {
            tesseract.kill();
            result = "OCR 识别超时 (20s)。语言包过量或图片过大。";
        }
    } else {
        result = "未找到 Tesseract 引擎组件。搜索路径包括 resources/Tesseract-OCR。";
    }
#else
    result = "当前平台不支持 OCR 功能";
#endif

    if (result.isEmpty()) {
        result = "未能从图片中识别出任何文字";
    }
    
    qDebug() << "[OCRManager] recognizeSync: 识别完成 ID:" << contextId 
             << "结果长度:" << result.length() << "线程:" << QThread::currentThread();
    qDebug() << "[OCRManager] 准备发送 recognitionFinished 信号 ID:" << contextId;
    
    try {
        emit recognitionFinished(result, contextId);
        qDebug() << "[OCRManager] recognitionFinished 信号已发送 ID:" << contextId;
    } catch (const std::exception& e) {
        qDebug() << "[OCRManager] 异常: 发送信号时出错 ID:" << contextId << "错误:" << e.what();
    } catch (...) {
        qDebug() << "[OCRManager] 异常: 发送信号时出现未知错误 ID:" << contextId;
    }
}
```

## 文件: `src/core/OCRManager.h`

```cpp
#ifndef OCRMANAGER_H
#define OCRMANAGER_H
#include <QObject>
#include <QImage>
#include <QString>

class OCRManager : public QObject {
    Q_OBJECT
public:
    static OCRManager& instance();
    void recognizeAsync(const QImage& image, int contextId = -1);
    
    // 设置 OCR 识别语言（默认: "chi_sim+eng"）
    // 可用语言见 traineddata 文件，多语言用 + 连接
    // 例如: "chi_sim+eng", "jpn+eng", "fra+deu"
    void setLanguage(const QString& lang);
    QString getLanguage() const;

private:
    void recognizeSync(const QImage& image, int contextId);
    QImage preprocessImage(const QImage& original);

signals:
    void recognitionFinished(const QString& text, int contextId);

private:
    OCRManager(QObject* parent = nullptr);
    QString m_language = "chi_sim+eng"; // 默认中文简体+英文
};

#endif // OCRMANAGER_H
```

## 文件: `src/ui/OCRResultWindow.cpp`

```cpp
#include "OCRResultWindow.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include "ToolTipOverlay.h"
#include "../core/ClipboardMonitor.h"
#include <QApplication>
#include <QClipboard>
#include <QToolTip>
#include <QCursor>
#include <QSettings>
#include <QDebug>
#include <QRegularExpression>

OCRResultWindow::OCRResultWindow(const QImage& image, int contextId, QWidget* parent)
    : FramelessDialog("识别文本", parent), m_image(image), m_contextId(contextId)
{
    setObjectName("OCRResultWindow");
    loadWindowSettings();
    setAttribute(Qt::WA_DeleteOnClose);
    setFixedSize(600, 450);
    
    // 强制更新标题栏样式
    m_titleLabel->clear();
    auto* titleLayout = qobject_cast<QHBoxLayout*>(m_titleLabel->parentWidget()->layout());
    if (titleLayout) {
        // 尝试在标题文字前插个图标
        QLabel* iconLabel = new QLabel;
        iconLabel->setPixmap(IconHelper::getIcon("screenshot_ocr", "#007ACC", 20).pixmap(20, 20));
        titleLayout->insertWidget(0, iconLabel);
        
        m_titleLabel->setText("识别文本");
        m_titleLabel->setStyleSheet("font-weight: bold; color: #eee;");
    }
    
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(15, 10, 15, 15);
    layout->setSpacing(12);

    m_textEdit = new QPlainTextEdit();
    m_textEdit->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_textEdit->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_textEdit->setPlaceholderText("正在识别中...");
    m_textEdit->setStyleSheet(R"(
        QPlainTextEdit {
            background-color: #1E1E1E;
            color: #D4D4D4;
            border: 1px solid #333333;
            border-radius: 4px;
            padding: 8px;
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 14px;
        }
        QScrollBar:vertical {
            border: none;
            background: #1E1E1E;
            width: 10px;
            margin: 0px;
        }
        QScrollBar::handle:vertical {
            background: #333;
            min-height: 20px;
            border-radius: 5px;
        }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
            height: 0px;
        }
    )");
    layout->addWidget(m_textEdit);

    auto* bottomLayout = new QHBoxLayout();
    bottomLayout->setSpacing(10);
    
    m_autoCopyCheck = new QCheckBox("下次自动复制");
    m_autoCopyCheck->setStyleSheet("QCheckBox { color: #999; font-size: 12px; } QCheckBox::indicator { width: 16px; height: 16px; }");
    
    QSettings settings("RapidNotes", "OCR");
    m_autoCopyCheck->setChecked(settings.value("autoCopy", false).toBool());
    
    // 立即保存设置，确保用户勾选后即刻生效
    connect(m_autoCopyCheck, &QCheckBox::toggled, [](bool checked){
        QSettings settings("RapidNotes", "OCR");
        settings.setValue("autoCopy", checked);
    });
    
    bottomLayout->addWidget(m_autoCopyCheck);

    bottomLayout->addStretch(1);

    QPushButton* toSimplifiedBtn = new QPushButton("转简体");
    toSimplifiedBtn->setFlat(true);
    toSimplifiedBtn->setStyleSheet("QPushButton { color: #1abc9c; border: none; font-size: 13px; } QPushButton:hover { color: #2ecc71; }");
    toSimplifiedBtn->setCursor(Qt::PointingHandCursor);
    connect(toSimplifiedBtn, &QPushButton::clicked, [this]{
        m_textEdit->setPlainText(StringUtils::convertChineseVariant(m_textEdit->toPlainText(), true));
    });
    bottomLayout->addWidget(toSimplifiedBtn);

    QPushButton* toTraditionalBtn = new QPushButton("转繁体");
    toTraditionalBtn->setFlat(true);
    toTraditionalBtn->setStyleSheet("QPushButton { color: #f39c12; border: none; font-size: 13px; } QPushButton:hover { color: #e67e22; }");
    toTraditionalBtn->setCursor(Qt::PointingHandCursor);
    connect(toTraditionalBtn, &QPushButton::clicked, [this]{
        m_textEdit->setPlainText(StringUtils::convertChineseVariant(m_textEdit->toPlainText(), false));
    });
    bottomLayout->addWidget(toTraditionalBtn);

    QPushButton* typesettingBtn = new QPushButton("排版");
    typesettingBtn->setFlat(true);
    typesettingBtn->setStyleSheet("QPushButton { color: #4a90e2; border: none; font-size: 13px; } QPushButton:hover { color: #6ab0ff; }");
    typesettingBtn->setCursor(Qt::PointingHandCursor);
    connect(typesettingBtn, &QPushButton::clicked, this, &OCRResultWindow::onTypesettingClicked);
    bottomLayout->addWidget(typesettingBtn);

    QPushButton* copyBtn = new QPushButton("复制");
    copyBtn->setFixedSize(80, 32);
    copyBtn->setStyleSheet(R"(
        QPushButton {
            background-color: #007ACC;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            font-size: 13px;
        }
        QPushButton:hover {
            background-color: #008be5;
        }
        QPushButton:pressed {
            background-color: #005a9e;
        }
    )");
    connect(copyBtn, &QPushButton::clicked, this, &OCRResultWindow::onCopyClicked);
    bottomLayout->addWidget(copyBtn);

    layout->addLayout(bottomLayout);
}

void OCRResultWindow::setRecognizedText(const QString& text, int contextId) {
    if (m_contextId != -1 && contextId != m_contextId) return;
    
    m_textEdit->setPlainText(text);
    
    if (m_autoCopyCheck->isChecked()) {
        if (!isVisible()) {
            // 静默模式反馈
            if (text.trimmed().isEmpty() || text.contains("未识别到") || text.contains("错误")) {
                this->show();
                return;
            }
            ToolTipOverlay::instance()->showText(QCursor::pos(), "✔ 识别完成并已复制到剪贴板");
        }
        onCopyClicked();
    }
}

void OCRResultWindow::onCopyClicked() {
    QString text = m_textEdit->toPlainText();
    if (!text.isEmpty()) {
        // [CRITICAL] 明确标记为 ocr_text 类型，确保通过识别提取的文字入库后显示扫描图标
        ClipboardMonitor::instance().forceNext("ocr_text");
        QApplication::clipboard()->setText(text);
    }
    QSettings settings("RapidNotes", "OCR");
    settings.setValue("autoCopy", m_autoCopyCheck->isChecked());
    
    // 明确关闭窗口。由于设置了 WA_DeleteOnClose，close() 会触发析构
    this->close();
}

void OCRResultWindow::onTypesettingClicked() {
    QString text = m_textEdit->toPlainText();
    if (text.isEmpty()) return;

    // 优化排版逻辑：合并被换行符切断的行，保留真正的段落（连续两个换行或空白行）
    // 处理逻辑：
    // 1. 统一换行符
    text.replace("\r\n", "\n");
    // 2. 识别段落：将两个以上的换行替换为特殊标记
    text.replace(QRegularExpression("\n{2,}"), "[[PARAGRAPH]]");
    // 3. 将剩余的单换行替换为空格（西文）或直接删除（中文）
    // 这里简单处理：删除所有单换行，去除行首尾空格
    QStringList lines = text.split('\n', Qt::SkipEmptyParts);
    QString merged;
    for (int i = 0; i < lines.size(); ++i) {
        merged += lines[i].trimmed();
    }
    // 4. 恢复段落
    merged.replace("[[PARAGRAPH]]", "\n\n");
    
    m_textEdit->setPlainText(merged);
}
```

## 文件: `src/ui/OCRResultWindow.h`

```cpp
#ifndef OCRRESULTWINDOW_H
#define OCRRESULTWINDOW_H

#include "FramelessDialog.h"
#include <QPlainTextEdit>
#include <QCheckBox>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>

class OCRResultWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit OCRResultWindow(const QImage& image, int contextId = -1, QWidget* parent = nullptr);
    void setRecognizedText(const QString& text, int contextId);

private slots:
    void onCopyClicked();
    void onTypesettingClicked();

private:
    QPlainTextEdit* m_textEdit;
    QCheckBox* m_autoCopyCheck;
    QImage m_image;
    int m_contextId;
};

#endif // OCRRESULTWINDOW_H
```

## 文件: `src/ui/OCRWindow.cpp`

```cpp
#include "OCRWindow.h"
#include "IconHelper.h"
#include "../core/OCRManager.h"
#include "../core/ClipboardMonitor.h"
#include <QApplication>
#include <QClipboard>
#include <QMimeData>
#include <QMouseEvent>
#include <QGraphicsDropShadowEffect>
#include <QFileDialog>
#include <QDropEvent>
#include <QFileInfo>
#include <QDateTime>
#include <QThread>

OCRWindow::OCRWindow(QWidget* parent) : FramelessDialog("截图取文", parent) {
    setObjectName("OCRWindow");
    setFixedSize(800, 500);
    setAcceptDrops(true);

    loadWindowSettings();
    initUI();
    onClearResults();
    
    qDebug() << "[OCR] OCRWindow 初始化完成，使用顺序处理模式";
    
    connect(&OCRManager::instance(), &OCRManager::recognitionFinished, 
            this, &OCRWindow::onRecognitionFinished, 
            static_cast<Qt::ConnectionType>(Qt::QueuedConnection | Qt::UniqueConnection));
}

OCRWindow::~OCRWindow() {
    m_processingQueue.clear();
    m_isProcessing = false;
}

void OCRWindow::initUI() {
    auto* mainHLayout = new QHBoxLayout(m_contentArea);
    mainHLayout->setContentsMargins(10, 10, 10, 10);
    mainHLayout->setSpacing(10);

    // --- 左侧：操作面板 ---
    auto* leftPanel = new QWidget();
    auto* leftLayout = new QVBoxLayout(leftPanel);
    leftLayout->setContentsMargins(0, 0, 0, 0);
    leftLayout->setSpacing(8);

    auto* btnBrowse = new QPushButton(" 本地浏览");
    btnBrowse->setIcon(IconHelper::getIcon("folder", "#ffffff"));
    btnBrowse->setFixedHeight(36);
    btnBrowse->setStyleSheet("QPushButton { background: #4a90e2; color: white; border-radius: 4px; padding: 0 10px; text-align: left; } QPushButton:hover { background: #357abd; }");
    connect(btnBrowse, &QPushButton::clicked, this, &OCRWindow::onBrowseAndRecognize);
    leftLayout->addWidget(btnBrowse);

    auto* btnPaste = new QPushButton(" 粘贴识别");
    btnPaste->setIcon(IconHelper::getIcon("copy", "#ffffff"));
    btnPaste->setFixedHeight(36);
    btnPaste->setStyleSheet("QPushButton { background: #2ecc71; color: white; border-radius: 4px; padding: 0 10px; text-align: left; } QPushButton:hover { background: #27ae60; }");
    connect(btnPaste, &QPushButton::clicked, this, &OCRWindow::onPasteAndRecognize);
    leftLayout->addWidget(btnPaste);

    leftLayout->addSpacing(10);

    auto* btnClear = new QPushButton(" 清空列表");
    btnClear->setIcon(IconHelper::getIcon("trash", "#ddbbbb"));
    btnClear->setFixedHeight(36);
    btnClear->setStyleSheet("QPushButton { background: #333; color: #ccc; border: 1px solid #444; border-radius: 4px; padding: 0 10px; text-align: left; } QPushButton:hover { background: #444; color: #fff; }");
    connect(btnClear, &QPushButton::clicked, this, &OCRWindow::onClearResults);
    leftLayout->addWidget(btnClear);

    leftLayout->addStretch();

    auto* btnCopy = new QPushButton(" 复制文字");
    btnCopy->setIcon(IconHelper::getIcon("copy", "#ffffff"));
    btnCopy->setFixedHeight(36);
    btnCopy->setStyleSheet("QPushButton { background: #3d3d3d; color: #eee; border: 1px solid #4a4a4a; border-radius: 4px; padding: 0 10px; text-align: left; } QPushButton:hover { background: #4d4d4d; }");
    connect(btnCopy, &QPushButton::clicked, this, &OCRWindow::onCopyResult);
    leftLayout->addWidget(btnCopy);

    leftPanel->setFixedWidth(120);
    mainHLayout->addWidget(leftPanel);

    // --- 中间：项目列表 ---
    auto* middlePanel = new QWidget();
    auto* middleLayout = new QVBoxLayout(middlePanel);
    middleLayout->setContentsMargins(0, 0, 0, 0);
    middleLayout->setSpacing(5);

    auto* listLabel = new QLabel("上传的项目");
    listLabel->setStyleSheet("color: #888; font-size: 11px; font-weight: bold;");
    middleLayout->addWidget(listLabel);

    m_itemList = new QListWidget();
    m_itemList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_itemList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_itemList->setStyleSheet(
        "QListWidget { background: #222; border: 1px solid #333; border-radius: 4px; color: #ddd; }"
        "QListWidget::item { height: 32px; padding-left: 5px; }"
        "QListWidget::item:selected { background: #357abd; color: white; border-radius: 2px; }"
    );
    connect(m_itemList, &QListWidget::itemSelectionChanged, this, &OCRWindow::onItemSelectionChanged);
    middleLayout->addWidget(m_itemList);

    middlePanel->setFixedWidth(180);
    mainHLayout->addWidget(middlePanel);

    // --- 右侧：结果展示 ---
    auto* rightPanel = new QWidget();
    auto* rightLayout = new QVBoxLayout(rightPanel);
    rightLayout->setContentsMargins(0, 0, 0, 0);
    rightLayout->setSpacing(5);

    auto* resultLabel = new QLabel("识别结果");
    resultLabel->setStyleSheet("color: #888; font-size: 11px; font-weight: bold;");
    rightLayout->addWidget(resultLabel);

    
    // 进度条
    m_progressBar = new QProgressBar();
    m_progressBar->setTextVisible(true);
    m_progressBar->setAlignment(Qt::AlignCenter);
    m_progressBar->setStyleSheet("QProgressBar { border: none; background: #333; border-radius: 4px; height: 6px; text-align: center; color: transparent; } QProgressBar::chunk { background-color: #4a90e2; border-radius: 4px; }");
    m_progressBar->hide();
    rightLayout->addWidget(m_progressBar);

    m_ocrResult = new QTextEdit();
    m_ocrResult->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_ocrResult->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_ocrResult->setReadOnly(true);
    m_ocrResult->setPlaceholderText("选择左侧项目查看识别结果...");
    m_ocrResult->setStyleSheet("QTextEdit { background: #1a1a1a; border: 1px solid #333; border-radius: 6px; color: #eee; font-size: 13px; padding: 10px; line-height: 1.4; }");
    rightLayout->addWidget(m_ocrResult);

    mainHLayout->addWidget(rightPanel);
}

void OCRWindow::onPasteAndRecognize() {
    qDebug() << "[OCR] 粘贴识别: 开始";
    
    // 自动清空之前的数据
    onClearResults();
    
    const QClipboard* clipboard = QApplication::clipboard();
    const QMimeData* mimeData = clipboard->mimeData();

    QList<QPair<QImage, QString>> imageData;

    if (!mimeData) return;

    if (mimeData->hasImage()) {
        QImage img = qvariant_cast<QImage>(mimeData->imageData());
        if (!img.isNull()) {
            imageData.append({img, "粘贴的图片"});
        }
    } else if (mimeData->hasUrls()) {
        for (const QUrl& url : mimeData->urls()) {
            QString path = url.toLocalFile();
            if (!path.isEmpty()) {
                QImage img(path);
                if (!img.isNull()) {
                    imageData.append({img, QFileInfo(path).fileName()});
                }
            }
        }
    }

    if (!imageData.isEmpty()) {
        // 限制最多 10 张图片
        if (imageData.size() > 10) {
            qDebug() << "[OCR] 粘贴识别: 图片数量超过限制，仅处理前 10 张";
            imageData = imageData.mid(0, 10);
        }
        
        qDebug() << "[OCR] 粘贴识别: 开始处理" << imageData.size() << "张图片";
        QList<QImage> imgs;
        for (auto& p : imageData) {
            OCRItem item;
            item.image = p.first;
            item.name = p.second;
            // 【核心修复】使用负数 ID 作为临时任务，避免与数据库中的 noteId 冲突导致误更新
            item.id = -(++m_lastUsedId);
            item.sessionVersion = m_sessionVersion;
            m_items.append(item);
            imgs << p.first;
            qDebug() << "[OCR] 添加任务 ID:" << item.id << "名称:" << item.name;

            auto* listItem = new QListWidgetItem(item.name, m_itemList);
            listItem->setData(Qt::UserRole, item.id);
            listItem->setIcon(IconHelper::getIcon("image", "#888"));
        }
        processImages(imgs);
        
        // 自动选中第一个新加入的项目
        m_itemList->setCurrentRow(m_itemList->count() - imageData.size());
    }
}

void OCRWindow::onBrowseAndRecognize() {
    QStringList files = QFileDialog::getOpenFileNames(this, "选择识别图片", "", "图片文件 (*.png *.jpg *.jpeg *.bmp *.gif)");
    if (files.isEmpty()) return;

    // 自动清空之前的数据
    onClearResults();

    qDebug() << "[OCR] 浏览识别: 选择了" << files.size() << "个文件";
    
    // 限制最多 10 张图片
    if (files.size() > 10) {
        qDebug() << "[OCR] 浏览识别: 文件数量超过限制，仅处理前 10 个";
        files = files.mid(0, 10);
    }
    
    QList<QImage> imgs;
    for (const QString& file : std::as_const(files)) {
        QImage img(file);
        if (!img.isNull()) {
            OCRItem item;
            item.image = img;
            item.name = QFileInfo(file).fileName();
            // 【核心修复】使用负数 ID
            item.id = -(++m_lastUsedId);
            item.sessionVersion = m_sessionVersion;
            m_items.append(item);
            imgs << img;
            qDebug() << "[OCR] 添加任务 ID:" << item.id << "文件:" << file;

            auto* listItem = new QListWidgetItem(item.name, m_itemList);
            listItem->setData(Qt::UserRole, item.id);
            listItem->setIcon(IconHelper::getIcon("image", "#888"));
        }
    }

    if (!imgs.isEmpty()) {
        processImages(imgs);
        m_itemList->setCurrentRow(m_itemList->count() - imgs.size());
    }
}

void OCRWindow::onClearResults() {
    qDebug() << "[OCR] 清空结果";
    
    m_isProcessing = false;
    m_processingQueue.clear();
    m_sessionVersion++; // 递增版本号，使旧的回调失效
    
    m_itemList->clear();
    m_items.clear();
    m_ocrResult->clear();
    
    // 重置进度条
    if (m_progressBar) {
        m_progressBar->hide();
        m_progressBar->setValue(0);
    }
    
    // 不重置 m_lastUsedId，防止异步回调 ID 冲突
    
    auto* summaryItem = new QListWidgetItem("--- 全部结果汇总 ---", m_itemList);
    summaryItem->setData(Qt::UserRole, 0); // 0 代表汇总
    summaryItem->setIcon(IconHelper::getIcon("file_managed", "#1abc9c"));
    m_itemList->setCurrentItem(summaryItem);
}

void OCRWindow::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasImage() || event->mimeData()->hasUrls()) {
        event->acceptProposedAction();
    }
}

void OCRWindow::dropEvent(QDropEvent* event) {
    qDebug() << "[OCR] 拖入识别: 开始";
    
    // 自动清空之前的数据
    onClearResults();
    
    const QMimeData* mime = event->mimeData();
    QList<QImage> imgsToProcess;

    // 限制最多 10 张图片
    int imageCount = 0;
    const int MAX_IMAGES = 10;

    if (mime->hasImage()) {
        QImage img = qvariant_cast<QImage>(mime->imageData());
        if (!img.isNull() && imageCount < MAX_IMAGES) {
            OCRItem item;
            item.image = img;
            item.name = "拖入的图片";
            // 【核心修复】使用负数 ID
            item.id = -(++m_lastUsedId);
            item.sessionVersion = m_sessionVersion;
            m_items.append(item);
            imgsToProcess << img;
            imageCount++;

            auto* listItem = new QListWidgetItem(item.name, m_itemList);
            listItem->setData(Qt::UserRole, item.id);
            listItem->setIcon(IconHelper::getIcon("image", "#888"));
        }
    }

    if (mime->hasUrls()) {
        for (const QUrl& url : mime->urls()) {
            if (imageCount >= MAX_IMAGES) {
                qDebug() << "[OCR] 拖入识别: 已达到最大图片数量限制 (10 张)";
                break;
            }
            
            QString path = url.toLocalFile();
            if (!path.isEmpty()) {
                QImage img(path);
                if (!img.isNull()) {
                    OCRItem item;
                    item.image = img;
                    item.name = QFileInfo(path).fileName();
                    // 【核心修复】使用负数 ID
                    item.id = -(++m_lastUsedId);
                    item.sessionVersion = m_sessionVersion;
                    m_items.append(item);
                    imgsToProcess << img;
                    imageCount++;

                    auto* listItem = new QListWidgetItem(item.name, m_itemList);
                    listItem->setData(Qt::UserRole, item.id);
                    listItem->setIcon(IconHelper::getIcon("image", "#888"));
                }
            }
        }
    }

    if (!imgsToProcess.isEmpty()) {
        processImages(imgsToProcess);
        m_itemList->setCurrentRow(m_itemList->count() - imgsToProcess.size());
        event->acceptProposedAction();
    }
}

void OCRWindow::processImages(const QList<QImage>& images) {
    qDebug() << "[OCR] processImages: 添加" << images.size() << "张图片到队列";
    
    m_processingQueue.clear(); // 清空旧队列
    
    // 将所有图片添加到队列
    int startIdx = m_items.size() - images.size();
    for (int i = 0; i < images.size(); ++i) {
        int taskId = m_items[startIdx + i].id;
        m_processingQueue.enqueue(taskId);
        qDebug() << "[OCR] 添加到队列 ID:" << taskId;
    }
    
    // 显示并初始化进度条
    if (m_progressBar && !images.isEmpty()) {
        m_progressBar->setMaximum(images.size()); // 仅当前批次
        m_progressBar->setValue(0);
        m_progressBar->show();
    }
    
    // 如果当前没有在处理，立即开始处理
    if (!m_isProcessing) {
        qDebug() << "[OCR] 开始顺序处理";
        processNextImage();
    }
}

void OCRWindow::processNextImage() {
    // 检查队列是否为空
    if (m_processingQueue.isEmpty()) {
        qDebug() << "[OCR] 所有任务处理完成";
        m_isProcessing = false;
        updateRightDisplay();
        return;
    }
    
    m_isProcessing = true;
    int taskId = m_processingQueue.dequeue();
    
    qDebug() << "[OCR] 开始处理 ID:" << taskId << "剩余:" << m_processingQueue.size();
    
    // 找到对应的图片
    OCRItem* item = nullptr;
    for (auto& it : m_items) {
        if (it.id == taskId) {
            item = &it;
            break;
        }
    }
    
    if (!item) {
        qDebug() << "[OCR] 错误: 未找到任务 ID:" << taskId;
        // 继续处理下一个
        QMetaObject::invokeMethod(this, &OCRWindow::processNextImage, Qt::QueuedConnection);
        return;
    }
    
    // 启动异步识别
    // 注意：这里我们使用 recognizeAsync，它会在后台线程运行
    // 识别完成后会发射 recognitionFinished 信号，我们在槽函数中触发下一个任务
    qDebug() << "[OCR] 调用 recognizeAsync ID:" << taskId;
    OCRManager::instance().recognizeAsync(item->image, taskId);
}


void OCRWindow::onItemSelectionChanged() {
    updateRightDisplay();
}

void OCRWindow::onRecognitionFinished(const QString& text, int contextId) {
    qDebug() << "[OCR] onRecognitionFinished: 收到识别结果 ID:" << contextId 
             << "线程:" << QThread::currentThread() << "文本长度:" << text.length();
    
    bool found = false;
    for (auto& item : m_items) {
        if (item.id == contextId) {
            // 检查会话版本号
            if (item.sessionVersion != m_sessionVersion) {
                qDebug() << "[OCR] 忽略过期回调 ID:" << contextId 
                         << "任务会话:" << item.sessionVersion 
                         << "当前会话:" << m_sessionVersion;
                // 注意：旧任务的回调不应该触发下一个新任务的处理
                // 因为新任务的处理循环是由新的 processImages 启动的
                return; 
            }
            
            item.result = text.trimmed();
            item.isFinished = true;
            found = true;
            qDebug() << "[OCR] 更新任务状态 ID:" << contextId << "名称:" << item.name;
            break;
        }
    }
    
    if (!found) {
        // 如果未找到任务（可能已被清空），也不要触发下一个
        qDebug() << "[OCR] 警告: 未找到对应的任务 ID:" << contextId;
        return;
    }
    
    // 统计完成进度
    int finished = 0;
    for (const auto& item : std::as_const(m_items)) {
        if (item.isFinished) finished++;
    }
    qDebug() << "[OCR] 识别进度:" << finished << "/" << m_items.size();
    
    // 更新进度条
    if (m_progressBar) {
        m_progressBar->setValue(finished);
        if (finished >= m_items.size()) {
            QTimer::singleShot(1000, m_progressBar, &QProgressBar::hide); // 完成1秒后隐藏
        }
    }
    
    // 延迟到主线程更新UI
    QMetaObject::invokeMethod(this, &OCRWindow::updateRightDisplay, Qt::QueuedConnection);
    
    // 延迟到下一个事件循环处理任务，避免栈溢出
    qDebug() << "[OCR] 当前任务完成，准备处理下一个";
    QMetaObject::invokeMethod(this, &OCRWindow::processNextImage, Qt::QueuedConnection);
}

void OCRWindow::updateRightDisplay() {
    // 确保在主线程执行
    if (QThread::currentThread() != this->thread()) {
        QMetaObject::invokeMethod(this, &OCRWindow::updateRightDisplay, Qt::QueuedConnection);
        return;
    }

    qDebug() << "[OCR] updateRightDisplay: 开始更新显示 线程:" << QThread::currentThread();
    
    if (!m_itemList) {
        qDebug() << "[OCR] updateRightDisplay: m_itemList 为空";
        return;
    }
    
    if (!m_ocrResult) {
        qDebug() << "[OCR] updateRightDisplay: m_ocrResult 为空";
        return;
    }
    
    auto* current = m_itemList->currentItem();
    if (!current) {
        qDebug() << "[OCR] updateRightDisplay: 没有选中项";
        return;
    }

    int id = current->data(Qt::UserRole).toInt();
    qDebug() << "[OCR] updateRightDisplay: 当前选中 ID:" << id << "m_items 大小:" << m_items.size();

    if (id == 0) {
        // 展示全部
        qDebug() << "[OCR] updateRightDisplay: 展示全部结果";
        QString allText;
        int itemCount = 0;
        for (const auto& item : std::as_const(m_items)) {
            itemCount++;
            if (!allText.isEmpty()) allText += "\n\n";
            allText += QString("【%1】\n").arg(item.name);
            allText += item.isFinished ? item.result : "正在识别管理中...";
            allText += "\n-----------------------------------";
        }
        qDebug() << "[OCR] updateRightDisplay: 处理了" << itemCount << "个项目，文本长度:" << allText.length();
        m_ocrResult->setPlainText(allText);
        qDebug() << "[OCR] updateRightDisplay: setPlainText 完成";
    } else {
        // 展示单个
        qDebug() << "[OCR] updateRightDisplay: 展示单个结果 ID:" << id;
        bool found = false;
        for (const auto& item : std::as_const(m_items)) {
            if (item.id == id) {
                found = true;
                QString text = item.isFinished ? item.result : "正在识别中，请稍候...";
                qDebug() << "[OCR] updateRightDisplay: 找到项目，文本长度:" << text.length();
                m_ocrResult->setPlainText(text);
                qDebug() << "[OCR] updateRightDisplay: setPlainText 完成";
                break;
            }
        }
        if (!found) {
            qDebug() << "[OCR] updateRightDisplay: 警告 - 未找到 ID:" << id;
        }
    }
    qDebug() << "[OCR] updateRightDisplay: 完成";
}

void OCRWindow::onCopyResult() {
    QString text = m_ocrResult->toPlainText();
    if (!text.isEmpty()) {
        // [CRITICAL] 明确标记为 ocr_text 类型，确保通过识别提取的文字入库后显示扫描图标
        ClipboardMonitor::instance().forceNext("ocr_text");
        QApplication::clipboard()->setText(text);
    }
}

```

## 文件: `src/ui/OCRWindow.h`

```cpp
#ifndef OCRWINDOW_H
#define OCRWINDOW_H

#include "FramelessDialog.h"
#include <QTextEdit>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QMap>
#include <QListWidget>
#include <QTimer>
#include <QQueue>
#include <QProgressBar>

class OCRWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit OCRWindow(QWidget* parent = nullptr);
    ~OCRWindow();

    void processImages(const QList<QImage>& images);

private slots:
    void onPasteAndRecognize();
    void onBrowseAndRecognize();
    void onClearResults();
    void onCopyResult();
    void onItemSelectionChanged();
    void processNextImage();  // 处理队列中的下一张图片
    void onRecognitionFinished(const QString& text, int contextId);

protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dropEvent(QDropEvent* event) override;

private:
    void initUI();
    void updateRightDisplay();

    struct OCRItem {
        QImage image;
        QString name;
        QString result;
        bool isFinished = false;
        int id = -1;
        int sessionVersion = 0;
    };

    QListWidget* m_itemList = nullptr;
    QTextEdit* m_ocrResult = nullptr;
    QProgressBar* m_progressBar = nullptr;
    
    QList<OCRItem> m_items;
    int m_lastUsedId = 0;
    int m_sessionVersion = 0;
    
    // 顺序处理队列
    QQueue<int> m_processingQueue;  // 待处理的任务 ID 队列
    bool m_isProcessing = false;  // 是否正在处理
};

#endif // OCRWINDOW_H
```

## 文件: `src/ui/PasswordGeneratorWindow.cpp`

```cpp
#include "PasswordGeneratorWindow.h"
#include "IconHelper.h"
#include "ToolTipOverlay.h"
#include "../core/DatabaseManager.h"
#include "../core/ClipboardMonitor.h"
#include <QMouseEvent>
#include <QApplication>
#include <QClipboard>
#include <QRandomGenerator>
#include <QTimer>
#include <QToolTip>
#include <QGraphicsDropShadowEffect>
#include <QSettings>

PasswordGeneratorWindow::PasswordGeneratorWindow(QWidget* parent) : FramelessDialog("密码生成器", parent) {
    setObjectName("PasswordGeneratorWindow");
    setFixedSize(570, 400);

    loadWindowSettings();
    initUI();
}

PasswordGeneratorWindow::~PasswordGeneratorWindow() {
}

void PasswordGeneratorWindow::initUI() {
    auto* innerLayout = new QVBoxLayout(m_contentArea);
    innerLayout->setContentsMargins(20, 10, 20, 20);
    innerLayout->setSpacing(10);

    m_usageEntry = new QLineEdit();
    m_usageEntry->setPlaceholderText("Account / Usage (e.g. GitHub, Gmail...)");
    m_usageEntry->setFixedHeight(36);
    m_usageEntry->setStyleSheet("QLineEdit { background-color: #252525; border: 1px solid #333333; border-radius: 8px; color: #cccccc; font-size: 13px; padding-left: 10px; } QLineEdit:focus { border-color: #3b8ed0; }");
    innerLayout->addWidget(m_usageEntry);

    innerLayout->addWidget(createDisplayArea());
    innerLayout->addWidget(createControlsArea());

    auto* generateBtn = new QPushButton("Generate Password");
    generateBtn->setFixedHeight(40);
    generateBtn->setFixedWidth(200);
    generateBtn->setStyleSheet("QPushButton { background-color: #2cc985; color: white; border: none; border-radius: 20px; font-size: 13px; font-weight: bold; } QPushButton:hover { background-color: #229c67; }");
    connect(generateBtn, &QPushButton::clicked, this, &PasswordGeneratorWindow::generatePassword);
    innerLayout->addWidget(generateBtn, 0, Qt::AlignCenter);

    m_statusLabel = new QLabel("");
    m_statusLabel->setAlignment(Qt::AlignCenter);
    m_statusLabel->setStyleSheet("color: gray; font-size: 9px;");
    innerLayout->addWidget(m_statusLabel);

}

QWidget* PasswordGeneratorWindow::createDisplayArea() {
    auto* frame = new QWidget();
    auto* layout = new QVBoxLayout(frame);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->setSpacing(4);

    m_passEntry = new QLineEdit();
    m_passEntry->setFixedHeight(44);
    m_passEntry->setAlignment(Qt::AlignCenter);
    m_passEntry->setReadOnly(true);
    m_passEntry->setStyleSheet("QLineEdit { background-color: #2b2b2b; border: none; border-radius: 10px; color: #e0e0e0; font-family: Consolas; font-size: 15px; }");

    m_strengthBar = new QProgressBar();
    m_strengthBar->setFixedHeight(3);
    m_strengthBar->setTextVisible(false);
    m_strengthBar->setStyleSheet("QProgressBar { border: none; background-color: #2b2b2b; border-radius: 1.5px; } QProgressBar::chunk { background-color: #4ade80; border-radius: 1.5px; }");
    m_strengthBar->setRange(0, 100);
    m_strengthBar->setValue(0);

    layout->addWidget(m_passEntry);
    layout->addWidget(m_strengthBar);
    return frame;
}

QWidget* PasswordGeneratorWindow::createControlsArea() {
    auto* frame = new QWidget();
    auto* layout = new QVBoxLayout(frame);
    layout->setContentsMargins(0, 5, 0, 5);
    layout->setSpacing(10);

    m_lengthLabel = new QLabel("Length: 16");
    m_lengthLabel->setStyleSheet("font-size: 12px; font-weight: bold; color: #cccccc;");

    m_lengthSlider = new QSlider(Qt::Horizontal);
    m_lengthSlider->setRange(8, 64);
    
    QSettings settings("RapidNotes", "PasswordGenerator");
    int savedLen = settings.value("length", 16).toInt();
    m_lengthSlider->setValue(savedLen);
    m_lengthLabel->setText(QString("Length: %1").arg(savedLen));

    connect(m_lengthSlider, &QSlider::valueChanged, [this](int v) {
        m_lengthLabel->setText(QString("Length: %1").arg(v));
        QSettings("RapidNotes", "PasswordGenerator").setValue("length", v);
    });
    m_lengthSlider->setStyleSheet("QSlider::groove:horizontal { border: 1px solid #444; height: 4px; background: #333; margin: 2px 0; border-radius: 2px; } "
                                  "QSlider::handle:horizontal { background-color: #3b8ed0; border: 5px solid #1e1e1e; width: 18px; height: 18px; margin: -7px 0; border-radius: 9px; } "
                                  "QSlider::sub-page:horizontal { background: #3b8ed0; border-radius: 2px; }");

    auto* checksFrame = new QWidget();
    auto* checksLayout = new QHBoxLayout(checksFrame);
    checksLayout->setContentsMargins(10, 0, 10, 0);

    QString cbStyle = "QCheckBox { spacing: 8px; font-size: 12px; font-weight: bold; color: #cccccc; } "
                      "QCheckBox::indicator { width: 18px; height: 18px; border: 2px solid #555; border-radius: 5px; background-color: transparent; } "
                      "QCheckBox::indicator:hover { border-color: #2cc985; } "
                      "QCheckBox::indicator:checked { background-color: #2cc985; border-color: #2cc985; }";

    m_checkUpper = new QCheckBox("A-Z"); m_checkUpper->setChecked(true); m_checkUpper->setStyleSheet(cbStyle);
    m_checkLower = new QCheckBox("a-z"); m_checkLower->setChecked(true); m_checkLower->setStyleSheet(cbStyle);
    m_checkDigits = new QCheckBox("0-9"); m_checkDigits->setChecked(true); m_checkDigits->setStyleSheet(cbStyle);
    m_checkSymbols = new QCheckBox("@#$"); m_checkSymbols->setChecked(true); m_checkSymbols->setStyleSheet(cbStyle);

    checksLayout->addStretch();
    checksLayout->addWidget(m_checkUpper);
    checksLayout->addStretch();
    checksLayout->addWidget(m_checkLower);
    checksLayout->addStretch();
    checksLayout->addWidget(m_checkDigits);
    checksLayout->addStretch();
    checksLayout->addWidget(m_checkSymbols);
    checksLayout->addStretch();

    m_excludeAmbiguous = new QCheckBox("排除相似字符 (0O1lI)");
    m_excludeAmbiguous->setChecked(settings.value("excludeAmbiguous", false).toBool());
    m_excludeAmbiguous->setStyleSheet("QCheckBox { spacing: 8px; font-size: 11px; color: #cccccc; } "
                                     "QCheckBox::indicator { width: 16px; height: 16px; border: 2px solid #555; border-radius: 4px; background-color: transparent; } "
                                     "QCheckBox::indicator:hover { border-color: #3b8ed0; } "
                                     "QCheckBox::indicator:checked { background-color: #3b8ed0; border-color: #3b8ed0; }");
    connect(m_excludeAmbiguous, &QCheckBox::toggled, [](bool checked){
        QSettings("RapidNotes", "PasswordGenerator").setValue("excludeAmbiguous", checked);
    });

    layout->addWidget(m_lengthLabel);
    layout->addWidget(m_lengthSlider);
    layout->addWidget(checksFrame);
    layout->addWidget(m_excludeAmbiguous);

    return frame;
}

void PasswordGeneratorWindow::generatePassword() {
    QString usageText = m_usageEntry->text().trimmed();
    if (usageText.isEmpty()) {
        m_usageEntry->setStyleSheet("QLineEdit { background-color: #252525; border: 1px solid #ef4444; border-radius: 8px; color: #cccccc; font-size: 13px; padding-left: 10px; }");
        ToolTipOverlay::instance()->showText(m_usageEntry->mapToGlobal(QPoint(0, m_usageEntry->height())), "请输入账号备注信息！");
        QTimer::singleShot(1500, [this]() {
            m_usageEntry->setStyleSheet("QLineEdit { background-color: #252525; border: 1px solid #333333; border-radius: 8px; color: #cccccc; font-size: 13px; padding-left: 10px; }");
        });
        return;
    }

    if (!m_checkUpper->isChecked() && !m_checkLower->isChecked() && !m_checkDigits->isChecked() && !m_checkSymbols->isChecked()) {
        ToolTipOverlay::instance()->showText(m_passEntry->mapToGlobal(QPoint(0, 0)), "至少选择一种字符类型！");
        return;
    }

    int length = m_lengthSlider->value();
    QString pwd = generateSecurePassword(length, m_checkUpper->isChecked(), m_checkLower->isChecked(), m_checkDigits->isChecked(), m_checkSymbols->isChecked(), m_excludeAmbiguous->isChecked());

    m_passEntry->setText(pwd);
    
    // 1. 手动存入数据库：备注为标题，密码为内容，绑定双标签
    DatabaseManager::instance().addNote(usageText, pwd, {"密码", "密码生成器"}, "", -1, "text");

    // 2. 复制到剪贴板前先屏蔽自动监听，防止重复入库。仅复制密码本体。
    ClipboardMonitor::instance().skipNext();
    QApplication::clipboard()->setText(pwd);

    m_statusLabel->setText(QString("✓ 已保存并复制密码！[%1]").arg(usageText));
    m_statusLabel->setStyleSheet("color: #4ade80; font-size: 9px;");

    // Update strength bar
    if (length < 10) {
        m_strengthBar->setStyleSheet("QProgressBar { border: none; background-color: #2b2b2b; border-radius: 1.5px; } QProgressBar::chunk { background-color: #ef4444; border-radius: 1.5px; }");
        m_strengthBar->setValue(30);
    } else if (length < 16) {
        m_strengthBar->setStyleSheet("QProgressBar { border: none; background-color: #2b2b2b; border-radius: 1.5px; } QProgressBar::chunk { background-color: #f59e0b; border-radius: 1.5px; }");
        m_strengthBar->setValue(60);
    } else {
        m_strengthBar->setStyleSheet("QProgressBar { border: none; background-color: #2b2b2b; border-radius: 1.5px; } QProgressBar::chunk { background-color: #2cc985; border-radius: 1.5px; }");
        m_strengthBar->setValue(100);
    }
}

QString PasswordGeneratorWindow::generateSecurePassword(int length, bool upper, bool lower, bool digits, bool symbols, bool excludeAmbiguous) {
    QString pool = "";
    QString required = "";
    QString symStr = "!@#$%^&*()-_=+[]{}|;:,.<>?/~`";
    QString ambig = "0O1lI";

    auto addFromSet = [&](bool use, const QString& set) {
        if (!use) return;
        QString filtered = set;
        if (excludeAmbiguous) {
            for (QChar c : ambig) filtered.remove(c);
        }
        if (!filtered.isEmpty()) {
            pool += filtered;
            required += filtered.at(QRandomGenerator::global()->bounded(filtered.length()));
        }
    };

    addFromSet(upper, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    addFromSet(lower, "abcdefghijklmnopqrstuvwxyz");
    addFromSet(digits, "0123456789");
    addFromSet(symbols, symStr);

    if (pool.isEmpty()) return "";

    QString pwd = required;
    while (pwd.length() < length) {
        pwd += pool.at(QRandomGenerator::global()->bounded(pool.length()));
    }

    // Shuffle
    for (int i = 0; i < pwd.length(); ++i) {
        int j = QRandomGenerator::global()->bounded(pwd.length());
        QChar temp = pwd[i];
        pwd[i] = pwd[j];
        pwd[j] = temp;
    }

    return pwd.left(length);
}

```

## 文件: `src/ui/PasswordGeneratorWindow.h`

```cpp
#ifndef PASSWORDGENERATORWINDOW_H
#define PASSWORDGENERATORWINDOW_H

#include "FramelessDialog.h"
#include <QLineEdit>
#include <QProgressBar>
#include <QSlider>
#include <QCheckBox>
#include <QLabel>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>

class PasswordGeneratorWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit PasswordGeneratorWindow(QWidget* parent = nullptr);
    ~PasswordGeneratorWindow();

private slots:
    void generatePassword();

private:
    void initUI();
    QWidget* createDisplayArea();
    QWidget* createControlsArea();
    QString generateSecurePassword(int length, bool upper, bool lower, bool digits, bool symbols, bool excludeAmbiguous);

    QLineEdit* m_usageEntry;
    QLineEdit* m_passEntry;
    QProgressBar* m_strengthBar;
    QLabel* m_lengthLabel;
    QSlider* m_lengthSlider;
    QCheckBox* m_checkUpper;
    QCheckBox* m_checkLower;
    QCheckBox* m_checkDigits;
    QCheckBox* m_checkSymbols;
    QCheckBox* m_excludeAmbiguous;
    QLabel* m_statusLabel;
    QPoint m_dragPos;
};

#endif // PASSWORDGENERATORWINDOW_H
```

## 文件: `src/ui/PixelRulerOverlay.cpp`

```cpp
#include "PixelRulerOverlay.h"
#include "ToolTipOverlay.h"
#include "IconHelper.h"
#include "../core/DatabaseManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QScreen>
#include <QGuiApplication>
#include <QMouseEvent>
#include <QKeyEvent>
#include <QPainter>
#include <QFontMetrics>
#include <cmath>

PixelRulerOverlay::PixelRulerOverlay(QWidget* parent) : QWidget(nullptr) {
    // [CRITICAL] 核心架构修复：作为顶级窗口，不使用 grabMouse 以允许与子部件 m_toolbar 交互
    setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool);
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_NoSystemBackground);
    setCursor(Qt::CrossCursor);
    setMouseTracking(true);
    
    QRect totalRect;
    const auto screens = QGuiApplication::screens();
    for (QScreen* screen : screens) {
        QRect geom = screen->geometry();
        totalRect = totalRect.united(geom);
        ScreenCapture cap;
        cap.geometry = geom;
        cap.dpr = screen->devicePixelRatio();
        cap.image = screen->grabWindow(0, 0, 0, geom.width(), geom.height()).toImage();
        m_captures.append(cap);
    }
    setGeometry(totalRect);

    initToolbar();
    setMode(Spacing);
}

PixelRulerOverlay::~PixelRulerOverlay() {
    if (m_toolbar) { m_toolbar->close(); m_toolbar->deleteLater(); }
}

bool PixelRulerOverlay::eventFilter(QObject* watched, QEvent* event) {
    if (event->type() == QEvent::HoverEnter) {
        QString text = watched->property("tooltipText").toString();
        if (!text.isEmpty()) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), text);
            return true;
        }
    } else if (event->type() == QEvent::HoverLeave) {
        ToolTipOverlay::hideTip();
        return true;
    }
    return QWidget::eventFilter(watched, event);
}

void PixelRulerOverlay::initToolbar() {
    // 将工具栏作为本窗体的子部件，确保它在最顶层且可交互
    m_toolbar = new QFrame(this);
    m_toolbar->setObjectName("rulerToolbar");
    m_toolbar->setStyleSheet(
        "QFrame#rulerToolbar { background: #1e1e1e; border-radius: 8px; border: 1px solid #444; }"
        "QPushButton { background: transparent; border: 1px solid transparent; border-radius: 4px; padding: 8px; }"
        "QPushButton:hover { background: #333; border: 1px solid #555; }"
        "QPushButton:checked { background: #007ACC; border: 1px solid #007ACC; }"
    );
    auto* l = new QHBoxLayout(m_toolbar);
    l->setContentsMargins(8, 4, 8, 4);
    l->setSpacing(8);

    auto addBtn = [&](const QString& icon, const QString& tip, Mode m, int key) {
        auto* btn = new QPushButton();
        btn->setAutoDefault(false);
        btn->setIcon(IconHelper::getIcon(icon, "#FFFFFF"));
        btn->setIconSize(QSize(20, 20));
        btn->setCheckable(true);
        btn->setProperty("tooltipText", QString("%1 (数字键 %2)").arg(tip).arg(key));
        btn->installEventFilter(this);
        connect(btn, &QPushButton::clicked, [this, m, btn](){
            for(auto* b : m_toolbar->findChildren<QPushButton*>()) b->setChecked(false);
            btn->setChecked(true);
            setMode(m);
        });
        l->addWidget(btn);
        if (m == Spacing) btn->setChecked(true);
        return btn;
    };

    addBtn("ruler_bounds", "边界测量", Bounds, 1);
    addBtn("ruler_spacing", "十字测量", Spacing, 2);
    addBtn("ruler_hor", "水平测量", Horizontal, 3);
    addBtn("ruler_ver", "垂直测量", Vertical, 4);

    auto* btnClose = new QPushButton();
    btnClose->setAutoDefault(false);
    btnClose->setIcon(IconHelper::getIcon("close", "#E81123"));
    btnClose->setIconSize(QSize(20, 20));
    connect(btnClose, &QPushButton::clicked, this, &QWidget::close);
    l->addWidget(btnClose);

    m_toolbar->adjustSize();
    m_toolbar->move((width() - m_toolbar->width()) / 2, 40);
    m_toolbar->show();
}

void PixelRulerOverlay::setMode(Mode m) {
    m_mode = m;
    m_startPoint = QPoint();
    update();
}

void PixelRulerOverlay::paintEvent(QPaintEvent*) {
    QPainter p(this);
    // 背景填充极低透明度，确保捕获鼠标移动
    p.fillRect(rect(), QColor(0, 0, 0, 1));
    p.setRenderHint(QPainter::Antialiasing);

    QPoint cur = mapFromGlobal(QCursor::pos());
    
    if (m_mode == Spacing) {
        drawCrossSpacing(p, cur);
    } else if (m_mode == Horizontal) {
        drawOneWaySpacing(p, cur, true);
    } else if (m_mode == Vertical) {
        drawOneWaySpacing(p, cur, false);
    } else if (m_mode == Bounds) {
        if (!m_startPoint.isNull()) drawBounds(p, m_startPoint, cur);
    }
}

// 绘制十字探测
void PixelRulerOverlay::drawCrossSpacing(QPainter& p, const QPoint& pos) {
    const ScreenCapture* cap = getCapture(mapToGlobal(pos));
    if (!cap) return;

    QPoint relPos = mapToGlobal(pos) - cap->geometry.topLeft();
    int px = relPos.x() * cap->dpr;
    int py = relPos.y() * cap->dpr;

    int left = findEdge(cap->image, px, py, -1, 0) / cap->dpr;
    int right = findEdge(cap->image, px, py, 1, 0) / cap->dpr;
    int top = findEdge(cap->image, px, py, 0, -1) / cap->dpr;
    int bottom = findEdge(cap->image, px, py, 0, 1) / cap->dpr;

    // 使用橙红色实线 (#ff5722)，对标用户提供的设计图
    p.setPen(QPen(QColor(255, 87, 34), 1, Qt::SolidLine));
    p.drawLine(pos.x() - left, pos.y(), pos.x() + right, pos.y());
    p.drawLine(pos.x(), pos.y() - top, pos.x(), pos.y() + bottom);

    // 绘制两端的小圆点 (对标 PowerToys 细节)
    p.setBrush(QColor(255, 87, 34));
    p.setPen(Qt::NoPen);
    p.drawEllipse(QPoint(pos.x() - left, pos.y()), 2, 2);
    p.drawEllipse(QPoint(pos.x() + right, pos.y()), 2, 2);
    p.drawEllipse(QPoint(pos.x(), pos.y() - top), 2, 2);
    p.drawEllipse(QPoint(pos.x(), pos.y() + bottom), 2, 2);

    // [CRITICAL] 采用单标签汇总模式，显示 W x H，避免四个标签互相遮挡
    // 偏移位置设在交叉点右下方，避免遮挡准星
    QString text = QString("%1 × %2").arg(left + right).arg(top + bottom);
    drawInfoBox(p, pos + QPoint(60, 30), text);
}

// 绘制单向探测 (水平或垂直)
void PixelRulerOverlay::drawOneWaySpacing(QPainter& p, const QPoint& pos, bool hor) {
    const ScreenCapture* cap = getCapture(mapToGlobal(pos));
    if (!cap) return;

    QPoint relPos = mapToGlobal(pos) - cap->geometry.topLeft();
    int px = relPos.x() * cap->dpr;
    int py = relPos.y() * cap->dpr;

    p.setPen(QPen(QColor(255, 87, 34), 1, Qt::SolidLine));
    if (hor) {
        int left = findEdge(cap->image, px, py, -1, 0) / cap->dpr;
        int right = findEdge(cap->image, px, py, 1, 0) / cap->dpr;
        p.drawLine(pos.x() - left, pos.y(), pos.x() + right, pos.y());
        // 绘制两端截止线
        p.drawLine(pos.x() - left, pos.y() - 10, pos.x() - left, pos.y() + 10);
        p.drawLine(pos.x() + right, pos.y() - 10, pos.x() + right, pos.y() + 10);
        drawLabel(p, pos.x() + (right - left)/2, pos.y() - 20, left + right, true, true);
    } else {
        int top = findEdge(cap->image, px, py, 0, -1) / cap->dpr;
        int bottom = findEdge(cap->image, px, py, 0, 1) / cap->dpr;
        p.drawLine(pos.x(), pos.y() - top, pos.x(), pos.y() + bottom);
        p.drawLine(pos.x() - 10, pos.y() - top, pos.x() + 10, pos.y() - top);
        p.drawLine(pos.x() - 10, pos.y() + bottom, pos.x() + 10, pos.y() + bottom);
        drawLabel(p, pos.x() + 20, pos.y() + (bottom - top)/2, top + bottom, false, true);
    }
}

void PixelRulerOverlay::drawLabel(QPainter& p, int x, int y, int val, bool isHor, bool isFixed) {
    if (val <= 1) return;
    QString text = QString::number(val);
    drawInfoBox(p, QPoint(x, y), text);
}

void PixelRulerOverlay::drawBounds(QPainter& p, const QPoint& s, const QPoint& e) {
    QRect r = QRect(s, e).normalized();
    p.setPen(QPen(Qt::cyan, 2));
    p.setBrush(QColor(0, 255, 255, 30));
    p.drawRect(r);

    QString text = QString("%1 × %2").arg(r.width()).arg(r.height());
    // [CRITICAL] 优化 Tip 位置：不再显示在选取中心，而是显示在选取下方且位于鼠标光标左下角
    QFontMetrics fm(p.font());
    int w = fm.horizontalAdvance(text) + 20;
    int h = 26;

    // 计算位置：右边缘靠近鼠标，且整体在选取区域下方
    int tipX = e.x() - 5 - w / 2;
    int tipY = std::max(r.bottom(), e.y()) + 10 + h / 2;
    
    drawInfoBox(p, QPoint(tipX, tipY), text);
}

void PixelRulerOverlay::drawInfoBox(QPainter& p, const QPoint& pos, const QString& text) {
    QFontMetrics fm(p.font());
    int w = fm.horizontalAdvance(text) + 20;
    int h = 26;
    // 以 pos 为中心绘制
    QRect r(pos.x() - w/2, pos.y() - h/2, w, h);
    
    // 自动边界调整，确保标签不超出屏幕
    if (r.right() > width()) r.moveRight(width() - 10);
    if (r.left() < 0) r.moveLeft(10);
    if (r.bottom() > height()) r.moveBottom(height() - 10);
    if (r.top() < 0) r.moveTop(10);

    // 添加 1 像素深灰色边框
    p.setPen(QPen(QColor(176, 176, 176), 1));
    p.setBrush(QColor(43, 43, 43)); // 移除透明度，改为完全不透明
    p.drawRoundedRect(r, 4, 4);
    p.setPen(Qt::white);
    p.drawText(r, Qt::AlignCenter, text);
}

int PixelRulerOverlay::findEdge(const QImage& img, int x, int y, int dx, int dy) {
    if (!img.rect().contains(x, y)) return 0;
    QColor startColor = img.pixelColor(x, y);
    int dist = 0;
    int curX = x + dx, curY = y + dy;
    while (img.rect().contains(curX, curY)) {
        QColor c = img.pixelColor(curX, curY);
        // 比较颜色差异,大于阈值则认为遇到了边界
        // 阈值 10: RGB 总差异 < 10 视为同色,提高边界检测精度
        if (colorDiff(startColor, c) > 10) break;
        dist++;
        curX += dx;
        curY += dy;
    }
    return dist;
}

int PixelRulerOverlay::colorDiff(const QColor& c1, const QColor& c2) {
    return std::abs(c1.red() - c2.red()) + std::abs(c1.green() - c2.green()) + std::abs(c1.blue() - c2.blue());
}

const PixelRulerOverlay::ScreenCapture* PixelRulerOverlay::getCapture(const QPoint& globalPos) {
    for (const auto& cap : m_captures) if (cap.geometry.contains(globalPos)) return &cap;
    return m_captures.isEmpty() ? nullptr : &m_captures[0];
}

void PixelRulerOverlay::mousePressEvent(QMouseEvent* event) {
    // [CRITICAL] 修正：如果点击在工具栏上，不触发测量逻辑
    if (m_toolbar->geometry().contains(event->pos())) {
        QWidget::mousePressEvent(event);
        return;
    }
    if (event->button() == Qt::LeftButton) {
        m_startPoint = event->pos();
        
        // 瞬间测量模式，点击即保存
        if (m_mode == Spacing || m_mode == Horizontal || m_mode == Vertical) {
            saveMeasurement(getMeasurementText(event->pos()));
        }
        
        update();
    } else if (event->button() == Qt::RightButton) {
        close();
    }
}

void PixelRulerOverlay::mouseMoveEvent(QMouseEvent* event) {
    update();
}

void PixelRulerOverlay::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton && !m_startPoint.isNull()) {
        // 边界测量模式，松开即保存
        if (m_mode == Bounds) {
            QRect r = QRect(m_startPoint, event->pos()).normalized();
            if (r.width() > 1 && r.height() > 1) {
                QString val = QString("%1 × %2").arg(r.width()).arg(r.height());
                saveMeasurement(val);
            }
        }
        m_startPoint = QPoint();
        update();
    }
}

QString PixelRulerOverlay::getMeasurementText(const QPoint& pos) {
    const ScreenCapture* cap = getCapture(mapToGlobal(pos));
    if (!cap) return "";

    QPoint relPos = mapToGlobal(pos) - cap->geometry.topLeft();
    int px = relPos.x() * cap->dpr;
    int py = relPos.y() * cap->dpr;

    if (m_mode == Spacing) {
        int left = findEdge(cap->image, px, py, -1, 0) / cap->dpr;
        int right = findEdge(cap->image, px, py, 1, 0) / cap->dpr;
        int top = findEdge(cap->image, px, py, 0, -1) / cap->dpr;
        int bottom = findEdge(cap->image, px, py, 0, 1) / cap->dpr;
        return QString("%1 × %2").arg(left + right).arg(top + bottom);
    } else if (m_mode == Horizontal) {
        int left = findEdge(cap->image, px, py, -1, 0) / cap->dpr;
        int right = findEdge(cap->image, px, py, 1, 0) / cap->dpr;
        return QString::number(left + right);
    } else if (m_mode == Vertical) {
        int top = findEdge(cap->image, px, py, 0, -1) / cap->dpr;
        int bottom = findEdge(cap->image, px, py, 0, 1) / cap->dpr;
        return QString::number(top + bottom);
    }
    return "";
}

void PixelRulerOverlay::saveMeasurement(const QString& val) {
    if (val.isEmpty()) return;
    
    DatabaseManager::instance().addNoteAsync(
        val,              // 标题改为像素值本身
        val,              // 内容改为像素值本身
        {"标尺", "测量", "像素"},
        "#ff5722", // 使用测量线的橙红色作为笔记卡片主色
        -1,
        "pixel_ruler"
    );
    
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 测量值已存入数据库: %1").arg(val));
}

void PixelRulerOverlay::keyPressEvent(QKeyEvent* event) {
    int key = event->key();
    if (key == Qt::Key_Escape) close();
    else if (key == Qt::Key_1) setMode(Bounds);
    else if (key == Qt::Key_2) setMode(Spacing);
    else if (key == Qt::Key_3) setMode(Horizontal);
    else if (key == Qt::Key_4) setMode(Vertical);
    
    // 同步工具栏按钮状态
    if (key >= Qt::Key_1 && key <= Qt::Key_4) {
        auto btns = m_toolbar->findChildren<QPushButton*>();
        int idx = key - Qt::Key_1;
        if (idx >= 0 && idx < btns.size()) {
            for(auto* b : btns) b->setChecked(false);
            btns[idx]->setChecked(true);
        }
    }
}
```

## 文件: `src/ui/PixelRulerOverlay.h`

```cpp
#ifndef PIXELRULEROVERLAY_H
#define PIXELRULEROVERLAY_H

#include <QWidget>
#include <QFrame>
#include <QImage>
#include <QRect>
#include <QList>

class PixelRulerOverlay : public QWidget {
    Q_OBJECT
    
    enum Mode { Bounds, Spacing, Horizontal, Vertical };
    
    struct ScreenCapture {
        QImage image;
        QRect geometry;
        qreal dpr;
    };

public:
    explicit PixelRulerOverlay(QWidget* parent = nullptr);
    ~PixelRulerOverlay();

    bool eventFilter(QObject* watched, QEvent* event) override;

protected:
    void initToolbar();
    void setMode(Mode m);
    void paintEvent(QPaintEvent*) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

private:
    // 绘制函数
    void drawCrossSpacing(QPainter& p, const QPoint& pos);
    void drawOneWaySpacing(QPainter& p, const QPoint& pos, bool hor);
    void drawLabel(QPainter& p, int x, int y, int val, bool isHor, bool isFixed = false);
    void drawBounds(QPainter& p, const QPoint& s, const QPoint& e);
    void drawInfoBox(QPainter& p, const QPoint& pos, const QString& text);
    
    // 工具函数
    int findEdge(const QImage& img, int x, int y, int dx, int dy);
    int colorDiff(const QColor& c1, const QColor& c2);
    const ScreenCapture* getCapture(const QPoint& globalPos);
    
    // 测量与保存
    QString getMeasurementText(const QPoint& pos);
    void saveMeasurement(const QString& val);

    Mode m_mode = Spacing;
    QPoint m_startPoint;
    QFrame* m_toolbar = nullptr;
    QList<ScreenCapture> m_captures;
};

#endif // PIXELRULEROVERLAY_H
```

## 文件: `src/ui/QuickNoteDelegate.h`

```cpp
#ifndef QUICKNOTEDELEGATE_H
#define QUICKNOTEDELEGATE_H

#include <QStyledItemDelegate>
#include <QPainter>
#include <QDateTime>
#include "../models/NoteModel.h"
#include "IconHelper.h"
#include "QuickWindow.h"

class QuickNoteDelegate : public QStyledItemDelegate {
    Q_OBJECT
public:
    explicit QuickNoteDelegate(QObject* parent = nullptr) : QStyledItemDelegate(parent) {}

    QSize sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        return QSize(option.rect.width(), 45); // 紧凑型高度
    }

    void paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        if (!index.isValid()) return;

        painter->save();
        painter->setRenderHint(QPainter::Antialiasing);

        QRect rect = option.rect;
        bool isSelected = (option.state & QStyle::State_Selected);
        bool isHovered = (option.state & QStyle::State_MouseOver);

        // 1. 绘制基础背景 (斑马纹对比度微调)
        QColor bgColor = (index.row() % 2 == 0) ? QColor("#1E1E1E") : QColor("#181818");
        if (isHovered && !isSelected) {
            bgColor = QColor(255, 255, 255, 20);
        }
        painter->fillRect(rect, bgColor);

        // 2. 绘制指示条 (根据置顶状态与选中状态动态调整)
        bool isPinned = index.data(NoteModel::PinnedRole).toBool();
        if (isPinned) {
            // 置顶项：在最左侧固定绘制 1px 红色条
            painter->fillRect(QRect(rect.left(), rect.top(), 1, rect.height()), QColor("#FF0000"));
        }

        if (isSelected) {
            // 只有在选中状态下才计算分类颜色
            QColor highlightColor("#4a90e2"); // 默认蓝
            QuickWindow* win = qobject_cast<QuickWindow*>(parent());
            if (win) {
                QString c = win->currentCategoryColor();
                if (!c.isEmpty() && QColor::isValidColorName(c)) {
                    highlightColor = QColor(c);
                }
            }

            if (isPinned) {
                // 置顶项被选中：在红条右侧绘制 4px 分类指示色
                painter->fillRect(QRect(rect.left() + 1, rect.top(), 4, rect.height()), highlightColor);
            } else {
                // 未置顶但已选中：绘制完整的 5px 分类指示色
                painter->fillRect(QRect(rect.left(), rect.top(), 5, rect.height()), highlightColor);
            }

            // 3. 选中项背景叠加层 (约 6% 不透明度)
            QColor overlay = highlightColor;
            overlay.setAlpha(15); 
            painter->fillRect(rect, overlay);
        }

        // 2. 分隔线 (对齐 Python 版，使用极浅的黑色半透明)
        painter->setPen(QColor(0, 0, 0, 25));
        painter->drawLine(rect.bottomLeft(), rect.bottomRight());

        // 图标 (DecorationRole)
        QIcon icon = index.data(Qt::DecorationRole).value<QIcon>();
        if (!icon.isNull()) {
            QString type = index.data(NoteModel::TypeRole).toString();
            if (type == "image") {
                // 如果是图片，绘制更大的缩略图 (32x32)
                int size = 32;
                icon.paint(painter, rect.left() + 10, rect.top() + (rect.height() - size) / 2, size, size);
            } else {
                icon.paint(painter, rect.left() + 10, rect.top() + (rect.height() - 20) / 2, 20, 20);
            }
        }

        // 标题文本 (根据用户要求，QuickWindow 仅显示笔记标题)
        QString text = index.data(NoteModel::TitleRole).toString();
        painter->setPen(isSelected ? Qt::white : QColor("#CCCCCC"));
        painter->setFont(QFont("Microsoft YaHei", 9));
        
        // 调整右侧边距 (-70) 以避开右侧的时间戳和星级
        QRect textRect = rect.adjusted(40, 0, -70, 0);
        painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter, 
                         painter->fontMetrics().elidedText(text, Qt::ElideRight, textRect.width()));

        // 时间 (极简展示) - 显示在右上方
        QString timeStr = index.data(NoteModel::TimeRole).toDateTime().toString("MM-dd HH:mm");
        painter->setPen(QColor("#666666"));
        painter->setFont(QFont("Segoe UI", 7));
        painter->drawText(rect.adjusted(0, 3, -10, 0), Qt::AlignRight | Qt::AlignTop, timeStr);

        // 星级 (Rating) - 显示在右下方 (仅显示实心星)
        int rating = index.data(NoteModel::RatingRole).toInt();
        if (rating > 0) {
            int starSize = 9;
            int spacing = 1;
            // 限制最大星级为 5
            int displayRating = qMin(rating, 5);
            int totalWidth = displayRating * starSize + (displayRating - 1) * spacing;
            int startX = rect.right() - 9 - totalWidth;
            int startY = rect.bottom() - starSize - 5;

            QIcon starFilled = IconHelper::getIcon("star_filled", "#F1C40F", starSize);

            for (int i = 0; i < displayRating; ++i) {
                QRect starRect(startX + i * (starSize + spacing), startY, starSize, starSize);
                starFilled.paint(painter, starRect);
            }
        }

        painter->restore();
    }
};

#endif // QUICKNOTEDELEGATE_H
```

## 文件: `src/viewmodels/QuickNoteViewModel.cpp`

```cpp
#include "QuickNoteViewModel.h"
#include "../core/ServiceLocator.h"

#include "../core/DatabaseManager.h"
#include <algorithm>

QuickNoteViewModel::QuickNoteViewModel(QObject* parent) : QObject(parent) {}

void QuickNoteViewModel::refreshData(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page) {
    m_currentFilterType = filterType;
    m_currentFilterValue = filterValue;
    m_currentPage = page;

    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;

    int totalCount = db->getNotesCount(keyword, filterType, filterValue);
    const int pageSize = 100;
    m_totalPages = std::max(1, (totalCount + pageSize - 1) / pageSize);
    
    if (m_currentPage > m_totalPages) m_currentPage = m_totalPages;
    if (m_currentPage < 1) m_currentPage = 1;

    auto notes = db->searchNotes(keyword, filterType, filterValue, m_currentPage, pageSize);
    emit dataRefreshed(notes, totalCount, m_totalPages);
}

void QuickNoteViewModel::deleteNotes(const QList<int>& ids, bool physical) {
    if (ids.isEmpty()) return;
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;

    if (physical || m_currentFilterType == "trash") {
        db->deleteNotesBatch(ids);
        emit statusMessageRequested(QString("✔ 已永久删除 %1 条数据").arg(ids.count()));
    } else {
        db->softDeleteNotes(ids);
        emit statusMessageRequested(QString("✔ 已移至回收站 %1 条数据").arg(ids.count()));
    }
    emit sidebarRefreshRequested();
}

void QuickNoteViewModel::toggleFavorite(const QList<int>& ids) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->toggleNoteState(id, "is_favorite");
    }
}

void QuickNoteViewModel::togglePin(const QList<int>& ids) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->toggleNoteState(id, "is_pinned");
    }
}

void QuickNoteViewModel::setRating(const QList<int>& ids, int rating) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->updateNoteState(id, "rating", rating);
    }
}

void QuickNoteViewModel::moveToCategory(const QList<int>& ids, int catId) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    db->moveNotesToCategory(ids, catId);
}

void QuickNoteViewModel::addTags(const QList<int>& ids, const QStringList& tags) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->addTagsToNote(id, tags);
    }
}

void QuickNoteViewModel::updateTags(const QList<int>& ids, const QStringList& tags) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    QString tagsStr = tags.join(", ");
    for (int id : ids) {
        db->updateNoteState(id, "tags", tagsStr);
    }
}
```

## 文件: `src/viewmodels/QuickNoteViewModel.h`

```cpp
#ifndef QUICKNOTEVIEWMODEL_H
#define QUICKNOTEVIEWMODEL_H

#include <QObject>
#include <QVariantMap>
#include <QList>
#include <QString>
#include <QVariant>

class QuickNoteViewModel : public QObject {
    Q_OBJECT
public:
    explicit QuickNoteViewModel(QObject* parent = nullptr);

    // 状态属性
    int currentPage() const { return m_currentPage; }
    int totalPages() const { return m_totalPages; }
    QString currentFilterType() const { return m_currentFilterType; }
    QVariant currentFilterValue() const { return m_currentFilterValue; }

    // 数据操作
    void refreshData(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page);
    void deleteNotes(const QList<int>& ids, bool physical);
    void toggleFavorite(const QList<int>& ids);
    void togglePin(const QList<int>& ids);
    void setRating(const QList<int>& ids, int rating);
    void moveToCategory(const QList<int>& ids, int catId);
    void addTags(const QList<int>& ids, const QStringList& tags);
    void updateTags(const QList<int>& ids, const QStringList& tags);

signals:
    void dataRefreshed(const QList<QVariantMap>& notes, int totalCount, int totalPages);
    void statusMessageRequested(const QString& message, bool isError = false);
    void sidebarRefreshRequested();

private:
    int m_currentPage = 1;
    int m_totalPages = 1;
    QString m_currentFilterType = "all";
    QVariant m_currentFilterValue = -1;
};

#endif // QUICKNOTEVIEWMODEL_H
```

## 文件: `src/ui/QuickPreview.h`

```cpp
#include "ToolTipOverlay.h"
#ifndef QUICKPREVIEW_H
#define QUICKPREVIEW_H

#include <QWidget>
#include "StringUtils.h"

#include <QTextEdit>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QLabel>
#include <QKeyEvent>
#include <QGraphicsDropShadowEffect>
#include <QMouseEvent>
#include <QApplication>
#include <QClipboard>
#include <QKeyEvent>
#include "ToolTipOverlay.h"
#include <QCursor>
#include <QFrame>
#include <QShortcut>
#include <QAction>
#include <QScreen>
#include <QGuiApplication>
#include <QLineEdit>
#include "IconHelper.h"
#include "../core/ShortcutManager.h"

class QuickPreview : public QWidget {
    Q_OBJECT
signals:
    void editRequested(int noteId);
    void prevRequested();
    void nextRequested();
    void historyNavigationRequested(int noteId);

public:
    explicit QuickPreview(QWidget* parent = nullptr) : QWidget(parent, Qt::Tool | Qt::FramelessWindowHint) {
        setObjectName("QuickPreview");
        setAttribute(Qt::WA_TranslucentBackground);
        setFocusPolicy(Qt::StrongFocus);
        
        auto* mainLayout = new QVBoxLayout(this);
        // [CRITICAL] 边距调整为 20px 以容纳阴影，防止出现“断崖式”阴影截止
        mainLayout->setContentsMargins(20, 20, 20, 20);

        m_container = new QFrame();
        m_container->setObjectName("previewContainer");
        m_container->setStyleSheet(
            "QFrame#previewContainer { background-color: #1e1e1e; border: 1px solid #444; border-radius: 8px; }"
            "QFrame#previewTitleBar { background-color: #1e1e1e; border-top-left-radius: 7px; border-top-right-radius: 7px; border-bottom: 1px solid #333; }"
            "QTextEdit { border-bottom-left-radius: 7px; border-bottom-right-radius: 7px; background: transparent; border: none; color: #ddd; font-size: 14px; padding: 10px; }"
            "QPushButton { border: none; border-radius: 4px; background: transparent; padding: 4px; }"
            "QPushButton:hover { background-color: #3e3e42; }"
            "QPushButton#btnClose:hover { background-color: #E81123; }"
        );
        
        auto* containerLayout = new QVBoxLayout(m_container);
        containerLayout->setContentsMargins(0, 0, 0, 0);
        containerLayout->setSpacing(0);

        // --- 标题栏 ---
        m_titleBar = new QFrame();
        m_titleBar->setObjectName("previewTitleBar");
        m_titleBar->setFixedHeight(36);
        m_titleBar->setAttribute(Qt::WA_StyledBackground);
        auto* titleLayout = new QHBoxLayout(m_titleBar);
        titleLayout->setContentsMargins(10, 0, 5, 0);
        titleLayout->setSpacing(5);

        m_titleLabel = new QLabel("预览");
        m_titleLabel->setStyleSheet("color: #888; font-size: 12px; font-weight: bold;");
        titleLayout->addWidget(m_titleLabel);

        // --- 集成搜索框 (增强视觉对比度) ---
        m_searchEdit = new QLineEdit();
        m_searchEdit->setFocusPolicy(Qt::ClickFocus); // [UX] 防止打开预览窗时自动夺取焦点，仅在点击或快捷键激活时获焦
        m_searchEdit->setPlaceholderText("查找内容...");
        m_searchEdit->setFixedWidth(250); // 增加宽度
        
        // 使用更明显的样式，添加内联搜索图标
        QAction* searchAction = new QAction(this);
        searchAction->setIcon(IconHelper::getIcon("search", "#888888"));
        m_searchEdit->addAction(searchAction, QLineEdit::LeadingPosition);
        
        m_searchEdit->setStyleSheet(
            "QLineEdit {"
            "  background-color: #2d2d2d; color: #eee; border: 1px solid #555; border-radius: 6px;"
            "  padding: 2px 10px; font-size: 12px;"
            "}"
            "QLineEdit:focus {"
            "  background-color: #383838; border-color: #007acc; color: #fff;"
            "}"
            "QLineEdit::placeholder { color: #666; }"
        );
        titleLayout->addSpacing(20);
        titleLayout->addWidget(m_searchEdit);

        m_searchCountLabel = new QLabel("0 / 0");
        m_searchCountLabel->setStyleSheet("color: #007acc; font-size: 11px; font-weight: bold; margin-left: 5px;");
        titleLayout->addWidget(m_searchCountLabel);

        titleLayout->addStretch();

        auto createBtn = [this](const QString& icon, const QString& tooltip, const QString& objName = "") {
            QPushButton* btn = new QPushButton();
            btn->setIcon(IconHelper::getIcon(icon, "#aaaaaa"));
            btn->setIconSize(QSize(16, 16));
            btn->setFixedSize(32, 32);
            btn->setToolTip(tooltip);
            if (!objName.isEmpty()) btn->setObjectName(objName);
            return btn;
        };

        m_btnBack = createBtn("nav_first", "后退 (Alt+Left)");
        m_btnBack->setFocusPolicy(Qt::NoFocus);
        m_btnForward = createBtn("nav_last", "前进 (Alt+Right)");
        m_btnForward->setFocusPolicy(Qt::NoFocus);

        QPushButton* btnPrev = createBtn("nav_prev", "上一个 (Alt+Up)");
        btnPrev->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnNext = createBtn("nav_next", "下一个 (Alt+Down)");
        btnNext->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnCopy = createBtn("copy", "复制内容 (Ctrl+C)");
        btnCopy->setFocusPolicy(Qt::NoFocus);
        m_btnPin = createBtn("pin_tilted", "置顶显示");
        m_btnPin->setCheckable(true);
        m_btnPin->setFocusPolicy(Qt::NoFocus);
        
        // 加载记忆状态
        QSettings settings("RapidNotes", "WindowStates");
        m_isPinned = settings.value("QuickPreview/StayOnTop", false).toBool();
        if (m_isPinned) {
            m_btnPin->setChecked(true);
            m_btnPin->setIcon(IconHelper::getIcon("pin_vertical", "#ffffff"));
            setWindowFlag(Qt::WindowStaysOnTopHint, true);
        }

        QPushButton* btnEdit = createBtn("edit", "编辑 (Ctrl+B)");
        btnEdit->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnMin = createBtn("minimize", "最小化");
        btnMin->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnMax = createBtn("maximize", "最大化");
        btnMax->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnClose = createBtn("close", "关闭", "btnClose");
        btnClose->setFocusPolicy(Qt::NoFocus);

        connect(m_btnBack, &QPushButton::clicked, this, &QuickPreview::navigateBack);
        connect(m_btnForward, &QPushButton::clicked, this, &QuickPreview::navigateForward);

        connect(btnPrev, &QPushButton::clicked, this, &QuickPreview::prevRequested);
        connect(btnNext, &QPushButton::clicked, this, &QuickPreview::nextRequested);
        connect(btnCopy, &QPushButton::clicked, this, &QuickPreview::copyFullContent);
        connect(m_btnPin, &QPushButton::toggled, [this](bool checked) {
            m_isPinned = checked;
            setWindowFlag(Qt::WindowStaysOnTopHint, m_isPinned);
            m_btnPin->setIcon(IconHelper::getIcon(m_isPinned ? "pin_vertical" : "pin_tilted", m_isPinned ? "#ffffff" : "#aaaaaa"));
            
            // 持久化记忆
            QSettings settings("RapidNotes", "WindowStates");
            settings.setValue("QuickPreview/StayOnTop", m_isPinned);
            
            show(); // 改变 flag 后需要 show 出来
        });

        connect(btnEdit, &QPushButton::clicked, [this]() {
            emit editRequested(m_currentNoteId);
        });
        connect(btnMin, &QPushButton::clicked, this, &QuickPreview::showMinimized);
        connect(btnMax, &QPushButton::clicked, [this]() {
            if (isMaximized()) showNormal();
            else showMaximized();
        });
        connect(btnClose, &QPushButton::clicked, this, &QuickPreview::hide);

        titleLayout->addWidget(m_btnBack);
        titleLayout->addWidget(m_btnForward);
        titleLayout->addSpacing(5);
        titleLayout->addWidget(btnPrev);
        titleLayout->addWidget(btnNext);
        titleLayout->addSpacing(5);
        titleLayout->addWidget(btnCopy);
        titleLayout->addWidget(m_btnPin);
        titleLayout->addSpacing(5);
        titleLayout->addWidget(btnEdit);
        titleLayout->addWidget(btnMin);
        titleLayout->addWidget(btnMax);
        titleLayout->addWidget(btnClose);

        containerLayout->addWidget(m_titleBar);

        connect(m_searchEdit, &QLineEdit::textChanged, this, &QuickPreview::performSearch);
        connect(m_searchEdit, &QLineEdit::returnPressed, this, &QuickPreview::findNext);

        m_textEdit = new QTextEdit();
        m_textEdit->setReadOnly(true);
        m_textEdit->setFocusPolicy(Qt::NoFocus); // 防止拦截空格键
        containerLayout->addWidget(m_textEdit);
        
        mainLayout->addWidget(m_container);
        
        auto* shadow = new QGraphicsDropShadowEffect(this);
        // [CRITICAL] 阴影模糊半径设为 20，配合 20px 的边距可确保阴影平滑过渡不被裁剪
        shadow->setBlurRadius(20);
        shadow->setColor(QColor(0, 0, 0, 120));
        shadow->setOffset(0, 4);
        m_container->setGraphicsEffect(shadow);
        
        resize(920, 720);

        setupShortcuts();
        connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &QuickPreview::updateShortcuts);
    }

    void showPreview(int noteId, const QString& title, const QString& content, const QPoint& pos, const QString& catName = "") {
        showPreview(noteId, title, content, "text", QByteArray(), pos, catName);
    }

    bool isPinned() const { return m_isPinned; }

    void showPreview(int noteId, const QString& title, const QString& content, const QString& type, const QByteArray& data, const QPoint& pos, const QString& catName = "") {
        m_currentNoteId = noteId;
        // 每次显示新笔记时重置搜索状态
        if (m_searchEdit) {
            m_searchEdit->clear();
        }
        addToHistory(noteId);
        if (!catName.isEmpty()) {
            m_titleLabel->setText(QString("预览 - %1").arg(catName));
        } else {
            m_titleLabel->setText("预览");
        }
        m_pureContent = content; // 记忆原始纯净内容
        QString html;
        QString titleHtml = QString("<h3 style='color: #eee; margin-bottom: 5px;'>%1</h3>").arg(title.toHtmlEscaped());
        QString hrHtml = "<hr style='border: 0; border-top: 1px solid #444; margin: 10px 0;'>";

        if (type == "color") {
            html = QString("%1%2"
                           "<div style='margin: 20px; text-align: center;'>"
                           "  <div style='background-color: %3; width: 100%; height: 200px; border-radius: 12px; border: 1px solid #555;'></div>"
                           "  <h1 style='color: white; margin-top: 20px; font-family: Consolas; font-size: 32px;'>%3</h1>"
                           "</div>")
                   .arg(titleHtml, hrHtml, content);
        } else if (type == "image" && !data.isEmpty()) {
            html = QString("%1%2<div style='text-align: center;'><img src='data:image/png;base64,%3' width='450'></div>")
                   .arg(titleHtml, hrHtml, QString(data.toBase64()));
        } else {
            // 判定是否已经是 HTML
            QString trimmed = content.trimmed();
            bool isHtml = trimmed.startsWith("<!DOCTYPE", Qt::CaseInsensitive) || 
                          trimmed.startsWith("<html", Qt::CaseInsensitive) || 
                          trimmed.contains("<style", Qt::CaseInsensitive) ||
                          Qt::mightBeRichText(content);
            
            QString body;
            if (isHtml) {
                body = content; // 直接使用 HTML
            } else {
                body = content.toHtmlEscaped();
                body.replace("\n", "<br>");
                body = QString("<div style='line-height: 1.6; color: #ccc; font-size: 13px;'>%1</div>").arg(body);
            }
            html = QString("%1%2%3").arg(titleHtml, hrHtml, body);
        }
        m_textEdit->setHtml(html);
        
        // 边缘检测：确保预览窗口不超出当前屏幕
        QPoint adjustedPos = pos;
        QScreen *screen = QGuiApplication::screenAt(QCursor::pos());
        if (!screen) screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect screenGeom = screen->availableGeometry();
            if (adjustedPos.x() + width() > screenGeom.right()) adjustedPos.setX(screenGeom.right() - width());
            if (adjustedPos.x() < screenGeom.left()) adjustedPos.setX(screenGeom.left());
            if (adjustedPos.y() + height() > screenGeom.bottom()) adjustedPos.setY(screenGeom.bottom() - height());
            if (adjustedPos.y() < screenGeom.top()) adjustedPos.setY(screenGeom.top());
        }

        move(adjustedPos);
        show();
        setFocus(); // [UX] 确保预览窗口打开后，焦点在窗口本身而非搜索框
    }

protected:
    void mousePressEvent(QMouseEvent* event) override {
        if (event->button() == Qt::LeftButton && m_titleBar->rect().contains(m_titleBar->mapFrom(this, event->pos()))) {
            m_dragging = true;
            m_dragPos = event->globalPosition().toPoint() - frameGeometry().topLeft();
            event->accept();
        }
    }

    void mouseMoveEvent(QMouseEvent* event) override {
        if (m_dragging && event->buttons() & Qt::LeftButton) {
            move(event->globalPosition().toPoint() - m_dragPos);
            event->accept();
        }
    }

    void mouseReleaseEvent(QMouseEvent* event) override {
        m_dragging = false;
        QWidget::mouseReleaseEvent(event);
    }

    void mouseDoubleClickEvent(QMouseEvent* event) override {
        if (m_titleBar->rect().contains(m_titleBar->mapFrom(this, event->pos()))) {
            if (isMaximized()) showNormal();
            else showMaximized();
            event->accept();
        }
    }

    void setupShortcuts() {
        auto add = [&](const QString& id, std::function<void()> func) {
            auto* sc = new QShortcut(ShortcutManager::instance().getShortcut(id), this, func);
            sc->setProperty("id", id);
            m_shortcuts.append(sc);
        };

        add("pv_prev", [this](){ emit prevRequested(); });
        add("pv_next", [this](){ emit nextRequested(); });
        add("pv_back", [this](){ navigateBack(); });
        add("pv_forward", [this](){ navigateForward(); });
        add("pv_edit", [this](){ emit editRequested(m_currentNoteId); });
        add("pv_copy", [this](){
            if (m_searchEdit && m_searchEdit->hasFocus()) {
                m_searchEdit->copy();
            } else {
                m_textEdit->copy();
            }
        });
        add("pv_close", [this](){ hide(); });
        add("pv_search", [this](){ toggleSearch(true); });

        // 移除 Space 快捷键，避免与 MainWindow 的全局预览快捷键冲突导致“关闭后立即重开”
        // auto* spaceSc = new QShortcut(QKeySequence("Space"), this, [this](){ hide(); }, Qt::WidgetWithChildrenShortcut);
        new QShortcut(QKeySequence("Escape"), this, [this](){ hide(); });
    }

    void updateShortcuts() {
        for (auto* sc : m_shortcuts) {
            QString id = sc->property("id").toString();
            sc->setKey(ShortcutManager::instance().getShortcut(id));
        }
    }

    void addToHistory(int noteId) {
        if (m_isNavigatingHistory) return;
        
        // 只有当新 ID 与当前历史位置 ID 不同时才记录
        if (!m_history.isEmpty() && m_historyIndex >= 0 && m_historyIndex < m_history.size()) {
            if (m_history.at(m_historyIndex) == noteId) return;
        }

        // 如果我们在历史中间进行了新操作，截断之后的前进记录
        while (m_historyIndex < m_history.size() - 1) {
            m_history.removeLast();
        }

        m_history.append(noteId);
        m_historyIndex = m_history.size() - 1;
        updateHistoryButtons();
    }

    void navigateBack() {
        if (m_historyIndex > 0) {
            m_historyIndex--;
            m_isNavigatingHistory = true;
            emit historyNavigationRequested(m_history.at(m_historyIndex));
            m_isNavigatingHistory = false;
            updateHistoryButtons();
        }
    }

    void navigateForward() {
        if (m_historyIndex < m_history.size() - 1) {
            m_historyIndex++;
            m_isNavigatingHistory = true;
            emit historyNavigationRequested(m_history.at(m_historyIndex));
            m_isNavigatingHistory = false;
            updateHistoryButtons();
        }
    }

    void toggleSearch(bool show) {
        if (show) {
            m_searchEdit->setFocus();
            m_searchEdit->selectAll();
            if (!m_searchEdit->text().isEmpty()) {
                performSearch(m_searchEdit->text());
            }
        } else {
            // [UX] 关闭搜索时清空输入并取消高亮，让正文重获焦点
            m_searchEdit->clear();
            m_searchEdit->clearFocus();
            QList<QTextEdit::ExtraSelection> empty;
            m_textEdit->setExtraSelections(empty);
            m_textEdit->setFocus();
            if (m_searchCountLabel) m_searchCountLabel->setText("0 / 0");
        }
    }

    void performSearch(const QString& text) {
        if (text.isEmpty()) {
            if (m_searchCountLabel) m_searchCountLabel->setText("0/0");
            m_textEdit->setExtraSelections({});
            return;
        }

        QList<QTextEdit::ExtraSelection> selections;
        
        // 记录当前位置
        QTextCursor originalCursor = m_textEdit->textCursor();
        
        m_textEdit->moveCursor(QTextCursor::Start);
        
        QColor color = QColor(255, 255, 0, 100);
        
        int count = 0;
        while (m_textEdit->find(text)) {
            count++;
            QTextEdit::ExtraSelection selection;
            selection.format.setBackground(color);
            selection.cursor = m_textEdit->textCursor();
            selections.append(selection);
        }
        
        m_textEdit->setExtraSelections(selections);
        m_textEdit->setTextCursor(originalCursor);
        
        updateSearchCount();
    }

    void findNext() {
        QString text = m_searchEdit->text();
        if (text.isEmpty()) return;
        
        if (!m_textEdit->find(text)) {
            // 如果到底了，回到开头继续找
            m_textEdit->moveCursor(QTextCursor::Start);
            m_textEdit->find(text);
        }
        updateSearchCount();
    }

    void findPrev() {
        QString text = m_searchEdit->text();
        if (text.isEmpty()) return;
        
        if (!m_textEdit->find(text, QTextDocument::FindBackward)) {
            // 如果到头了，回到末尾继续找
            m_textEdit->moveCursor(QTextCursor::End);
            m_textEdit->find(text, QTextDocument::FindBackward);
        }
        updateSearchCount();
    }

    void updateSearchCount() {
        QString text = m_searchEdit->text();
        if (text.isEmpty() || !m_searchCountLabel) return;

        QTextCursor currentCursor = m_textEdit->textCursor();
        int total = m_textEdit->extraSelections().size();
        int current = 0;
        
        // 如果没有匹配项
        if (total == 0) {
            m_searchCountLabel->setText("0/0");
            return;
        }

        // 计算当前位置是第几个匹配项
        QTextDocument* doc = m_textEdit->document();
        QTextCursor tempCursor(doc);
        while (!(tempCursor = doc->find(text, tempCursor)).isNull()) {
            current++;
            if (tempCursor.selectionEnd() >= currentCursor.selectionEnd()) {
                break;
            }
        }
        
        m_searchCountLabel->setText(QString("%1/%2").arg(current).arg(total));
    }

    void copyFullContent() {
        // 仅复制正文内容，不包含预览窗口添加的标题和分割线
        if (m_pureContent.isEmpty()) {
            QApplication::clipboard()->setText(m_textEdit->toPlainText());
        } else {
            // 如果是 HTML 且包含 <html> 标签，复制为富文本
            if (m_pureContent.contains("<html", Qt::CaseInsensitive)) {
                QMimeData* mime = new QMimeData();
                mime->setHtml(m_pureContent);
                mime->setText(StringUtils::htmlToPlainText(m_pureContent));
                QApplication::clipboard()->setMimeData(mime);
            } else {
                QApplication::clipboard()->setText(m_pureContent);
            }
        }
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #2ecc71;'>✔ 全部正文已提取到剪贴板</b>");
    }

    void updateHistoryButtons() {
        if (m_btnBack) m_btnBack->setEnabled(m_historyIndex > 0);
        if (m_btnForward) m_btnForward->setEnabled(m_historyIndex < m_history.size() - 1);
        
        if (m_btnBack) m_btnBack->setIcon(IconHelper::getIcon("nav_first", m_historyIndex > 0 ? "#aaaaaa" : "#444444"));
        if (m_btnForward) m_btnForward->setIcon(IconHelper::getIcon("nav_last", m_historyIndex < m_history.size() - 1 ? "#aaaaaa" : "#444444"));
    }

protected:
    void keyPressEvent(QKeyEvent* event) override {
        // [CRITICAL] 优先响应搜索框的交互逻辑
        if (event->key() == Qt::Key_Escape) {
            // 如果搜索框内有文字或正在输入，则优先清空/退出搜索状态
            if (m_searchEdit && (m_searchEdit->hasFocus() || !m_searchEdit->text().isEmpty())) {
                toggleSearch(false);
            } else {
                hide();
            }
            event->accept();
            return;
        }
        
        // [CRITICAL] 显式拦截 Ctrl+W 确保在任何焦点状态下都能快速关闭预览窗口
        if (event->key() == Qt::Key_W && (event->modifiers() & Qt::ControlModifier)) {
            hide();
            event->accept();
            return;
        }
        
        QWidget::keyPressEvent(event);
    }

    void hideEvent(QHideEvent* event) override {
        // 窗口关闭时，将焦点还给父窗口（列表），方便用户继续使用键盘导航
        if (parentWidget()) {
            parentWidget()->activateWindow();
            parentWidget()->setFocus();
        }
        QWidget::hideEvent(event);
    }

private:
    QFrame* m_container;
    QList<QShortcut*> m_shortcuts;
    QWidget* m_titleBar;
    QLabel* m_titleLabel;
    QLineEdit* m_searchEdit = nullptr;
    QLabel* m_searchCountLabel = nullptr;
    QTextEdit* m_textEdit;
    QString m_pureContent; // 纯净内容暂存
    int m_currentNoteId = -1;
    bool m_dragging = false;
    bool m_isPinned = false;
    QPushButton* m_btnPin = nullptr;
    QPushButton* m_btnBack = nullptr;
    QPushButton* m_btnForward = nullptr;
    QPoint m_dragPos;

    QList<int> m_history;
    int m_historyIndex = -1;
    bool m_isNavigatingHistory = false;
};

#endif // QUICKPREVIEW_H
```

## 文件: `src/ui/QuickWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "QuickWindow.h"
#include "NoteEditWindow.h"
#include "StringUtils.h"
#include "AdvancedTagSelector.h"
#include "IconHelper.h"
#include "QuickNoteDelegate.h"
#include "CategoryDelegate.h"
#include "../core/DatabaseManager.h"
#include "../core/ClipboardMonitor.h"
#include <QGuiApplication>
#include <utility>
#include <QScreen>
#include <QKeyEvent>
#include <QGraphicsDropShadowEffect>
#include <QSettings>
#include <QMenu>
#include <QWindow>
#include <QShortcut>
#include <QKeySequence>
#include <QClipboard>
#include <QMimeData>
#include <QDrag>
#include <QTimer>
#include <QApplication>
#include <QElapsedTimer>
#include <QActionGroup>
#include <QAction>
#include <QUrl>
#include <QBuffer>
#include <QToolTip>
#include <QRegularExpression>
#include <QImage>
#include <QMap>
#include <QSet>
#include <QFileInfo>
#include <QDir>
#include <QFile>
#include <QDesktopServices>
#include <QCoreApplication>
#include <QLineEdit>
#include <QTextEdit>
#include <QPlainTextEdit>
#include <QInputDialog>
#include <QColorDialog>
#include <QToolTip>
#include "FramelessDialog.h"
#include "CategoryPasswordDialog.h"
#include "SettingsWindow.h"
#include "OCRResultWindow.h"
#include "../core/ShortcutManager.h"
#include "../core/OCRManager.h"
#include <QRandomGenerator>
#include <QStyledItemDelegate>
#include <QPainter>
#include <QPropertyAnimation>
#include <QGraphicsOpacityEffect>

#ifdef Q_OS_WIN
#include <windows.h>
#include <windowsx.h>
#endif

// --- AppLockWidget 实现 (Eagle 风格启动锁) ---
class AppLockWidget : public QWidget {
    Q_OBJECT
public:
    AppLockWidget(const QString& correctPassword, QWidget* parent = nullptr)
        : QWidget(parent), m_correctPassword(correctPassword) {
        setObjectName("AppLockWidget");
        setFocusPolicy(Qt::StrongFocus);
        setAttribute(Qt::WA_StyledBackground);
        
        auto* layout = new QVBoxLayout(this);
        layout->setAlignment(Qt::AlignCenter);
        layout->setSpacing(20);

        // 背景色
        setStyleSheet("QWidget#AppLockWidget { background-color: #1C1C1C; border-radius: 10px; } "
                      "QLabel { background: transparent; border: none; }");

        // 1. 锁图标
        auto* lockIcon = new QLabel();
        lockIcon->setPixmap(IconHelper::getIcon("lock_secure", "#aaaaaa").pixmap(64, 64));
        lockIcon->setAlignment(Qt::AlignCenter);
        layout->addWidget(lockIcon);

        // 2. 标题文字
        auto* titleLabel = new QLabel("已锁定");
        titleLabel->setStyleSheet("color: #EEEEEE; font-size: 18px; font-weight: bold;");
        titleLabel->setAlignment(Qt::AlignCenter);
        layout->addWidget(titleLabel);

        // 3. 密码提示文字
        QSettings settings("RapidNotes", "QuickWindow");
        QString hint = settings.value("appPasswordHint", "请输入启动密码").toString();
        auto* hintLabel = new QLabel(hint);
        hintLabel->setStyleSheet("color: #666666; font-size: 12px;");
        hintLabel->setAlignment(Qt::AlignCenter);
        layout->addWidget(hintLabel);

        // 4. 密码输入框
        m_pwdEdit = new QLineEdit();
        m_pwdEdit->setEchoMode(QLineEdit::Password);
        m_pwdEdit->setPlaceholderText("请输入密码");
        m_pwdEdit->setFixedWidth(240);
        m_pwdEdit->setFixedHeight(36);
        m_pwdEdit->setAlignment(Qt::AlignCenter);
        m_pwdEdit->setStyleSheet(
            "QLineEdit {"
            "  background-color: #2A2A2A; border: 1px solid #333; border-radius: 6px;"
            "  color: white; font-size: 14px;"
            "}"
            "QLineEdit:focus { border: 1px solid #3A90FF; }"
        );
        connect(m_pwdEdit, &QLineEdit::returnPressed, this, &AppLockWidget::handleVerify);
        layout->addWidget(m_pwdEdit, 0, Qt::AlignHCenter);

        // 5. 右上角关闭按钮
        m_closeBtn = new QPushButton(this);
        m_closeBtn->setIcon(IconHelper::getIcon("close", "#aaaaaa"));
        m_closeBtn->setIconSize(QSize(18, 18));
        m_closeBtn->setFixedSize(32, 32);
        m_closeBtn->setCursor(Qt::PointingHandCursor);
        m_closeBtn->setStyleSheet(
            "QPushButton { border: none; border-radius: 4px; background: transparent; } "
            "QPushButton:hover { background-color: #E81123; }"
        );
        connect(m_closeBtn, &QPushButton::clicked, []() { QApplication::quit(); });

        // 初始焦点
        m_pwdEdit->setFocus();
    }

    void focusInput() {
        m_pwdEdit->setFocus();
        m_pwdEdit->selectAll();
    }

protected:
    void keyPressEvent(QKeyEvent* event) override {
        if (event->key() == Qt::Key_Escape) {
            QApplication::quit();
        }
        QWidget::keyPressEvent(event);
    }

    void resizeEvent(QResizeEvent* event) override {
        m_closeBtn->move(width() - m_closeBtn->width() - 10, 10);
        QWidget::resizeEvent(event);
    }

private slots:
    void handleVerify() {
        if (m_pwdEdit->text() == m_correctPassword) {
            startFadeOut();
        } else {
            startShake();
        }
    }

    void startFadeOut() {
        auto* opacityEffect = new QGraphicsOpacityEffect(this);
        setGraphicsEffect(opacityEffect);
        auto* animation = new QPropertyAnimation(opacityEffect, "opacity");
        animation->setDuration(300);
        animation->setStartValue(1.0);
        animation->setEndValue(0.0);
        animation->setEasingCurve(QEasingCurve::OutCubic);
        connect(animation, &QPropertyAnimation::finished, this, [this]() {
            emit unlocked();
            this->deleteLater();
        });
        animation->start(QAbstractAnimation::DeleteWhenStopped);
    }

    void startShake() {
        m_pwdEdit->clear();
        auto* anim = new QPropertyAnimation(m_pwdEdit, "pos");
        anim->setDuration(400);
        anim->setLoopCount(1);
        
        QPoint pos = m_pwdEdit->pos();
        anim->setKeyValueAt(0, pos);
        anim->setKeyValueAt(0.1, pos + QPoint(-10, 0));
        anim->setKeyValueAt(0.3, pos + QPoint(10, 0));
        anim->setKeyValueAt(0.5, pos + QPoint(-10, 0));
        anim->setKeyValueAt(0.7, pos + QPoint(10, 0));
        anim->setKeyValueAt(0.9, pos + QPoint(-10, 0));
        anim->setKeyValueAt(1, pos);
        
        anim->start(QAbstractAnimation::DeleteWhenStopped);
    }

signals:
    void unlocked();

private:
    QLineEdit* m_pwdEdit;
    QPushButton* m_closeBtn;
    QString m_correctPassword;
};


// 定义调整大小的边缘触发区域宽度 (与边距一致，改为 12px 以匹配新边距)
#define RESIZE_MARGIN 12

QuickWindow::QuickWindow(QWidget* parent) 
    : QWidget(parent, Qt::FramelessWindowHint) 
{
     setWindowTitle("快速笔记");
    setAcceptDrops(true);
    setAttribute(Qt::WA_TranslucentBackground);
    // [CRITICAL] 强制开启非活动窗口的 ToolTip 显示。
    setAttribute(Qt::WA_AlwaysShowToolTips);
    setAttribute(Qt::WA_DeleteOnClose, false);
    
    // 关键修复：开启鼠标追踪，否则不按住鼠标时无法检测边缘
    setMouseTracking(true);
    setAttribute(Qt::WA_Hover);
    
    initUI();

    m_refreshTimer = new QTimer(this);
    m_refreshTimer->setSingleShot(true);
    m_refreshTimer->setInterval(200);
    connect(m_refreshTimer, &QTimer::timeout, this, [this](){
        if (this->isVisible()) {
            refreshData();
            refreshSidebar();
        }
    });

    connect(&DatabaseManager::instance(), &DatabaseManager::noteAdded, this, &QuickWindow::onNoteAdded);
    connect(&DatabaseManager::instance(), &DatabaseManager::noteUpdated, this, &QuickWindow::scheduleRefresh);
    connect(&ClipboardMonitor::instance(), &ClipboardMonitor::newContentDetected, this, &QuickWindow::scheduleRefresh);

    connect(&DatabaseManager::instance(), &DatabaseManager::categoriesChanged, this, [this](){
        m_model->updateCategoryMap();
        
        // 如果当前正在查看某个分类，同步更新其高亮色
        if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
            auto categories = DatabaseManager::instance().getAllCategories();
            for (const auto& cat : std::as_const(categories)) {
                if (cat.value("id").toInt() == m_currentFilterValue) {
                    m_currentCategoryColor = cat.value("color").toString();
                    if (m_currentCategoryColor.isEmpty()) m_currentCategoryColor = "#4a90e2";
                    applyListTheme(m_currentCategoryColor);
                    break;
                }
            }
        }
        
        scheduleRefresh();
    });

#ifdef Q_OS_WIN
    m_monitorTimer = new QTimer(this);
    connect(m_monitorTimer, &QTimer::timeout, [this]() {
        HWND currentHwnd = GetForegroundWindow();
        if (currentHwnd == 0 || currentHwnd == (HWND)winId()) return;
        if (currentHwnd != m_lastActiveHwnd) {
            m_lastActiveHwnd = currentHwnd;
            m_lastThreadId = GetWindowThreadProcessId(m_lastActiveHwnd, nullptr);
            
            GUITHREADINFO gti;
            gti.cbSize = sizeof(GUITHREADINFO);
            if (GetGUIThreadInfo(m_lastThreadId, &gti)) {
                m_lastFocusHwnd = gti.hwndFocus;
            } else {
                m_lastFocusHwnd = nullptr;
            }
        }
    });
    m_monitorTimer->start(200);
#endif
}

void QuickWindow::initUI() {
    auto* mainLayout = new QVBoxLayout(this);
    // 【修改点1】边距调整为 12px，给窄阴影留出空间防止截断，同时保持紧凑
    mainLayout->setContentsMargins(12, 12, 12, 12); 

    auto* container = new QWidget();
    container->setObjectName("container");
    container->setMouseTracking(true); // 确保容器不阻断鼠标追踪
    container->setStyleSheet(
        "QWidget#container { background: #1E1E1E; border-radius: 10px; border: 1px solid #333; }"
        "QListView, QTreeView { background: transparent; border: none; color: #BBB; outline: none; }"
        "QTreeView::item { height: 22px; padding: 0px 4px; border-radius: 4px; }"
        "QTreeView::item:hover { background-color: #2a2d2e; }"
        "QTreeView::item:selected { background-color: transparent; color: white; }"
        "QListView::item { padding: 6px; border-bottom: 1px solid #2A2A2A; }"
    );
    
    // 【修改点2】阴影参数调整：更窄(BlurRadius 15)且不扩散
    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(15);               // 变窄：15 (原25)
    shadow->setColor(QColor(0, 0, 0, 90));   // 变柔：90 (原100)，略微降低浓度
    shadow->setOffset(0, 2);                 // 变贴：垂直偏移2 (原4)
    container->setGraphicsEffect(shadow);

    auto* containerLayout = new QHBoxLayout(container);
    containerLayout->setContentsMargins(0, 0, 0, 0);
    containerLayout->setSpacing(0);

    // --- 左侧内容区域 ---
    auto* leftContent = new QWidget();
    leftContent->setObjectName("leftContent");
    leftContent->setStyleSheet("QWidget#leftContent { background: #1E1E1E; border-top-left-radius: 10px; border-bottom-left-radius: 10px; }");
    leftContent->setMouseTracking(true);
    auto* leftLayout = new QVBoxLayout(leftContent);
    leftLayout->setContentsMargins(10, 10, 10, 5);
    leftLayout->setSpacing(8);
    
    m_searchEdit = new SearchLineEdit();
    m_searchEdit->setPlaceholderText("搜索灵感 (双击查看历史)");
    m_searchEdit->setClearButtonEnabled(true);
    leftLayout->addWidget(m_searchEdit);

    m_splitter = new QSplitter(Qt::Horizontal);
    m_splitter->setHandleWidth(4);
    m_splitter->setChildrenCollapsible(false);
    
    m_listView = new DittoListView();
    m_listView->setDragEnabled(true);
    m_listView->setSelectionMode(QAbstractItemView::ExtendedSelection);
    m_listView->setIconSize(QSize(28, 28));
    m_listView->setAlternatingRowColors(true);
    m_listView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_listView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_listView->setMouseTracking(true);
    m_listView->setItemDelegate(new QuickNoteDelegate(this));
    m_model = new NoteModel(this);
    m_listView->setModel(m_model);
    m_listView->setContextMenuPolicy(Qt::CustomContextMenu);

    m_lockWidget = new CategoryLockWidget(this);
    m_lockWidget->setVisible(false);
    connect(m_lockWidget, &CategoryLockWidget::unlocked, this, [this](){
        refreshData();
    });
    connect(m_listView, &QListView::customContextMenuRequested, this, &QuickWindow::showListContextMenu);
    connect(m_listView, &QListView::doubleClicked, this, [this](const QModelIndex& index){
        activateNote(index);
    });

    auto* sidebarContainer = new QWidget();
    auto* sidebarLayout = new QVBoxLayout(sidebarContainer);
    sidebarLayout->setContentsMargins(0, 0, 0, 0);
    sidebarLayout->setSpacing(0);

    QString treeStyle = R"(
        QTreeView {
            background-color: transparent;
            border: none;
            outline: none;
            color: #ccc;
        }
        /* 针对我的分区标题进行加粗白色处理 */
        QTreeView::item:!selectable {
            color: #ffffff;
            font-weight: bold;
        }
        QTreeView::item {
            height: 22px;
            padding: 0px;
            border: none;
            background: transparent;
        }
        QTreeView::item:hover, QTreeView::item:selected {
            background: transparent;
        }
        QTreeView::branch:hover, QTreeView::branch:selected {
            background: transparent;
        }
        QTreeView::branch {
            image: none;
        }
    )";

    m_systemTree = new DropTreeView();
    m_systemTree->setStyleSheet(treeStyle);
    m_systemTree->setItemDelegate(new CategoryDelegate(this));
    m_systemModel = new CategoryModel(CategoryModel::System, this);
    m_systemTree->setModel(m_systemModel);
    m_systemTree->setHeaderHidden(true);
    m_systemTree->setMouseTracking(true);
    m_systemTree->setIndentation(12);
    m_systemTree->setFixedHeight(176); // 8 items * 22px = 176px
    m_systemTree->setEditTriggers(QAbstractItemView::NoEditTriggers); // 绝不可重命名
    m_systemTree->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_systemTree->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_systemTree, &QTreeView::customContextMenuRequested, this, &QuickWindow::showSidebarMenu);

    m_partitionTree = new DropTreeView();
    m_partitionTree->setStyleSheet(treeStyle);
    m_partitionTree->setItemDelegate(new CategoryDelegate(this));
    m_partitionModel = new CategoryModel(CategoryModel::User, this);
    m_partitionTree->setModel(m_partitionModel);
    m_partitionTree->setHeaderHidden(true);
    m_partitionTree->setMouseTracking(true);
    m_partitionTree->setIndentation(12);
    m_partitionTree->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_partitionTree->setDragEnabled(true);
    m_partitionTree->setAcceptDrops(true);
    m_partitionTree->setDropIndicatorShown(true);
    m_partitionTree->setDragDropMode(QAbstractItemView::InternalMove);
    m_partitionTree->setDefaultDropAction(Qt::MoveAction);
    m_partitionTree->expandAll();
    m_partitionTree->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_partitionTree, &QTreeView::customContextMenuRequested, this, &QuickWindow::showSidebarMenu);

    sidebarLayout->addWidget(m_systemTree);
    sidebarLayout->addWidget(m_partitionTree);

    // 树形菜单点击逻辑...
    auto onSelectionChanged = [this](DropTreeView* tree, const QModelIndex& index) {
        if (!index.isValid()) return;
        if (tree == m_systemTree) {
            m_partitionTree->selectionModel()->clearSelection();
            m_partitionTree->setCurrentIndex(QModelIndex());
        } else {
            m_systemTree->selectionModel()->clearSelection();
            m_systemTree->setCurrentIndex(QModelIndex());
        }
        m_currentFilterType = index.data(CategoryModel::TypeRole).toString();
        QString name = index.data(CategoryModel::NameRole).toString();
        updatePartitionStatus(name);

        // 统一从模型获取颜色，实现全分区变色联动
        m_currentCategoryColor = index.data(CategoryModel::ColorRole).toString();
        if (m_currentCategoryColor.isEmpty()) m_currentCategoryColor = "#4a90e2";

        if (m_currentFilterType == "category") {
            m_currentFilterValue = index.data(CategoryModel::IdRole).toInt();
            StringUtils::recordRecentCategory(m_currentFilterValue.toInt());
        } else {
            m_currentFilterValue = -1;
        }
        
        applyListTheme(m_currentCategoryColor);
        m_currentPage = 1;
        refreshData();
    };
    connect(m_systemTree, &QTreeView::clicked, this, [this, onSelectionChanged](const QModelIndex& idx){ onSelectionChanged(m_systemTree, idx); });
    connect(m_partitionTree, &QTreeView::clicked, this, [this, onSelectionChanged](const QModelIndex& idx){ onSelectionChanged(m_partitionTree, idx); });

    // 拖拽逻辑...
    auto onNotesDropped = [this](const QList<int>& ids, const QModelIndex& targetIndex) {
        if (!targetIndex.isValid()) return;
        QString type = targetIndex.data(CategoryModel::TypeRole).toString();
        
        if (type == "category") {
            int catId = targetIndex.data(CategoryModel::IdRole).toInt();
            DatabaseManager::instance().moveNotesToCategory(ids, catId);
            StringUtils::recordRecentCategory(catId);
        } else if (type == "uncategorized") {
            DatabaseManager::instance().moveNotesToCategory(ids, -1);
        } else {
            for (int id : ids) {
                if (type == "bookmark") DatabaseManager::instance().updateNoteState(id, "is_favorite", 1);
                else if (type == "trash") DatabaseManager::instance().updateNoteState(id, "is_deleted", 1);
            }
        }
        // refreshData 和 refreshSidebar 将通过 DatabaseManager 信号触发的 scheduleRefresh 异步执行，
        // 从而避免在 dropEvent 堆栈中立即 reset model 导致的潜在闪退。
    };
    connect(m_systemTree, &DropTreeView::notesDropped, this, onNotesDropped);
    connect(m_partitionTree, &DropTreeView::notesDropped, this, onNotesDropped);

    // 右键菜单...
    // (此处省略部分右键菜单代码以保持简洁，逻辑与原版保持一致)
    // 主要是 showSidebarMenu 的实现...

    m_splitter->addWidget(m_listView);
    m_splitter->addWidget(m_lockWidget);
    m_splitter->addWidget(sidebarContainer);
    m_splitter->setStretchFactor(0, 1);
    m_splitter->setStretchFactor(1, 1);
    m_splitter->setStretchFactor(2, 0);
    m_splitter->setSizes({550, 0, 150});
    leftLayout->addWidget(m_splitter);

    applyListTheme(""); // 【核心修复】初始化时即应用深色主题

    // --- 底部状态栏与标签输入框 ---
    auto* bottomLayout = new QHBoxLayout();
    bottomLayout->setContentsMargins(2, 0, 10, 5);
    bottomLayout->setSpacing(10);

    m_statusLabel = new QLabel("当前分区: 全部数据");
    m_statusLabel->setStyleSheet("font-size: 11px; color: #888;");
    m_statusLabel->setFixedHeight(32);
    bottomLayout->addWidget(m_statusLabel);

    m_tagEdit = new ClickableLineEdit();
    m_tagEdit->setPlaceholderText("输入标签添加... (双击显示历史)");
    m_tagEdit->setStyleSheet(
        "QLineEdit { background-color: rgba(255, 255, 255, 0.05); "
        "border: 1px solid rgba(255, 255, 255, 0.1); "
        "border-radius: 10px; "
        "padding: 6px 12px; "
        "font-size: 12px; "
        "color: #EEE; } "
        "QLineEdit:focus { border-color: #4a90e2; background-color: rgba(255, 255, 255, 0.08); } "
        "QLineEdit:disabled { background-color: transparent; border: 1px solid #333; color: #666; }"
    );
    m_tagEdit->setEnabled(false); // 初始禁用
    connect(m_tagEdit, &QLineEdit::returnPressed, this, &QuickWindow::handleTagInput);
    connect(m_tagEdit, &ClickableLineEdit::doubleClicked, this, [this](){
        this->openTagSelector();
    });
    bottomLayout->addWidget(m_tagEdit, 1);

    leftLayout->addLayout(bottomLayout);

    containerLayout->addWidget(leftContent);

    // --- 右侧垂直工具栏 (Custom Toolbar Implementation) ---
    // 【核心修正】根据图二 1:1 还原，压缩宽度，修正图标名，重构分页布局
    
    QWidget* customToolbar = new QWidget(this);
    customToolbar->setFixedWidth(40); // 压缩至 40px
    customToolbar->setStyleSheet(
        "QWidget { background-color: #252526; border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-left: 1px solid #333; }"
        "QPushButton { border: none; border-radius: 4px; background: transparent; padding: 0px; outline: none; }"
        "QPushButton:hover { background-color: #3e3e42; }"
        "QPushButton#btnClose:hover { background-color: #E81123; }"
        "QPushButton:pressed { background-color: #2d2d2d; }"
        "QLabel { color: #888; font-size: 11px; }"
        "QLineEdit { background: transparent; border: 1px solid #444; border-radius: 4px; color: white; font-size: 11px; font-weight: bold; padding: 0; }"
    );
    
    QVBoxLayout* toolLayout = new QVBoxLayout(customToolbar);
    toolLayout->setContentsMargins(4, 8, 4, 8); // 对齐 Python 版边距
    toolLayout->setSpacing(4); // 紧凑间距，匹配图二

    // 辅助函数：创建图标按钮，支持旋转
    auto createToolBtn = [](QString iconName, QString color, QString tooltip, int rotate = 0) {
        QPushButton* btn = new QPushButton();
        QIcon icon = IconHelper::getIcon(iconName, color);
        if (rotate != 0) {
            QPixmap pix = icon.pixmap(32, 32);
            QTransform trans;
            trans.rotate(rotate);
            btn->setIcon(QIcon(pix.transformed(trans, Qt::SmoothTransformation)));
        } else {
            btn->setIcon(icon);
        }
        btn->setIconSize(QSize(20, 20)); // 统一标准化为 20px 图标
        btn->setFixedSize(32, 32);
        btn->setToolTip(tooltip);
        btn->setCursor(Qt::PointingHandCursor);
        btn->setFocusPolicy(Qt::NoFocus);
        return btn;
    };

    // 1. 顶部窗口控制区 (修正图标名为 SvgIcons 中存在的名称)
    QPushButton* btnClose = createToolBtn("close", "#aaaaaa", "关闭");
    btnClose->setObjectName("btnClose");
    connect(btnClose, &QPushButton::clicked, this, &QuickWindow::hide);

    QPushButton* btnFull = createToolBtn("maximize", "#aaaaaa", "打开/关闭主窗口");
    connect(btnFull, &QPushButton::clicked, [this](){ emit toggleMainWindowRequested(); });

    QPushButton* btnMin = createToolBtn("minimize", "#aaaaaa", "最小化");
    connect(btnMin, &QPushButton::clicked, this, &QuickWindow::showMinimized);

    toolLayout->addWidget(btnClose, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnFull, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnMin, 0, Qt::AlignHCenter);

    toolLayout->addSpacing(8);

    // 2. 功能按钮区
    QPushButton* btnPin = createToolBtn("pin_tilted", "#aaaaaa", "置顶");
    btnPin->setCheckable(true);
    btnPin->setObjectName("btnPin");
    btnPin->setStyleSheet("QPushButton:checked { background-color: #3A90FF; }");
    if (windowFlags() & Qt::WindowStaysOnTopHint) {
        btnPin->setChecked(true);
        btnPin->setIcon(IconHelper::getIcon("pin_vertical", "#ffffff"));
    }
    connect(btnPin, &QPushButton::toggled, this, &QuickWindow::toggleStayOnTop);

    QPushButton* btnSidebar = createToolBtn("eye", "#aaaaaa", "显示/隐藏侧边栏");
    btnSidebar->setObjectName("btnSidebar");
    btnSidebar->setCheckable(true);
    btnSidebar->setChecked(true);
    btnSidebar->setStyleSheet("QPushButton:checked { background-color: #3A90FF; }");
    connect(btnSidebar, &QPushButton::clicked, this, &QuickWindow::toggleSidebar);

    QPushButton* btnRefresh = createToolBtn("refresh", "#aaaaaa", "刷新");
    connect(btnRefresh, &QPushButton::clicked, this, &QuickWindow::refreshData);

    QPushButton* btnToolbox = createToolBtn("toolbox", "#aaaaaa", "工具箱");
    btnToolbox->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(btnToolbox, &QPushButton::clicked, this, &QuickWindow::toolboxRequested);
    connect(btnToolbox, &QPushButton::customContextMenuRequested, this, &QuickWindow::showToolboxMenu);

    QPushButton* btnLock = createToolBtn("lock_secure", "#aaaaaa", "锁定应用");
    connect(btnLock, &QPushButton::clicked, this, &QuickWindow::doGlobalLock);

    toolLayout->addWidget(btnPin, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnSidebar, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnRefresh, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnToolbox, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnLock, 0, Qt::AlignHCenter);

    toolLayout->addStretch();

    // 3. 分页区 (完全复刻图二布局：箭头+输入框+下方总数)
    QPushButton* btnPrev = createToolBtn("nav_prev", "#aaaaaa", "上一页", 90);
    btnPrev->setFixedSize(32, 20);
    connect(btnPrev, &QPushButton::clicked, [this](){
        if (m_currentPage > 1) { m_currentPage--; refreshData(); }
    });

    QLineEdit* pageInput = new QLineEdit("1");
    pageInput->setObjectName("pageInput");
    pageInput->setAlignment(Qt::AlignCenter);
    pageInput->setFixedSize(28, 20);
    connect(pageInput, &QLineEdit::returnPressed, [this, pageInput](){
        int p = pageInput->text().toInt();
        if (p > 0 && p <= m_totalPages) { m_currentPage = p; refreshData(); }
    });

    QLabel* totalLabel = new QLabel("1");
    totalLabel->setObjectName("totalLabel");
    totalLabel->setAlignment(Qt::AlignCenter);
    totalLabel->setStyleSheet("color: #666; font-size: 10px; border: none; background: transparent;");

    QPushButton* btnNext = createToolBtn("nav_next", "#aaaaaa", "下一页", 90);
    btnNext->setFixedSize(32, 20);
    connect(btnNext, &QPushButton::clicked, [this](){
        if (m_currentPage < m_totalPages) { m_currentPage++; refreshData(); }
    });

    toolLayout->addWidget(btnPrev, 0, Qt::AlignHCenter);
    toolLayout->addWidget(pageInput, 0, Qt::AlignHCenter);
    toolLayout->addWidget(totalLabel, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnNext, 0, Qt::AlignHCenter);

    toolLayout->addSpacing(20); // 增加分页与标题间距

    // 4. 垂直标题 "快速笔记"
    QLabel* verticalTitle = new QLabel("快\n速\n笔\n记");
    verticalTitle->setAlignment(Qt::AlignCenter);
    verticalTitle->setStyleSheet("color: #444; font-size: 11px; font-weight: bold; border: none; background: transparent; line-height: 1.1;");
    toolLayout->addWidget(verticalTitle, 0, Qt::AlignHCenter);

    toolLayout->addSpacing(12);

    // 5. 底部 Logo (修正为 zap 图标以匹配图二蓝闪电)
    QPushButton* btnLogo = createToolBtn("zap", "#3A90FF", "RapidNotes");
    btnLogo->setCursor(Qt::ArrowCursor);
    btnLogo->setStyleSheet("background: transparent; border: none;");
    toolLayout->addWidget(btnLogo, 0, Qt::AlignHCenter);

    containerLayout->addWidget(customToolbar);
    
    // m_toolbar = new QuickToolbar(this); // 移除旧代码
    // containerLayout->addWidget(m_toolbar); // 移除旧代码
    
    mainLayout->addWidget(container);
    
    // 初始大小和最小大小
    resize(900, 630);
    setMinimumSize(400, 300);

    m_quickPreview = new QuickPreview(this);
    connect(m_quickPreview, &QuickPreview::editRequested, this, &QuickWindow::doEditNote);
    connect(m_quickPreview, &QuickPreview::prevRequested, this, [this](){
        QModelIndex current = m_listView->currentIndex();
        if (!current.isValid() || m_model->rowCount() == 0) return;

        int catId = current.data(NoteModel::CategoryIdRole).toInt();
        int row = current.row();
        int count = m_model->rowCount();
        
        for (int i = 1; i <= count; ++i) {
            int prevRow = (row - i + count) % count;
            QModelIndex idx = m_model->index(prevRow, 0);
            if (idx.data(NoteModel::CategoryIdRole).toInt() == catId) {
                m_listView->setCurrentIndex(idx);
                m_listView->scrollTo(idx);
                updatePreviewContent();
                if (prevRow > row) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "已回环至列表末尾相同分类");
                }
                return;
            }
        }
    });
    connect(m_quickPreview, &QuickPreview::nextRequested, this, [this](){
        QModelIndex current = m_listView->currentIndex();
        if (!current.isValid() || m_model->rowCount() == 0) return;

        int catId = current.data(NoteModel::CategoryIdRole).toInt();
        int row = current.row();
        int count = m_model->rowCount();

        for (int i = 1; i <= count; ++i) {
            int nextRow = (row + i) % count;
            QModelIndex idx = m_model->index(nextRow, 0);
            if (idx.data(NoteModel::CategoryIdRole).toInt() == catId) {
                m_listView->setCurrentIndex(idx);
                m_listView->scrollTo(idx);
                updatePreviewContent();
                if (nextRow < row) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "已回环至列表起始相同分类");
                }
                return;
            }
        }
    });
    connect(m_quickPreview, &QuickPreview::historyNavigationRequested, this, [this](int id){
        for (int i = 0; i < m_model->rowCount(); ++i) {
            QModelIndex idx = m_model->index(i, 0);
            if (idx.data(NoteModel::IdRole).toInt() == id) {
                m_listView->setCurrentIndex(idx);
                m_listView->scrollTo(idx);
                return;
            }
        }
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        if (!note.isEmpty()) {
            m_quickPreview->showPreview(
                id,
                note.value("title").toString(),
                note.value("content").toString(),
                note.value("item_type").toString(),
                note.value("data_blob").toByteArray(),
                m_quickPreview->pos(),
                ""
            );
        }
    });
    m_listView->installEventFilter(this);
    m_systemTree->installEventFilter(this);
    m_partitionTree->installEventFilter(this);

    // 搜索逻辑
    m_searchTimer = new QTimer(this);
    m_searchTimer->setSingleShot(true);
    connect(m_searchTimer, &QTimer::timeout, this, &QuickWindow::refreshData);
    connect(m_searchEdit, &QLineEdit::textChanged, [this](const QString& text){
        m_currentPage = 1;
        m_searchTimer->start(300);
    });

    connect(m_searchEdit, &QLineEdit::returnPressed, [this](){
        QString text = m_searchEdit->text().trimmed();
        if (text.isEmpty()) return;
        m_searchEdit->addHistoryEntry(text);
        
        // 强制立即刷新一次数据，防止定时器延迟导致 rowCount 不准确
        m_searchTimer->stop();
        refreshData();
    });

    // 监听列表选择变化，动态切换输入框状态
    connect(m_listView->selectionModel(), &QItemSelectionModel::selectionChanged, this, [this](){
        auto selected = m_listView->selectionModel()->selectedIndexes();
        if (selected.isEmpty()) {
            m_tagEdit->setEnabled(false);
            m_tagEdit->clear();
            m_tagEdit->setPlaceholderText("请先选择一个项目");
        } else {
            m_tagEdit->setEnabled(true);
            m_tagEdit->setPlaceholderText(selected.size() == 1 ? "输入新标签... (双击显示历史)" : "批量添加标签... (双击显示历史)");
            
            // 联动更新：如果预览窗口处于显示状态，随选中项即时更新内容
            if (m_quickPreview->isVisible()) {
                updatePreviewContent();
            }
        }
    });

    setupShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &QuickWindow::updateShortcuts);
    restoreState();
    refreshData();
    setupAppLock();
}

void QuickWindow::setupAppLock() {
    if (m_appLockWidget) return;
    QSettings settings("RapidNotes", "QuickWindow");
    QString appPwd = settings.value("appPassword").toString();
    if (!appPwd.isEmpty()) {
        auto* lock = new AppLockWidget(appPwd, this);
        m_appLockWidget = lock;
        lock->resize(this->size());
        
        connect(lock, &AppLockWidget::unlocked, this, [this]() {
            m_appLockWidget = nullptr;
            m_searchEdit->setFocus();
        });
        
        lock->show();
        lock->raise();
    }
}

void QuickWindow::saveState() {
    QSettings settings("RapidNotes", "QuickWindow");
    settings.setValue("geometry", saveGeometry());
    settings.setValue("splitter", m_splitter->saveState());
    settings.setValue("sidebarHidden", m_systemTree->parentWidget()->isHidden());
    settings.setValue("stayOnTop", m_isStayOnTop);
    settings.setValue("autoCategorizeClipboard", m_autoCategorizeClipboard);
}

void QuickWindow::restoreState() {
    QSettings settings("RapidNotes", "QuickWindow");
    if (settings.contains("geometry")) {
        restoreGeometry(settings.value("geometry").toByteArray());
    }
    if (settings.contains("splitter")) {
        m_splitter->restoreState(settings.value("splitter").toByteArray());
    }
    if (settings.contains("sidebarHidden")) {
        bool hidden = settings.value("sidebarHidden").toBool();
        m_systemTree->parentWidget()->setHidden(hidden);
        
        // 同步刷新眼睛图标状态
        auto* btnSidebar = findChild<QPushButton*>("btnSidebar");
        if (btnSidebar) {
            bool visible = !hidden;
            btnSidebar->setChecked(visible);
            btnSidebar->setIcon(IconHelper::getIcon("eye", visible ? "#ffffff" : "#aaaaaa"));
        }
    }
    if (settings.contains("stayOnTop")) {
        toggleStayOnTop(settings.value("stayOnTop").toBool());
    }
    if (settings.contains("autoCategorizeClipboard")) {
        m_autoCategorizeClipboard = settings.value("autoCategorizeClipboard").toBool();
    }
}

void QuickWindow::setupShortcuts() {
    auto add = [&](const QString& id, std::function<void()> func) {
        auto* sc = new QShortcut(ShortcutManager::instance().getShortcut(id), this, func);
        sc->setProperty("id", id);
        m_shortcuts.append(sc);
    };

    add("qw_search", [this](){ m_searchEdit->setFocus(); m_searchEdit->selectAll(); });
    add("qw_delete_soft", [this](){ doDeleteSelected(false); });
    add("qw_delete_hard", [this](){ doDeleteSelected(true); });
    add("qw_favorite", [this](){ doToggleFavorite(); });
    add("qw_preview", [this](){ doPreview(); });
    add("qw_pin", [this](){ doTogglePin(); });
    add("qw_close", [this](){ hide(); });
    add("qw_lock_item", [this](){ doLockSelected(); });
    add("qw_new_idea", [this](){ doNewIdea(); });
    add("qw_select_all", [this](){ m_listView->selectAll(); });
    add("qw_extract", [this](){ doExtractContent(); });
    add("qw_lock_cat", [this](){
        if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
            DatabaseManager::instance().lockCategory(m_currentFilterValue.toInt());
            refreshSidebar();
            refreshData();
        }
    });
    add("qw_stay_on_top", [this](){ toggleStayOnTop(!m_isStayOnTop); });
    add("qw_toggle_main", [this](){ emit toggleMainWindowRequested(); });
    add("qw_toolbox", [this](){ emit toolboxRequested(); });
    add("qw_edit", [this](){ doEditSelected(); });
    add("qw_sidebar", [this](){ toggleSidebar(); });
    add("qw_prev_page", [this](){ if(m_currentPage > 1) { m_currentPage--; refreshData(); } });
    add("qw_next_page", [this](){ if(m_currentPage < m_totalPages) { m_currentPage++; refreshData(); } });
    add("qw_copy_tags", [this](){ doCopyTags(); });
    add("qw_paste_tags", [this](){ doPasteTags(); });
    
    for (int i = 0; i <= 5; ++i) {
        add(QString("qw_rating_%1").arg(i), [this, i](){ doSetRating(i); });
    }
}

void QuickWindow::updateShortcuts() {
    for (auto* sc : m_shortcuts) {
        QString id = sc->property("id").toString();
        sc->setKey(ShortcutManager::instance().getShortcut(id));
    }
}

void QuickWindow::scheduleRefresh() {
    m_refreshTimer->start();
}

void QuickWindow::onNoteAdded(const QVariantMap& note) {
    // 检查是否符合当前过滤条件
    bool matches = false;
    if (m_currentFilterType == "all") matches = true;
    else if (m_currentFilterType == "today") matches = true;
    else if (m_currentFilterType == "category") {
        matches = (note.value("category_id").toInt() == m_currentFilterValue.toInt());
    } else if (m_currentFilterType == "untagged") {
        matches = note.value("tags").toString().isEmpty();
    }
    
    if (matches && m_currentPage == 1) {
        m_model->prependNote(note);
    }
    
    // 依然需要触发侧边栏计数刷新 (节流执行)
    scheduleRefresh();
}

void QuickWindow::refreshData() {
    if (!isVisible()) return;

    // 记忆当前选中的 ID 列表，以便在刷新后恢复多选状态
    QSet<int> selectedIds;
    auto selectedIndices = m_listView->selectionModel()->selectedIndexes();
    for (const auto& idx : selectedIndices) {
        selectedIds.insert(idx.data(NoteModel::IdRole).toInt());
    }
    int lastCurrentId = m_listView->currentIndex().data(NoteModel::IdRole).toInt();

    QString keyword = m_searchEdit->text();
    
    int totalCount = DatabaseManager::instance().getNotesCount(keyword, m_currentFilterType, m_currentFilterValue);
    
    const int pageSize = 100; // 对齐 Python 版
    m_totalPages = qMax(1, (totalCount + pageSize - 1) / pageSize); 
    if (m_currentPage > m_totalPages) m_currentPage = m_totalPages;
    if (m_currentPage < 1) m_currentPage = 1;

    // 检查当前分类是否锁定
    bool isLocked = false;
    if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
        int catId = m_currentFilterValue.toInt();
        if (DatabaseManager::instance().isCategoryLocked(catId)) {
            isLocked = true;
            QString hint;
            auto cats = DatabaseManager::instance().getAllCategories();
            for(const auto& c : std::as_const(cats)) if(c.value("id").toInt() == catId) hint = c.value("password_hint").toString();
            m_lockWidget->setCategory(catId, hint);
        }
    }

    m_listView->setVisible(!isLocked);
    m_lockWidget->setVisible(isLocked);

    if (isLocked && m_quickPreview->isVisible()) {
        m_quickPreview->hide();
    }

    m_model->setNotes(isLocked ? QList<QVariantMap>() : DatabaseManager::instance().searchNotes(keyword, m_currentFilterType, m_currentFilterValue, m_currentPage, pageSize));
    
    // 恢复选中状态 (支持多选恢复)
    if (!selectedIds.isEmpty()) {
        QItemSelection selection;
        for (int i = 0; i < m_model->rowCount(); ++i) {
            QModelIndex idx = m_model->index(i, 0);
            int id = idx.data(NoteModel::IdRole).toInt();
            if (selectedIds.contains(id)) {
                selection.select(idx, idx);
            }
            if (id == lastCurrentId) {
                m_listView->setCurrentIndex(idx);
            }
        }
        if (!selection.isEmpty()) {
            m_listView->selectionModel()->select(selection, QItemSelectionModel::Select | QItemSelectionModel::Rows);
        }
    }

    // 更新工具栏页码 (对齐新版 1:1 布局)
    auto* pageInput = findChild<QLineEdit*>("pageInput");
    if (pageInput) pageInput->setText(QString::number(m_currentPage));
    
    auto* totalLabel = findChild<QLabel*>("totalLabel");
    if (totalLabel) totalLabel->setText(QString::number(m_totalPages));
}

void QuickWindow::updatePartitionStatus(const QString& name) {
    m_statusLabel->setText(QString("当前分区: %1").arg(name.isEmpty() ? "全部数据" : name));
    m_statusLabel->show();
}

void QuickWindow::refreshSidebar() {
    if (!isVisible()) return;
    // 保存选中状态
    QString selectedType;
    QVariant selectedValue;
    QModelIndex sysIdx = m_systemTree->currentIndex();
    QModelIndex partIdx = m_partitionTree->currentIndex();
    
    if (sysIdx.isValid()) {
        selectedType = sysIdx.data(CategoryModel::TypeRole).toString();
        selectedValue = sysIdx.data(CategoryModel::NameRole);
    } else if (partIdx.isValid()) {
        selectedType = partIdx.data(CategoryModel::TypeRole).toString();
        selectedValue = partIdx.data(CategoryModel::IdRole);
    }

    m_systemModel->refresh();
    m_partitionModel->refresh();
    m_partitionTree->expandAll();

    // 恢复选中
    if (!selectedType.isEmpty()) {
        if (selectedType != "category") {
            for (int i = 0; i < m_systemModel->rowCount(); ++i) {
                QModelIndex idx = m_systemModel->index(i, 0);
                if (idx.data(CategoryModel::TypeRole).toString() == selectedType &&
                    idx.data(CategoryModel::NameRole) == selectedValue) {
                    m_systemTree->setCurrentIndex(idx);
                    break;
                }
            }
        } else {
            std::function<void(const QModelIndex&)> findAndSelect = [&](const QModelIndex& parent) {
                for (int i = 0; i < m_partitionModel->rowCount(parent); ++i) {
                    QModelIndex idx = m_partitionModel->index(i, 0, parent);
                    if (idx.data(CategoryModel::IdRole) == selectedValue) {
                        m_partitionTree->setCurrentIndex(idx);
                        return;
                    }
                    if (m_partitionModel->rowCount(idx) > 0) findAndSelect(idx);
                }
            };
            findAndSelect(QModelIndex());
        }
    }
}

void QuickWindow::applyListTheme(const QString& colorHex) {
    QString style;
    if (!colorHex.isEmpty()) {
        QColor c(colorHex);
        // 对齐 Python 版，背景保持深色，高亮色由 Delegate 处理，这里主要设置斑马纹
        style = QString("QListView { "
                        "  border: none; "
                        "  background-color: #1e1e1e; "
                        "  alternate-background-color: #252526; "
                        "  selection-background-color: transparent; "
                        "  color: #eee; "
                        "  outline: none; "
                        "}");
    } else {
        style = "QListView { "
                "  border: none; "
                "  background-color: #1e1e1e; "
                "  alternate-background-color: #252526; "
                "  selection-background-color: transparent; "
                "  color: #eee; "
                "  outline: none; "
                "}";
    }
    m_listView->setStyleSheet(style);
}

void QuickWindow::activateNote(const QModelIndex& index) {
    if (!index.isValid()) return;

    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    
    // 记录访问
    DatabaseManager::instance().recordAccess(id);

    QString itemType = note.value("item_type").toString();
    QString content = note.value("content").toString();
    QByteArray blob = note.value("data_blob").toByteArray();
    
    if (itemType == "image") {
        QImage img;
        img.loadFromData(blob);
        ClipboardMonitor::instance().skipNext();
        QApplication::clipboard()->setImage(img);
    } else if (itemType == "local_file" || itemType == "local_folder" || itemType == "local_batch") {
        // 文件系统托管模式：从相对路径恢复绝对路径
        QString fullPath = QCoreApplication::applicationDirPath() + "/" + content;
        QFileInfo fi(fullPath);
        if (fi.exists()) {
            QMimeData* mimeData = new QMimeData();
            if (itemType == "local_batch") {
                // 批量托管模式：双击发送该批量的所有文件/文件夹内容
                QDir dir(fullPath);
                QList<QUrl> urls;
                for (const QString& fileName : dir.entryList(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot)) {
                    urls << QUrl::fromLocalFile(dir.absoluteFilePath(fileName));
                }
                if (urls.isEmpty()) urls << QUrl::fromLocalFile(fullPath); // 保底发送文件夹自身
                mimeData->setUrls(urls);
            } else {
                mimeData->setUrls({QUrl::fromLocalFile(fullPath)});
            }
            ClipboardMonitor::instance().skipNext();
            QApplication::clipboard()->setMimeData(mimeData);
        } else {
            QApplication::clipboard()->setText(content);
            ToolTipOverlay::instance()->showText(QCursor::pos(), "⚠️ 文件已丢失或被移动");
        }
    } else if (!blob.isEmpty() && (itemType == "file" || itemType == "folder")) {
        // 旧的数据库存储模式：导出到临时目录
        QString title = note.value("title").toString();
        QString exportDir = QDir::tempPath() + "/RapidNotes_Export";
        QDir().mkpath(exportDir);
        QString tempPath = exportDir + "/" + title;
        
        QFile f(tempPath);
        if (f.open(QIODevice::WriteOnly)) {
            f.write(blob);
            f.close();
            
            QMimeData* mimeData = new QMimeData();
            mimeData->setUrls({QUrl::fromLocalFile(tempPath)});
            QApplication::clipboard()->setMimeData(mimeData);
        } else {
            QApplication::clipboard()->setText(content);
        }
    } else if (itemType != "text" && !itemType.isEmpty()) {
        QStringList rawPaths = content.split(';', Qt::SkipEmptyParts);
        QList<QUrl> validUrls;
        QStringList missingFiles;
        
        for (const QString& p : std::as_const(rawPaths)) {
            QString path = p.trimmed().remove('\"');
            if (QFileInfo::exists(path)) {
                validUrls << QUrl::fromLocalFile(path);
            } else {
                missingFiles << QFileInfo(path).fileName();
            }
        }
        
        if (!validUrls.isEmpty()) {
            QMimeData* mimeData = new QMimeData();
            mimeData->setUrls(validUrls);
            QApplication::clipboard()->setMimeData(mimeData);
        } else {
            QApplication::clipboard()->setText(content);
            if (!missingFiles.isEmpty()) {
                ToolTipOverlay::instance()->showText(QCursor::pos(), "⚠️ 原文件已丢失，已复制路径文本");
            }
        }
    } else {
        StringUtils::copyNoteToClipboard(content);
    }

    // hide(); // 用户要求不隐藏窗口

#ifdef Q_OS_WIN
    if (m_lastActiveHwnd && IsWindow(m_lastActiveHwnd)) {
        DWORD currThread = GetCurrentThreadId();
        bool attached = false;
        if (m_lastThreadId != 0 && m_lastThreadId != currThread) {
            attached = AttachThreadInput(currThread, m_lastThreadId, TRUE);
        }

        if (IsIconic(m_lastActiveHwnd)) {
            ShowWindow(m_lastActiveHwnd, SW_RESTORE);
        }
        SetForegroundWindow(m_lastActiveHwnd);
        
        if (m_lastFocusHwnd && IsWindow(m_lastFocusHwnd)) {
            SetFocus(m_lastFocusHwnd);
        }

        DWORD lastThread = m_lastThreadId;
        QTimer::singleShot(300, [lastThread, attached]() {
            // 1. 使用 SendInput 强制清理所有修饰键状态 (L/R Ctrl, Shift, Alt, Win)
            // 替换旧的 keybd_event，确保清理逻辑更原子化
            INPUT releaseInputs[8];
            memset(releaseInputs, 0, sizeof(releaseInputs));
            BYTE keys[] = { VK_LCONTROL, VK_RCONTROL, VK_LSHIFT, VK_RSHIFT, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN };
            for (int i = 0; i < 8; ++i) {
                releaseInputs[i].type = INPUT_KEYBOARD;
                releaseInputs[i].ki.wVk = keys[i];
                releaseInputs[i].ki.dwFlags = KEYEVENTF_KEYUP;
            }
            SendInput(8, releaseInputs, sizeof(INPUT));

            // 2. 使用 SendInput 发送 Ctrl+V 序列 (显式指定 VK_LCONTROL 提高兼容性)
            INPUT inputs[4];
            memset(inputs, 0, sizeof(inputs));

            // Ctrl 按下
            inputs[0].type = INPUT_KEYBOARD;
            inputs[0].ki.wVk = VK_LCONTROL;
            inputs[0].ki.wScan = MapVirtualKey(VK_LCONTROL, MAPVK_VK_TO_VSC);

            // V 按下
            inputs[1].type = INPUT_KEYBOARD;
            inputs[1].ki.wVk = 'V';
            inputs[1].ki.wScan = MapVirtualKey('V', MAPVK_VK_TO_VSC);

            // V 抬起
            inputs[2].type = INPUT_KEYBOARD;
            inputs[2].ki.wVk = 'V';
            inputs[2].ki.wScan = MapVirtualKey('V', MAPVK_VK_TO_VSC);
            inputs[2].ki.dwFlags = KEYEVENTF_KEYUP;

            // Ctrl 抬起
            inputs[3].type = INPUT_KEYBOARD;
            inputs[3].ki.wVk = VK_LCONTROL;
            inputs[3].ki.wScan = MapVirtualKey(VK_LCONTROL, MAPVK_VK_TO_VSC);
            inputs[3].ki.dwFlags = KEYEVENTF_KEYUP;

            SendInput(4, inputs, sizeof(INPUT));

            if (attached) {
                // 确保按键消息推入后再分离线程
                AttachThreadInput(GetCurrentThreadId(), lastThread, FALSE);
            }
        });
    }
#endif
}

void QuickWindow::doDeleteSelected(bool physical) {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    bool inTrash = (m_currentFilterType == "trash");
    
    if (physical || inTrash) {
        // 物理删除前增加二次确认
        QString title = inTrash ? "清空项目" : "彻底删除";
        QString text = QString("确定要永久删除选中的 %1 条数据吗？\n此操作不可逆，数据将无法找回。").arg(selected.count());
        
        auto* msg = new FramelessMessageBox(title, text, this);
        msg->setAttribute(Qt::WA_DeleteOnClose);
        
        // 提取 ID 列表以备删除
        QList<int> idsToDelete;
        for (const auto& index : std::as_const(selected)) idsToDelete << index.data(NoteModel::IdRole).toInt();
        
        connect(msg, &FramelessMessageBox::confirmed, this, [this, idsToDelete]() {
            if (idsToDelete.isEmpty()) return;
            DatabaseManager::instance().deleteNotesBatch(idsToDelete);
            refreshData();
            refreshSidebar();
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已永久删除 %1 条数据").arg(idsToDelete.size()));
        });
        msg->show();
    } else {
        // 移至回收站：解除绑定
        QList<int> idsToTrash;
        for (const auto& index : std::as_const(selected)) idsToTrash << index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().softDeleteNotes(idsToTrash);
        refreshData();
    }
    refreshSidebar();
}

void QuickWindow::doRestoreTrash() {
    if (DatabaseManager::instance().restoreAllFromTrash()) {
        refreshData();
        refreshSidebar();
    }
}

void QuickWindow::doToggleFavorite() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().toggleNoteState(id, "is_favorite");
    }
    refreshData();
}

void QuickWindow::doTogglePin() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().toggleNoteState(id, "is_pinned");
    }
    refreshData();
}

void QuickWindow::doLockSelected() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    
    bool firstState = selected.first().data(NoteModel::LockedRole).toBool();
    bool targetState = !firstState;

    QList<int> ids;
    for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
    
    DatabaseManager::instance().updateNoteStateBatch(ids, "is_locked", targetState);
    refreshData();
}

void QuickWindow::doNewIdea() {
    NoteEditWindow* win = new NoteEditWindow();
    connect(win, &NoteEditWindow::noteSaved, this, &QuickWindow::refreshData);
    win->show();
}

void QuickWindow::doExtractContent() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    QStringList texts;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        QString type = note.value("item_type").toString();
        if (type == "text" || type.isEmpty()) {
            QString content = note.value("content").toString();
            texts << StringUtils::htmlToPlainText(content);
        }
    }
    if (!texts.isEmpty()) {
        ClipboardMonitor::instance().skipNext();
        QApplication::clipboard()->setText(texts.join("\n---\n"));
    }
}

void QuickWindow::doEditSelected() {
    QModelIndex index = m_listView->currentIndex();
    if (!index.isValid()) return;
    doEditNote(index.data(NoteModel::IdRole).toInt());
}

void QuickWindow::doEditNote(int id) {
    if (id <= 0) return;
    NoteEditWindow* win = new NoteEditWindow(id);
    connect(win, &NoteEditWindow::noteSaved, this, &QuickWindow::refreshData);
    win->show();
}

void QuickWindow::doSetRating(int rating) {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().updateNoteState(id, "rating", rating);
    }
    refreshData();
}

void QuickWindow::doGlobalLock() {
    // 0. 预检密码是否设定
    QSettings settings("RapidNotes", "QuickWindow");
    if (settings.value("appPassword").toString().isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 尚未设定应用密码，请先进行设定</b>");
        return;
    }

    // 1. 隐藏所有其它顶级业务窗口 (排除自身、悬浮球)
    for (QWidget* widget : QApplication::topLevelWidgets()) {
        if (widget == this) continue;
        if (widget->objectName() == "FloatingBall") continue;
        if (widget->inherits("QSystemTrayIcon")) continue; // 虽然不是 QWidget 但遍历通常不含它
        
        // 排除某些特定窗口类或对象名 (可选)
        if (widget->isVisible()) {
            widget->hide();
        }
    }

    // 2. 强制显示应用锁
    setupAppLock();

    // 3. 弹出极速窗口并聚焦
    showAuto();
    
    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #2ecc71;'>✔ 应用已锁定</b>");
}

void QuickWindow::updatePreviewContent() {
    QModelIndex index = m_listView->currentIndex();
    if (!index.isValid()) return;
    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    
    // 记录访问
    DatabaseManager::instance().recordAccess(id);

    // 尽量保持当前预览窗口的位置，如果没显示则计算初始位置
    QPoint pos;
    if (m_quickPreview->isVisible()) {
        pos = m_quickPreview->pos();
    } else {
        pos = m_listView->mapToGlobal(m_listView->rect().center()) - QPoint(250, 300);
    }

    m_quickPreview->showPreview(
        id,
        note.value("title").toString(), 
        note.value("content").toString(), 
        note.value("item_type").toString(),
        note.value("data_blob").toByteArray(),
        pos,
        index.data(NoteModel::CategoryNameRole).toString()
    );
}

void QuickWindow::doPreview() {
    // 增加防抖保护，防止双重触发
    static QElapsedTimer timer;
    if (timer.isValid() && timer.elapsed() < 200) {
        return;
    }
    timer.restart();

    QWidget* focusWidget = QApplication::focusWidget();
    // 保护：如果焦点在搜索框或其他输入框，空格键应保留其原始功能
    // 但如果焦点在预览窗口内部，则允许切换预览
    if (focusWidget && (qobject_cast<QLineEdit*>(focusWidget) || 
                        qobject_cast<QTextEdit*>(focusWidget) ||
                        qobject_cast<QPlainTextEdit*>(focusWidget))) {
        if (focusWidget != m_quickPreview && !m_quickPreview->isAncestorOf(focusWidget)) {
            return;
        }
    }

    if (m_quickPreview->isVisible()) {
        m_quickPreview->hide();
        return;
    }
    
    updatePreviewContent();
    
    m_quickPreview->raise();
    m_quickPreview->activateWindow();
}

void QuickWindow::toggleStayOnTop(bool checked) {
    m_isStayOnTop = checked;

    if (isVisible()) {
#ifdef Q_OS_WIN
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, checked ? HWND_TOPMOST : HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
        Qt::WindowFlags f = windowFlags();
        if (checked) f |= Qt::WindowStaysOnTopHint;
        else f &= ~Qt::WindowStaysOnTopHint;
        setWindowFlags(f);
        show();
#endif
    }
    // 更新按钮状态与图标
    auto* btnPin = findChild<QPushButton*>("btnPin");
    if (btnPin) {
        if (btnPin->isChecked() != checked) btnPin->setChecked(checked);
        // 切换图标样式 (选中时白色垂直，未选中时灰色倾斜)
        btnPin->setIcon(IconHelper::getIcon(checked ? "pin_vertical" : "pin_tilted", checked ? "#ffffff" : "#aaaaaa"));
    }
}

void QuickWindow::toggleSidebar() {
    bool visible = !m_systemTree->parentWidget()->isVisible();
    m_systemTree->parentWidget()->setVisible(visible);
    
    // 更新按钮状态
    auto* btnSidebar = findChild<QPushButton*>("btnSidebar");
    if (btnSidebar) {
        btnSidebar->setChecked(visible);
        btnSidebar->setIcon(IconHelper::getIcon("eye", visible ? "#ffffff" : "#aaaaaa"));
    }

    QString name;
    if (m_systemTree->currentIndex().isValid()) name = m_systemTree->currentIndex().data().toString();
    else name = m_partitionTree->currentIndex().data().toString();
    
    updatePartitionStatus(name);
}

void QuickWindow::showListContextMenu(const QPoint& pos) {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) {
        QModelIndex index = m_listView->indexAt(pos);
        if (index.isValid()) {
            m_listView->setCurrentIndex(index);
            selected << index;
        } else {
            return;
        }
    }

    int selCount = selected.size();
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                       "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    if (selCount == 1) {
        menu.addAction(IconHelper::getIcon("eye", "#1abc9c", 18), "预览 (Space)", this, &QuickWindow::doPreview);
        
        QString type = selected.first().data(NoteModel::TypeRole).toString();
        if (type == "image") {
            menu.addAction(IconHelper::getIcon("screenshot_ocr", "#3498db", 18), "从图提取文字", this, &QuickWindow::doOCR);
        }
    }
    
    menu.addAction(IconHelper::getIcon("copy", "#1abc9c", 18), QString("复制内容 (%1)").arg(selCount), this, &QuickWindow::doExtractContent);
    menu.addSeparator();

    if (selCount == 1) {
        menu.addAction(IconHelper::getIcon("edit", "#4a90e2", 18), "编辑 (Ctrl+B)", this, &QuickWindow::doEditSelected);
        menu.addSeparator();
    }

    auto* ratingMenu = menu.addMenu(IconHelper::getIcon("star", "#f39c12", 18), QString("设置星级 (%1)").arg(selCount));
    ratingMenu->setStyleSheet(menu.styleSheet());
    auto* starGroup = new QActionGroup(this);
    int currentRating = (selCount == 1) ? selected.first().data(NoteModel::RatingRole).toInt() : -1;
    
    for (int i = 1; i <= 5; ++i) {
        QString stars = QString("★").repeated(i);
        QAction* action = ratingMenu->addAction(stars, [this, i]() { doSetRating(i); });
        action->setCheckable(true);
        if (i == currentRating) action->setChecked(true);
        starGroup->addAction(action);
    }
    ratingMenu->addSeparator();
    ratingMenu->addAction("清除评级", [this]() { doSetRating(0); });

    bool isFavorite = selected.first().data(NoteModel::FavoriteRole).toBool();
    menu.addAction(IconHelper::getIcon(isFavorite ? "bookmark_filled" : "bookmark", "#ff6b81", 18), 
                   isFavorite ? "取消书签" : "添加书签 (Ctrl+E)", this, &QuickWindow::doToggleFavorite);

    bool isPinned = selected.first().data(NoteModel::PinnedRole).toBool();
    menu.addAction(IconHelper::getIcon(isPinned ? "pin_vertical" : "pin_tilted", isPinned ? "#3A90FF" : "#aaaaaa", 18), 
                   isPinned ? "取消置顶" : "置顶选中项 (Ctrl+P)", this, &QuickWindow::doTogglePin);
    
    bool isLocked = selected.first().data(NoteModel::LockedRole).toBool();
    menu.addAction(IconHelper::getIcon("lock", isLocked ? "#aaaaaa" : "#888888", 18), 
                   isLocked ? "解锁选中项" : "锁定选中项 (Ctrl+S)", this, &QuickWindow::doLockSelected);
    
    menu.addSeparator();

    auto* catMenu = menu.addMenu(IconHelper::getIcon("branch", "#cccccc", 18), QString("移动选中项到分类 (%1)").arg(selCount));
    catMenu->setStyleSheet(menu.styleSheet());
    catMenu->addAction(IconHelper::getIcon("uncategorized", "#e67e22", 18), "未分类", [this]() { doMoveToCategory(-1); });
    
    QVariantList recentCats = StringUtils::getRecentCategories();
    auto allCategories = DatabaseManager::instance().getAllCategories();
    QMap<int, QVariantMap> catMap;
    for (const auto& cat : std::as_const(allCategories)) catMap[cat.value("id").toInt()] = cat;

    int count = 0;
    for (const auto& v : std::as_const(recentCats)) {
        if (count >= 10) break;
        int cid = v.toInt();
        if (catMap.contains(cid)) {
            const auto& cat = catMap.value(cid);
            catMenu->addAction(IconHelper::getIcon("branch", cat.value("color").toString(), 18), cat.value("name").toString(), [this, cid]() {
                doMoveToCategory(cid);
            });
            count++;
        }
    }

    menu.addSeparator();
    if (m_currentFilterType == "trash") {
        menu.addAction(IconHelper::getIcon("refresh", "#2ecc71", 18), "恢复 (还原到未分类)", [this, selected](){
            QList<int> ids;
            for (const auto& index : selected) ids << index.data(NoteModel::IdRole).toInt();
            DatabaseManager::instance().moveNotesToCategory(ids, -1);
            refreshData();
            refreshSidebar();
        });
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "彻底删除 (不可逆)", [this](){ doDeleteSelected(true); });
    } else {
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "移至回收站 (Delete)", [this](){ doDeleteSelected(false); });
    }

    menu.exec(m_listView->mapToGlobal(pos));
}

void QuickWindow::showSidebarMenu(const QPoint& pos) {
    auto* tree = qobject_cast<QTreeView*>(sender());
    if (!tree) return;

    QModelIndex index = tree->indexAt(pos);
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                       "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    if (!index.isValid() || index.data().toString() == "我的分区") {
        menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建分组", [this]() {
            bool ok;
            QString text = QInputDialog::getText(this, "新建组", "组名称:", QLineEdit::Normal, "", &ok);
            if (ok && !text.isEmpty()) {
                DatabaseManager::instance().addCategory(text);
            }
        });
        menu.exec(tree->mapToGlobal(pos));
        return;
    }

    QString type = index.data(CategoryModel::TypeRole).toString();
    if (type == "category") {
        int catId = index.data(CategoryModel::IdRole).toInt();
        QString currentName = index.data(CategoryModel::NameRole).toString();

        menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建数据", [this, catId]() {
            auto* win = new NoteEditWindow();
            win->setDefaultCategory(catId);
            connect(win, &NoteEditWindow::noteSaved, this, &QuickWindow::refreshData);
            win->show();
        });
        menu.addSeparator();
        menu.addAction(IconHelper::getIcon("palette", "#e67e22", 18), "设置颜色", [this, catId]() {
            auto* dlg = new QColorDialog(Qt::gray, this);
            dlg->setWindowTitle("选择分类颜色");
            dlg->setWindowFlags(dlg->windowFlags() | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);
            connect(dlg, &QColorDialog::colorSelected, [this, catId](const QColor& color){
                if (color.isValid()) {
                    DatabaseManager::instance().setCategoryColor(catId, color.name());
                    refreshSidebar();
                }
            });
            connect(dlg, &QColorDialog::finished, dlg, &QObject::deleteLater);
            dlg->show();
        });
        menu.addAction(IconHelper::getIcon("random_color", "#FF6B9D", 18), "随机颜色", [this, catId]() {
            static const QStringList palette = {
                "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEEAD",
                "#D4A5A5", "#9B59B6", "#3498DB", "#E67E22", "#2ECC71",
                "#E74C3C", "#F1C40F", "#1ABC9C", "#34495E", "#95A5A6"
            };
            QString chosenColor = palette.at(QRandomGenerator::global()->bounded(palette.size()));
            DatabaseManager::instance().setCategoryColor(catId, chosenColor);
            refreshData();
            refreshSidebar();
        });
        menu.addAction(IconHelper::getIcon("tag", "#FFAB91", 18), "设置预设标签", [this, catId]() {
            QString currentTags = DatabaseManager::instance().getCategoryPresetTags(catId);
            auto* dlg = new FramelessInputDialog("设置预设标签", "标签 (逗号分隔):", currentTags, this);
            connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                DatabaseManager::instance().setCategoryPresetTags(catId, dlg->text());
            });
            dlg->show();
        });
        menu.addSeparator();
        menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建分组", [this]() {
            auto* dlg = new FramelessInputDialog("新建分组", "组名称:", "", this);
            connect(dlg, &FramelessInputDialog::accepted, [this, dlg](){
                QString text = dlg->text();
                if (!text.isEmpty()) {
                    DatabaseManager::instance().addCategory(text);
                    refreshSidebar();
                }
            });
            dlg->show();
            dlg->activateWindow();
            dlg->raise();
        });
        menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建子分区", [this, catId]() {
            auto* dlg = new FramelessInputDialog("新建子分区", "区名称:", "", this);
            connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                QString text = dlg->text();
                if (!text.isEmpty()) {
                    DatabaseManager::instance().addCategory(text, catId);
                    refreshSidebar();
                }
            });
            dlg->show();
            dlg->activateWindow();
            dlg->raise();
        });
        menu.addSeparator();

        menu.addAction(IconHelper::getIcon("edit", "#aaaaaa", 18), "重命名", [this, catId, currentName]() {
            auto* dlg = new FramelessInputDialog("重命名", "新名称:", currentName, this);
            connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                QString text = dlg->text();
                if (!text.isEmpty()) {
                    DatabaseManager::instance().renameCategory(catId, text);
                    refreshSidebar();
                }
            });
            dlg->show();
            dlg->activateWindow();
            dlg->raise();
        });
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "删除", [this, catId]() {
            auto* dlg = new FramelessMessageBox("确认删除", "确定要删除此分类吗？内容将移至未分类。", this);
            dlg->setAttribute(Qt::WA_DeleteOnClose);
            connect(dlg, &FramelessMessageBox::confirmed, [this, catId](){
                DatabaseManager::instance().deleteCategory(catId);
                refreshSidebar();
            });
            dlg->show();
        });

        menu.addSeparator();
        auto* sortMenu = menu.addMenu(IconHelper::getIcon("list_ol", "#aaaaaa", 18), "排列");
        sortMenu->setStyleSheet(menu.styleSheet());

        int parentId = -1;
        QModelIndex parentIdx = index.parent();
        if (parentIdx.isValid() && parentIdx.data(CategoryModel::TypeRole).toString() == "category") {
            parentId = parentIdx.data(CategoryModel::IdRole).toInt();
        }

        sortMenu->addAction("标题(当前层级) (A→Z)", [this, parentId]() {
            if (DatabaseManager::instance().reorderCategories(parentId, true))
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 排列已完成</b>");
        });
        sortMenu->addAction("标题(当前层级) (Z→A)", [this, parentId]() {
            if (DatabaseManager::instance().reorderCategories(parentId, false))
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 排列已完成</b>");
        });
        sortMenu->addAction("标题(全部) (A→Z)", [this]() {
            if (DatabaseManager::instance().reorderAllCategories(true))
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 全部排列已完成</b>");
        });
        sortMenu->addAction("标题(全部) (Z→A)", [this]() {
            if (DatabaseManager::instance().reorderAllCategories(false))
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 全部排列已完成</b>");
        });

        menu.addSeparator();
        auto* pwdMenu = menu.addMenu(IconHelper::getIcon("lock", "#aaaaaa", 18), "密码保护");
        pwdMenu->setStyleSheet(menu.styleSheet());

        pwdMenu->addAction("设置", [this, catId]() {
            QTimer::singleShot(0, [this, catId]() {
                auto* dlg = new CategoryPasswordDialog("设置密码", this);
                connect(dlg, &QDialog::accepted, [this, catId, dlg]() {
                    DatabaseManager::instance().setCategoryPassword(catId, dlg->password(), dlg->passwordHint());
                    refreshSidebar();
                    refreshData();
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
        });
        pwdMenu->addAction("修改", [this, catId]() {
            QTimer::singleShot(0, [this, catId]() {
                auto* verifyDlg = new FramelessInputDialog("验证旧密码", "请输入当前密码:", "", this);
                verifyDlg->setEchoMode(QLineEdit::Password);
                connect(verifyDlg, &FramelessInputDialog::accepted, [this, catId, verifyDlg]() {
                    if (DatabaseManager::instance().verifyCategoryPassword(catId, verifyDlg->text())) {
                        auto* dlg = new CategoryPasswordDialog("修改密码", this);
                        QString currentHint;
                        auto cats = DatabaseManager::instance().getAllCategories();
                        for(const auto& c : std::as_const(cats)) if(c.value("id").toInt() == catId) currentHint = c.value("password_hint").toString();
                        dlg->setInitialData(currentHint);
                        connect(dlg, &QDialog::accepted, [this, catId, dlg]() {
                            DatabaseManager::instance().setCategoryPassword(catId, dlg->password(), dlg->passwordHint());
                            refreshSidebar();
                            refreshData();
                        });
                        dlg->show();
                        dlg->activateWindow();
                        dlg->raise();
                    } else {
                        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 旧密码验证失败</b>");
                    }
                });
                verifyDlg->show();
                verifyDlg->activateWindow();
                verifyDlg->raise();
            });
        });
        pwdMenu->addAction("移除", [this, catId]() {
            QTimer::singleShot(0, [this, catId]() {
                auto* dlg = new FramelessInputDialog("验证密码", "请输入当前密码以移除保护:", "", this);
                dlg->setEchoMode(QLineEdit::Password);
                connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg]() {
                    if (DatabaseManager::instance().verifyCategoryPassword(catId, dlg->text())) {
                        DatabaseManager::instance().removeCategoryPassword(catId);
                        refreshSidebar();
                        refreshData();
                    } else {
                        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 密码错误</b>");
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
        });
        pwdMenu->addAction("立即锁定", [this, catId]() {
            DatabaseManager::instance().lockCategory(catId);
            refreshSidebar();
            refreshData();
        })->setShortcut(QKeySequence("Ctrl+Shift+L"));
    } else if (type == "trash") {
        menu.addAction(IconHelper::getIcon("refresh", "#2ecc71", 18), "全部恢复 (到未分类)", this, &QuickWindow::doRestoreTrash);
        menu.addSeparator();
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "清空回收站", [this]() {
            auto* dlg = new FramelessMessageBox("确认清空", "确定要永久删除回收站中的所有内容吗？\n(此操作不可逆)", this);
            dlg->setAttribute(Qt::WA_DeleteOnClose);
            connect(dlg, &FramelessMessageBox::confirmed, [this](){
                DatabaseManager::instance().emptyTrash();
                refreshData();
                refreshSidebar();
            });
            dlg->show();
        });
    }

    menu.exec(tree->mapToGlobal(pos));
}

void QuickWindow::showToolboxMenu(const QPoint& pos) {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                       "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    QString iconName = m_autoCategorizeClipboard ? "switch_on" : "switch_off";
    QString iconColor = m_autoCategorizeClipboard ? "#00A650" : "#000000";
    QAction* autoCatAction = menu.addAction(IconHelper::getIcon(iconName, iconColor, 18), "剪贴板自动归档到当前分类");
    autoCatAction->setCheckable(true);
    autoCatAction->setChecked(m_autoCategorizeClipboard);
    connect(autoCatAction, &QAction::triggered, [this](bool checked){
        m_autoCategorizeClipboard = checked;
        ToolTipOverlay::instance()->showText(QCursor::pos(), m_autoCategorizeClipboard ? "✅ 剪贴板自动归档已开启" : "❌ 剪贴板自动归档已关闭");
    });

    menu.addSeparator();
    
    menu.addAction(IconHelper::getIcon("settings", "#aaaaaa", 18), "更多设置...", [this]() {
        auto* dlg = new SettingsWindow(this);
        dlg->setAttribute(Qt::WA_DeleteOnClose);
        // 预定位：居中于当前极速窗口
        dlg->move(this->geometry().center() - dlg->rect().center());
        dlg->exec();
    });

    menu.exec(QCursor::pos());
}

void QuickWindow::doMoveToCategory(int catId) {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    if (catId != -1) {
        StringUtils::recordRecentCategory(catId);
    }

    QList<int> ids;
    for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
    
    DatabaseManager::instance().moveNotesToCategory(ids, catId);
    refreshData();
}

void QuickWindow::handleTagInput() {
    QString text = m_tagEdit->text().trimmed();
    if (text.isEmpty()) return;
    
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QStringList tags = { text };
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().addTagsToNote(id, tags);
    }
    
    m_tagEdit->clear();
    refreshData();
    ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 标签已添加");
}

void QuickWindow::openTagSelector() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QStringList currentTags;
    if (selected.size() == 1) {
        int id = selected.first().data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        currentTags = note.value("tags").toString().split(",", Qt::SkipEmptyParts);
    }

    for (QString& t : currentTags) t = t.trimmed();

    auto* selector = new AdvancedTagSelector(this);
    auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
    auto allTags = DatabaseManager::instance().getAllTags();
    selector->setup(recentTags, allTags, currentTags);

    connect(selector, &AdvancedTagSelector::tagsConfirmed, [this, selected](const QStringList& tags){
        for (const auto& index : std::as_const(selected)) {
            int id = index.data(NoteModel::IdRole).toInt();
            DatabaseManager::instance().updateNoteState(id, "tags", tags.join(", "));
        }
        refreshData();
        ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 标签已更新");
    });

    selector->showAtCursor();
}

void QuickWindow::doCopyTags() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    // 获取选中的第一个项的标签
    int id = selected.first().data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    QString tagsStr = note.value("tags").toString();
    QStringList tags = tagsStr.split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
    for (QString& t : tags) t = t.trimmed();

    DatabaseManager::setTagClipboard(tags);
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✅ 已复制 %1 个标签").arg(tags.size()));
}

void QuickWindow::doOCR() {
    QModelIndex index = m_listView->currentIndex();
    if (!index.isValid()) return;

    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    if (note.value("item_type").toString() != "image") return;

    QByteArray data = note.value("data_blob").toByteArray();
    QImage img;
    img.loadFromData(data);
    if (img.isNull()) return;

    auto* resWin = new OCRResultWindow(img, id);
    connect(&OCRManager::instance(), &OCRManager::recognitionFinished, resWin, &OCRResultWindow::setRecognizedText);
    
    QSettings settings("RapidNotes", "OCR");
    if (settings.value("autoCopy", false).toBool()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "⏳ 正在识别文字...");
    } else {
        resWin->show();
    }
    
    OCRManager::instance().recognizeAsync(img, id);
}

void QuickWindow::doPasteTags() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QStringList tagsToPaste = DatabaseManager::getTagClipboard();
    if (tagsToPaste.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "❌ 标签剪贴板为空");
        return;
    }

    // 直接覆盖标签 (符合粘贴语义)
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().updateNoteState(id, "tags", tagsToPaste.join(", "));
    }

    refreshData();
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✅ 已覆盖粘贴标签至 %1 条数据").arg(selected.size()));
}

void QuickWindow::focusLockInput() {
    if (m_appLockWidget) {
        static_cast<AppLockWidget*>(m_appLockWidget)->focusInput();
    }
}

void QuickWindow::showAuto() {
#ifdef Q_OS_WIN
    HWND myHwnd = (HWND)winId();
    HWND current = GetForegroundWindow();
    if (current != myHwnd) {
        m_lastActiveHwnd = current;
        m_lastThreadId = GetWindowThreadProcessId(m_lastActiveHwnd, nullptr);
        GUITHREADINFO gti;
        gti.cbSize = sizeof(GUITHREADINFO);
        if (GetGUIThreadInfo(m_lastThreadId, &gti)) {
            m_lastFocusHwnd = gti.hwndFocus;
        } else {
            m_lastFocusHwnd = nullptr;
        }
    }
#endif

    // 仅在从未保存过位置时执行居中逻辑
    QSettings settings("RapidNotes", "QuickWindow");
    if (!settings.contains("geometry")) {
        QScreen *screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect screenGeom = screen->geometry();
            move(screenGeom.center() - rect().center());
        }
    }

    QPoint targetPos = pos();
    bool wasHidden = !isVisible() || isMinimized();

    if (isMinimized()) {
        showNormal();
    } else {
        show();
    }

    if (wasHidden) {
        setWindowOpacity(0);
        auto* fade = new QPropertyAnimation(this, "windowOpacity");
        fade->setDuration(300);
        fade->setStartValue(0.0);
        fade->setEndValue(1.0);
        fade->setEasingCurve(QEasingCurve::OutCubic);

        auto* slide = new QPropertyAnimation(this, "pos");
        slide->setDuration(300);
        slide->setStartValue(targetPos + QPoint(0, 10));
        slide->setEndValue(targetPos);
        slide->setEasingCurve(QEasingCurve::OutCubic);

        fade->start(QAbstractAnimation::DeleteWhenStopped);
        slide->start(QAbstractAnimation::DeleteWhenStopped);
    }
    
    raise();
    activateWindow();
    
#ifdef Q_OS_WIN
    // 强制置顶并激活，即使在其他窗口之后也能强制唤起
    SetForegroundWindow(myHwnd);
#endif

    if (isLocked()) {
        focusLockInput();
    } else {
        m_searchEdit->setFocus();
        m_searchEdit->selectAll();
    }
}

void QuickWindow::showEvent(QShowEvent* event) {
    QWidget::showEvent(event);
    
    // 强制每次显示时都清除选择，确保输入框初始处于禁用状态
    if (m_listView && m_listView->selectionModel()) {
        m_listView->clearSelection();
        m_listView->setCurrentIndex(QModelIndex());
    }

#ifdef Q_OS_WIN
    HWND myHwnd = (HWND)winId();
    if (m_isStayOnTop) {
        SetWindowPos(myHwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    } else {
        // 瞬间置顶再取消，确保能强制唤起
        SetWindowPos(myHwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        QTimer::singleShot(150, [myHwnd]() {
            SetWindowPos(myHwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        });
    }
#endif
}

#ifdef Q_OS_WIN
bool QuickWindow::nativeEvent(const QByteArray &eventType, void *message, qintptr *result) {
    MSG* msg = static_cast<MSG*>(message);
    if (msg->message == WM_NCHITTEST) {
        // 原生边缘检测，实现丝滑的双向箭头缩放体验
        int x = GET_X_LPARAM(msg->lParam);
        int y = GET_Y_LPARAM(msg->lParam);
        
        // 转换为本地坐标
        QPoint pos = mapFromGlobal(QPoint(x, y));
        int margin = RESIZE_MARGIN;
        int w = width();
        int h = height();

        bool left = pos.x() < margin;
        bool right = pos.x() > w - margin;
        bool top = pos.y() < margin;
        bool bottom = pos.y() > h - margin;

        if (top && left) *result = HTTOPLEFT;
        else if (top && right) *result = HTTOPRIGHT;
        else if (bottom && left) *result = HTBOTTOMLEFT;
        else if (bottom && right) *result = HTBOTTOMRIGHT;
        else if (top) *result = HTTOP;
        else if (bottom) *result = HTBOTTOM;
        else if (left) *result = HTLEFT;
        else if (right) *result = HTRIGHT;
        else return QWidget::nativeEvent(eventType, message, result);

        return true;
    }
    return QWidget::nativeEvent(eventType, message, result);
}
#endif

bool QuickWindow::event(QEvent* event) {
    return QWidget::event(event);
}

void QuickWindow::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        // 不在边距区域，启动移动窗口（只有点击空白处时）
        if (auto* handle = windowHandle()) {
            handle->startSystemMove();
        }
        event->accept();
    }
}

void QuickWindow::mouseMoveEvent(QMouseEvent* event) {
    QWidget::mouseMoveEvent(event);
}

void QuickWindow::mouseReleaseEvent(QMouseEvent* event) {
    QWidget::mouseReleaseEvent(event);
}

void QuickWindow::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls() || event->mimeData()->hasText() || event->mimeData()->hasImage()) {
        event->acceptProposedAction();
    }
}

void QuickWindow::dragMoveEvent(QDragMoveEvent* event) {
    event->acceptProposedAction();
}

void QuickWindow::dropEvent(QDropEvent* event) {
    const QMimeData* mime = event->mimeData();
    int targetId = -1;
    if (m_currentFilterType == "category") {
        targetId = m_currentFilterValue.toInt();
    }

    QString itemType = "text";
    QString title;
    QString content;
    QByteArray dataBlob;
    QStringList tags;

    if (mime->hasText() && !mime->text().trimmed().isEmpty()) {
        content = mime->text();
        title = content.trimmed().left(50).replace("\n", " ");
        itemType = "text";
    } else if (mime->hasUrls()) {
        QList<QUrl> urls = mime->urls();
        QStringList paths;
        for (const QUrl& url : std::as_const(urls)) {
            if (url.isLocalFile()) {
                QString p = url.toLocalFile();
                paths << p;
                if (title.isEmpty()) {
                    QFileInfo info(p);
                    title = info.fileName();
                    itemType = info.isDir() ? "folder" : "file";
                }
            } else {
                paths << url.toString();
                if (title.isEmpty()) {
                    title = "外部链接";
                    itemType = "link";
                }
            }
        }
        content = paths.join(";");
        if (paths.size() > 1) {
            title = QString("批量导入 (%1个文件)").arg(paths.size());
            itemType = "files";
        }
    } else if (mime->hasImage()) {
        QImage img = qvariant_cast<QImage>(mime->imageData());
        if (!img.isNull()) {
            QBuffer buffer(&dataBlob);
            buffer.open(QIODevice::WriteOnly);
            img.save(&buffer, "PNG");
            itemType = "image";
            title = "[拖入图片] " + QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
            content = "[Image Data]";
        }
    }

    if (!content.isEmpty() || !dataBlob.isEmpty()) {
        DatabaseManager::instance().addNote(title, content, tags, "", targetId, itemType, dataBlob);
        event->acceptProposedAction();
    }
}

void QuickWindow::hideEvent(QHideEvent* event) {
    // 保护：仅在非系统自发（spontaneous）且窗口确实不可见时才可能退出
    // 防止初始化或某些 Windows 系统消息导致的误退
    if (m_appLockWidget && !event->spontaneous() && !isVisible()) {
        qDebug() << "[QuickWin] 退出程序，因为应用锁处于活动状态且窗口被隐藏";
        QApplication::quit();
    }
    saveState();
    QWidget::hideEvent(event);
}

void QuickWindow::resizeEvent(QResizeEvent* event) {
    if (m_appLockWidget) {
        m_appLockWidget->resize(this->size());
    }
    QWidget::resizeEvent(event);
    saveState();
}

void QuickWindow::moveEvent(QMoveEvent* event) {
    QWidget::moveEvent(event);
    saveState();
}

void QuickWindow::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Escape) {
        hide();
        return;
    }
    QWidget::keyPressEvent(event);
}

bool QuickWindow::eventFilter(QObject* watched, QEvent* event) {
    // 逻辑 1: 鼠标移动到列表或侧边栏范围内，立即恢复正常光标
    if (watched == m_listView || watched == m_systemTree || watched == m_partitionTree) {
        if (event->type() == QEvent::MouseMove || event->type() == QEvent::Enter) {
            setCursor(Qt::ArrowCursor);
        }
    }

    // 逻辑 2: 侧边栏点击分类且不释放左键时，显示手指光标
    if (watched == m_partitionTree && event->type() == QEvent::KeyPress) {
        QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
        int key = keyEvent->key();
        auto modifiers = keyEvent->modifiers();

        if ((key == Qt::Key_Up || key == Qt::Key_Down) && (modifiers & Qt::ControlModifier)) {
            QModelIndex current = m_partitionTree->currentIndex();
            if (current.isValid() && current.data(CategoryModel::TypeRole).toString() == "category") {
                int catId = current.data(CategoryModel::IdRole).toInt();
                DatabaseManager::MoveDirection dir;

                if (key == Qt::Key_Up) {
                    dir = (modifiers & Qt::ShiftModifier) ? DatabaseManager::Top : DatabaseManager::Up;
                } else {
                    dir = (modifiers & Qt::ShiftModifier) ? DatabaseManager::Bottom : DatabaseManager::Down;
                }

                if (DatabaseManager::instance().moveCategory(catId, dir)) {
                    refreshSidebar();
                    return true;
                }
            }
        }
    }

    if (watched == m_systemTree || watched == m_partitionTree) {
        if (event->type() == QEvent::MouseButtonPress) {
            QMouseEvent* me = static_cast<QMouseEvent*>(event);
            if (me->button() == Qt::LeftButton) {
                QTreeView* tree = qobject_cast<QTreeView*>(watched);
                if (tree && tree->indexAt(me->pos()).isValid()) {
                    setCursor(Qt::PointingHandCursor);
                }
            }
        } else if (event->type() == QEvent::MouseButtonRelease) {
            setCursor(Qt::ArrowCursor);
        }
    }

    if ((watched == m_listView || watched == m_searchEdit) && event->type() == QEvent::KeyPress) {
        QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
        if (keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Enter) {
            if (watched == m_listView) {
                activateNote(m_listView->currentIndex());
                return true;
            }
        }
        if (keyEvent->key() == Qt::Key_Escape) {
            hide();
            return true;
        }
    }
    return QWidget::eventFilter(watched, event);
}

void DittoListView::startDrag(Qt::DropActions supportedActions) {
    // 深度对齐 Ditto：禁用笨重的快照卡片 Pixmap，保持视觉清爽
    QDrag* drag = new QDrag(this);
    drag->setMimeData(model()->mimeData(selectedIndexes()));
    
    // 【深度修复】提供 1x1 透明占位符。
    // 许多现代应用（如 Chrome）在 Windows 上执行 DND 时会验证拖拽图像。
    // 如果完全没有 Pixmap，投放信号可能无法在网页输入框触发。
    QPixmap pix(1, 1);
    pix.fill(Qt::transparent);
    drag->setPixmap(pix);
    drag->setHotSpot(QPoint(0, 0));
    
    // 【核心修复】显式指定默认动作为 CopyAction。
    // 许多外部应用（特别是网页浏览器）需要明确的 Copy 握手信号。
    drag->exec(Qt::CopyAction | Qt::MoveAction, Qt::CopyAction);
}

void DittoListView::mousePressEvent(QMouseEvent* event) {
    QModelIndex index = indexAt(event->pos());
    if (!index.isValid()) {
        // 点击在空白区域，清除选择
        clearSelection();
        setCurrentIndex(QModelIndex());
    }
    QListView::mousePressEvent(event);
}

#include "QuickWindow.moc"
```

## 文件: `src/ui/QuickWindow.h`

```cpp
#ifndef QUICKWINDOW_H
#define QUICKWINDOW_H

#include <QWidget>
#include "SearchLineEdit.h"
#include <QListView>
#include <QTreeView>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QSplitter>
#include <QLabel>
#include <QTimer>
#include <QKeyEvent>
#include <QResizeEvent>
#include <QHideEvent>
#include "../models/NoteModel.h"
#include "../models/CategoryModel.h"
#include "QuickPreview.h"
#include "DropTreeView.h"
#include "CategoryLockWidget.h"
#include "ClickableLineEdit.h"
#include <QShortcut>

#ifdef Q_OS_WIN
#include <windows.h>
#include <windowsx.h>
#endif

// 自定义列表视图，实现 Ditto 风格的轻量化拖拽
class DittoListView : public QListView {
    Q_OBJECT
public:
    using QListView::QListView;
protected:
    void startDrag(Qt::DropActions supportedActions) override;
    void mousePressEvent(QMouseEvent* event) override;
};

class QuickWindow : public QWidget {
    Q_OBJECT
public:
    explicit QuickWindow(QWidget* parent = nullptr);
    void showAuto();
    void focusLockInput();
    void saveState();
    void restoreState();

public slots:
    void refreshData();
    void scheduleRefresh();
    void onNoteAdded(const QVariantMap& note);

signals:
    void toggleMainWindowRequested();
    void toolboxRequested();

protected:
#ifdef Q_OS_WIN
    bool nativeEvent(const QByteArray &eventType, void *message, qintptr *result) override;
#endif
    bool event(QEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
    void showEvent(QShowEvent* event) override;
    void hideEvent(QHideEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void resizeEvent(QResizeEvent* event) override;
    void moveEvent(QMoveEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

private:
    void initUI();
    void setupAppLock();
    void activateNote(const QModelIndex& index);
    void setupShortcuts();
    void updatePartitionStatus(const QString& name);
    void refreshSidebar();
    void applyListTheme(const QString& colorHex);
    void updateShortcuts();
public:
    QString currentCategoryColor() const { return m_currentCategoryColor; }
    bool isAutoCategorizeEnabled() const { return m_autoCategorizeClipboard; }
    bool isLocked() const { return m_appLockWidget != nullptr; }
    int getCurrentCategoryId() const { return (m_currentFilterType == "category") ? m_currentFilterValue.toInt() : -1; }

    // 快捷键处理函数
    void doDeleteSelected(bool physical = false);
    void doToggleFavorite();
    void doTogglePin();
    void doLockSelected();
    void doNewIdea();
    void doExtractContent();
    void doOCR();
    void doEditSelected();
    void doEditNote(int id);
    void doSetRating(int rating);
    void doMoveToCategory(int catId);
    void doRestoreTrash();
    void doPreview();
    void doGlobalLock();
    void toggleStayOnTop(bool checked);
    void toggleSidebar();
    void showListContextMenu(const QPoint& pos);
    void showSidebarMenu(const QPoint& pos);
    void showToolboxMenu(const QPoint& pos);
    void updatePreviewContent();
    void handleTagInput();
    void openTagSelector();
    void doCopyTags();
    void doPasteTags();
    
    SearchLineEdit* m_searchEdit;
    QListView* m_listView;
    CategoryLockWidget* m_lockWidget;
    QWidget* m_appLockWidget = nullptr;
    NoteModel* m_model;
    QuickPreview* m_quickPreview;
    
    DropTreeView* m_systemTree;
    DropTreeView* m_partitionTree;
    CategoryModel* m_systemModel;
    CategoryModel* m_partitionModel;
    
    QTimer* m_searchTimer;
    QTimer* m_monitorTimer;
    QTimer* m_refreshTimer;
    QSplitter* m_splitter;
    QLabel* m_statusLabel;
    ClickableLineEdit* m_tagEdit;
    QList<QShortcut*> m_shortcuts;

    int m_currentPage = 1;
    int m_totalPages = 1;
    QString m_currentFilterType = "all";
    QVariant m_currentFilterValue = -1;
    QString m_currentCategoryColor = "#4a90e2"; // 默认蓝色
    bool m_autoCategorizeClipboard = false;
    bool m_isStayOnTop = false;

#ifdef Q_OS_WIN
    HWND m_lastActiveHwnd = nullptr;
    HWND m_lastFocusHwnd = nullptr;
    DWORD m_lastThreadId = 0;
#endif
};

#endif // QUICKWINDOW_H
```

## 文件: `src/ui/ResizeHandle.cpp`

```cpp
#include "ResizeHandle.h"

ResizeHandle::ResizeHandle(QWidget* target, QWidget* parent) 
    : QWidget(parent), m_target(target) 
{
    setFixedSize(20, 20);
    setCursor(Qt::SizeFDiagCursor);
}

void ResizeHandle::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_startPos = event->globalPosition().toPoint();
        m_startSize = m_target->size();
        event->accept();
    }
}

void ResizeHandle::mouseMoveEvent(QMouseEvent* event) {
    if (event->buttons() & Qt::LeftButton) {
        QPoint delta = event->globalPosition().toPoint() - m_startPos;
        int newW = qMax(m_startSize.width() + delta.x(), 600);
        int newH = qMax(m_startSize.height() + delta.y(), 400);
        m_target->resize(newW, newH);
        event->accept();
    }
}
```

## 文件: `src/ui/ResizeHandle.h`

```cpp
#ifndef RESIZEHANDLE_H
#define RESIZEHANDLE_H

#include <QWidget>
#include <QMouseEvent>

/**
 * @brief 隐形调整大小手柄
 */
class ResizeHandle : public QWidget {
    Q_OBJECT
public:
    explicit ResizeHandle(QWidget* target, QWidget* parent = nullptr);

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;

private:
    QWidget* m_target;
    QPoint m_startPos;
    QSize m_startSize;
};

#endif // RESIZEHANDLE_H
```

## 文件: `src/ui/ScreenshotTool.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "ScreenshotTool.h"
#include "StringUtils.h"

#include "IconHelper.h"
#include <QApplication>
#include <QScreen>
#include <QPainterPathStroker>
#include <QWheelEvent>
#include <QScrollArea>
#include <QScrollBar>
#include <QFileDialog>
#include <QClipboard>
#include <QMenu>
#include <QWidgetAction>
#include <QComboBox>
#include <QFontComboBox>
#include <QDateTime>
#include <QInputDialog>
#include <QFontMetrics>
#include <QStyle>
#include <QStyleOption>
#include <QColorDialog>
#include <QSettings>
#include <QToolTip>
#include <QAbstractItemView>
#include <QDir>
#include <QGraphicsDropShadowEffect>
#include <QCoreApplication>
#include <cmath>

#ifdef Q_OS_WIN
#include <windows.h>
#include <dwmapi.h>
#include <tchar.h>
#pragma comment(lib, "dwmapi.lib")

QRect getActualWindowRect(HWND hwnd) {
    RECT rect;
    if (SUCCEEDED(DwmGetWindowAttribute(hwnd, DWMWA_EXTENDED_FRAME_BOUNDS, &rect, sizeof(rect)))) {
        return QRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
    }
    GetWindowRect(hwnd, &rect);
    return QRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
}
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

static QList<QColor> getStandardColorList() {
    return {
        QColor(255, 0, 0), QColor(255, 165, 0), QColor(255, 255, 0), QColor(0, 255, 0),
        QColor(0, 255, 255), QColor(0, 0, 255), QColor(128, 0, 128), QColor(0, 0, 0), QColor(255, 255, 255)
    };
}

class IconFactory {
public:
    static QIcon createArrowStyleIcon(ArrowStyle style) {
        // 增大图标画布，以适应无文本的宽型菜单
        QPixmap pix(120, 32);
        pix.fill(Qt::transparent);
        QPainter p(&pix);
        p.setRenderHint(QPainter::Antialiasing);
        p.setPen(QPen(Qt::white, 2.5, Qt::SolidLine, Qt::FlatCap, Qt::RoundJoin));
        p.setBrush(Qt::white);
        
        QPointF start(10, 16), end(110, 16);
        QPointF dir = end - start;
        double angle = std::atan2(dir.y(), dir.x());
        double len = 100.0;

        bool isOutline = (style == ArrowStyle::OutlineSingle || style == ArrowStyle::OutlineDouble || style == ArrowStyle::OutlineDot);
        
        if (style == ArrowStyle::SolidSingle || style == ArrowStyle::OutlineSingle) {
            double hLen = 22;
            double bWid = 10;
            double wLen = 18;
            double wWid = 3;
            QPointF unit_dir = dir / len;
            QPointF perp_dir(-unit_dir.y(), unit_dir.x());

            if (isOutline) {
                p.setPen(QPen(Qt::white, 2.0));
                p.setBrush(Qt::transparent);
            } else {
                p.setPen(Qt::NoPen);
                p.setBrush(Qt::white);
            }
            p.drawPolygon(QPolygonF() << end 
                << end - unit_dir * hLen + perp_dir * bWid
                << end - unit_dir * wLen + perp_dir * wWid
                << start
                << end - unit_dir * wLen - perp_dir * wWid
                << end - unit_dir * hLen - perp_dir * bWid);
        } else if (style == ArrowStyle::Thin) {
            p.setPen(QPen(Qt::white, 3.0, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
            p.drawLine(start, end);
            double headSize = 18;
            p.drawLine(end, end - QPointF(headSize * std::cos(angle - 0.5), headSize * std::sin(angle - 0.5)));
            p.drawLine(end, end - QPointF(headSize * std::cos(angle + 0.5), headSize * std::sin(angle + 0.5)));
        } else if (style == ArrowStyle::SolidDouble || style == ArrowStyle::OutlineDouble) {
            p.setPen(QPen(Qt::white, 2.0));
            if (isOutline) p.setBrush(Qt::transparent); else p.setBrush(Qt::white);
            auto drawH = [&](const QPointF& e, double ang) {
                QPointF du(std::cos(ang), std::sin(ang));
                QPointF dp(-du.y(), du.x());
                p.drawPolygon(QPolygonF() << e << e - du * 16 + dp * 8 << e - du * 13 + dp * 2 << e - du * 13 - dp * 2 << e - du * 16 - dp * 8);
            };
            p.drawLine(start + (dir/len)*12, end - (dir/len)*12);
            drawH(end, angle); drawH(start, angle + M_PI);
        } else if (style == ArrowStyle::SolidDot || style == ArrowStyle::OutlineDot) {
            p.setPen(QPen(Qt::white, 2.0));
            if (isOutline) p.setBrush(Qt::transparent); else p.setBrush(Qt::white);
            p.drawLine(start, end - (dir/len)*12);
            p.drawEllipse(start, 5, 5);
            QPointF du(std::cos(angle), std::sin(angle));
            QPointF dp(-du.y(), du.x());
            p.drawPolygon(QPolygonF() << end << end - du * 16 + dp * 8 << end - du * 13 + dp * 2 << end - du * 13 - dp * 2 << end - du * 16 - dp * 8);
        } else if (style == ArrowStyle::Dimension) {
            p.setPen(QPen(Qt::white, 2.5, Qt::SolidLine, Qt::FlatCap, Qt::RoundJoin));
            p.drawLine(start, end);
            QPointF du(std::cos(angle), std::sin(angle));
            QPointF dp(-du.y(), du.x());
            p.drawLine(start + dp * 8, start - dp * 8);
            p.drawLine(end + dp * 8, end - dp * 8);
        }
        return QIcon(pix);
    }
};

PinnedScreenshotWidget::PinnedScreenshotWidget(const QPixmap& pixmap, const QRect& screenRect, QWidget* parent)
    : QWidget(nullptr, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool), m_pixmap(pixmap)
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_DeleteOnClose);
    setFixedSize(pixmap.size() / pixmap.devicePixelRatio());
    move(screenRect.topLeft());
}

void PinnedScreenshotWidget::paintEvent(QPaintEvent*) {
    QPainter p(this);
    p.drawPixmap(rect(), m_pixmap);
    p.setPen(QPen(QColor(0, 120, 255, 200), 2));
    p.drawRect(rect().adjusted(0, 0, -1, -1));
}

void PinnedScreenshotWidget::mousePressEvent(QMouseEvent* e) {
    if (e->button() == Qt::LeftButton) m_dragPos = e->globalPosition().toPoint() - frameGeometry().topLeft();
}

void PinnedScreenshotWidget::mouseMoveEvent(QMouseEvent* e) {
    if (e->buttons() & Qt::LeftButton) move(e->globalPosition().toPoint() - m_dragPos);
}

void PinnedScreenshotWidget::mouseDoubleClickEvent(QMouseEvent*) { close(); }
void PinnedScreenshotWidget::contextMenuEvent(QContextMenuEvent* e) {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.addAction("复制", [this](){ 
        ClipboardMonitor::instance().forceNext();
        QApplication::clipboard()->setPixmap(m_pixmap); 
    });
    menu.addAction("保存", [this](){
        QString fileName = QString("RPN_%1.png").arg(QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss"));
        QString f = QFileDialog::getSaveFileName(this, "保存截图", fileName, "PNG(*.png)");
        if(!f.isEmpty()) m_pixmap.save(f);
    });
    menu.addSeparator();
    menu.addAction("关闭", this, &QWidget::close);
    menu.exec(e->globalPos());
}

SelectionInfoBar::SelectionInfoBar(QWidget* parent) : QWidget(parent) {
    setAttribute(Qt::WA_TransparentForMouseEvents);
    setFixedSize(180, 28);
    hide();
}
void SelectionInfoBar::updateInfo(const QRect& rect) {
    m_text = QString("%1, %2 | %3 x %4").arg(rect.x()).arg(rect.y()).arg(rect.width()).arg(rect.height());
    update();
}
void SelectionInfoBar::paintEvent(QPaintEvent*) {
    QPainter p(this); p.setRenderHint(QPainter::Antialiasing);
    p.setBrush(QColor(0, 0, 0, 200)); p.setPen(Qt::NoPen);
    p.drawRoundedRect(rect(), 4, 4);
    p.setPen(Qt::white); p.setFont(QFont("Arial", 9));
    p.drawText(rect(), Qt::AlignCenter, m_text);
}

ScreenshotToolbar::ScreenshotToolbar(ScreenshotTool* tool) 
    : QWidget(nullptr, Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint) 
{
    m_tool = tool;
    setObjectName("ScreenshotToolbar");
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_AlwaysShowToolTips);
    setMouseTracking(true);

    setStyleSheet(R"(
        #MainContainer { 
            background-color: #2D2D2D; 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            border-radius: 12px; 
        }
        #ToolRow, #OptionWidget {
            background: transparent;
        }
        QPushButton { 
            background: transparent; 
            border: none; 
            border-radius: 4px; 
            padding: 4px; 
        }
        #MainContainer QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }
        #MainContainer QPushButton:checked { background-color: #007ACC; }
        #OptionWidget { 
            background: transparent; 
        }
        QPushButton[colorBtn="true"] { padding: 0px; border-radius: 2px; }
        QPushButton[sizeBtn="true"] { background-color: #777; border-radius: 50%; }
        QPushButton[sizeBtn="true"]:checked { background-color: #007ACC; }
        QPushButton[sizeBtn="true"]:checked { background-color: #007ACC; }
    )");
    setAttribute(Qt::WA_StyledBackground);

    auto* outerLayout = new QVBoxLayout(this);
    outerLayout->setContentsMargins(6, 6, 6, 6);
    outerLayout->setSpacing(0);
    outerLayout->setSizeConstraint(QLayout::SetFixedSize);

    QFrame* mainContainer = new QFrame;
    mainContainer->setObjectName("MainContainer");
    mainContainer->setAttribute(Qt::WA_StyledBackground);
    outerLayout->addWidget(mainContainer);

    auto* mainLayout = new QVBoxLayout(mainContainer);
    mainLayout->setContentsMargins(4, 2, 4, 2); mainLayout->setSpacing(0);
    // [CRITICAL] 设置尺寸约束为 SetFixedSize，确保工具栏在子部件隐藏时能自动收缩高度，防止出现多余背景 / Use SetFixedSize to ensure toolbar shrinks when options are hidden
    mainLayout->setSizeConstraint(QLayout::SetFixedSize);
    
    QWidget* toolRow = new QWidget;
    toolRow->setObjectName("ToolRow");
    auto* layout = new QHBoxLayout(toolRow);
    layout->setContentsMargins(6, 4, 6, 4); layout->setSpacing(2);

    addToolButton(layout, ScreenshotToolType::Rect, "screenshot_rect", "矩形 (R)");
    addToolButton(layout, ScreenshotToolType::Ellipse, "screenshot_ellipse", "椭圆 (E)");
    addToolButton(layout, ScreenshotToolType::Arrow, "screenshot_arrow", "箭头 (A)");
    addToolButton(layout, ScreenshotToolType::Line, "screenshot_line", "直线 (L)");
    
    addToolButton(layout, ScreenshotToolType::Pen, "screenshot_pen", "画笔 (P)");
    addToolButton(layout, ScreenshotToolType::Marker, "screenshot_marker", "记号笔 (M)");
    addToolButton(layout, ScreenshotToolType::Text, "screenshot_text", "文字 (T)");
    addToolButton(layout, ScreenshotToolType::Mosaic, "screenshot_mosaic", "画笔马赛克 (Z)");
    addToolButton(layout, ScreenshotToolType::MosaicRect, "screenshot_rect", "矩形马赛克 (M)");
    addToolButton(layout, ScreenshotToolType::Eraser, "screenshot_eraser", "橡皮擦 (X)");
    addToolButton(layout, ScreenshotToolType::Picker, "screen_picker", "取色器 (C)");

    layout->addSpacing(8);

    QFrame* divider = new QFrame();
    divider->setFrameShape(QFrame::VLine);
    divider->setFrameShadow(QFrame::Plain);
    divider->setStyleSheet("background-color: #555;");
    divider->setFixedWidth(1);
    divider->setFixedHeight(20);
    layout->addWidget(divider);

    layout->addSpacing(8);
    
    addActionButton(layout, "undo", "撤销 (Ctrl+Z)", [tool]{ tool->undo(); });
    addActionButton(layout, "redo", "重做 (Ctrl+Shift+Z)", [tool]{ tool->redo(); });
    addActionButton(layout, "screenshot_pin", "置顶截图 (F)", [tool]{ tool->pin(); });
    addActionButton(layout, "screenshot_ocr", "截图取文 (O)", [tool]{ tool->executeOCR(); });
    addActionButton(layout, "screenshot_save", "保存", [tool]{ tool->save(); });
    addActionButton(layout, "screenshot_copy", "复制 (Ctrl+C)", [tool]{ tool->copyToClipboard(); });
    addActionButton(layout, "screenshot_close", "取消 (Esc)", [tool]{ tool->cancel(); }); 
    addActionButton(layout, "screenshot_confirm", "完成 (Enter)", [tool]{ tool->confirm(); });

    mainLayout->addWidget(toolRow);

    // [CRITICAL] 水平分割线，用于分隔工具行和选项行 / Horizontal divider between tool row and option row
    m_horizontalDivider = new QFrame();
    m_horizontalDivider->setFrameShape(QFrame::HLine);
    m_horizontalDivider->setFrameShadow(QFrame::Plain);
    m_horizontalDivider->setStyleSheet("background-color: #555;");
    m_horizontalDivider->setFixedHeight(1);
    m_horizontalDivider->setVisible(false);
    mainLayout->addWidget(m_horizontalDivider);

    createOptionWidget();
    mainLayout->addWidget(m_optionWidget);
}

void ScreenshotToolbar::addToolButton(QBoxLayout* layout, ScreenshotToolType type, const QString& iconName, const QString& tip) {
    auto* btn = new QPushButton();
    btn->setAttribute(Qt::WA_StyledBackground);
    btn->setIcon(IconHelper::getIcon(iconName)); btn->setIconSize(QSize(20, 20));
    btn->setToolTip(tip); btn->setCheckable(true); btn->setFixedSize(32, 32);
    layout->addWidget(btn); m_buttons[type] = btn;
    connect(btn, &QPushButton::clicked, [this, type]{ selectTool(type); });
}

void ScreenshotToolbar::addActionButton(QBoxLayout* layout, const QString& iconName, const QString& tip, std::function<void()> func) {
    auto* btn = new QPushButton();
    btn->setAttribute(Qt::WA_StyledBackground);
    btn->setIcon(IconHelper::getIcon(iconName)); btn->setIconSize(QSize(20, 20));
    btn->setToolTip(tip); btn->setFixedSize(32, 32);
    layout->addWidget(btn); connect(btn, &QPushButton::clicked, func);
}

void ScreenshotToolbar::createOptionWidget() {
    m_optionWidget = new QWidget; m_optionWidget->setObjectName("OptionWidget");
    m_optionWidget->setAttribute(Qt::WA_TranslucentBackground);
    auto* layout = new QHBoxLayout(m_optionWidget); layout->setContentsMargins(8, 4, 8, 4); layout->setSpacing(4);

    // 1. 箭头样式按钮 (迁移至最左侧)
    m_arrowStyleBtn = new QPushButton(); m_arrowStyleBtn->setFixedSize(56, 24);
    updateArrowButtonIcon(m_tool->m_currentArrowStyle); m_arrowStyleBtn->setToolTip("箭头样式 (W)");
    connect(m_arrowStyleBtn, &QPushButton::clicked, this, &ScreenshotToolbar::showArrowMenu);
    layout->addWidget(m_arrowStyleBtn);

    // 2. 形状填充选项 (Rect/Ellipse)
    m_outlineBtn = new QPushButton();
    m_outlineBtn->setCheckable(true);
    m_outlineBtn->setFixedSize(24, 24);
    m_outlineBtn->setIcon(IconHelper::getIcon("screenshot_rect", "#ffffff"));
    m_outlineBtn->setToolTip("虚心 (Hollow)");
    m_outlineBtn->setStyleSheet("QPushButton { border: 1px solid #555; border-radius: 4px; } QPushButton:checked { background-color: #007ACC; border-color: #007ACC; }");
    
    m_solidBtn = new QPushButton();
    m_solidBtn->setCheckable(true);
    m_solidBtn->setFixedSize(24, 24);
    m_solidBtn->setIcon(IconHelper::getIcon("screenshot_fill", "#ffffff"));
    m_solidBtn->setToolTip("实心 (Solid)");
    m_solidBtn->setStyleSheet("QPushButton { border: 1px solid #555; border-radius: 4px; } QPushButton:checked { background-color: #007ACC; border-color: #007ACC; }");

    auto* fillGroup = new QButtonGroup(this);
    fillGroup->addButton(m_outlineBtn);
    fillGroup->addButton(m_solidBtn);
    layout->addWidget(m_outlineBtn);
    layout->addWidget(m_solidBtn);
    if (m_tool->m_fillEnabled) m_solidBtn->setChecked(true); else m_outlineBtn->setChecked(true);
    connect(m_outlineBtn, &QPushButton::clicked, [this]{ m_tool->setFillEnabled(false); });
    connect(m_solidBtn, &QPushButton::clicked, [this]{ m_tool->setFillEnabled(true); });

    // 3. 文字选项 (Text) - 采用独立胶囊布局 (Independent capsule layout)
    m_textOptionWidget = new QWidget;
    m_textOptionWidget->setAttribute(Qt::WA_TranslucentBackground);
    m_textOptionWidget->setStyleSheet("background: transparent; border: none;");
    auto* textOptionLayout = new QHBoxLayout(m_textOptionWidget);
    textOptionLayout->setContentsMargins(0, 0, 0, 0); textOptionLayout->setSpacing(4);

    auto createCapsule = [](QWidget* content, int width = -1) {
        QWidget* capsule = new QWidget;
        capsule->setFixedHeight(28);
        if (width > 0) capsule->setFixedWidth(width);
        capsule->setAttribute(Qt::WA_StyledBackground);
        capsule->setStyleSheet("background-color: #3D3D3D; border-radius: 6px; border: none;");
        auto* l = new QHBoxLayout(capsule);
        l->setContentsMargins(4, 0, 4, 0);
        l->setSpacing(0);
        l->addWidget(content);
        return capsule;
    };

    m_boldBtn = new QPushButton(); m_boldBtn->setCheckable(true); m_boldBtn->setFixedSize(24, 24);
    m_boldBtn->setIcon(IconHelper::getIcon("bold", "#ffffff")); m_boldBtn->setToolTip("加粗 (Bold)");
    m_boldBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } QPushButton:hover { background-color: #555; } QPushButton:checked { background-color: #007ACC; }");
    m_boldBtn->setChecked(m_tool->m_currentBold);
    connect(m_boldBtn, &QPushButton::toggled, [this](bool checked){ m_tool->setBold(checked); });
    textOptionLayout->addWidget(createCapsule(m_boldBtn, 32));

    m_italicBtn = new QPushButton(); m_italicBtn->setCheckable(true); m_italicBtn->setFixedSize(24, 24);
    m_italicBtn->setIcon(IconHelper::getIcon("italic", "#ffffff")); m_italicBtn->setToolTip("倾斜 (Italic)");
    m_italicBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } QPushButton:hover { background-color: #555; } QPushButton:checked { background-color: #007ACC; }");
    m_italicBtn->setChecked(m_tool->m_currentItalic);
    connect(m_italicBtn, &QPushButton::toggled, [this](bool checked){ m_tool->setItalic(checked); });
    textOptionLayout->addWidget(createCapsule(m_italicBtn, 32));

    auto* fontCombo = new QComboBox(); fontCombo->addItems({"微软雅黑", "宋体", "黑体", "楷体", "Arial", "Consolas"});
    fontCombo->setCurrentText(m_tool->m_currentFontFamily); fontCombo->setFixedSize(100, 28);
    fontCombo->setAttribute(Qt::WA_StyledBackground);
    fontCombo->setAttribute(Qt::WA_TranslucentBackground);
    fontCombo->view()->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    fontCombo->setStyleSheet(R"(
        QComboBox { background-color: #3D3D3D; color: white; border: 1px solid transparent; border-radius: 6px; padding-left: 8px; }
        QComboBox::drop-down { width: 0px; border: none; }
        QComboBox QAbstractItemView { 
            background-color: #3D3D3D; 
            color: white;
            selection-background-color: transparent;
            border: 1px solid #555; 
            border-radius: 6px; 
            outline: none;
            padding: 2px;
        }
        QComboBox QAbstractItemView::item { 
            height: 18px; 
            border-radius: 3px; 
            padding: 0px 4px; 
            margin: 1px 2px;
            color: white;
            border: none;
        }
        QComboBox QAbstractItemView::item:selected { 
            background-color: #007ACC; 
            color: white; 
        }
        QScrollBar:vertical { width: 0px; background: transparent; }
    )");
    connect(fontCombo, &QComboBox::currentTextChanged, [this](const QString& font){ m_tool->setFontFamily(font); });
    fontCombo->view()->window()->setAttribute(Qt::WA_TranslucentBackground);
    fontCombo->view()->window()->setWindowFlags(Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint);
    fontCombo->view()->setFixedWidth(100);
    textOptionLayout->addWidget(fontCombo);

    auto* sizeCombo = new QComboBox();
    for(int s : {10, 12, 14, 16, 18, 20, 24, 28, 32, 36, 48}) sizeCombo->addItem(QString::number(s), s);
    sizeCombo->setCurrentIndex(sizeCombo->findData(m_tool->m_currentFontSize)); sizeCombo->setFixedSize(50, 28);
    sizeCombo->setAttribute(Qt::WA_StyledBackground);
    sizeCombo->setAttribute(Qt::WA_TranslucentBackground);
    sizeCombo->view()->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    sizeCombo->setStyleSheet(R"(
        QComboBox { background-color: #3D3D3D; color: white; border: 1px solid transparent; border-radius: 6px; padding-left: 8px; }
        QComboBox::drop-down { width: 0px; border: none; }
        QComboBox QAbstractItemView { 
            background-color: #3D3D3D; 
            color: white;
            selection-background-color: transparent;
            border: 1px solid #555; 
            border-radius: 6px; 
            outline: none;
            padding: 2px;
        }
        QComboBox QAbstractItemView::item { 
            height: 18px; 
            border-radius: 3px; 
            padding: 0px 4px; 
            margin: 1px 2px;
            color: white;
            border: none;
        }
        QComboBox QAbstractItemView::item:selected { 
            background-color: #007ACC; 
            color: white; 
        }
        QScrollBar:vertical { width: 0px; background: transparent; }
    )");
    connect(sizeCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), [this, sizeCombo](int index){ m_tool->setFontSize(sizeCombo->itemData(index).toInt()); });
    sizeCombo->view()->window()->setAttribute(Qt::WA_TranslucentBackground);
    sizeCombo->view()->window()->setWindowFlags(Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint);
    sizeCombo->view()->setFixedWidth(50);
    textOptionLayout->addWidget(sizeCombo);
    
    layout->addWidget(m_textOptionWidget);

    // [CRITICAL] 垂直分割线，用于分隔工具选项和粗细选项 / Vertical divider between tool options and size options
    m_textDivider = new QFrame();
    m_textDivider->setFrameShape(QFrame::VLine);
    m_textDivider->setFrameShadow(QFrame::Plain);
    m_textDivider->setStyleSheet("background-color: #555;");
    m_textDivider->setFixedWidth(1);
    m_textDivider->setFixedHeight(16);
    layout->addSpacing(4);
    layout->addWidget(m_textDivider);
    layout->addSpacing(4);

    // 4. 描边粗细 (Size Buttons)
    int sizes[] = {2, 4, 8};
    m_sizeGroup = new QButtonGroup(this);
    for(int s : sizes) {
        auto* btn = new QPushButton; btn->setProperty("sizeBtn", true); btn->setFixedSize(14 + s, 14 + s);
        btn->setCheckable(true); if(s == m_tool->m_currentStrokeWidth) btn->setChecked(true);
        layout->addWidget(btn); m_sizeGroup->addButton(btn);
        connect(btn, &QPushButton::clicked, [this, s]{ m_tool->setDrawWidth(s); });
    }

    // 分隔符
    QFrame* colorDivider = new QFrame();
    colorDivider->setFrameShape(QFrame::VLine);
    colorDivider->setFrameShadow(QFrame::Plain);
    colorDivider->setStyleSheet("background-color: #555;");
    colorDivider->setFixedWidth(1);
    colorDivider->setFixedHeight(16);
    layout->addSpacing(4);
    layout->addWidget(colorDivider);
    layout->addSpacing(4);

    // 5. 标准颜色选择区域 (9色)
    m_colorGroup = new QButtonGroup(this);
    m_colorGroup->setExclusive(false); // 改为非独占，实现全覆盖高亮
    for(const auto& c : getStandardColorList()) {
        auto* btn = new QPushButton; btn->setProperty("colorBtn", true); btn->setProperty("colorValue", c); 
        btn->setFixedSize(20, 20); btn->setCheckable(true);
        // [CRITICAL] 采用“等色边框”方案：非选中时边框颜色与背景一致，选中时变为白色。
        // 此变量极其重要：padding: 0px 和 border-color: %1 共同解决了 QSS 渲染时父容器背景色露底（黑色背景）的问题。
        // [CRITICAL] This variable is extremely important: padding: 0px and border-color: %1 
        // solve the issue of parent container background bleeding through (black background issue).
        btn->setStyleSheet(QString("QPushButton { background-color: %1; border: 2px solid %1; border-radius: 2px; padding: 0px; } "
                                   "QPushButton:hover { background-color: %1; border-color: %1; } "
                                   "QPushButton:checked { background-color: %1; border-color: white; }").arg(c.name()));
        layout->addWidget(btn); m_colorGroup->addButton(btn);
        connect(btn, &QPushButton::clicked, [this, c]{ m_tool->setDrawColor(c); });
    }

    // 分隔符 (右侧)
    QFrame* colorDividerRight = new QFrame();
    colorDividerRight->setFrameShape(QFrame::VLine);
    colorDividerRight->setFrameShadow(QFrame::Plain);
    colorDividerRight->setStyleSheet("background-color: #555;");
    colorDividerRight->setFixedWidth(1);
    colorDividerRight->setFixedHeight(16);
    layout->addSpacing(4);
    layout->addWidget(colorDividerRight);
    layout->addSpacing(4);

    // 6. 最近颜色展示区 (填满红色方框区域)
    auto* recentContainer = new QWidget;
    recentContainer->setStyleSheet("background: transparent; border: none;");
    m_recentLayout = new QHBoxLayout(recentContainer);
    m_recentLayout->setContentsMargins(0, 0, 0, 0); m_recentLayout->setSpacing(4);
    layout->addWidget(recentContainer);

    QSettings settings("RapidNotes", "Screenshot");
    for (const QString& name : settings.value("recentColors").toStringList()) { addRecentColor(QColor(name), false); }

    // --- 弹性间距 ---
    layout->addStretch();

    // 7. 右侧控制按钮统一管理
    // 色轮按钮 (图标换成调色盘)
    m_wheelBtn = new QPushButton(); m_wheelBtn->setFixedSize(32, 32);
    // [CRITICAL] 调色盘图标内部已设为彩色。此处传入当前颜色仅为染其外轮廓，以指示当前选色。
    // [CRITICAL] The palette icon now has fixed internal colors. Tinting here only affects the outline to indicate selection.
    m_wheelBtn->setIcon(IconHelper::getIcon("palette", m_tool->m_currentColor.name()));
    m_wheelBtn->setIconSize(QSize(20, 20));
    m_wheelBtn->setToolTip("自定义颜色 (C)");
    connect(m_wheelBtn, &QPushButton::clicked, [this]{
        QColorDialog dialog(m_tool->m_currentColor, m_tool);
        dialog.setWindowTitle("选择标注颜色"); dialog.setOptions(QColorDialog::ShowAlphaChannel | QColorDialog::DontUseNativeDialog);
        dialog.setWindowFlags(dialog.windowFlags() | Qt::WindowStaysOnTopHint);
        if (dialog.exec() == QDialog::Accepted) { QColor c = dialog.selectedColor(); m_tool->setDrawColor(c); addRecentColor(c); }
        m_tool->activateWindow(); m_tool->updateToolbarPosition();
    });
    layout->addWidget(m_wheelBtn);

    // 调色盘 (图标换成金色五角星)
    m_paletteBtn = new QPushButton(); m_paletteBtn->setFixedSize(32, 32);
    m_paletteBtn->setIcon(IconHelper::getIcon("star_filled", "#FFD700"));
    m_paletteBtn->setIconSize(QSize(20, 20));
    m_paletteBtn->setToolTip("颜色收藏夹 (G)");
    m_paletteBtn->setCursor(Qt::PointingHandCursor);
    layout->addWidget(m_paletteBtn);

    QList<QColor> fullColors = {
        QColor(255, 0, 0), QColor(255, 69, 0), QColor(255, 165, 0), QColor(255, 215, 0),
        QColor(255, 255, 0), QColor(154, 205, 50), QColor(0, 255, 0), QColor(34, 139, 34),
        QColor(0, 255, 255), QColor(0, 191, 255), QColor(0, 120, 255), QColor(0, 0, 255),
        QColor(138, 43, 226), QColor(128, 0, 128), QColor(255, 0, 255), QColor(255, 192, 203),
        QColor(255, 255, 255), QColor(192, 192, 192), QColor(128, 128, 128), QColor(0, 0, 0)
    };
    connect(m_paletteBtn, &QPushButton::clicked, [this, fullColors]{
        QMenu* menu = new QMenu(this);
        IconHelper::setupMenu(menu);
        menu->setStyleSheet("QMenu { background-color: #2D2D2D; border: 1px solid #555; padding: 4px; }");
        QWidget* gridContainer = new QWidget; QGridLayout* grid = new QGridLayout(gridContainer);
        grid->setContentsMargins(4, 4, 4, 4); grid->setSpacing(4);
        int row = 0, col = 0;
        for (const auto& c : fullColors) {
            auto* btn = new QPushButton; btn->setFixedSize(22, 22);
            btn->setStyleSheet(QString("background-color: %1; border: 1px solid #555; border-radius: 2px;").arg(c.name()));
            grid->addWidget(btn, row, col);
            connect(btn, &QPushButton::clicked, [this, c, menu]{ m_tool->setDrawColor(c); menu->close(); });
            if (++col >= 5) { col = 0; row++; }
        }
        QWidgetAction* action = new QWidgetAction(menu); action->setDefaultWidget(gridContainer); menu->addAction(action);
        menu->exec(QCursor::pos()); delete menu;
    });

    // 移除按钮
    m_removeColorBtn = new QPushButton("×");
    m_removeColorBtn->setFixedSize(18, 24); m_removeColorBtn->setToolTip("移除选中的最近颜色");
    m_removeColorBtn->setCursor(Qt::PointingHandCursor);
    m_removeColorBtn->setStyleSheet(R"(
        QPushButton { color: #999; background: transparent; border: none; font-size: 16px; font-weight: bold; }
        QPushButton:hover { color: #ff5555; }
    )");
    connect(m_removeColorBtn, &QPushButton::clicked, [this]{
        QColor current = m_tool->m_currentColor;
        for (int i = 0; i < m_recentLayout->count(); ++i) {
            auto* item = m_recentLayout->itemAt(i); auto* btn = qobject_cast<QPushButton*>(item->widget());
            if (btn && btn->property("colorValue").value<QColor>().rgba() == current.rgba()) {
                m_recentLayout->removeItem(item); btn->deleteLater(); delete item;
                QSettings settings("RapidNotes", "Screenshot"); QStringList recent = settings.value("recentColors").toStringList();
                recent.removeAll(current.name()); settings.setValue("recentColors", recent);
                break;
            }
        }
    });
    layout->addWidget(m_removeColorBtn);

    m_optionWidget->setVisible(false);
    syncColorSelection(m_tool->m_currentColor);
}

void ScreenshotToolbar::showArrowMenu() {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    // 使用 QWidgetAction 替代 QMenu::setIconSize 以获得更好的版本兼容性和视觉控制
    menu.setStyleSheet(R"(
        QMenu { background-color: #2D2D2D; border: 1px solid #555; padding: 2px; }
        QMenu::item { padding: 0px; }
    )");

    auto addAct = [&](ArrowStyle s) {
        QWidgetAction* action = new QWidgetAction(&menu);
        QPushButton* btn = new QPushButton();
        btn->setFixedSize(120, 36);
        btn->setIcon(IconFactory::createArrowStyleIcon(s));
        btn->setIconSize(QSize(100, 24));
        btn->setCursor(Qt::PointingHandCursor);
        btn->setStyleSheet(R"(
            QPushButton { background-color: transparent; border: none; border-radius: 4px; }
            QPushButton:hover { background-color: #007ACC; }
        )");
        connect(btn, &QPushButton::clicked, [this, s, &menu]{ 
            m_tool->setArrowStyle(s); 
            updateArrowButtonIcon(s); 
            menu.close(); 
        });
        action->setDefaultWidget(btn);
        menu.addAction(action);
    };

    addAct(ArrowStyle::SolidSingle);
    addAct(ArrowStyle::SolidDouble);
    addAct(ArrowStyle::OutlineSingle);
    addAct(ArrowStyle::OutlineDouble);
    addAct(ArrowStyle::Dimension);
    addAct(ArrowStyle::Thin);
    addAct(ArrowStyle::SolidDot);
    addAct(ArrowStyle::OutlineDot);

    menu.exec(mapToGlobal(m_arrowStyleBtn->geometry().bottomLeft()));
}

void ScreenshotToolbar::addRecentColor(const QColor& c, bool save) {
    if (!m_recentLayout || !m_wheelBtn) return;
    
    // 1. 优先同步高亮状态 (Ensure highlight is synced even if not added to recent)
    syncColorSelection(c);

    // 2. 如果是 9 种标准色之一，则不重复添加到“最近颜色”
    for (const auto& sc : getStandardColorList()) {
        if (sc.rgba() == c.rgba()) return;
    }

    // 3. 检查是否已经在最近颜色列表中
    for (int i = 0; i < m_recentLayout->count(); ++i) {
        auto* b = qobject_cast<QPushButton*>(m_recentLayout->itemAt(i)->widget());
        if (b && b->property("colorValue").value<QColor>().rgba() == c.rgba()) return;
    }

    // 4. 限制最近颜色数量 (增加到 15 以填满区域)
    if (m_recentLayout->count() >= 15) {
        auto* item = m_recentLayout->takeAt(0);
        if (item->widget()) {
            if (m_colorGroup) m_colorGroup->removeButton(qobject_cast<QPushButton*>(item->widget()));
            item->widget()->deleteLater();
        }
        delete item;
    }

    // 5. 创建并添加新的最近颜色按钮
    auto* btn = new QPushButton; btn->setFixedSize(20, 20);
    btn->setProperty("colorBtn", true);
    btn->setProperty("colorValue", c);
    btn->setCheckable(true);
    // [CRITICAL] 采用与标准色一致的“等色边框”方案，这是解决颜色按钮黑色背景问题的核心逻辑。
    // [CRITICAL] This logic is the core fix for the color button's black background issue.
    btn->setStyleSheet(QString("QPushButton { background-color: %1; border: 2px solid %1; border-radius: 2px; padding: 0px; } "
                               "QPushButton:hover { background-color: %1; border-color: %1; } "
                               "QPushButton:checked { background-color: %1; border-color: white; }").arg(c.name()));
    btn->setToolTip(c.name());
    m_recentLayout->addWidget(btn);
    if (m_colorGroup) m_colorGroup->addButton(btn);

    connect(btn, &QPushButton::clicked, [this, c]{
        m_tool->setDrawColor(c);
    });

    if (save) {
        QSettings settings("RapidNotes", "Screenshot");
        QStringList recent = settings.value("recentColors").toStringList();
        if (!recent.contains(c.name())) {
            recent.append(c.name());
            if (recent.size() > 15) recent.removeFirst();
            settings.setValue("recentColors", recent);
        }
    }
    
    // 再次调用以确保新添加的按钮也被正确选中
    syncColorSelection(c);
}

void ScreenshotToolbar::syncColorSelection(const QColor& color) {
    if (!m_colorGroup) return;
    
    // 暂时阻塞信号，避免循环触发
    m_colorGroup->blockSignals(true);
    // m_colorGroup 包含标准色和最近色按钮，实现全覆盖同步 (Cover both standard and recent colors)
    for (auto* btn : m_colorGroup->buttons()) {
        QColor btnColor = btn->property("colorValue").value<QColor>();
        // 使用 rgba 进行精确对比，实现全覆盖高亮 (All coverage highlight)
        if (btnColor.rgba() == color.rgba()) {
            btn->setChecked(true);
        } else {
            btn->setChecked(false);
        }
    }
    
    // [CRITICAL] 同步更新调色盘图标的外轮廓颜色，而内部色点保持彩色。
    if (m_wheelBtn) {
        m_wheelBtn->setIcon(IconHelper::getIcon("palette", color.name()));
    }
    
    m_colorGroup->blockSignals(false);
}

void ScreenshotToolbar::updateArrowButtonIcon(ArrowStyle style) {
    m_arrowStyleBtn->setIcon(IconFactory::createArrowStyleIcon(style)); 
    m_arrowStyleBtn->setIconSize(QSize(48, 16));
}

void ScreenshotToolbar::selectTool(ScreenshotToolType type) {
    for(auto* b : std::as_const(m_buttons)) b->setChecked(false);
    if(m_buttons.contains(type)) m_buttons[type]->setChecked(true);
    
    // 恢复原来的两行逻辑：显示就展示选项卡
    bool hasOptions = (type != ScreenshotToolType::None);
    m_optionWidget->setVisible(hasOptions);
    if (m_horizontalDivider) m_horizontalDivider->setVisible(hasOptions);

    bool isArrow = (type == ScreenshotToolType::Arrow);
    bool isRectOrEllipse = (type == ScreenshotToolType::Rect || type == ScreenshotToolType::Ellipse);
    bool isText = (type == ScreenshotToolType::Text);

    m_arrowStyleBtn->setVisible(isArrow);
    m_outlineBtn->setVisible(isRectOrEllipse);
    m_solidBtn->setVisible(isRectOrEllipse);
    m_textOptionWidget->setVisible(isText);

    if (m_textDivider) {
        m_textDivider->setVisible(isArrow || isRectOrEllipse || isText);
    }

    m_tool->setTool(type); 
    
    // [CRITICAL] 必须调用此系列方法以强制触发窗口尺寸重新计算，消除高度异常 / Force UI update to recalculate size
    m_optionWidget->updateGeometry();
    if (m_horizontalDivider) m_horizontalDivider->updateGeometry();
    if (layout()) layout()->activate();
    adjustSize(); 
    m_tool->updateToolbarPosition();
}

void ScreenshotToolbar::mousePressEvent(QMouseEvent *event) {
    if (event->button() == Qt::LeftButton) {
        m_isDragging = true; m_dragPosition = event->globalPosition().toPoint() - frameGeometry().topLeft();
    }
}
void ScreenshotToolbar::mouseMoveEvent(QMouseEvent *event) {
    if (m_isDragging) move(event->globalPosition().toPoint() - m_dragPosition);
}
void ScreenshotToolbar::mouseReleaseEvent(QMouseEvent *) { m_isDragging = false; }
void ScreenshotToolbar::paintEvent(QPaintEvent *) {
    // 作为透明容器，不再执行默认绘制逻辑，完全由 MainContainer 处理背景
}

void ScreenshotToolbar::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Escape) {
        m_tool->cancel();
    } else {
        QWidget::keyPressEvent(event);
    }
}

ScreenshotTool::~ScreenshotTool() {
    if (m_toolbar) m_toolbar->deleteLater();
    qDeleteAll(m_annotations);
    qDeleteAll(m_redoStack);
    delete m_activeShape;
}

ScreenshotTool::ScreenshotTool(QWidget* parent) 
    : QWidget(parent, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint) 
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_QuitOnClose, false);
    setAttribute(Qt::WA_DeleteOnClose);
    setWindowState(Qt::WindowFullScreen);
    setMouseTracking(true);
    m_screenPixmap = QGuiApplication::primaryScreen()->grabWindow(0);
    m_screenImage = m_screenPixmap.toImage();
    QImage small = m_screenImage.scaled(m_screenImage.width()/15, m_screenImage.height()/15, Qt::IgnoreAspectRatio, Qt::FastTransformation);
    m_mosaicPixmap = QPixmap::fromImage(small.scaled(m_screenImage.size(), Qt::IgnoreAspectRatio, Qt::FastTransformation));

    QSettings settings("RapidNotes", "Screenshot");
    m_currentColor = settings.value("color", QColor(255, 50, 50)).value<QColor>();
    m_currentStrokeWidth = settings.value("strokeWidth", 3).toInt();
    m_currentArrowStyle = static_cast<ArrowStyle>(settings.value("arrowStyle", 0).toInt());
    m_currentTool = static_cast<ScreenshotToolType>(settings.value("tool", 0).toInt());
    m_currentFontFamily = settings.value("fontFamily", "Microsoft YaHei").toString();
    m_currentFontSize = settings.value("fontSize", 14).toInt();
    m_currentBold = settings.value("bold", true).toBool();
    m_currentItalic = settings.value("italic", false).toBool();
    m_isConfirmed = false;

    m_toolbar = new ScreenshotToolbar(this); m_toolbar->hide();
    m_infoBar = new SelectionInfoBar(this);
    m_lastMouseMovePos = mapFromGlobal(QCursor::pos());
    m_textInput = new QLineEdit(this); m_textInput->hide(); m_textInput->setFrame(false);
    m_textInput->installEventFilter(this);
    connect(m_textInput, &QLineEdit::editingFinished, this, &ScreenshotTool::commitTextInput);
}

void ScreenshotTool::showEvent(QShowEvent* event) { QWidget::showEvent(event); detectWindows(); }
void ScreenshotTool::cancel() { emit screenshotCanceled(); if (m_toolbar) m_toolbar->close(); close(); }

int BaseShape::getHandleAt(const QPoint& pos) const {
    auto handles = getHandles();
    for (int i = 0; i < handles.size(); ++i) {
        if (handles[i].contains(pos)) return i;
    }
    return -1;
}

void BaseShape::moveBy(const QPoint& delta) {
    for (auto& p : data.points) p += delta;
}

static bool isNearLine(const QPointF& p, const QPointF& s, const QPointF& e, int threshold) {
    double l2 = QPointF::dotProduct(e - s, e - s);
    if (l2 == 0.0) return (p - s).manhattanLength() < threshold;
    double t = std::max(0.0, std::min(1.0, QPointF::dotProduct(p - s, e - s) / l2));
    QPointF projection = s + t * (e - s);
    return (p - projection).manhattanLength() < threshold;
}

void RectShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    p.setPen(QPen(data.color, data.strokeWidth, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
    p.setBrush(data.isFilled ? QBrush(data.color) : Qt::NoBrush);
    p.drawRect(QRectF(data.points[0], data.points[1]).normalized());
}

bool RectShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    if (data.isFilled && r.contains(pos)) return true;
    int t = std::max(5, data.strokeWidth + 2);
    return std::abs(pos.x() - r.left()) < t || std::abs(pos.x() - r.right()) < t ||
           std::abs(pos.y() - r.top()) < t || std::abs(pos.y() - r.bottom()) < t;
}

QList<QRect> RectShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    h << QRect(r.left()-s/2, r.top()-s/2, s, s) << QRect(r.right()-s/2, r.top()-s/2, s, s)
      << QRect(r.right()-s/2, r.bottom()-s/2, s, s) << QRect(r.left()-s/2, r.bottom()-s/2, s, s);
    return h;
}

void RectShape::updatePoint(int index, const QPoint& pos) {
    if (data.points.size() < 2) return;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    if (index == 0) { r.setTopLeft(pos); }
    else if (index == 1) { r.setTopRight(pos); }
    else if (index == 2) { r.setBottomRight(pos); }
    else if (index == 3) { r.setBottomLeft(pos); }
    data.points[0] = r.topLeft(); data.points[1] = r.bottomRight();
}

void EllipseShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    p.setPen(QPen(data.color, data.strokeWidth, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
    p.setBrush(data.isFilled ? QBrush(data.color) : Qt::NoBrush);
    p.drawEllipse(QRectF(data.points[0], data.points[1]).normalized());
}

bool EllipseShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    QPainterPath path; path.addEllipse(r);
    if (data.isFilled && path.contains(pos)) return true;
    QPainterPathStroker stroker; stroker.setWidth(std::max(10, data.strokeWidth + 4));
    return stroker.createStroke(path).contains(pos);
}

QList<QRect> EllipseShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    h << QRect(r.left()-s/2, r.top()-s/2, s, s) << QRect(r.right()-s/2, r.top()-s/2, s, s)
      << QRect(r.right()-s/2, r.bottom()-s/2, s, s) << QRect(r.left()-s/2, r.bottom()-s/2, s, s);
    return h;
}

void EllipseShape::updatePoint(int index, const QPoint& pos) {
    if (data.points.size() < 2) return;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    if (index == 0) { r.setTopLeft(pos); }
    else if (index == 1) { r.setTopRight(pos); }
    else if (index == 2) { r.setBottomRight(pos); }
    else if (index == 3) { r.setBottomLeft(pos); }
    data.points[0] = r.topLeft(); data.points[1] = r.bottomRight();
}

void LineShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    p.setPen(QPen(data.color, data.strokeWidth, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
    p.drawLine(data.points[0], data.points[1]);
}

bool LineShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    return isNearLine(pos, data.points[0], data.points[1], std::max(8, data.strokeWidth + 3));
}

QList<QRect> LineShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    h << QRect(data.points[0].toPoint().x()-s/2, data.points[0].toPoint().y()-s/2, s, s)
      << QRect(data.points[1].toPoint().x()-s/2, data.points[1].toPoint().y()-s/2, s, s);
    return h;
}

void ArrowShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    QPointF start = data.points[0], end = data.points[1];
    QPointF dir = end - start;
    double len = std::sqrt(QPointF::dotProduct(dir, dir));
    if (len < 2) return;
    QPointF unit = dir / len; QPointF perp(-unit.y(), unit.x());
    double angle = std::atan2(dir.y(), dir.x());
    
    // 增加基础尺寸，使其更显眼
    double baseSize = 24 + data.strokeWidth * 2.0;
    double headLen = baseSize;
    bool isOutline = (data.arrowStyle == ArrowStyle::OutlineSingle || data.arrowStyle == ArrowStyle::OutlineDouble || data.arrowStyle == ArrowStyle::OutlineDot);
    
    if (data.arrowStyle == ArrowStyle::SolidSingle || data.arrowStyle == ArrowStyle::OutlineSingle) {
        if (isOutline) {
            QPointF neck = end - unit * (headLen * 0.8); double w = data.strokeWidth + 2;
            QPolygonF poly; poly << end << neck + perp * (headLen*0.5) << neck + perp * w << start + perp * w << start - perp * w << neck - perp * w << neck - perp * (headLen*0.5);
            p.setBrush(Qt::transparent); p.setPen(QPen(data.color, 2.5)); p.drawPolygon(poly);
        } else {
            double barbWidth = headLen * 0.55; double waistLen = headLen * 0.75; double waistWidth = data.strokeWidth + 1;
            p.setPen(Qt::NoPen); p.setBrush(data.color);
            p.drawPolygon(QPolygonF() << end << end - unit * headLen + perp * barbWidth << end - unit * waistLen + perp * waistWidth << start << end - unit * waistLen - perp * waistWidth << end - unit * headLen - perp * barbWidth);
        }
    } else if (data.arrowStyle == ArrowStyle::Thin) {
        p.setPen(QPen(data.color, data.strokeWidth + 1, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
        p.drawLine(start, end);
        double thinAngle = 0.5; double thinLen = headLen * 0.8;
        p.drawLine(end, end - QPointF(thinLen * std::cos(angle - thinAngle), thinLen * std::sin(angle - thinAngle)));
        p.drawLine(end, end - QPointF(thinLen * std::cos(angle + thinAngle), thinLen * std::sin(angle + thinAngle)));
    } else if (data.arrowStyle == ArrowStyle::SolidDouble || data.arrowStyle == ArrowStyle::OutlineDouble) {
        p.setPen(QPen(data.color, data.strokeWidth + 1)); p.drawLine(start + unit * (headLen*0.7), end - unit * (headLen*0.7));
        p.setPen(isOutline ? QPen(data.color, 2.0) : Qt::NoPen);
        p.setBrush(isOutline ? Qt::transparent : data.color);
        auto drawH = [&](const QPointF& e, double ang) {
            QPointF u(std::cos(ang), std::sin(ang)), pr(-u.y(), u.x());
            p.drawPolygon(QPolygonF() << e << e - u * headLen + pr * (headLen*0.5) << e - u * (headLen*0.7) + pr * (data.strokeWidth) << e - u * (headLen*0.7) - pr * (data.strokeWidth) << e - u * headLen - pr * (headLen*0.5));
        };
        drawH(end, angle); drawH(start, angle + M_PI);
    } else if (data.arrowStyle == ArrowStyle::SolidDot || data.arrowStyle == ArrowStyle::OutlineDot) {
        p.setPen(QPen(data.color, data.strokeWidth + 1)); p.drawLine(start, end - unit * (headLen*0.7));
        p.setPen(isOutline ? QPen(data.color, 2.0) : Qt::NoPen);
        p.setBrush(isOutline ? Qt::transparent : data.color);
        p.drawEllipse(start, 5+data.strokeWidth, 5+data.strokeWidth);
        p.drawPolygon(QPolygonF() << end << end - unit * headLen + perp * (headLen*0.5) << end - unit * (headLen*0.7) + perp * (data.strokeWidth) << end - unit * (headLen*0.7) - perp * (data.strokeWidth) << end - unit * headLen - perp * (headLen*0.5));
    } else if (data.arrowStyle == ArrowStyle::Dimension) {
        p.setPen(QPen(data.color, data.strokeWidth + 1, Qt::SolidLine, Qt::FlatCap, Qt::RoundJoin));
        p.drawLine(start, end);
        p.drawLine(start + perp * (10 + data.strokeWidth), start - perp * (10 + data.strokeWidth));
        p.drawLine(end + perp * (10 + data.strokeWidth), end - perp * (10 + data.strokeWidth));
    }
}

bool ArrowShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    return isNearLine(pos, data.points[0], data.points[1], std::max(15, data.strokeWidth + 8));
}

QList<QRect> ArrowShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    h << QRect(data.points[0].toPoint().x()-s/2, data.points[0].toPoint().y()-s/2, s, s)
      << QRect(data.points[1].toPoint().x()-s/2, data.points[1].toPoint().y()-s/2, s, s);
    return h;
}

void PenShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    p.setPen(QPen(data.color, data.strokeWidth, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
    QPainterPath path; path.moveTo(data.points[0]);
    for(int i=1; i<data.points.size(); ++i) path.lineTo(data.points[i]);
    p.drawPath(path);
}

bool PenShape::hitTest(const QPoint& pos) const {
    for (int i = 0; i < data.points.size() - 1; ++i) {
        if (isNearLine(pos, data.points[i], data.points[i+1], std::max(10, data.strokeWidth + 4))) return true;
    }
    return false;
}

void MarkerShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.isEmpty()) return;
    p.setBrush(data.color); p.setPen(Qt::NoPen); int r = 12 + data.strokeWidth;
    p.drawEllipse(data.points[0], r, r); p.setPen(Qt::white); p.setFont(QFont("Arial", r, QFont::Bold));
    p.drawText(QRectF(data.points[0].x()-r, data.points[0].y()-r, r*2, r*2), Qt::AlignCenter, data.text);
}

bool MarkerShape::hitTest(const QPoint& pos) const {
    if (data.points.isEmpty()) return false;
    int r = 12 + data.strokeWidth;
    return (pos - data.points[0].toPoint()).manhattanLength() < r + 5;
}

void TextShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.isEmpty() || data.text.isEmpty()) return;
    p.setPen(data.color);
    QFont font(data.fontFamily, data.fontSize);
    font.setBold(data.isBold);
    font.setItalic(data.isItalic);
    p.setFont(font);
    p.drawText(data.points[0], data.text);
}

bool TextShape::hitTest(const QPoint& pos) const {
    if (data.points.isEmpty() || data.text.isEmpty()) return false;
    QFont font(data.fontFamily, data.fontSize);
    font.setBold(data.isBold); font.setItalic(data.isItalic);
    QRect r = QFontMetrics(font).boundingRect(data.text);
    r.moveTo(data.points[0].toPoint().x(), data.points[0].toPoint().y() - r.height());
    return r.adjusted(-10, -10, 10, 10).contains(pos);
}

QList<QRect> TextShape::getHandles() const {
    if (data.points.isEmpty() || data.text.isEmpty()) return {};
    QList<QRect> h; int s = 10;
    // 为文字左上角提供一个移动句柄
    h << QRect(data.points[0].toPoint().x()-s/2, data.points[0].toPoint().y()-s/2, s, s);
    return h;
}

void MosaicShape::draw(QPainter& p, const QPixmap& mosaicPixmap) const {
    if (data.points.size() < 2) return;
    p.save();
    QPainterPath path; path.moveTo(data.points[0]);
    for(int i=1; i<data.points.size(); ++i) path.lineTo(data.points[i]);
    QPainterPathStroker s; s.setWidth(data.strokeWidth * 6);
    p.setClipPath(s.createStroke(path));
    p.drawPixmap(0, 0, mosaicPixmap);
    p.restore();
}

bool MosaicShape::hitTest(const QPoint& pos) const {
    for (int i = 0; i < data.points.size() - 1; ++i) {
        if (isNearLine(pos, data.points[i], data.points[i+1], data.strokeWidth * 3)) return true;
    }
    return false;
}

void MosaicRectShape::draw(QPainter& p, const QPixmap& mosaicPixmap) const {
    if (data.points.size() < 2) return;
    p.save();
    p.setClipRect(QRectF(data.points[0], data.points[1]).normalized());
    p.drawPixmap(0, 0, mosaicPixmap);
    p.restore();
}

bool MosaicRectShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    return QRectF(data.points[0], data.points[1]).normalized().contains(pos);
}

QList<QRect> MosaicRectShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    h << QRect(r.left()-s/2, r.top()-s/2, s, s) << QRect(r.right()-s/2, r.top()-s/2, s, s)
      << QRect(r.right()-s/2, r.bottom()-s/2, s, s) << QRect(r.left()-s/2, r.bottom()-s/2, s, s);
    return h;
}

void MosaicRectShape::updatePoint(int index, const QPoint& pos) {
    if (data.points.size() < 2) return;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    if (index == 0) { r.setTopLeft(pos); }
    else if (index == 1) { r.setTopRight(pos); }
    else if (index == 2) { r.setBottomRight(pos); }
    else if (index == 3) { r.setBottomLeft(pos); }
    data.points[0] = r.topLeft(); data.points[1] = r.bottomRight();
}

static BaseShape* createShape(const DrawingAnnotation& ann) {
    switch(ann.type) {
        case ScreenshotToolType::Rect: return new RectShape(ann);
        case ScreenshotToolType::Ellipse: return new EllipseShape(ann);
        case ScreenshotToolType::Line: return new LineShape(ann);
        case ScreenshotToolType::Arrow: return new ArrowShape(ann);
        case ScreenshotToolType::Pen: return new PenShape(ann);
        case ScreenshotToolType::Marker: return new MarkerShape(ann);
        case ScreenshotToolType::Text: return new TextShape(ann);
        case ScreenshotToolType::Mosaic: return new MosaicShape(ann);
        case ScreenshotToolType::MosaicRect: return new MosaicRectShape(ann);
        default: return nullptr;
    }
}

void ScreenshotTool::mousePressEvent(QMouseEvent* e) {
    m_lastMouseMovePos = e->pos();
    setFocus();
    if(m_textInput->isVisible() && !m_textInput->geometry().contains(e->pos())) commitTextInput();
    
    if (m_currentTool == ScreenshotToolType::Picker && e->button() == Qt::LeftButton) {
        QColor c = m_screenImage.pixelColor(e->pos());
        setDrawColor(c);
        // 取色后切回上一个工具，如果上一个是 None 则保持 None
        setTool(ScreenshotToolType::None);
        m_toolbar->selectTool(ScreenshotToolType::None);
        update();
        return;
    }
    if(e->button() == Qt::RightButton) {
        if (m_isDrawing) { m_isDrawing = false; delete m_activeShape; m_activeShape = nullptr; update(); return; }
        if (m_currentTool != ScreenshotToolType::None) { m_currentTool = ScreenshotToolType::None; m_toolbar->selectTool(ScreenshotToolType::None); update(); return; }
        cancel(); return;
    }
    if(e->button() != Qt::LeftButton) return;
    m_dragHandle = -1; m_editHandle = -1;

    // 强化：在按下鼠标时重新进行一次命中测试，确保 hoveredShape 准确
    if (m_state == ScreenshotState::Editing && !m_isDragging && !m_isDrawing) {
        m_hoveredShape = nullptr;
        for (int i = m_annotations.size() - 1; i >= 0; --i) {
            if (m_annotations[i]->hitTest(e->pos()) || m_annotations[i]->getHandleAt(e->pos()) != -1) {
                m_hoveredShape = m_annotations[i];
                break;
            }
        }
    }

    if (m_state == ScreenshotState::Selecting) {
        m_startPoint = e->pos(); m_endPoint = m_startPoint; m_isDragging = true; m_toolbar->hide(); m_infoBar->hide();
    } else {
        // 优先处理已有标注的句柄
        if (m_hoveredShape) {
            int handle = m_hoveredShape->getHandleAt(e->pos());
            // [CRITICAL] 使用 m_dragOrigin 而不是 m_startPoint，防止修改选区大小 / Use m_dragOrigin to prevent selection resize
            if (handle != -1) { m_editHandle = handle; m_dragOrigin = e->pos(); m_isDragging = true; update(); return; }
            if (m_hoveredShape->hitTest(e->pos())) { m_editHandle = 100; m_dragOrigin = e->pos(); m_isDragging = true; update(); return; }
        }

        int handle = getHandleAt(e->pos());
        if (selectionRect().contains(e->pos()) && m_currentTool != ScreenshotToolType::None && handle == -1) {
            if (m_currentTool == ScreenshotToolType::Text) { showTextInput(e->pos()); return; }
            m_isDrawing = true; m_currentAnnotation = {m_currentTool, {e->pos()}, m_currentColor, "", m_currentStrokeWidth, LineStyle::Solid, m_currentArrowStyle, m_fillEnabled, 
                                                       m_currentFontFamily, m_currentFontSize, m_currentBold, m_currentItalic};
            if(m_currentTool == ScreenshotToolType::Marker) {
                int c = 1; for(auto* a : std::as_const(m_annotations)) if(a->data.type == ScreenshotToolType::Marker) c++;
                m_currentAnnotation.text = QString::number(c);
            }
            delete m_activeShape;
            m_activeShape = createShape(m_currentAnnotation);
        } else if (handle != -1) {
            m_dragHandle = handle; m_isDragging = true;
        } else if (selectionRect().contains(e->pos())) {
            // [CRITICAL] 移动选区时使用 m_dragOrigin / Use m_dragOrigin when moving selection
            m_dragHandle = 8; m_dragOrigin = e->pos(); m_isDragging = true;
        }
    }
    update();
}

void ScreenshotTool::mouseMoveEvent(QMouseEvent* e) {
    m_lastMouseMovePos = e->pos();
    if (m_state == ScreenshotState::Selecting && !m_isDragging) {
        QRect smallest; long long minArea = -1;
        for (const QRect& r : std::as_const(m_detectedRects)) {
            if (r.contains(e->pos())) {
                long long area = (long long)r.width() * r.height();
                if (minArea == -1 || area < minArea) { minArea = area; smallest = r; }
            }
        }
        if (m_highlightedRect != smallest) { m_highlightedRect = smallest; update(); }
    } else {
        m_highlightedRect = QRect();
    }

    if (!m_isDragging && !m_isDrawing && m_state == ScreenshotState::Editing) {
        BaseShape* prevHover = m_hoveredShape; m_hoveredShape = nullptr;
        for (int i = m_annotations.size() - 1; i >= 0; --i) {
            if (m_annotations[i]->hitTest(e->pos()) || m_annotations[i]->getHandleAt(e->pos()) != -1) {
                m_hoveredShape = m_annotations[i]; break;
            }
        }
        if (prevHover != m_hoveredShape) update();
    }

    if (m_isDragging) {
        QPoint p = e->pos();
        if (m_editHandle != -1 && m_hoveredShape) {
            if (m_editHandle == 100) { m_hoveredShape->moveBy(p - m_dragOrigin); m_dragOrigin = p; }
            else { m_hoveredShape->updatePoint(m_editHandle, p); }
            update(); return;
        }
        if (m_currentTool == ScreenshotToolType::Eraser) {
            bool changed = false;
            for (int i = m_annotations.size() - 1; i >= 0; --i) {
                if (m_annotations[i]->hitTest(p)) { m_redoStack.append(m_annotations.takeAt(i)); changed = true; if(m_hoveredShape == m_redoStack.last()) m_hoveredShape = nullptr; }
            }
            if (changed) update(); return;
        }
        if (m_state == ScreenshotState::Selecting) {
            m_endPoint = e->pos();
        } else if (m_dragHandle == 8) {
            QPoint delta = e->pos() - m_dragOrigin;
            m_startPoint += delta; m_endPoint += delta;
            m_dragOrigin = e->pos();
        } else if (m_dragHandle != -1) {
            if(m_dragHandle==0) m_startPoint = p; else if(m_dragHandle==1) m_startPoint.setY(p.y()); else if(m_dragHandle==2) { m_startPoint.setY(p.y()); m_endPoint.setX(p.x()); }
            else if(m_dragHandle==3) m_endPoint.setX(p.x()); else if(m_dragHandle==4) m_endPoint = p; else if(m_dragHandle==5) m_endPoint.setY(p.y());
            else if(m_dragHandle==6) { m_endPoint.setY(p.y()); m_startPoint.setX(p.x()); } else if(m_dragHandle==7) m_startPoint.setX(p.x());
        }
        if (!selectionRect().isEmpty()) {
            if (!m_isImmediateOCR) {
                m_infoBar->updateInfo(selectionRect()); m_infoBar->show(); m_infoBar->move(selectionRect().left(), selectionRect().top() - 35); m_infoBar->raise();
            }
            updateToolbarPosition();
        }
    } else if (m_isDrawing && m_activeShape) {
        updateToolbarPosition();
        if (m_currentTool == ScreenshotToolType::Arrow || m_currentTool == ScreenshotToolType::Line || m_currentTool == ScreenshotToolType::Rect || m_currentTool == ScreenshotToolType::Ellipse || m_currentTool == ScreenshotToolType::MosaicRect) {
            if (m_activeShape->data.points.size() > 1) m_activeShape->data.points[1] = e->pos(); else m_activeShape->data.points.append(e->pos());
        } else m_activeShape->data.points.append(e->pos());
    } else updateCursor(e->pos());
    update();
}

void ScreenshotTool::mouseReleaseEvent(QMouseEvent* e) {
    if (m_isDrawing) {
        m_isDrawing = false;
        if (m_activeShape) {
            m_annotations.append(m_activeShape);
            m_activeShape = nullptr;
            qDeleteAll(m_redoStack);
            m_redoStack.clear();
        }
    }
    else if (m_isDragging) {
        m_isDragging = false;
        m_editHandle = -1;
        if (m_state == ScreenshotState::Selecting) {
            if ((e->pos() - m_startPoint).manhattanLength() < 5) {
                if (!m_highlightedRect.isEmpty()) { m_startPoint = m_highlightedRect.topLeft(); m_endPoint = m_highlightedRect.bottomRight(); }
            }
            if (selectionRect().width() > 2 && selectionRect().height() > 2) {
                m_state = ScreenshotState::Editing;
                m_highlightedRect = QRect();
                m_detectedRects.clear();
            }
        }
    }
    if (m_state == ScreenshotState::Editing) {
        if (m_isImmediateOCR) {
            confirm();
            return;
        }
        updateToolbarPosition(); m_toolbar->show(); m_infoBar->updateInfo(selectionRect());
        m_infoBar->show(); m_infoBar->move(selectionRect().left(), selectionRect().top() - 35);
    }
    update();
}

void ScreenshotTool::updateToolbarPosition() {
    QRect r = selectionRect(); if(r.isEmpty()) return; m_toolbar->adjustSize();
    // 补偿 6px 的外边距，并将视觉位置贴近选区边缘（保留 4px 视觉间距）
    int x = r.right() - m_toolbar->width() + 6;
    int y = r.bottom() - 4; 
    
    if (x < -6) x = -6; 
    if (y + m_toolbar->height() - 6 > height()) y = r.top() - m_toolbar->height() + 4;
    
    m_toolbar->move(x, y); 
    if (!m_isImmediateOCR) {
        if (m_state == ScreenshotState::Editing && !m_toolbar->isVisible()) m_toolbar->show();
        if (m_toolbar->isVisible()) m_toolbar->raise();
    }
}

void ScreenshotTool::wheelEvent(QWheelEvent* event) {
    int delta = event->angleDelta().y();
    if (m_hoveredShape) {
        if (m_hoveredShape->data.type == ScreenshotToolType::Text) {
            int newSize = m_hoveredShape->data.fontSize + (delta > 0 ? 2 : -2);
            m_hoveredShape->data.fontSize = std::max(8, std::min(100, newSize));
        } else {
            int newWidth = m_hoveredShape->data.strokeWidth + (delta > 0 ? 1 : -1);
            m_hoveredShape->data.strokeWidth = std::max(1, std::min(50, newWidth));
        }
        update();
    } else {
        // 如果没有悬浮标注，修改全局设置
        if (m_currentTool == ScreenshotToolType::Text) {
            m_currentFontSize += (delta > 0 ? 2 : -2);
            m_currentFontSize = std::max(8, std::min(100, m_currentFontSize));
        } else {
            m_currentStrokeWidth += (delta > 0 ? 1 : -1);
            m_currentStrokeWidth = std::max(1, std::min(50, m_currentStrokeWidth));
        }
    }
    event->accept();
}

void ScreenshotTool::paintEvent(QPaintEvent*) {
    QPainter p(this); p.setRenderHint(QPainter::Antialiasing);
    p.drawPixmap(0,0,m_screenPixmap);
    QRect r = selectionRect(); QPainterPath path; path.addRect(rect());
    if(r.isValid()) path.addRect(r); p.fillPath(path, QColor(0,0,0,120));

    if (m_state == ScreenshotState::Selecting && !m_isDragging && !m_highlightedRect.isEmpty()) {
        p.setPen(QPen(QColor(0, 120, 255, 200), 2)); p.setBrush(QColor(0, 120, 255, 30)); p.drawRect(m_highlightedRect);
    }
    if(r.isValid()) {
        p.setPen(QPen(QColor(0, 120, 255), 2)); p.drawRect(r);
        auto h = getHandleRects(); p.setBrush(Qt::white); for(auto& hr : h) p.drawEllipse(hr);
        p.save(); // [CRITICAL] 保存状态以防 clip 影响后续绘制
        p.setClipRect(r);
        for(auto* a : std::as_const(m_annotations)) {
            a->draw(p, m_mosaicPixmap);
            if (a == m_hoveredShape) {
                p.save();
                p.setRenderHint(QPainter::Antialiasing);
                p.setPen(QPen(Qt::cyan, 1.2, Qt::DashLine));
                p.setBrush(Qt::NoBrush);
                
                // 针对不同形状绘制更有意义的连接虚线
                if (a->data.type == ScreenshotToolType::Line || a->data.type == ScreenshotToolType::Arrow) {
                    if (a->data.points.size() >= 2) p.drawLine(a->data.points[0], a->data.points[1]);
                } else if (a->data.type == ScreenshotToolType::Rect || a->data.type == ScreenshotToolType::Ellipse || a->data.type == ScreenshotToolType::MosaicRect) {
                    if (a->data.points.size() >= 2) p.drawRect(QRectF(a->data.points[0], a->data.points[1]).normalized());
                } else if (a->data.type == ScreenshotToolType::Text) {
                    // 文字工具显示边界框
                    QFont font(a->data.fontFamily, a->data.fontSize);
                    font.setBold(a->data.isBold); font.setItalic(a->data.isItalic);
                    QRect r = QFontMetrics(font).boundingRect(a->data.text);
                    r.moveTo(a->data.points[0].toPoint().x(), a->data.points[0].toPoint().y() - r.height());
                    p.drawRect(r.adjusted(-4, -2, 4, 2));
                }

                // 绘制编辑句柄
                auto handles = a->getHandles();
                for(const auto& hh : std::as_const(handles)) {
                    p.setPen(QPen(Qt::white, 1));
                    p.setBrush(QColor(0, 120, 255));
                    p.drawRect(hh);
                }
                p.restore();
            }
        }
        if(m_isDrawing && m_activeShape) {
            m_activeShape->draw(p, m_mosaicPixmap);
        }
        p.restore(); // [CRITICAL] 恢复状态，解除选区 clip
    }

    // [CRITICAL] 放大镜绘制必须在选区 clip 之外，以防被裁剪
    if (m_state == ScreenshotState::Selecting || m_isDragging || m_isDrawing || m_currentTool == ScreenshotToolType::Picker) {
        drawMagnifier(p, m_lastMouseMovePos);
    }
}

void ScreenshotTool::setTool(ScreenshotToolType t) { if(m_textInput->isVisible()) commitTextInput(); m_currentTool = t; QSettings("RapidNotes", "Screenshot").setValue("tool", static_cast<int>(t)); }
void ScreenshotTool::setDrawColor(const QColor& c) { 
    m_currentColor = c; 
    QSettings("RapidNotes", "Screenshot").setValue("color", c); 
    if (m_toolbar) m_toolbar->addRecentColor(c);
}
void ScreenshotTool::setDrawWidth(int w) { m_currentStrokeWidth = w; QSettings("RapidNotes", "Screenshot").setValue("strokeWidth", w); }
void ScreenshotTool::setArrowStyle(ArrowStyle s) { m_currentArrowStyle = s; QSettings("RapidNotes", "Screenshot").setValue("arrowStyle", static_cast<int>(s)); }
void ScreenshotTool::setFillEnabled(bool enabled) { m_fillEnabled = enabled; }
void ScreenshotTool::setBold(bool bold) { m_currentBold = bold; QSettings("RapidNotes", "Screenshot").setValue("bold", bold); }
void ScreenshotTool::setItalic(bool italic) { m_currentItalic = italic; QSettings("RapidNotes", "Screenshot").setValue("italic", italic); }
void ScreenshotTool::setFontFamily(const QString& family) { m_currentFontFamily = family; QSettings("RapidNotes", "Screenshot").setValue("fontFamily", family); }
void ScreenshotTool::setFontSize(int size) { m_currentFontSize = size; QSettings("RapidNotes", "Screenshot").setValue("fontSize", size); }

void ScreenshotTool::undo() { if(!m_annotations.isEmpty()) { m_redoStack.append(m_annotations.takeLast()); update(); } }
void ScreenshotTool::redo() { if(!m_redoStack.isEmpty()) { m_annotations.append(m_redoStack.takeLast()); update(); } }
void ScreenshotTool::copyToClipboard() { 
    QImage img = generateFinalImage();
    emit screenshotCaptured(img, false);
    ClipboardMonitor::instance().forceNext();
    QApplication::clipboard()->setImage(img); 
    autoSaveImage(img);
    cancel(); 
}
void ScreenshotTool::save() { 
    QImage img = generateFinalImage();
    emit screenshotCaptured(img, false);
    QString fileName = QString("RPN_%1.png").arg(QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss"));
    QString f = QFileDialog::getSaveFileName(this, "保存截图", fileName, "PNG(*.png)"); 
    if(!f.isEmpty()) img.save(f); 
    autoSaveImage(img);
    cancel(); 
}
void ScreenshotTool::confirm() { 
    if (m_isConfirmed) return;
    m_isConfirmed = true;
    QImage img = generateFinalImage();
    emit screenshotCaptured(img, m_isImmediateOCR); 
    autoSaveImage(img);
    cancel(); 
}
void ScreenshotTool::pin() { QImage img = generateFinalImage(); if (img.isNull()) return; auto* widget = new PinnedScreenshotWidget(QPixmap::fromImage(img), selectionRect()); widget->show(); cancel(); }

QRect ScreenshotTool::selectionRect() const { return QRect(m_startPoint, m_endPoint).normalized(); }
QList<QRect> ScreenshotTool::getHandleRects() const {
    QRect r = selectionRect(); QList<QRect> l; if(r.isEmpty()) return l; int s = 10;
    l << QRect(r.left()-s/2, r.top()-s/2, s, s) << QRect(r.center().x()-s/2, r.top()-s/2, s, s)
      << QRect(r.right()-s/2, r.top()-s/2, s, s) << QRect(r.right()-s/2, r.center().y()-s/2, s, s)
      << QRect(r.right()-s/2, r.bottom()-s/2, s, s) << QRect(r.center().x()-s/2, r.bottom()-s/2, s, s)
      << QRect(r.left()-s/2, r.bottom()-s/2, s, s) << QRect(r.left()-s/2, r.center().y()-s/2, s, s);
    return l;
}
int ScreenshotTool::getHandleAt(const QPoint& p) const { auto l = getHandleRects(); for(int i=0; i<l.size(); ++i) if(l[i].contains(p)) return i; return -1; }
void ScreenshotTool::updateCursor(const QPoint& p) {
    if (m_state == ScreenshotState::Editing) {
        int handle = getHandleAt(p); if (handle != -1) {
            switch (handle) { case 0: case 4: setCursor(Qt::SizeFDiagCursor); break; case 1: case 5: setCursor(Qt::SizeVerCursor); break; case 2: case 6: setCursor(Qt::SizeBDiagCursor); break; case 3: case 7: setCursor(Qt::SizeHorCursor); break; }
            return;
        }
        if (selectionRect().contains(p)) { if (m_currentTool != ScreenshotToolType::None) setCursor(Qt::CrossCursor); else setCursor(Qt::SizeAllCursor); return; }
    }
    setCursor(Qt::ArrowCursor);
}
void ScreenshotTool::showTextInput(const QPoint& p) { 
    m_textInput->move(p); 
    m_textInput->resize(200, 30); 
    QFont font(m_currentFontFamily, m_currentFontSize);
    font.setBold(m_currentBold);
    font.setItalic(m_currentItalic);
    m_textInput->setFont(font);
    m_textInput->setStyleSheet(QString("color: %1; background: transparent;").arg(m_currentColor.name()));
    m_textInput->show(); 
    m_textInput->setFocus(); 
}
void ScreenshotTool::commitTextInput() {
    if(m_textInput->text().isEmpty()) { m_textInput->hide(); return; }
    DrawingAnnotation ann = {ScreenshotToolType::Text, {m_textInput->pos()}, m_currentColor, m_textInput->text(), m_currentStrokeWidth, LineStyle::Solid, ArrowStyle::SolidSingle, false,
                             m_currentFontFamily, m_currentFontSize, m_currentBold, m_currentItalic};
    BaseShape* shape = createShape(ann);
    if (shape) {
        m_annotations.append(shape);
        qDeleteAll(m_redoStack);
        m_redoStack.clear();
    }
    m_textInput->hide(); m_textInput->clear(); update();
}

#ifdef Q_OS_WIN
BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam) {
    QList<QRect>* rects = reinterpret_cast<QList<QRect>*>(lParam);
    // 子窗口使用 GetWindowRect 即可，DWM 扩展边框通常只针对顶层窗口
    if (IsWindowVisible(hwnd)) {
        RECT rect;
        if (GetWindowRect(hwnd, &rect)) {
            QRect qr(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
            if (qr.width() > 5 && qr.height() > 5) rects->append(qr);
        }
    }
    return TRUE;
}
BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam) {
    QList<QRect>* rects = reinterpret_cast<QList<QRect>*>(lParam);
    if (IsWindowVisible(hwnd) && !IsIconic(hwnd)) {
        TCHAR className[256]; GetClassName(hwnd, className, 256);
        if (_tcscmp(className, _T("Qt662QWindowIcon")) == 0) return TRUE;
        int cloaked = 0; DwmGetWindowAttribute(hwnd, DWMWA_CLOAKED, &cloaked, sizeof(cloaked));
        if (cloaked) return TRUE;
        QRect qr = getActualWindowRect(hwnd); if (qr.width() > 10 && qr.height() > 10) { rects->append(qr); EnumChildWindows(hwnd, EnumChildProc, lParam); }
    }
    return TRUE;
}
#endif
void ScreenshotTool::detectWindows() { 
    if (m_state != ScreenshotState::Selecting) return;
    m_detectedRects.clear();
#ifdef Q_OS_WIN
    EnumWindows(EnumWindowsProc, reinterpret_cast<LPARAM>(&m_detectedRects));
#endif

    // 关键优化：遍历本应用内所有活跃的 Qt 部件，实现对搜索框、分类栏等细微控件的精确侦测
    for (QWidget* top : QApplication::topLevelWidgets()) {
        if (top->isVisible() && !top->isMinimized() && top != this && top->windowOpacity() > 0) {
            collectQtWidgets(top);
        }
    }

    // 统一坐标系转换
    QPoint offset = mapToGlobal(QPoint(0,0)); 
    for(QRect& r : m_detectedRects) r.translate(-offset);
    
    // 去重并过滤极小区域
    QList<QRect> filtered;
    for (const QRect& r : std::as_const(m_detectedRects)) {
        if (r.width() > 5 && r.height() > 5 && !filtered.contains(r)) {
            filtered.append(r);
        }
    }
    m_detectedRects = filtered;
}

void ScreenshotTool::drawMagnifier(QPainter& p, const QPoint& pos) {
    if (pos.x() < 0 || pos.y() < 0 || pos.x() >= m_screenImage.width() || pos.y() >= m_screenImage.height()) return;

    p.save();
    const int zoom = 12;
    const int cols = 21;
    const int rows = 11;
    const int magWidth = cols * zoom;
    const int magHeight = rows * zoom;
    const int infoHeight = 130;
    
    int margin = 30;
    QRect sel = selectionRect();
    QRect magRect(pos.x() + margin, pos.y() + margin, magWidth, magHeight);

    // [CRITICAL] 放大镜绘制逻辑：当鼠标在选区内时，尝试在四个方向寻找空间放置放大镜，避免遮挡。
    if (m_state == ScreenshotState::Editing && sel.contains(pos)) {
        if (sel.right() + margin + magWidth < width()) magRect.moveTo(sel.right() + margin, pos.y() - magHeight / 2);
        else if (sel.left() - margin - magWidth > 0) magRect.moveTo(sel.left() - margin - magWidth, pos.y() - magHeight / 2);
        else if (sel.top() - margin - magHeight - infoHeight > 0) magRect.moveTo(pos.x() - magWidth / 2, sel.top() - margin - magHeight - infoHeight);
        else if (sel.bottom() + margin < height()) magRect.moveTo(pos.x() - magWidth / 2, sel.bottom() + margin);
    }

    // 边界安全检查，确保放大镜和信息面板不超出屏幕
    if (magRect.right() > width()) magRect.moveRight(width() - 5);
    if (magRect.left() < 0) magRect.moveLeft(5);
    if (magRect.bottom() + infoHeight > height()) magRect.moveBottom(height() - infoHeight - 5);
    if (magRect.top() < 0) magRect.moveTop(5);
    
    p.setRenderHint(QPainter::Antialiasing, false);
    
    // 1. 绘制放大区域背景及边框
    p.setPen(QPen(Qt::white, 1));
    p.setBrush(Qt::black);
    p.drawRect(magRect.adjusted(-1, -1, 1, 1));
    
    // 这里的源矩形取自原始屏幕像素
    QRect srcRect(pos.x() - cols/2, pos.y() - rows/2, cols, rows);
    p.drawPixmap(magRect, m_screenPixmap, srcRect);
    
    // 2. 绘制像素网格
    p.setPen(QPen(QColor(255, 255, 255, 50), 1));
    for (int i = 0; i <= magWidth; i += zoom) p.drawLine(magRect.left() + i, magRect.top(), magRect.left() + i, magRect.bottom());
    for (int i = 0; i <= magHeight; i += zoom) p.drawLine(magRect.left(), magRect.top() + i, magRect.right(), magRect.top() + i);
    
    // 3. 绘制中心像素高亮框
    p.setPen(QPen(Qt::white, 1));
    p.setBrush(Qt::NoBrush);
    p.drawRect(magRect.left() + (cols/2)*zoom, magRect.top() + (rows/2)*zoom, zoom, zoom);
    
    // 4. 绘制下方黑色信息面板
    QRect infoRect(magRect.left(), magRect.bottom() + 1, magWidth, infoHeight);
    p.fillRect(infoRect, Qt::black);
    
    QColor color = m_screenImage.pixelColor(pos);
    QString colorStr;
    if (m_colorFormatIndex == 0) colorStr = color.name(QColor::HexRgb).toUpper();
    else if (m_colorFormatIndex == 1) colorStr = QString("%1, %2, %3").arg(color.red()).arg(color.green()).arg(color.blue());
    else {
        // HSL 格式处理
        int h = color.hslHue() < 0 ? 0 : color.hslHue();
        int s = int(color.hslSaturationF() * 100);
        int l = int(color.lightnessF() * 100);
        colorStr = QString("HSL(%1, %2, %3)").arg(h).arg(s).arg(l);
    }

    p.setPen(Qt::white);
    p.setRenderHint(QPainter::TextAntialiasing);
    QFont font("Microsoft YaHei", 10);
    p.setFont(font);

    // 第一行：坐标 (x , y)
    QString coordStr = QString("(%1 , %2)").arg(pos.x()).arg(pos.y());
    p.drawText(infoRect.adjusted(0, 10, 0, 0), Qt::AlignHCenter | Qt::AlignTop, coordStr);

    // 第二行：颜色预览方块 + 色值文本
    int textWidth = p.fontMetrics().horizontalAdvance(colorStr);
    int totalContentWidth = 16 + 8 + textWidth; // 方块(16) + 间距(8) + 文本
    int startX = infoRect.left() + (magWidth - totalContentWidth) / 2;
    int line2Y = infoRect.top() + 38;
    
    p.setBrush(color);
    p.setPen(QPen(Qt::white, 1));
    p.drawRect(startX, line2Y, 16, 16);
    
    p.setPen(Qt::white);
    p.drawText(startX + 24, line2Y + 13, colorStr);

    // 第三、四、五行：功能提示
    font.setPointSize(9);
    p.setFont(font);
    p.drawText(infoRect.adjusted(0, 65, 0, 0), Qt::AlignHCenter | Qt::AlignTop, "Shift:  切换颜色格式");
    p.drawText(infoRect.adjusted(0, 86, 0, 0), Qt::AlignHCenter | Qt::AlignTop, "C:  复制色值");
    p.drawText(infoRect.adjusted(0, 107, 0, 0), Qt::AlignHCenter | Qt::AlignTop, "M:  复制坐标");

    p.restore();
}

void ScreenshotTool::collectQtWidgets(QWidget* parent) {
    if (!parent || !parent->isVisible()) return;

    // 记录当前部件的全局几何信息
    QRect r = parent->rect();
    QPoint globalPos = parent->mapToGlobal(QPoint(0,0));
    r.moveTo(globalPos);
    m_detectedRects.append(r);

    // 递归处理子部件
    const QObjectList& children = parent->children();
    for (QObject* childObj : children) {
        QWidget* child = qobject_cast<QWidget*>(childObj);
        if (child && child->isVisible() && !child->rect().isEmpty()) {
            collectQtWidgets(child);
        }
    }
}
void ScreenshotTool::executeOCR() {
    QImage img = generateFinalImage();
    emit screenshotCaptured(img, true);
    cancel();
}

QImage ScreenshotTool::generateFinalImage() {
    QRect r = selectionRect(); if(r.isEmpty()) return QImage();
    QPixmap p = m_screenPixmap.copy(r); QPainter painter(&p); painter.translate(-r.topLeft());
    for(auto* a : std::as_const(m_annotations)) a->draw(painter, m_mosaicPixmap);
    return p.toImage();
}

void ScreenshotTool::autoSaveImage(const QImage& img) {
    if (img.isNull()) return;
    
    QSettings settings("RapidNotes", "Screenshot");
    QString defaultPath = QCoreApplication::applicationDirPath() + "/RPN_screenshot";
    QString savePath = settings.value("savePath", defaultPath).toString();
    
    QDir dir(savePath);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    
    QString fileName = QString("RPN_%1.png").arg(QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss"));
    QString fullPath = dir.absoluteFilePath(fileName);
    
    if (img.save(fullPath)) {
        // 使用非阻塞彩色反馈告知用户已自动保存
        ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已自动保存至:\n%1").arg(fullPath));
    } else {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "✖ 自动保存失败，请检查路径权限");
    }
}
void ScreenshotTool::keyPressEvent(QKeyEvent* e) { 
    if(e->key() == Qt::Key_Escape) cancel(); 
    else if(e->key() == Qt::Key_Return || e->key() == Qt::Key_Enter || e->key() == Qt::Key_Space) { if(m_state == ScreenshotState::Editing) confirm(); }
    else if (e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_Z) undo();
    else if (e->modifiers() == (Qt::ControlModifier | Qt::ShiftModifier) && e->key() == Qt::Key_Z) redo();
    else if (e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_O) executeOCR();
    else if (e->key() == Qt::Key_F) pin();
    else if (e->key() == Qt::Key_C) { 
        // 如果放大镜可见，C 键用于复制当前像素色值
        if (m_state == ScreenshotState::Selecting || m_isDragging || m_isDrawing || m_currentTool == ScreenshotToolType::Picker) {
            QColor color = m_screenImage.pixelColor(m_lastMouseMovePos);
            QString colorStr;
            if (m_colorFormatIndex == 0) colorStr = color.name(QColor::HexRgb).toUpper();
            else if (m_colorFormatIndex == 1) colorStr = QString("%1, %2, %3").arg(color.red()).arg(color.green()).arg(color.blue());
            else colorStr = QString("HSL(%1, %2, %3)").arg(color.hslHue() < 0 ? 0 : color.hslHue()).arg(int(color.hslSaturationF()*100)).arg(int(color.lightnessF()*100));
            
            ClipboardMonitor::instance().forceNext();
            QApplication::clipboard()->setText(colorStr);
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("已复制色值: %1").arg(colorStr));
        } else {
            m_toolbar->selectTool(ScreenshotToolType::Picker); 
        }
    }
    else if (e->key() == Qt::Key_Shift) {
        m_colorFormatIndex = (m_colorFormatIndex + 1) % 3;
        update();
    }
    else if (e->key() == Qt::Key_M) {
        QString coordStr = QString("%1, %2").arg(m_lastMouseMovePos.x()).arg(m_lastMouseMovePos.y());
        ClipboardMonitor::instance().forceNext();
        QApplication::clipboard()->setText(coordStr);
        ToolTipOverlay::instance()->showText(QCursor::pos(), QString("已复制坐标: %1").arg(coordStr));
    }
}
void ScreenshotTool::mouseDoubleClickEvent(QMouseEvent* e) { if(selectionRect().contains(e->pos())) confirm(); }

bool ScreenshotTool::eventFilter(QObject* watched, QEvent* event) {
    if (watched == m_textInput && event->type() == QEvent::KeyPress) {
        QKeyEvent* ke = static_cast<QKeyEvent*>(event);
        if (ke->key() == Qt::Key_Escape) {
            cancel();
            return true;
        }
    }
    return QWidget::eventFilter(watched, event);
}
```

## 文件: `src/ui/ScreenshotTool.h`

```cpp
#ifndef SCREENSHOTTOOL_H
#define SCREENSHOTTOOL_H

#include <QWidget>
#include <QMouseEvent>
#include <QGuiApplication>
#include <QScreen>
#include <QPixmap>
#include <QPainter>
#include <QPainterPath>
#include <QPushButton>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QMap>
#include <QLineEdit>
#include <QButtonGroup>
#include <QMenu>
#include <QColorDialog>
#include <QList>
#include <functional>
#include <utility>

enum class ScreenshotState { Selecting, Editing };
enum class ScreenshotToolType { None, Rect, Ellipse, Arrow, Line, Pen, Marker, Text, Mosaic, MosaicRect, Eraser, Picker };
enum class ArrowStyle { 
    SolidSingle, OutlineSingle, 
    SolidDouble, OutlineDouble, 
    SolidDot, OutlineDot,
    Thin,
    Dimension
};
enum class LineStyle { Solid, Dash, Dot };

struct DrawingAnnotation {
    ScreenshotToolType type;
    QList<QPointF> points;
    QColor color;
    QString text;
    int strokeWidth;
    LineStyle lineStyle;
    ArrowStyle arrowStyle;
    bool isFilled = false;
    // 文本相关属性
    QString fontFamily = "Microsoft YaHei";
    int fontSize = 12;
    bool isBold = false;
    bool isItalic = false;
};

class BaseShape {
public:
    BaseShape(const DrawingAnnotation& ann) : data(ann) {}
    virtual ~BaseShape() = default;
    virtual void draw(QPainter& painter, const QPixmap& mosaicPixmap) const = 0;
    virtual bool hitTest(const QPoint& pos) const = 0;
    virtual QList<QRect> getHandles() const { return {}; }
    virtual int getHandleAt(const QPoint& pos) const;
    virtual void updatePoint(int index, const QPoint& pos) { if(index >= 0 && index < data.points.size()) data.points[index] = pos; }
    virtual void moveBy(const QPoint& delta);
    DrawingAnnotation data;
};

class RectShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
    void updatePoint(int index, const QPoint& pos) override;
};

class EllipseShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
    void updatePoint(int index, const QPoint& pos) override;
};

class LineShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
};

class ArrowShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
};

class PenShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
};

class MarkerShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
};

class TextShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
};

class MosaicShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
};

class MosaicRectShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
    void updatePoint(int index, const QPoint& pos) override;
};

class ScreenshotTool;
class ScreenshotToolbar;

class PinnedScreenshotWidget : public QWidget {
    Q_OBJECT
public:
    explicit PinnedScreenshotWidget(const QPixmap& pixmap, const QRect& screenRect, QWidget* parent = nullptr);
protected:
    void paintEvent(QPaintEvent*) override;
    void mousePressEvent(QMouseEvent*) override;
    void mouseMoveEvent(QMouseEvent*) override;
    void mouseDoubleClickEvent(QMouseEvent*) override;
    void contextMenuEvent(QContextMenuEvent*) override;
private:
    QPixmap m_pixmap;
    QPoint m_dragPos;
};

class ScreenshotToolbar : public QWidget {
    Q_OBJECT
public:
    explicit ScreenshotToolbar(ScreenshotTool* tool);
    void addToolButton(QBoxLayout* layout, ScreenshotToolType type, const QString& iconType, const QString& tip);
    void addActionButton(QBoxLayout* layout, const QString& iconName, const QString& tip, std::function<void()> func);
    void selectTool(ScreenshotToolType type);
    void updateArrowButtonIcon(ArrowStyle style);
    void addRecentColor(const QColor& c, bool save = true);
    void syncColorSelection(const QColor& color);

protected:
    void paintEvent(QPaintEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

private:
    void createOptionWidget();
    void showArrowMenu();

public:
    ScreenshotTool* m_tool;
    QMap<ScreenshotToolType, QPushButton*> m_buttons;
    QWidget* m_optionWidget = nullptr;
    QPushButton* m_arrowStyleBtn = nullptr;
    QPushButton* m_outlineBtn = nullptr;
    QPushButton* m_solidBtn = nullptr;
    QPushButton* m_wheelBtn = nullptr;
    QBoxLayout* m_recentLayout = nullptr;
    QWidget* m_textOptionWidget = nullptr;
    QWidget* m_sizeOptionWidget = nullptr;
    QFrame* m_textDivider = nullptr;
    QFrame* m_horizontalDivider = nullptr;
    QPushButton* m_boldBtn = nullptr;
    QPushButton* m_italicBtn = nullptr;
    QPushButton* m_removeColorBtn = nullptr; // 用于删除最近颜色

    bool m_isDragging = false;
    QPoint m_dragPosition;

    QButtonGroup* m_colorGroup = nullptr;
    QButtonGroup* m_sizeGroup = nullptr;
    QPushButton* m_paletteBtn = nullptr;
};

class SelectionInfoBar : public QWidget {
    Q_OBJECT
    friend class ScreenshotToolbar;
public:
    explicit SelectionInfoBar(QWidget* parent = nullptr);
    void updateInfo(const QRect& rect);
protected:
    void paintEvent(QPaintEvent*) override;
private:
    QString m_text;
};

class ScreenshotTool : public QWidget {
    Q_OBJECT
    friend class ScreenshotToolbar;
public:
    explicit ScreenshotTool(QWidget* parent = nullptr);
    ~ScreenshotTool() override;
    
    void setDrawColor(const QColor& color);
    void setDrawWidth(int width);
    void setArrowStyle(ArrowStyle style);
    void setFillEnabled(bool enabled);
    void setBold(bool bold);
    void setItalic(bool italic);
    void setFontFamily(const QString& family);
    void setFontSize(int size);
    
    void updateToolbarPosition();
    void undo();
    void redo();
    void copyToClipboard();
    void save();
    void confirm();
    void pin();
    void cancel(); 
    void executeOCR();

    void setImmediateOCRMode(bool enabled) { m_isImmediateOCR = enabled; }

signals:
    void screenshotCaptured(const QImage& image, bool isOcr = false);
    void screenshotCanceled();

protected:
    void paintEvent(QPaintEvent*) override;
    void wheelEvent(QWheelEvent* event) override;
    void showEvent(QShowEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void mouseDoubleClickEvent(QMouseEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

public slots:
    void setTool(ScreenshotToolType type);

private:
    QRect selectionRect() const;
    QList<QRect> getHandleRects() const;
    int getHandleAt(const QPoint& pos) const;
    void updateCursor(const QPoint& pos);
    void showTextInput(const QPoint& pos);
    void commitTextInput();
    QImage generateFinalImage();
    void autoSaveImage(const QImage& img);
    void detectWindows();
    void collectQtWidgets(QWidget* parent);
    void drawMagnifier(QPainter& p, const QPoint& pos);

    QPixmap m_screenPixmap;
    QImage m_screenImage;
    QPixmap m_mosaicPixmap;
    
    ScreenshotState m_state = ScreenshotState::Selecting;
    ScreenshotToolType m_currentTool = ScreenshotToolType::None;
    
    QList<QRect> m_detectedRects;
    QRect m_highlightedRect;

    QPoint m_startPoint, m_endPoint;
    QPoint m_dragOrigin; // 新增：用于记录拖拽操作的起始点，避免污染 m_startPoint
    bool m_isDragging = false;
    int m_dragHandle = -1; 
    bool m_isConfirmed = false;

    QList<BaseShape*> m_annotations;
    QList<BaseShape*> m_redoStack;
    BaseShape* m_activeShape = nullptr;
    BaseShape* m_hoveredShape = nullptr;
    int m_editHandle = -1;
    DrawingAnnotation m_currentAnnotation;
    bool m_isDrawing = false;

    ScreenshotToolbar* m_toolbar = nullptr;
    SelectionInfoBar* m_infoBar = nullptr;
    QLineEdit* m_textInput = nullptr;
    QPoint m_lastMouseMovePos;
    int m_colorFormatIndex = 0; // 0: Hex, 1: RGB, 2: HSL
    bool m_isImmediateOCR = false;

    QColor m_currentColor = QColor(255, 50, 50); 
    int m_currentStrokeWidth = 3; 
    ArrowStyle m_currentArrowStyle = ArrowStyle::SolidSingle;
    bool m_fillEnabled = false;
    LineStyle m_currentLineStyle = LineStyle::Solid;

    QString m_currentFontFamily = "Microsoft YaHei";
    int m_currentFontSize = 14;
    bool m_currentBold = true;
    bool m_currentItalic = false;
};

#endif // SCREENSHOTTOOL_H
```

## 文件: `src/ui/SearchLineEdit.cpp`

```cpp
#include "SearchLineEdit.h"
#include "IconHelper.h"
#include <QSettings>
#include <QMenu>
#include <QFrame>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QScrollArea>
#include <QLayout>
#include <QStyle>
#include <QGraphicsDropShadowEffect>
#include <QPropertyAnimation>
#include "FlowLayout.h"

// --- History Chip ---
class HistoryChip : public QFrame {
    Q_OBJECT
public:
    HistoryChip(const QString& text, QWidget* parent = nullptr) : QFrame(parent), m_text(text) {
        setAttribute(Qt::WA_StyledBackground);
        setCursor(Qt::PointingHandCursor);
        setObjectName("HistoryChip");
        
        auto* layout = new QHBoxLayout(this);
        layout->setContentsMargins(10, 6, 10, 6);
        layout->setSpacing(10);
        
        auto* lbl = new QLabel(text);
        lbl->setStyleSheet("border: none; background: transparent; color: #DDD; font-size: 13px;");
        layout->addWidget(lbl);
        layout->addStretch();
        
        m_btnDel = new QPushButton();
        m_btnDel->setIcon(IconHelper::getIcon("close", "#666", 16));
        m_btnDel->setIconSize(QSize(10, 10));
        m_btnDel->setFixedSize(16, 16);
        m_btnDel->setCursor(Qt::PointingHandCursor);
        m_btnDel->setStyleSheet(
            "QPushButton {"
            "  background-color: transparent;"
            "  border-radius: 4px;"
            "  padding: 0px;"
            "}"
            "QPushButton:hover {"
            "  background-color: #E74C3C;"
            "}"
        );
        
        connect(m_btnDel, &QPushButton::clicked, this, [this](){ emit deleted(m_text); });
        layout->addWidget(m_btnDel);

        setStyleSheet(
            "#HistoryChip {"
            "  background-color: transparent;"
            "  border: none;"
            "  border-radius: 4px;"
            "}"
            "#HistoryChip:hover {"
            "  background-color: #3E3E42;"
            "}"
        );
    }
    
    void mousePressEvent(QMouseEvent* e) override { 
        if(e->button() == Qt::LeftButton && !m_btnDel->underMouse()) {
            emit clicked(m_text); 
        }
        QFrame::mousePressEvent(e);
    }

signals:
    void clicked(const QString& text);
    void deleted(const QString& text);
private:
    QString m_text;
    QPushButton* m_btnDel;
};

// --- SearchHistoryPopup ---
class SearchHistoryPopup : public QWidget {
    Q_OBJECT
public:
    explicit SearchHistoryPopup(SearchLineEdit* edit) 
        : QWidget(edit->window(), Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint) 
    {
        m_edit = edit;
        setAttribute(Qt::WA_TranslucentBackground);
        
        auto* rootLayout = new QVBoxLayout(this);
        rootLayout->setContentsMargins(m_shadowMargin, m_shadowMargin, m_shadowMargin, m_shadowMargin);
        
        m_container = new QFrame();
        m_container->setObjectName("PopupContainer");
        m_container->setStyleSheet(
            "#PopupContainer {"
            "  background-color: #252526;"
            "  border: 1px solid #444;"
            "  border-radius: 10px;"
            "}"
        );
        rootLayout->addWidget(m_container);

        auto* shadow = new QGraphicsDropShadowEffect(m_container);
        shadow->setBlurRadius(20); shadow->setXOffset(0); shadow->setYOffset(5);
        shadow->setColor(QColor(0, 0, 0, 120));
        m_container->setGraphicsEffect(shadow);

        auto* layout = new QVBoxLayout(m_container);
        layout->setContentsMargins(12, 12, 12, 12);
        layout->setSpacing(10);

        auto* top = new QHBoxLayout();
        auto* icon = new QLabel();
        icon->setPixmap(IconHelper::getIcon("clock", "#888").pixmap(14, 14));
        icon->setStyleSheet("border: none; background: transparent;");
        top->addWidget(icon);

        auto* title = new QLabel("搜索历史");
        title->setStyleSheet("color: #888; font-weight: bold; font-size: 11px; background: transparent; border: none;");
        top->addWidget(title);
        top->addStretch();
        auto* clearBtn = new QPushButton("清空");
        clearBtn->setCursor(Qt::PointingHandCursor);
        clearBtn->setStyleSheet("QPushButton { background: transparent; color: #666; border: none; font-size: 11px; } QPushButton:hover { color: #E74C3C; }");
        connect(clearBtn, &QPushButton::clicked, [this](){
            m_edit->clearHistory();
            refreshUI();
        });
        top->addWidget(clearBtn);
        layout->addLayout(top);

        auto* scroll = new QScrollArea();
        scroll->setWidgetResizable(true);
        scroll->setStyleSheet(
            "QScrollArea { background-color: transparent; border: none; }"
            "QScrollArea > QWidget > QWidget { background-color: transparent; }"
        );
        scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

        m_chipsWidget = new QWidget();
        m_chipsWidget->setStyleSheet("background-color: transparent;");
        m_vLayout = new QVBoxLayout(m_chipsWidget);
        m_vLayout->setContentsMargins(0, 0, 0, 0);
        m_vLayout->setSpacing(2);
        m_vLayout->addStretch();
        scroll->setWidget(m_chipsWidget);
        layout->addWidget(scroll);

        m_opacityAnim = new QPropertyAnimation(this, "windowOpacity");
        m_opacityAnim->setDuration(200);
        m_opacityAnim->setEasingCurve(QEasingCurve::OutCubic);

        refreshUI();
    }

    void refreshUI() {
        QLayoutItem* item;
        while ((item = m_vLayout->takeAt(0))) {
            if(item->widget()) item->widget()->deleteLater();
            delete item;
        }
        m_vLayout->addStretch(); // 底部拉伸
        
        QStringList history = m_edit->getHistory();
        int targetContentWidth = m_edit->width();
        int contentHeight = 0;

        if(history.isEmpty()) {
            auto* lbl = new QLabel("暂无历史记录");
            lbl->setAlignment(Qt::AlignCenter);
            lbl->setStyleSheet("color: #555; font-style: italic; margin: 20px; background: transparent; border: none;");
            m_vLayout->insertWidget(0, lbl);
            contentHeight = 100;
        } else {
            for(const QString& text : history) {
                auto* chip = new HistoryChip(text);
                chip->setFixedHeight(32);
                connect(chip, &HistoryChip::clicked, this, [this](const QString& t){ 
                    m_edit->setText(t); 
                    emit m_edit->returnPressed(); 
                    close(); 
                });
                connect(chip, &HistoryChip::deleted, this, [this](const QString& t){ 
                    m_edit->removeHistoryEntry(t); 
                    refreshUI(); 
                });
                m_vLayout->insertWidget(m_vLayout->count() - 1, chip); // 插入到 stretch 之前
            }
            
            contentHeight = qMin(410, (int)history.size() * 34 + 60);
        }
        
        this->resize(targetContentWidth + (m_shadowMargin * 2), contentHeight + (m_shadowMargin * 2));
    }

    void showAnimated() {
        refreshUI();
        
        // 坐标对齐逻辑
        QPoint pos = m_edit->mapToGlobal(QPoint(0, m_edit->height()));
        int xPos = pos.x() - m_shadowMargin;
        int yPos = pos.y() + 5 - m_shadowMargin; // 5px 间距
        move(xPos, yPos);
        
        setWindowOpacity(0);
        show();
        
        m_opacityAnim->setStartValue(0);
        m_opacityAnim->setEndValue(1);
        m_opacityAnim->start();
    }

private:
    SearchLineEdit* m_edit;
    QFrame* m_container;
    QWidget* m_chipsWidget;
    QVBoxLayout* m_vLayout;
    QPropertyAnimation* m_opacityAnim;
    int m_shadowMargin = 12;
};

// --- SearchLineEdit Implementation ---
SearchLineEdit::SearchLineEdit(QWidget* parent) : QLineEdit(parent) {
    setClearButtonEnabled(true);
    setStyleSheet(
        "QLineEdit { "
        "  background-color: #252526; "
        "  border: 1px solid #333; "
        "  border-radius: 6px; "
        "  padding: 8px 15px; "
        "  color: #eee; "
        "  font-size: 14px; "
        "} "
        "QLineEdit:focus { border: 1px solid #4a90e2; } "
    );
}

void SearchLineEdit::mouseDoubleClickEvent(QMouseEvent* e) {
    if (e->button() == Qt::LeftButton) showPopup();
    QLineEdit::mouseDoubleClickEvent(e);
}

void SearchLineEdit::showPopup() {
    if(!m_popup) m_popup = new SearchHistoryPopup(this);
    m_popup->showAnimated();
}

void SearchLineEdit::addHistoryEntry(const QString& text) {
    if(text.isEmpty()) return;
    QSettings settings("RapidNotes", "SearchHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(text);
    history.prepend(text);
    while(history.size() > 10) history.removeLast();
    settings.setValue("list", history);
}

QStringList SearchLineEdit::getHistory() const {
    QSettings settings("RapidNotes", "SearchHistory");
    return settings.value("list").toStringList();
}

void SearchLineEdit::clearHistory() {
    QSettings settings("RapidNotes", "SearchHistory");
    settings.setValue("list", QStringList());
}

void SearchLineEdit::removeHistoryEntry(const QString& text) {
    QSettings settings("RapidNotes", "SearchHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(text);
    settings.setValue("list", history);
}

#include "SearchLineEdit.moc"
```

## 文件: `src/ui/SearchLineEdit.h`

```cpp
#ifndef SEARCHLINEEDIT_H
#define SEARCHLINEEDIT_H

#include <QLineEdit>
#include <QMouseEvent>

class SearchHistoryPopup;

class SearchLineEdit : public QLineEdit {
    Q_OBJECT
public:
    explicit SearchLineEdit(QWidget* parent = nullptr);
    void addHistoryEntry(const QString& text);
    QStringList getHistory() const;
    void clearHistory();
    void removeHistoryEntry(const QString& text);

protected:
    void mouseDoubleClickEvent(QMouseEvent* e) override;

private:
    void showPopup();
    SearchHistoryPopup* m_popup = nullptr;
};

#endif // SEARCHLINEEDIT_H
```

## 文件: `src/core/ServiceLocator.h`

```cpp
#ifndef SERVICELOCATOR_H
#define SERVICELOCATOR_H

#include <memory>
#include <map>
#include <typeindex>
#include <mutex>

class ServiceLocator {
public:
    template<typename T>
    static void registerService(std::shared_ptr<T> service) {
        std::lock_guard<std::mutex> lock(instance().m_mutex);
        instance().m_services[typeid(T)] = service;
    }

    template<typename T>
    static std::shared_ptr<T> get() {
        std::lock_guard<std::mutex> lock(instance().m_mutex);
        auto it = instance().m_services.find(typeid(T));
        if (it != instance().m_services.end()) {
            return std::static_pointer_cast<T>(it->second);
        }
        return nullptr;
    }

private:
    ServiceLocator() = default;
    static ServiceLocator& instance() {
        static ServiceLocator inst;
        return inst;
    }

    std::map<std::type_index, std::shared_ptr<void>> m_services;
    std::mutex m_mutex;
};

#endif // SERVICELOCATOR_H
```

## 文件: `src/ui/SettingsWindow.cpp`

```cpp
#include "SettingsWindow.h"
#include "CategoryPasswordDialog.h"
#include "../core/HotkeyManager.h"
#include "../core/ShortcutManager.h"
#include <QHBoxLayout>
#include <QSettings>
#include <QFileDialog>
#include <QScrollArea>
#include <QApplication>
#include <QInputDialog>
#include "ToolTipOverlay.h"

#ifdef Q_OS_WIN
#include <windows.h>
#endif

// --- HotkeyEdit 实现 ---
HotkeyEdit::HotkeyEdit(QWidget* parent) : QLineEdit(parent) {
    setReadOnly(true);
    setPlaceholderText("按键设置...");
    setAlignment(Qt::AlignCenter);
    setStyleSheet("QLineEdit { background: #1a1a1a; color: #4a90e2; font-weight: bold; border-radius: 4px; padding: 4px; border: 1px solid #333; }");
}

void HotkeyEdit::setKeyData(uint mods, uint vk) {
    m_mods = mods;
    m_vk = vk;
    setText(keyToString(mods, vk));
}

void HotkeyEdit::keyPressEvent(QKeyEvent* event) {
    int key = event->key();
    if (key == Qt::Key_Escape || key == Qt::Key_Backspace) {
        m_mods = 0;
        m_vk = 0;
        setText("");
        return;
    }

    if (key >= Qt::Key_Control && key <= Qt::Key_Meta) return;

    uint winMods = 0;
    if (event->modifiers() & Qt::ControlModifier) winMods |= 0x0002; // MOD_CONTROL
    if (event->modifiers() & Qt::AltModifier)     winMods |= 0x0001; // MOD_ALT
    if (event->modifiers() & Qt::ShiftModifier)   winMods |= 0x0004; // MOD_SHIFT
    if (event->modifiers() & Qt::MetaModifier)    winMods |= 0x0008; // MOD_WIN

    m_mods = winMods;
    m_vk = event->nativeVirtualKey();
    if (m_vk == 0) m_vk = key; // 兜底处理

    setText(keyToString(m_mods, m_vk));
}

QString HotkeyEdit::keyToString(uint mods, uint vk) {
    if (vk == 0) return "";
    QStringList parts;
    if (mods & 0x0002) parts << "Ctrl";
    if (mods & 0x0001) parts << "Alt";
    if (mods & 0x0004) parts << "Shift";
    if (mods & 0x0008) parts << "Win";
    
    // 简单模拟 VK 到 字符串转换
    QKeySequence ks(vk);
    parts << ks.toString();
    return parts.join(" + ");
}

// --- ShortcutEdit 实现 ---
ShortcutEdit::ShortcutEdit(QWidget* parent) : QLineEdit(parent) {
    setReadOnly(true);
    setPlaceholderText("录制快捷键...");
}

void ShortcutEdit::setKeySequence(const QKeySequence& seq) {
    m_seq = seq;
    setText(m_seq.toString());
}

void ShortcutEdit::keyPressEvent(QKeyEvent* event) {
    int key = event->key();
    if (key == Qt::Key_Escape || key == Qt::Key_Backspace) {
        m_seq = QKeySequence();
        setText("");
        return;
    }
    if (key >= Qt::Key_Control && key <= Qt::Key_Meta) return;

    m_seq = QKeySequence(event->modifiers() | key);
    setText(m_seq.toString());
}

// --- SettingsWindow 实现 ---
SettingsWindow::SettingsWindow(QWidget* parent)
    : FramelessDialog("系统设置", parent)
{
    setFixedSize(700, 500);
    initUi();
    loadSettings();
}

void SettingsWindow::initUi() {
    auto* mainLayout = new QHBoxLayout(m_contentArea);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    // 左侧导航
    m_navBar = new QListWidget();
    m_navBar->setFixedWidth(160);
    m_navBar->setSpacing(0);
    m_navBar->setStyleSheet(
        "QListWidget { background-color: #1e1e1e; border: none; border-right: 1px solid #333; outline: none; padding: 0px; }"
        "QListWidget::item { height: 40px; min-height: 40px; max-height: 40px; padding: 0px; padding-left: 15px; margin: 0px; color: #aaa; border: none; }"
        "QListWidget::item:selected { background-color: #2d2d2d; color: #3a90ff; border-left: 3px solid #3a90ff; }"
        "QListWidget::item:hover { background-color: #252525; }"
    );
    
    QStringList categories = {"安全设置", "全局热键", "局内快捷键", "截图设置", "软件激活"};
    m_navBar->addItems(categories);
    connect(m_navBar, &QListWidget::currentRowChanged, this, &SettingsWindow::onCategoryChanged);

    // 右侧内容
    m_contentStack = new QStackedWidget();
    m_contentStack->addWidget(createSecurityPage());
    m_contentStack->addWidget(createGlobalHotkeyPage());
    m_contentStack->addWidget(createAppShortcutPage());
    m_contentStack->addWidget(createScreenshotPage());
    m_contentStack->addWidget(createActivationPage());

    auto* rightLayout = new QVBoxLayout();
    rightLayout->setContentsMargins(20, 20, 20, 20);
    rightLayout->addWidget(m_contentStack);
    
    // 底部按钮
    auto* btnLayout = new QHBoxLayout();
    
    auto* btnRestore = new QPushButton("恢复默认设置");
    btnRestore->setFixedSize(120, 36);
    btnRestore->setStyleSheet("QPushButton { background: #444; color: #ccc; border-radius: 4px; font-weight: normal; }"
                              "QPushButton:hover { background: #555; color: white; }");
    connect(btnRestore, &QPushButton::clicked, this, &SettingsWindow::onRestoreDefaults);
    btnLayout->addWidget(btnRestore);

    btnLayout->addStretch();
    auto* btnSave = new QPushButton("保存并生效");
    btnSave->setFixedSize(120, 36);
    btnSave->setStyleSheet("QPushButton { background: #3a90ff; color: white; border-radius: 4px; font-weight: bold; }"
                           "QPushButton:hover { background: #2b7ae6; }");
    connect(btnSave, &QPushButton::clicked, this, &SettingsWindow::onSaveClicked);
    btnLayout->addWidget(btnSave);
    rightLayout->addLayout(btnLayout);

    mainLayout->addWidget(m_navBar);
    mainLayout->addLayout(rightLayout);
    
    m_navBar->setCurrentRow(0);
}

QWidget* SettingsWindow::createSecurityPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    layout->setSpacing(20);

    m_lblPwdStatus = new QLabel("当前状态：未设置锁定窗口密码");
    m_lblPwdStatus->setStyleSheet("color: #888; font-size: 14px;");
    layout->addWidget(m_lblPwdStatus);

    m_btnSetPwd = new QPushButton("设置锁定窗口密码");
    m_btnModifyPwd = new QPushButton("修改启动密码");
    m_btnRemovePwd = new QPushButton("彻底移除密码");

    QString btnStyle = "QPushButton { height: 40px; background: #2d2d2d; color: #eee; border: 1px solid #444; border-radius: 6px; }"
                       "QPushButton:hover { background: #3d3d3d; }";
    m_btnSetPwd->setStyleSheet(btnStyle);
    m_btnModifyPwd->setStyleSheet(btnStyle);
    m_btnRemovePwd->setStyleSheet("QPushButton { height: 40px; background: #442222; color: #f66; border: 1px solid #633; border-radius: 6px; }"
                                  "QPushButton:hover { background: #552222; }");

    connect(m_btnSetPwd, &QPushButton::clicked, this, &SettingsWindow::onSetPassword);
    connect(m_btnModifyPwd, &QPushButton::clicked, this, &SettingsWindow::onModifyPassword);
    connect(m_btnRemovePwd, &QPushButton::clicked, this, &SettingsWindow::onRemovePassword);

    layout->addWidget(m_btnSetPwd);
    layout->addWidget(m_btnModifyPwd);
    layout->addWidget(m_btnRemovePwd);
    layout->addStretch();
    return page;
}

QWidget* SettingsWindow::createActivationPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    layout->setSpacing(15);

    layout->addWidget(new QLabel("软件激活："));
    
    m_editSecretKey = new QLineEdit();
    m_editSecretKey->setEchoMode(QLineEdit::Password);
    m_editSecretKey->setPlaceholderText("请输入激活密钥...");
    m_editSecretKey->setStyleSheet("QLineEdit { height: 36px; padding: 0 10px; background: #1a1a1a; color: #fff; border: 1px solid #333; border-radius: 4px; }");
    layout->addWidget(m_editSecretKey);

    auto* btnActivate = new QPushButton("立即激活");
    btnActivate->setFixedHeight(40);
    btnActivate->setStyleSheet("QPushButton { background: #3a90ff; color: white; border-radius: 4px; font-weight: bold; }"
                               "QPushButton:hover { background: #2b7ae6; }");
    connect(btnActivate, &QPushButton::clicked, this, &SettingsWindow::onVerifySecretKey);
    layout->addWidget(btnActivate);

    layout->addWidget(new QLabel("<span style='color: #666; font-size: 11px;'>提示：输入正确的密钥并激活后，系统将重置试用次数。</span>"));

    layout->addStretch();
    return page;
}

#include "../core/DatabaseManager.h"

void SettingsWindow::onVerifySecretKey() {
    QString key = m_editSecretKey->text().trimmed();
    if (key == "CAC90F82-2C22-4B45-BC0C-8B34BA3CE25C") {
        DatabaseManager::instance().resetUsageCount();
        m_editSecretKey->clear();
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            "<b style='color: #2ecc71;'>✅ 激活成功，感谢支持！</b>", 5000, QColor("#2ecc71"));
    } else {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>❌ 密钥错误，激活失败</b>");
    }
}

QWidget* SettingsWindow::createGlobalHotkeyPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    
    auto addRow = [&](const QString& label, HotkeyEdit*& edit) {
        auto* hl = new QHBoxLayout();
        hl->addWidget(new QLabel(label));
        edit = new HotkeyEdit();
        edit->setFixedWidth(200);
        hl->addWidget(edit);
        layout->addLayout(hl);
    };

    layout->addWidget(new QLabel("系统全局热键，修改后点击保存立即生效："));
    layout->addSpacing(10);
    addRow("激活极速窗口:", m_hkQuickWin);
    addRow("快速收藏/加星:", m_hkFavorite);
    addRow("截图功能:", m_hkScreenshot);
    addRow("截图取文 (OCR):", m_hkOcr);
    
    layout->addStretch();
    return page;
}

QWidget* SettingsWindow::createAppShortcutPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    
    auto* scroll = new QScrollArea();
    scroll->setWidgetResizable(true);
    scroll->setStyleSheet("QScrollArea { border: none; background: transparent; }");
    
    auto* container = new QWidget();
    auto* vLayout = new QVBoxLayout(container);
    
    auto& sm = ShortcutManager::instance();
    QString currentCat = "";
    
    for (const auto& info : sm.getAllShortcuts()) {
        if (info.category != currentCat) {
            currentCat = info.category;
            auto* catLabel = new QLabel(currentCat);
            catLabel->setStyleSheet("color: #3a90ff; font-weight: bold; margin-top: 15px; border-bottom: 1px solid #333;");
            vLayout->addWidget(catLabel);
        }
        
        auto* row = new QHBoxLayout();
        row->addWidget(new QLabel(info.description));
        auto* edit = new ShortcutEdit();
        edit->setKeySequence(sm.getShortcut(info.id));
        edit->setProperty("id", info.id);
        edit->setFixedWidth(150);
        row->addWidget(edit);
        vLayout->addLayout(row);
    }
    
    scroll->setWidget(container);
    layout->addWidget(scroll);
    return page;
}

QWidget* SettingsWindow::createScreenshotPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    
    layout->addWidget(new QLabel("截图自动保存路径："));
    auto* row = new QHBoxLayout();
    m_editScreenshotPath = new QLineEdit();
    row->addWidget(m_editScreenshotPath);
    
    auto* btnBrowse = new QPushButton("浏览...");
    connect(btnBrowse, &QPushButton::clicked, this, &SettingsWindow::onBrowsePath);
    row->addWidget(btnBrowse);
    layout->addLayout(row);
    
    layout->addWidget(new QLabel("提示：若未设置，默认保存至程序目录下的 /RPN_screenshot"));
    layout->addStretch();
    return page;
}

void SettingsWindow::onCategoryChanged(int index) {
    m_contentStack->setCurrentIndex(index);
}

void SettingsWindow::loadSettings() {
    // 1. 加载安全设置
    updateSecurityUI();

    // 2. 加载全局热键
    QSettings hotkeys("RapidNotes", "Hotkeys");
    m_hkQuickWin->setKeyData(hotkeys.value("quickWin_mods", 0x0001).toUInt(), hotkeys.value("quickWin_vk", 0x20).toUInt());
    m_hkFavorite->setKeyData(hotkeys.value("favorite_mods", 0x0002 | 0x0004).toUInt(), hotkeys.value("favorite_vk", 0x45).toUInt());
    m_hkScreenshot->setKeyData(hotkeys.value("screenshot_mods", 0x0002 | 0x0001).toUInt(), hotkeys.value("screenshot_vk", 0x41).toUInt());
    m_hkOcr->setKeyData(hotkeys.value("ocr_mods", 0x0002 | 0x0001).toUInt(), hotkeys.value("ocr_vk", 0x51).toUInt());

    // 3. 局内快捷键在创建页面时已加载

    // 4. 加载截图路径
    QSettings ss("RapidNotes", "Screenshot");
    m_editScreenshotPath->setText(ss.value("savePath", qApp->applicationDirPath() + "/RPN_screenshot").toString());
}

void SettingsWindow::updateSecurityUI() {
    QSettings settings("RapidNotes", "QuickWindow");
    bool hasPwd = !settings.value("appPassword").toString().isEmpty();
    
    m_btnSetPwd->setVisible(!hasPwd);
    m_btnModifyPwd->setVisible(hasPwd);
    m_btnRemovePwd->setVisible(hasPwd);
    m_lblPwdStatus->setText(hasPwd ? "当前状态：已启用启动密码" : "当前状态：未设置锁定窗口密码");
}

void SettingsWindow::onSetPassword() {
    CategoryPasswordDialog dlg("设置锁定窗口密码", this);
    if (dlg.exec() == QDialog::Accepted) {
        QSettings settings("RapidNotes", "QuickWindow");
        settings.setValue("appPassword", dlg.password());
        settings.setValue("appPasswordHint", dlg.passwordHint());
        updateSecurityUI();
    }
}

void SettingsWindow::onModifyPassword() {
    // 简单起见，这里复用对话框，逻辑上通常先验证旧密码，这里按提示直接覆盖或弹出交互
    CategoryPasswordDialog dlg("修改启动密码", this);
    QSettings settings("RapidNotes", "QuickWindow");
    dlg.setInitialData(settings.value("appPasswordHint").toString());
    if (dlg.exec() == QDialog::Accepted) {
        settings.setValue("appPassword", dlg.password());
        settings.setValue("appPasswordHint", dlg.passwordHint());
        updateSecurityUI();
    }
}

void SettingsWindow::onRemovePassword() {
    // 移除前需要验证（此处为了逻辑闭环简单弹窗验证，或要求输入当前密码）
    QSettings settings("RapidNotes", "QuickWindow");
    QString realPwd = settings.value("appPassword").toString();

    // 弹出简单对话框要求确认
    bool ok = false;
    QString input = QInputDialog::getText(this, "身份验证", "请输入当前密码以移除：", QLineEdit::Password, "", &ok);
    if (ok && input == realPwd) {
        settings.remove("appPassword");
        settings.remove("appPasswordHint");
        updateSecurityUI();
    } else if (ok) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            "<b style='color: #e74c3c;'>❌ 密码错误，无法移除</b>");
    }
}

void SettingsWindow::onBrowsePath() {
    QString dir = QFileDialog::getExistingDirectory(this, "选择截图保存目录", m_editScreenshotPath->text());
    if (!dir.isEmpty()) {
        m_editScreenshotPath->setText(dir);
    }
}

void SettingsWindow::onSaveClicked() {
    // 1. 保存全局热键
    QSettings hotkeys("RapidNotes", "Hotkeys");
    hotkeys.setValue("quickWin_mods", m_hkQuickWin->mods());
    hotkeys.setValue("quickWin_vk", m_hkQuickWin->vk());
    hotkeys.setValue("favorite_mods", m_hkFavorite->mods());
    hotkeys.setValue("favorite_vk", m_hkFavorite->vk());
    hotkeys.setValue("screenshot_mods", m_hkScreenshot->mods());
    hotkeys.setValue("screenshot_vk", m_hkScreenshot->vk());
    hotkeys.setValue("ocr_mods", m_hkOcr->mods());
    hotkeys.setValue("ocr_vk", m_hkOcr->vk());
    
    HotkeyManager::instance().reapplyHotkeys();

    // 2. 保存局内快捷键
    auto& sm = ShortcutManager::instance();
    auto edits = m_contentStack->widget(2)->findChildren<ShortcutEdit*>();
    for (auto* edit : edits) {
        sm.setShortcut(edit->property("id").toString(), edit->keySequence());
    }
    sm.save();

    // 3. 保存截图设置
    QSettings ss("RapidNotes", "Screenshot");
    ss.setValue("savePath", m_editScreenshotPath->text());

    ToolTipOverlay::instance()->showText(QCursor::pos(), 
        "<b style='color: #2ecc71;'>✅ 设置已保存并立即生效</b>");
}

void SettingsWindow::onRestoreDefaults() {
    bool ok = false;
    QString input = QInputDialog::getText(this, "恢复默认设置", 
                                          "确认恢复默认设置？所有配置都将被重置。\n请输入“confirm”以继续：", 
                                          QLineEdit::Normal, "", &ok);
    
    if (ok && input.toLower() == "confirm") {
        // 1. 清除各部分的设置
        QSettings("RapidNotes", "Hotkeys").clear();
        QSettings("RapidNotes", "QuickWindow").clear();
        QSettings("RapidNotes", "Screenshot").clear();
        
        // 2. 局内快捷键重置
        ShortcutManager::instance().resetToDefaults();
        ShortcutManager::instance().save();
        
        // 3. 立即重载热键
        HotkeyManager::instance().reapplyHotkeys();
        
        // 4. 重新加载界面
        loadSettings();
        
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            "<b style='color: #3498db;'>ℹ️ 已恢复默认设置</b>");
    }
}
```

## 文件: `src/ui/SettingsWindow.h`

```cpp
#ifndef SETTINGSWINDOW_H
#define SETTINGSWINDOW_H

#include "FramelessDialog.h"
#include <QLineEdit>
#include <QKeySequence>
#include <QKeyEvent>
#include <QPushButton>
#include <QLabel>
#include <QListWidget>
#include <QStackedWidget>
#include <QVBoxLayout>

/**
 * @brief 全局热键捕获控件
 */
class HotkeyEdit : public QLineEdit {
    Q_OBJECT
public:
    explicit HotkeyEdit(QWidget* parent = nullptr);
    void setKeyData(uint mods, uint vk);
    uint mods() const { return m_mods; }
    uint vk() const { return m_vk; }

protected:
    void keyPressEvent(QKeyEvent* event) override;

private:
    uint m_mods = 0;
    uint m_vk = 0;
    QString keyToString(uint mods, uint vk);
};

/**
 * @brief 局内快捷键捕获控件
 */
class ShortcutEdit : public QLineEdit {
    Q_OBJECT
public:
    explicit ShortcutEdit(QWidget* parent = nullptr);
    void setKeySequence(const QKeySequence& seq);
    QKeySequence keySequence() const { return m_seq; }

protected:
    void keyPressEvent(QKeyEvent* event) override;

private:
    QKeySequence m_seq;
};

/**
 * @brief 设置窗口
 */
class SettingsWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit SettingsWindow(QWidget* parent = nullptr);

private slots:
    void onCategoryChanged(int index);
    void onSaveClicked();
    void onRestoreDefaults();
    
    // 安全设置相关
    void onSetPassword();
    void onModifyPassword();
    void onRemovePassword();
    void updateSecurityUI();

    // 软件激活相关
    void onVerifySecretKey();

    // 截图设置相关
    void onBrowsePath();

private:
    void initUi();
    void loadSettings();
    
    QWidget* createSecurityPage();
    QWidget* createGlobalHotkeyPage();
    QWidget* createAppShortcutPage();
    QWidget* createScreenshotPage();
    QWidget* createActivationPage();

    QListWidget* m_navBar;
    QStackedWidget* m_contentStack;

    // 安全设置组件
    QPushButton* m_btnSetPwd;
    QPushButton* m_btnModifyPwd;
    QPushButton* m_btnRemovePwd;
    QLabel* m_lblPwdStatus;

    // 全局热键组件
    HotkeyEdit* m_hkQuickWin;
    HotkeyEdit* m_hkFavorite;
    HotkeyEdit* m_hkScreenshot;
    HotkeyEdit* m_hkOcr;

    // 截图设置组件
    QLineEdit* m_editScreenshotPath;

    // 软件激活组件
    QLineEdit* m_editSecretKey;
};

#endif // SETTINGSWINDOW_H
```

## 文件: `src/core/ShortcutManager.cpp`

```cpp
#include "ShortcutManager.h"

ShortcutManager& ShortcutManager::instance() {
    static ShortcutManager inst;
    return inst;
}

ShortcutManager::ShortcutManager(QObject* parent) : QObject(parent) {
    initDefaults();
    load();
}

void ShortcutManager::initDefaults() {
    auto add = [&](const QString& id, const QString& desc, const QString& def, const QString& cat) {
        m_shortcuts[id] = {id, desc, QKeySequence(def), cat};
    };

    // QuickWindow shortcuts
    add("qw_search", "搜索灵感", "Ctrl+F", "极速窗口");
    add("qw_delete_soft", "移至回收站", "Delete", "极速窗口");
    add("qw_delete_hard", "彻底删除", "Shift+Delete", "极速窗口");
    add("qw_favorite", "切换书签状态", "Ctrl+E", "极速窗口");
    add("qw_preview", "快速预览内容", "Space", "极速窗口");
    add("qw_pin", "置顶/取消置顶项目", "Ctrl+P", "极速窗口");
    add("qw_close", "关闭窗口", "Ctrl+W", "极速窗口");
    add("qw_lock_item", "锁定/解锁项目", "Ctrl+S", "极速窗口");
    add("qw_new_idea", "新建灵感", "Ctrl+N", "极速窗口");
    add("qw_select_all", "全选列表", "Ctrl+A", "极速窗口");
    add("qw_extract", "提取内容到剪贴板", "Ctrl+C", "极速窗口");
    add("qw_lock_cat", "立即锁定当前分类", "Ctrl+Shift+L", "极速窗口");
    add("qw_stay_on_top", "切换窗口置顶", "Alt+D", "极速窗口");
    add("qw_toggle_main", "打开主窗口", "Alt+W", "极速窗口");
    add("qw_toolbox", "打开工具箱", "Ctrl+Shift+T", "极速窗口");
    add("qw_edit", "编辑选中项", "Ctrl+B", "极速窗口");
    add("qw_sidebar", "显示/隐藏侧边栏", "Ctrl+Q", "极速窗口");
    add("qw_prev_page", "上一页", "Alt+S", "极速窗口");
    add("qw_next_page", "下一页", "Alt+X", "极速窗口");
    add("qw_copy_tags", "复制标签", "Ctrl+Shift+C", "极速窗口");
    add("qw_paste_tags", "粘贴标签", "Ctrl+Shift+V", "极速窗口");
    for (int i = 0; i <= 5; ++i) {
        add(QString("qw_rating_%1").arg(i), QString("设置星级 %1").arg(i), QString("Ctrl+%1").arg(i), "极速窗口");
    }

    // MainWindow shortcuts
    add("mw_filter", "开启高级筛选", "Ctrl+G", "主窗口");
    add("mw_preview", "预览选中项", "Space", "主窗口");
    add("mw_meta", "开启元数据面板", "Ctrl+I", "主窗口");
    add("mw_refresh", "刷新列表", "F5", "主窗口");
    add("mw_search", "聚焦搜索框", "Ctrl+F", "主窗口");
    add("mw_new", "新建笔记", "Ctrl+N", "主窗口");
    add("mw_favorite", "切换书签状态", "Ctrl+E", "主窗口");
    add("mw_pin", "置顶/取消置顶", "Ctrl+P", "主窗口");
    add("mw_save", "保存笔记/锁定项", "Ctrl+S", "主窗口");
    add("mw_edit", "编辑笔记", "Ctrl+B", "主窗口");
    add("mw_extract", "提取内容", "Ctrl+C", "主窗口");
    add("mw_lock_cat", "锁定分类", "Ctrl+Shift+L", "主窗口");
    add("mw_delete_soft", "移至回收站", "Delete", "主窗口");
    add("mw_delete_hard", "彻底删除", "Shift+Delete", "主窗口");
    add("mw_copy_tags", "复制标签", "Ctrl+Shift+C", "主窗口");
    add("mw_paste_tags", "粘贴标签", "Ctrl+Shift+V", "主窗口");
    add("mw_close", "关闭窗口", "Ctrl+W", "主窗口");
    for (int i = 0; i <= 5; ++i) {
        add(QString("mw_rating_%1").arg(i), QString("设置星级 %1").arg(i), QString("Ctrl+%1").arg(i), "主窗口");
    }

    // NoteEditWindow
    add("ed_save", "保存修改", "Ctrl+S", "编辑器");
    add("ed_close", "关闭编辑器", "Ctrl+W", "编辑器");
    add("ed_search", "内容内查找", "Ctrl+F", "编辑器");

    // QuickPreview
    add("pv_prev", "上一个项目", "Alt+Up", "预览窗");
    add("pv_next", "下一个项目", "Alt+Down", "预览窗");
    add("pv_back", "历史后退", "Alt+Left", "预览窗");
    add("pv_forward", "历史前进", "Alt+Right", "预览窗");
    add("pv_copy", "复制内容", "Ctrl+C", "预览窗");
    add("pv_edit", "编辑项目", "Ctrl+B", "预览窗");
    add("pv_close", "关闭预览", "Ctrl+W", "预览窗");
    add("pv_search", "内容内查找", "Ctrl+F", "预览窗");

    // FileSearch & KeywordSearch
    add("fs_select_all", "全选结果", "Ctrl+A", "搜索窗口");
    add("fs_copy", "复制选中内容", "Ctrl+C", "搜索窗口");
    add("fs_delete", "删除选中项", "Delete", "搜索窗口");
    add("fs_scan", "开始/重新扫描", "F5", "搜索窗口");

    add("ks_search", "执行搜索", "Ctrl+F", "关键字搜索");
    add("ks_replace", "执行替换", "Ctrl+R", "关键字搜索");
    add("ks_undo", "撤销上次替换", "Ctrl+Z", "关键字搜索");
    add("ks_swap", "交换查找与替换内容", "Ctrl+Shift+S", "关键字搜索");
}

QKeySequence ShortcutManager::getShortcut(const QString& id) const {
    if (m_customKeys.contains(id)) return m_customKeys[id];
    if (m_shortcuts.contains(id)) return m_shortcuts[id].defaultKey;
    return QKeySequence();
}

void ShortcutManager::setShortcut(const QString& id, const QKeySequence& key) {
    m_customKeys[id] = key;
}

QList<ShortcutManager::ShortcutInfo> ShortcutManager::getShortcutsByCategory(const QString& category) const {
    QList<ShortcutInfo> result;
    for (const auto& info : m_shortcuts) {
        if (info.category == category) result << info;
    }
    return result;
}

void ShortcutManager::save() {
    QSettings settings("RapidNotes", "InternalHotkeys");
    settings.beginGroup("Custom");
    for (auto it = m_customKeys.begin(); it != m_customKeys.end(); ++it) {
        settings.setValue(it.key(), it.value().toString());
    }
    settings.endGroup();
    emit shortcutsChanged();
}

void ShortcutManager::load() {
    QSettings settings("RapidNotes", "InternalHotkeys");
    settings.beginGroup("Custom");
    QStringList keys = settings.allKeys();
    for (const QString& key : keys) {
        m_customKeys[key] = QKeySequence(settings.value(key).toString());
    }
    settings.endGroup();
}

void ShortcutManager::resetToDefaults() {
    m_customKeys.clear();
    QSettings settings("RapidNotes", "InternalHotkeys");
    settings.remove("Custom");
    emit shortcutsChanged();
}
```

## 文件: `src/core/ShortcutManager.h`

```cpp
#ifndef SHORTCUTMANAGER_H
#define SHORTCUTMANAGER_H

#include <QObject>
#include <QKeySequence>
#include <QMap>
#include <QString>
#include <QSettings>

class ShortcutManager : public QObject {
    Q_OBJECT
public:
    struct ShortcutInfo {
        QString id;
        QString description;
        QKeySequence defaultKey;
        QString category;
    };

    static ShortcutManager& instance();

    QKeySequence getShortcut(const QString& id) const;
    void setShortcut(const QString& id, const QKeySequence& key);
    
    QList<ShortcutInfo> getAllShortcuts() const { return m_shortcuts.values(); }
    QList<ShortcutInfo> getShortcutsByCategory(const QString& category) const;

    void save();
    void load();
    void resetToDefaults();

signals:
    void shortcutsChanged();

private:
    ShortcutManager(QObject* parent = nullptr);
    void initDefaults();

    QMap<QString, ShortcutInfo> m_shortcuts;
    QMap<QString, QKeySequence> m_customKeys;
};

#endif // SHORTCUTMANAGER_H
```

## 文件: `src/ui/StringUtils.h`

```cpp
#ifndef STRINGUTILS_H
#define STRINGUTILS_H

#include <QString>
#include <QTextDocument>
#include <QMimeData>
#include <QClipboard>
#include <QApplication>
#include <QRegularExpression>
#include <QSettings>
#include <QVariantList>
#include <QUrl>
#include <vector>
#include "../core/ClipboardMonitor.h"

#ifdef Q_OS_WIN
#include <windows.h>
#endif

class StringUtils {
public:
    /**
     * @brief 智能语言拆分：中文作为标题，非中文作为内容
     */
    static void smartSplitLanguage(const QString& text, QString& title, QString& content) {
        QString trimmedText = text.trimmed();
        if (trimmedText.isEmpty()) {
            title = "新笔记";
            content = "";
            return;
        }

        // 匹配中文字符范围
        static QRegularExpression chineseRegex("[\\x{4e00}-\\x{9fa5}]+");
        // 匹配非中文且非空白非标点的字符（识别泰文、英文等）
        static QRegularExpression otherRegex("[^\\x{4e00}-\\x{9fa5}\\s\\p{P}]+");

        bool hasChinese = trimmedText.contains(chineseRegex);
        bool hasOther = trimmedText.contains(otherRegex);

        if (hasChinese && hasOther) {
            // 提取所有中文块作为标题
            QStringList chineseBlocks;
            QRegularExpressionMatchIterator i = chineseRegex.globalMatch(trimmedText);
            while (i.hasNext()) {
                chineseBlocks << i.next().captured();
            }
            title = chineseBlocks.join(" ").simplified();
            if (title.isEmpty()) title = "未命名";

            // 移除中文块后的剩余部分作为内容
            QString remaining = trimmedText;
            remaining.replace(chineseRegex, " ");
            content = remaining.simplified();
            
            // 如果拆分后内容为空（例如全是标点），则保留全文
            if (content.isEmpty()) content = trimmedText;
        } else {
            // 单一语种或无法识别：首行作为标题，全文作为内容
            QStringList lines = trimmedText.split('\n', Qt::SkipEmptyParts);
            if (!lines.isEmpty()) {
                title = lines[0].trimmed();
                if (title.length() > 60) title = title.left(57) + "...";
                content = trimmedText;
            } else {
                title = "新笔记";
                content = trimmedText;
            }
        }
    }

    /**
     * @brief 智能识别语言：判断文本是否包含中文
     */
    static bool containsChinese(const QString& text) {
        static QRegularExpression chineseRegex("[\\x{4e00}-\\x{9fa5}]+");
        return text.contains(chineseRegex);
    }

    /**
     * @brief 偶数行配对拆分：每两行为一组
     * 规则：含中文的行为标题，若同语种则第一行为标题。
     */
    static QList<QPair<QString, QString>> smartSplitPairs(const QString& text) {
        QList<QPair<QString, QString>> results;
        QStringList lines = text.split('\n', Qt::SkipEmptyParts);
        
        if (lines.isEmpty()) return results;

        // 如果是偶数行，执行配对逻辑
        if (lines.size() > 0 && lines.size() % 2 == 0) {
            for (int i = 0; i < lines.size(); i += 2) {
                QString line1 = lines[i].trimmed();
                QString line2 = lines[i+1].trimmed();
                
                bool c1 = containsChinese(line1);
                bool c2 = containsChinese(line2);
                
                if (c1 && !c2) {
                    results.append({line1, line2});
                } else if (!c1 && c2) {
                    results.append({line2, line1});
                } else {
                    // 同语种，第一行为标题
                    results.append({line1, line2});
                }
            }
        } else {
            // 奇数行或单行，沿用之前的单条逻辑
            QString title, content;
            smartSplitLanguage(text, title, content);
            results.append({title, content});
        }
        
        return results;
    }

public:
    static bool isHtml(const QString& text) {
        return text.contains("<!DOCTYPE HTML") || text.contains("<html>") || text.contains("<style");
    }

    static QString htmlToPlainText(const QString& html) {
        if (!isHtml(html)) return html;
        QTextDocument doc;
        doc.setHtml(html);
        return doc.toPlainText();
    }

    static void copyNoteToClipboard(const QString& content) {
        ClipboardMonitor::instance().skipNext();
        QMimeData* mimeData = new QMimeData();
        if (isHtml(content)) {
            mimeData->setHtml(content);
            mimeData->setText(htmlToPlainText(content));
        } else {
            mimeData->setText(content);
        }
        QApplication::clipboard()->setMimeData(mimeData);
    }

    /**
     * @brief 简繁转换 (利用 Windows 原生 API)
     * @param toSimplified true 为转简体，false 为转繁体
     */
    static QString convertChineseVariant(const QString& text, bool toSimplified) {
#ifdef Q_OS_WIN
        if (text.isEmpty()) return text;
        
        // 转换为宽字符
        std::wstring wstr = text.toStdWString();
        DWORD flags = toSimplified ? LCMAP_SIMPLIFIED_CHINESE : LCMAP_TRADITIONAL_CHINESE;
        
        // 第一次调用获取长度
        int size = LCMapStringEx(LOCALE_NAME_USER_DEFAULT, flags, wstr.c_str(), -1, NULL, 0, NULL, NULL, 0);
        if (size > 0) {
            std::vector<wchar_t> buffer(size);
            // 第二次调用执行转换
            LCMapStringEx(LOCALE_NAME_USER_DEFAULT, flags, wstr.c_str(), -1, buffer.data(), size, NULL, NULL, 0);
            return QString::fromWCharArray(buffer.data());
        }
#endif
        return text;
    }

    /**
     * @brief 记录最近访问或使用的分类
     */
    static void recordRecentCategory(int catId) {
        if (catId <= 0) return;
        QSettings settings("RapidNotes", "QuickWindow");
        QVariantList recentCats = settings.value("recentCategories").toList();
        
        // 转换为 int 列表方便操作
        QList<int> ids;
        for(const auto& v : recentCats) ids << v.toInt();
        
        ids.removeAll(catId);
        ids.prepend(catId);
        
        // 限制为最近 10 个
        while (ids.size() > 10) ids.removeLast();
        
        QVariantList result;
        for(int id : ids) result << id;
        settings.setValue("recentCategories", result);
        settings.sync();
    }

    /**
     * @brief 获取最近访问或使用的分类 ID 列表
     */
    static QVariantList getRecentCategories() {
        QSettings settings("RapidNotes", "QuickWindow");
        return settings.value("recentCategories").toList();
    }
};

#endif // STRINGUTILS_H
```

## 文件: `src/ui/SvgIcons.h`

```cpp
#ifndef SVGICONS_H
#define SVGICONS_H

#include <QString>
#include <QMap>

namespace SvgIcons {
    inline const QMap<QString, QString> icons = {
        {"text", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="11" x2="14" y2="11"></line><line x1="4" y1="16" x2="20" y2="16"></line><line x1="4" y1="21" x2="14" y2="21"></line></svg>)svg"},
        {"untagged", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line><path d="M11 11l4 4m0-4l-4 4" /></svg>)svg"},
        {"tag", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>)svg"},
        {"file", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>)svg"},
        {"code", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>)svg"},
        {"link", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>)svg"},
        {"image", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>)svg"},
        {"branch", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="3"></circle><path d="M12 8v5"></path><path d="M12 13l-5 4"></path><path d="M12 13l5 4"></path><circle cx="7" cy="19" r="3"></circle><circle cx="17" cy="19" r="3"></circle></svg>)svg"},
        {"category", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="8" y="2" width="8" height="6" rx="1"></rect><path d="M12 8 v3"></path><path d="M12 11 h-6"></path><path d="M12 11 h6"></path><rect x="2" y="13" width="8" height="5" rx="1"></rect><rect x="14" y="13" width="8" height="5" rx="1"></rect><circle cx="12" cy="5" r="1" fill="currentColor"></circle><circle cx="6" cy="15.5" r="1" fill="currentColor"></circle><circle cx="18" cy="15.5" r="1" fill="currentColor"></circle></svg>)svg"},
        {"uncategorized", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5 8 C5 4 10 4 10 8 C10 11 7 12 7 14" /><circle cx="7" cy="19" r="1" fill="currentColor" stroke="none"/><path d="M14 5 v14" /><path d="M14 6 h3" /> <circle cx="20" cy="6" r="2" /><path d="M14 12 h3" /> <circle cx="20" cy="12" r="2" /><path d="M14 18 h3" /> <circle cx="20" cy="18" r="2" /></svg>)svg"},
        {"trash", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><line x1="10" y1="11" x2="10" y2="17" /><line x1="14" y1="11" x2="14" y2="17" /></svg>)svg"},
        {"refresh", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6"></path><path d="M2.5 22v-6h6"></path><path d="M21.5 8A10 10 0 0 0 6 3.5l-3.5 4"></path><path d="M2.5 16A10 10 0 0 0 18 20.5l3.5-4"></path><circle cx="12" cy="12" r="1.5" fill="currentColor" opacity="0.3"></circle></svg>)svg"},
        {"search", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>)svg"},
        {"add", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>)svg"},
        {"edit", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>)svg"},
        {"bookmark", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>)svg"},
        {"star", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>)svg"},
        {"location", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>)svg"},
        {"pin", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 12V6H8v6l-2 2v2h5v8l1 1 1-1v-8h5v-2l-2-2z"></path></svg>)svg"},
        {"lock", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>)svg"},
        {"lock_secure", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><path fill-rule="evenodd" d="M12 2a5 5 0 0 0-5 5v3H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2h-1V7a5 5 0 0 0-5-5zM9 10V7a3 3 0 0 1 6 0v3H9zm3 4a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm-0.75 3h1.5v3h-1.5v-3z" clip-rule="evenodd"/></svg>)svg"},
        // 专门用于"密码生成器"的图标：锁+密码位样式
        {"password_generator", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M16 11V7a4 4 0 0 0-8 0v4" />
            <rect x="3" y="11" width="13" height="10" rx="2" />
            <rect x="11" y="14" width="11" height="7" rx="3.5" />
            <rect x="13.5" y="16.5" width="1.5" height="1.5" fill="currentColor" stroke="none" />
            <rect x="16.25" y="16.5" width="1.5" height="1.5" fill="currentColor" stroke="none" />
            <rect x="19" y="16.5" width="1.5" height="1.5" fill="currentColor" stroke="none" />
        </svg>)svg"},
        {"message", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 15a2 2 0 0 0 2 2h12l4 4V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2z"></path><line x1="8" y1="9" x2="16" y2="9"></line><line x1="8" y1="13" x2="14" y2="13"></line></svg>)svg"},
        {"eye", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>)svg"},
        {"toolbox", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M6 7V5a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v2"></path><line x1="12" y1="12" x2="12" y2="16"></line><line x1="8" y1="12" x2="8" y2="16"></line><line x1="16" y1="12" x2="16" y2="16"></line></svg>)svg"},
        {"today", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>)svg"},
        {"all_data", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path></svg>)svg"},
        {"sidebar", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>)svg"},
        {"sidebar_right", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="15" y1="3" x2="15" y2="21"></line></svg>)svg"},
        {"nav_first", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline></svg>)svg"},
        {"nav_prev", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>)svg"},
        {"nav_next", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>)svg"},
        {"nav_last", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline></svg>)svg"},
        {"undo", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path></svg>)svg"},
        {"coffee", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8h1a4 4 0 0 1 0 8h-1"/><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"/><line x1="6" y1="1" x2="6" y2="4"/><line x1="10" y1="1" x2="10" y2="4"/><line x1="14" y1="1" x2="14" y2="4"/></svg>)svg"},
        {"grid", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/></svg>)svg"},
        {"book", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20v2H6.5A2.5 2.5 0 0 1 4 19.5z"/><path d="M4 5.5A2.5 2.5 0 0 1 6.5 3H20v2H6.5A2.5 2.5 0 0 1 4 5.5z"/></svg>)svg"},
        {"leaf", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 12c0-4.42-3.58-8-8-8S4 7.58 4 12s3.58 8 8 8 8-3.58 8-8z"/><path d="M12 2a10 10 0 0 0-10 10h20a10 10 0 0 0-10-10z"/></svg>)svg"},
        {"book_open", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>)svg"},
        {"redo", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"></path><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"></path></svg>)svg"},
        {"list_ul", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>)svg"},
        {"list_ol", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="10" y1="6" x2="21" y2="6"></line><line x1="10" y1="12" x2="21" y2="12"></line><line x1="10" y1="18" x2="21" y2="18"></line><path d="M4 6h1v4"></path><path d="M4 10h2"></path><path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"></path></svg>)svg"},
        {"todo", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><path d="M9 12l2 2 4-4"></path></svg>)svg"},
        {"close", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>)svg"},
        {"save", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>)svg"},
        {"filter", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>)svg"},
        {"select", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>)svg"},
        {"grip_diagonal", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="19" cy="19" r="1"></circle><circle cx="19" cy="14" r="1"></circle><circle cx="14" cy="19" r="1"></circle><circle cx="19" cy="9" r="1"></circle><circle cx="14" cy="14" r="1"></circle><circle cx="9" cy="19" r="1"></circle></svg>)svg"},
        {"folder", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>)svg"},
        {"file_managed", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M12 18h6v3h-6z" fill="currentColor" stroke="none" /><path d="M12 15h6v1h-6z" fill="currentColor" stroke="none" /></svg>)svg"},
        {"folder_managed", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><path d="M12 18h8v3h-8z" fill="currentColor" stroke="none" /><path d="M12 15h8v1h-8z" fill="currentColor" stroke="none" /></svg>)svg"},
        {"settings", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>)svg"},
        {"calendar", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>)svg"},
        {"clock", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>)svg"},
        {"palette", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="13.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="10.5" r="2.5"></circle><circle cx="8.5" cy="7.5" r="2.5"></circle><circle cx="6.5" cy="12.5" r="2.5"></circle><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"></path></svg>)svg"},
        {"zap", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>)svg"},
        {"monitor", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>)svg"},
        {"power", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line></svg>)svg"},
        {"minimize", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>)svg"},
        {"maximize", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>)svg"},
        {"restore", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="10" height="10" rx="1"></rect><rect x="11" y="3" width="10" height="10" rx="1"></rect></svg>)svg"},
        {"copy", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>)svg"},
        {"pin_vertical", R"svg(<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M16 9V4h1c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 1.66-1.34 3-3 3v2h5.97v7l1.03 1 1.03-1v-7H19v-2c-1.66 0-3-1.34-3-3z"></path></svg>)svg"},
        {"pin_tilted", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" transform="rotate(45 12 12)"><path d="M16 12V6H8v6l-2 2v2h5v8l1 1 1-1v-8h5v-2l-2-2z"></path></svg>)svg"},
        {"star_filled", R"svg(<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>)svg"},
        {"bookmark_filled", R"svg(<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>)svg"},
        {"circle_filled", R"svg(<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="8"></circle></svg>)svg"},
        {"edit_clear", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.5 19H9a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h8.5L22 12l-4.5 7z"></path><path d="M12 9l4 4"></path><path d="M16 9l-4 4"></path></svg>)svg"},
        {"no_color", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>)svg"},
        {"random_color", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>)svg"},
        {"screen_picker", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 2 4 4"/><path d="m17 7 3-3"/><path d="M19 9 8.7 19.3c-1 1-2.5 1-3.4 0l-.6-.6c-1-1-1-2.5 0-3.4L15 5"/><path d="m9 11 4 4"/><path d="m5 19-3 3"/><path d="m14 4 6 6"/></svg>)svg"},
        {"pixel_ruler", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2" transform="rotate(45 12 12)"/><path d="m8.5 9.5 1 1"/><path d="m11 12 1 1"/><path d="m13.5 14.5 1 1"/><path d="m16 17 1 1"/></svg>)svg"},
        {"ruler_bounds", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 8V4h4m8 0h4v4m0 8v4h-4M8 20H4v-4"/></svg>)svg"},
        {"ruler_spacing", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 4v16m-8-8h16"/></svg>)svg"},
        {"ruler_hor", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="2" y1="12" x2="22" y2="12"/><line x1="2" y1="8" x2="2" y2="16"/><line x1="22" y1="8" x2="22" y2="16"/></svg>)svg"},
        {"ruler_ver", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="2" x2="12" y2="22"/><line x1="8" y1="2" x2="16" y2="2"/><line x1="8" y1="22" x2="16" y2="22"/></svg>)svg"},
        {"screenshot_rect", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>)svg"},
        {"screenshot_fill", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>)svg"},
        {"screenshot_ellipse", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>)svg"},
        {"screenshot_arrow", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><path d="M22 2L11 5L14 8L4 18L6 20L16 10L19 13L22 2Z"/></svg>)svg"},
        {"screenshot_pen", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg>)svg"},
        {"screenshot_marker", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><text x="12" y="16" text-anchor="middle" font-size="12" font-weight="bold" fill="currentColor">1</text></svg>)svg"},
        {"screenshot_mosaic", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="6" height="6"/><rect x="9" y="3" width="6" height="6"/><rect x="15" y="3" width="6" height="6"/><rect x="3" y="9" width="6" height="6"/><rect x="9" y="9" width="6" height="6"/><rect x="15" y="9" width="6" height="6"/><rect x="3" y="15" width="6" height="6"/><rect x="9" y="15" width="6" height="6"/><rect x="15" y="15" width="6" height="6"/></svg>)svg"},
        {"screenshot_confirm", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>)svg"},
        {"screenshot_text", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>)svg"},
        {"screenshot_line", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5"></line></svg>)svg"},
        {"screenshot_save", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>)svg"},
        {"screenshot_copy", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>)svg"},
        {"screenshot_close", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>)svg"},
        {"screenshot_eraser", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>)svg"},
        {"screenshot_pin", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 12V6H8v6l-2 2v2h5v8l1 1 1-1v-8h5v-2l-2-2z"></path></svg>)svg"},
        {"screenshot_ocr", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 3H5a2 2 0 0 0-2 2v2M17 3h2a2 2 0 0 1 2 2v2M7 21H5a2 2 0 0 1-2-2v-2M17 21h2a2 2 0 0 0 2-2v-2M8 8h8M8 12h8M8 16h5"/></svg>)svg"},
        {"bold", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>)svg"},
        {"italic", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>)svg"},
        {"color_wheel", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 2v20M2 12h20M12 2a10 10 0 0 1 7.07 17.07M12 2A10 10 0 0 0 4.93 19.07"/></svg>)svg"},
        {"typesetting", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 6h16M4 12h10M4 18h16"/></svg>)svg"},
        {"find_keyword", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><circle cx="11.5" cy="14.5" r="2.5"></circle><line x1="13.5" y1="16.5" x2="15.5" y2="18.5"></line></svg>)svg"},
        {"swap", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 10l5-5 5 5M17 14l-5 5-5-5M12 5v14"/></svg>)svg"},
        {"merge", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 21V10"/><path d="M12 10l-4-4"/><path d="M12 10l4-4"/><path d="M8 6V3"/><path d="M16 6V3"/></svg>)svg"},
        {"cut", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></svg>)svg"},
        {"rotate", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M18 4H10a4 4 0 0 0-4 4v12"/><polyline points="3 17 6 20 9 17"/><path d="M6 20h8a4 4 0 0 0 4-4V4"/><polyline points="21 7 18 4 15 7"/></svg>)svg"},
        {"menu_dots", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/></svg>)svg"},
        {"move", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg>)svg"},
        {"help", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>)svg"},
        {"scan", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2"></path><path d="M17 3h2a2 2 0 0 1 2 2v2"></path><path d="M21 17v2a2 2 0 0 1-2 2h-2"></path><path d="M7 21H5a2 2 0 0 1-2-2v-2"></path><line x1="7" y1="12" x2="17" y2="12"></line></svg>)svg"},
        {"camera", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>)svg"},
        {"ball_on", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8v4l3 2"></path></svg>)svg"},
        {"ball_off", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>)svg"},
        {"paint_bucket", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2a2 2 0 0 0 2.8 0L19 11Z"/>
            <path d="m5 2 5 5"/>
            <path d="m2 13 5 5"/>
            <path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z" fill="currentColor" stroke="none"/>
        </svg>)svg"},
        {"clipboard_auto", R"svg(<svg viewBox="0 -960 960 960" fill="currentColor"><path d="M280-240q-100 0-170-70T40-480q0-100 70-170t170-70h400q100 0 170 70t70 170q0 100-70 170t-170 70H280Zm0-80h400q66 0 113-47t47-113q0-66-47-113t-113-47H280q-66 0-113 47t-47 113q0 66 47 113t113 47Zm85-75q35-35 35-85t-35-85q-35-35-85-35t-85 35q-35 35-35 85t35 85q35 35 85 35t85-35Zm115-85Z"/></svg>)svg"},
        {"switch_on", R"svg(<svg viewBox="0 0 24 24"><rect x="2" y="5" width="20" height="14" rx="7" fill="white" /><rect x="3.5" y="6.5" width="17" height="11" rx="5.5" fill="currentColor" /><circle cx="15" cy="12" r="3.5" fill="white" /></svg>)svg"},
        {"switch_off", R"svg(<svg viewBox="0 0 24 24"><rect x="2" y="5" width="20" height="14" rx="7" fill="white" /><rect x="3.5" y="6.5" width="17" height="11" rx="5.5" fill="currentColor" /><circle cx="9" cy="12" r="3.5" fill="white" /></svg>)svg"},
        {"arrow_up", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 4 L2 20 L22 20 Z"/></svg>)svg"},
        {"arrow_down", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 20 L2 4 L22 4 Z"/></svg>)svg"},
    };
}

#endif // SVGICONS_H
```

## 文件: `src/ui/SystemTray.cpp`

```cpp
#include "SystemTray.h"
#include "StringUtils.h"

#include "IconHelper.h"
#include "FloatingBall.h"
#include <QApplication>
#include <QIcon>
#include <QStyle>

SystemTray::SystemTray(QObject* parent) : QObject(parent) {
    m_trayIcon = new QSystemTrayIcon(this);
    
    // 复刻 Python 版：使用渲染的悬浮球作为托盘图标
    m_trayIcon->setIcon(FloatingBall::generateBallIcon());
    m_trayIcon->setToolTip("快速笔记");

    m_menu = new QMenu();
    IconHelper::setupMenu(m_menu);
    m_menu->setStyleSheet(
        "QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
        /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
        "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
        "QMenu::icon { margin-left: 6px; } "
        "QMenu::item:selected { background-color: #4a90e2; color: white; }"
    );
    
    m_menu->addAction(IconHelper::getIcon("monitor", "#aaaaaa", 18), "显示主界面", this, &SystemTray::showMainWindow);
    m_menu->addAction(IconHelper::getIcon("zap", "#aaaaaa", 18), "显示快速笔记", this, &SystemTray::showQuickWindow);
    
    m_ballAction = new QAction("隐藏悬浮球", this);
    m_ballAction->setIcon(IconHelper::getIcon("ball_off", "#aaaaaa", 18));
    connect(m_ballAction, &QAction::triggered, this, [this](){
        bool willBeVisible = (m_ballAction->text() == "显示悬浮球");
        emit toggleFloatingBall(willBeVisible);
    });
    m_menu->addAction(m_ballAction);

    m_menu->addAction(IconHelper::getIcon("help", "#aaaaaa", 18), "使用说明", this, &SystemTray::showHelpRequested);
    m_menu->addAction(IconHelper::getIcon("settings", "#aaaaaa", 18), "设置", this, &SystemTray::showSettings);
    m_menu->addSeparator();
    m_menu->addAction(IconHelper::getIcon("power", "#aaaaaa", 18), "退出程序", this, &SystemTray::quitApp);

    m_trayIcon->setContextMenu(m_menu);

    connect(m_trayIcon, &QSystemTrayIcon::activated, this, [this](QSystemTrayIcon::ActivationReason reason){
        if (reason == QSystemTrayIcon::Trigger) {
            emit showQuickWindow();
        }
    });
}

void SystemTray::show() {
    m_trayIcon->show();
}

void SystemTray::updateBallAction(bool visible) {
    if (visible) {
        m_ballAction->setText("隐藏悬浮球");
        m_ballAction->setIcon(IconHelper::getIcon("ball_off", "#aaaaaa", 18));
    } else {
        m_ballAction->setText("显示悬浮球");
        m_ballAction->setIcon(IconHelper::getIcon("ball_on", "#aaaaaa", 18));
    }
}
```

## 文件: `src/ui/SystemTray.h`

```cpp
#ifndef SYSTEMTRAY_H
#define SYSTEMTRAY_H

#include <QSystemTrayIcon>
#include <QMenu>
#include <QObject>

class SystemTray : public QObject {
    Q_OBJECT
public:
    explicit SystemTray(QObject* parent = nullptr);
    void show();

signals:
    void showMainWindow();
    void showQuickWindow();
    void showHelpRequested();
    void showSettings();
    void quitApp();
    void toggleFloatingBall(bool visible);

public slots:
    void updateBallAction(bool visible);

private:
    QSystemTrayIcon* m_trayIcon;
    QMenu* m_menu;
    QAction* m_ballAction;
};

#endif // SYSTEMTRAY_H
```

## 文件: `src/ui/TagEditDialog.cpp`

```cpp
#include "TagEditDialog.h"
#include "AdvancedTagSelector.h"
#include "../core/DatabaseManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QRegularExpression>

TagEditDialog::TagEditDialog(const QString& currentTags, QWidget* parent) 
    : FramelessDialog("设置预设标签", parent) 
{
    // 1. 严格执行 500x350 规格要求
    resize(500, 350);
    setMinimumSize(500, 300);

    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(20, 15, 20, 20);
    layout->setSpacing(12);

    auto* lbl = new QLabel("标签 (胶囊化展示):");
    lbl->setStyleSheet("color: #aaa; font-size: 13px; font-weight: bold;");
    layout->addWidget(lbl);

    // 2. 集成胶囊标签编辑器
    m_tagEditor = new TagEditorWidget(this);
    QStringList tagList = currentTags.split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
    for(QString& t : tagList) t = t.trimmed();
    m_tagEditor->setTags(tagList);
    
    // 连接双击信号，唤起高级选择器
    connect(m_tagEditor, &TagEditorWidget::doubleClicked, this, &TagEditDialog::openTagSelector);
    layout->addWidget(m_tagEditor);

    auto* tips = new QLabel("提示：双击空白区域可打开高级标签面板");
    tips->setStyleSheet("color: #666; font-size: 11px;");
    layout->addWidget(tips);

    layout->addStretch();

    // 3. 底部按钮
    auto* btnLayout = new QHBoxLayout();
    btnLayout->addStretch();
    
    auto* btnCancel = new QPushButton("取消");
    btnCancel->setFixedSize(80, 32);
    btnCancel->setCursor(Qt::PointingHandCursor);
    btnCancel->setStyleSheet("QPushButton { background-color: #333; color: #EEE; border: none; border-radius: 4px; } QPushButton:hover { background-color: #444; }");
    connect(btnCancel, &QPushButton::clicked, this, &QDialog::reject);
    btnLayout->addWidget(btnCancel);

    auto* btnOk = new QPushButton("确定");
    btnOk->setFixedSize(80, 32);
    btnOk->setCursor(Qt::PointingHandCursor);
    btnOk->setStyleSheet("QPushButton { background-color: #4a90e2; color: white; border: none; border-radius: 4px; font-weight: bold; } QPushButton:hover { background-color: #357abd; }");
    connect(btnOk, &QPushButton::clicked, this, [this](){
        emit tagsConfirmed(getTags());
        accept();
    });
    btnLayout->addWidget(btnOk);

    layout->addLayout(btnLayout);
}

QString TagEditDialog::getTags() const {
    return m_tagEditor->tags().join(", ");
}

void TagEditDialog::openTagSelector() {
    auto* selector = new AdvancedTagSelector(this);
    
    // 准备数据
    auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
    QStringList allTags = DatabaseManager::instance().getAllTags();
    QStringList selected = m_tagEditor->tags();

    selector->setup(recentTags, allTags, selected);
    
    // 监听确认并更新胶囊
    connect(selector, &AdvancedTagSelector::tagsConfirmed, [this](const QStringList& tags){
        m_tagEditor->setTags(tags);
    });

    selector->showAtCursor();
}
```

## 文件: `src/ui/TagEditDialog.h`

```cpp
#ifndef TAGEDITDIALOG_H
#define TAGEDITDIALOG_H

#include "FramelessDialog.h"
#include "TagEditorWidget.h"

class TagEditDialog : public FramelessDialog {
    Q_OBJECT
public:
    explicit TagEditDialog(const QString& currentTags, QWidget* parent = nullptr);
    QString getTags() const;

signals:
    void tagsConfirmed(const QString& tags);

private slots:
    void openTagSelector();

private:
    TagEditorWidget* m_tagEditor;
};

#endif // TAGEDITDIALOG_H
```

## 文件: `src/ui/TagEditorWidget.cpp`

```cpp
#include "TagEditorWidget.h"
#include "IconHelper.h"
#include <QMouseEvent>
#include <QVariant>
#include <QRegularExpression>
#include <utility>
#include "StringUtils.h"

TagEditorWidget::TagEditorWidget(QWidget* parent) : QFrame(parent) {
    setObjectName("TagEditor");
    setMinimumHeight(150);
    setCursor(Qt::IBeamCursor);
    
    // 基础样式：圆角矩形，深色半透明感
    setStyleSheet(
        "QFrame#TagEditor {"
        "  background-color: #1A1A1A;"
        "  border: 1px solid #333;"
        "  border-radius: 8px;"
        "}"
        "QFrame#TagEditor:hover {"
        "  border: 1px solid #4a90e2;"
        "}"
    );

    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(10, 10, 10, 10);
    
    // 使用 FlowLayout 自动换行
    m_flow = new FlowLayout(0, 8, 8);
    mainLayout->addLayout(m_flow);
    mainLayout->addStretch();
}

void TagEditorWidget::setTags(const QStringList& tags) {
    m_tags = tags;
    updateChips();
}

void TagEditorWidget::addTag(const QString& tag) {
    if (tag.isEmpty() || m_tags.contains(tag)) return;
    m_tags.append(tag);
    updateChips();
    emit tagsChanged();
}

void TagEditorWidget::removeTag(const QString& tag) {
    if (m_tags.removeAll(tag) > 0) {
        updateChips();
        emit tagsChanged();
    }
}

void TagEditorWidget::clear() {
    m_tags.clear();
    updateChips();
    emit tagsChanged();
}

void TagEditorWidget::mouseDoubleClickEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        emit doubleClicked();
    }
    QFrame::mouseDoubleClickEvent(event);
}

void TagEditorWidget::updateChips() {
    // 清空现有 Chips
    QLayoutItem* child;
    while ((child = m_flow->takeAt(0)) != nullptr) {
        if (child->widget()) {
            child->widget()->deleteLater();
        }
        delete child;
    }

    // 重新创建
    for (const QString& tag : std::as_const(m_tags)) {
        m_flow->addWidget(createChip(tag));
    }
}

QWidget* TagEditorWidget::createChip(const QString& tag) {
    auto* chip = new QWidget();
    chip->setObjectName("TagChip");
    chip->setStyleSheet(
        "QWidget#TagChip {"
        "  background-color: #2D2D2D;"
        "  border: 1px solid #444;"
        "  border-radius: 12px;"
        "}"
        "QWidget#TagChip:hover {"
        "  background-color: #383838;"
        "}"
    );

    auto* layout = new QHBoxLayout(chip);
    layout->setContentsMargins(10, 4, 10, 4);
    layout->setSpacing(6);

    auto* label = new QLabel(tag);
    label->setStyleSheet("color: #EEE; font-size: 12px; border: none; background: transparent;");
    layout->addWidget(label);

    auto* btnClose = new QPushButton();
    btnClose->setFixedSize(14, 14);
    btnClose->setCursor(Qt::PointingHandCursor);
    btnClose->setIcon(IconHelper::getIcon("close", "#888", 12));
    btnClose->setToolTip("移除标签");
    btnClose->setStyleSheet(
        "QPushButton { background: transparent; border: none; border-radius: 7px; }"
        "QPushButton:hover { background-color: #e74c3c; }"
    );
    
    connect(btnClose, &QPushButton::clicked, this, [this, tag](){
        removeTag(tag);
    });
    
    layout->addWidget(btnClose);
    return chip;
}
```

## 文件: `src/ui/TagEditorWidget.h`

```cpp
#ifndef TAGEDITORWIDGET_H
#define TAGEDITORWIDGET_H

#include <QFrame>
#include <QStringList>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include "FlowLayout.h"

class TagEditorWidget : public QFrame {
    Q_OBJECT
public:
    explicit TagEditorWidget(QWidget* parent = nullptr);

    void setTags(const QStringList& tags);
    QStringList tags() const { return m_tags; }
    
    void addTag(const QString& tag);
    void removeTag(const QString& tag);
    void clear();

signals:
    void tagsChanged();
    void doubleClicked();

protected:
    void mouseDoubleClickEvent(QMouseEvent* event) override;

private:
    void updateChips();
    QWidget* createChip(const QString& tag);

    QStringList m_tags;
    FlowLayout* m_flow;
};

#endif // TAGEDITORWIDGET_H
```

## 文件: `src/ui/TagManagerWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "TagManagerWindow.h"
#include "StringUtils.h"

#include "IconHelper.h"
#include "../core/DatabaseManager.h"
#include "FramelessDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QHeaderView>
#include <QMouseEvent>
#include <QGraphicsDropShadowEffect>
#include <QToolTip>

TagManagerWindow::TagManagerWindow(QWidget* parent) : FramelessDialog("标签管理", parent) {
    setObjectName("TagManagerWindow");
    loadWindowSettings();
    resize(430, 580);

    initUI();
    refreshData();
}

TagManagerWindow::~TagManagerWindow() {
}

void TagManagerWindow::initUI() {
    auto* contentLayout = new QVBoxLayout(m_contentArea);
    contentLayout->setContentsMargins(20, 10, 20, 20);
    contentLayout->setSpacing(12);

    // Search Bar
    m_searchEdit = new QLineEdit();
    m_searchEdit->setPlaceholderText("搜索标签...");
    m_searchEdit->setStyleSheet("QLineEdit { background-color: #2D2D2D; border: 1px solid #444; border-radius: 6px; color: white; padding: 6px 10px; font-size: 13px; } "
                               "QLineEdit:focus { border-color: #f1c40f; }");
    connect(m_searchEdit, &QLineEdit::textChanged, this, &TagManagerWindow::handleSearch);
    contentLayout->addWidget(m_searchEdit);

    // Table
    m_tagTable = new QTableWidget(0, 2);
    m_tagTable->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_tagTable->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_tagTable->setHorizontalHeaderLabels({"标签名称", "使用次数"});
    m_tagTable->horizontalHeader()->setStretchLastSection(false);
    m_tagTable->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Stretch);
    m_tagTable->horizontalHeader()->setSectionResizeMode(1, QHeaderView::ResizeToContents);
    m_tagTable->verticalHeader()->setVisible(false);
    m_tagTable->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_tagTable->setSelectionMode(QAbstractItemView::SingleSelection);
    m_tagTable->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_tagTable->setStyleSheet(
        "QTableWidget { background-color: #252526; border: 1px solid #333; border-radius: 6px; color: #CCC; gridline-color: #333; outline: none; } "
        "QTableWidget::item { padding: 5px; } "
        "QTableWidget::item:selected { background-color: #3E3E42; color: #FFF; } "
        "QHeaderView::section { background-color: #2D2D30; color: #888; border: none; height: 30px; font-weight: bold; font-size: 12px; border-bottom: 1px solid #333; }"
    );
    contentLayout->addWidget(m_tagTable);

    // Action Buttons
    auto* btnLayout = new QHBoxLayout();
    
    auto* btnRename = new QPushButton("重命名");
    btnRename->setStyleSheet("QPushButton { background-color: #333; color: #EEE; border: none; border-radius: 4px; padding: 8px 15px; font-weight: bold; } "
                             "QPushButton:hover { background-color: #444; }");
    connect(btnRename, &QPushButton::clicked, this, &TagManagerWindow::handleRename);
    btnLayout->addWidget(btnRename);

    auto* btnDelete = new QPushButton("删除");
    btnDelete->setStyleSheet("QPushButton { background-color: rgba(231, 76, 60, 0.2); color: #e74c3c; border: 1px solid rgba(231, 76, 60, 0.4); border-radius: 4px; padding: 8px 15px; font-weight: bold; } "
                             "QPushButton:hover { background-color: rgba(231, 76, 60, 0.3); }");
    connect(btnDelete, &QPushButton::clicked, this, &TagManagerWindow::handleDelete);
    btnLayout->addWidget(btnDelete);

    contentLayout->addLayout(btnLayout);
}

void TagManagerWindow::refreshData() {
    m_tagTable->setRowCount(0);
    
    QVariantMap filterStats = DatabaseManager::instance().getFilterStats();
    QVariantMap tagStats = filterStats.value("tags").toMap();
    
    QString keyword = m_searchEdit->text().trimmed().toLower();
    
    // Sort by name
    QStringList tagNames = tagStats.keys();
    tagNames.sort();

    for (const QString& name : std::as_const(tagNames)) {
        if (!keyword.isEmpty() && !name.toLower().contains(keyword)) continue;

        int row = m_tagTable->rowCount();
        m_tagTable->insertRow(row);
        
        auto* nameItem = new QTableWidgetItem(name);
        auto* countItem = new QTableWidgetItem(tagStats.value(name).toString());
        countItem->setTextAlignment(Qt::AlignCenter);
        
        m_tagTable->setItem(row, 0, nameItem);
        m_tagTable->setItem(row, 1, countItem);
    }
}

void TagManagerWindow::handleRename() {
    int row = m_tagTable->currentRow();
    if (row < 0) return;

    QString oldName = m_tagTable->item(row, 0)->text();
    auto* dlg = new FramelessInputDialog("重命名标签", "新标签名称:", oldName, this);
    connect(dlg, &FramelessInputDialog::accepted, [this, oldName, dlg](){
        QString newName = dlg->text().trimmed();
        if (!newName.isEmpty() && newName != oldName) {
            if (DatabaseManager::instance().renameTagGlobally(oldName, newName)) {
                ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 标签已重命名并同步至所有笔记");
                refreshData();
            }
        }
    });
    dlg->show();
}

void TagManagerWindow::handleDelete() {
    int row = m_tagTable->currentRow();
    if (row < 0) return;

    QString tagName = m_tagTable->item(row, 0)->text();
    auto* dlg = new FramelessMessageBox("确认删除", QString("确定要从所有笔记中移除标签 '%1' 吗？").arg(tagName), this);
    connect(dlg, &FramelessMessageBox::confirmed, [this, tagName](){
        if (DatabaseManager::instance().deleteTagGlobally(tagName)) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 标签已从所有笔记中移除");
            refreshData();
        }
    });
    dlg->show();
}

void TagManagerWindow::handleSearch(const QString& text) {
    refreshData();
}

```

## 文件: `src/ui/TagManagerWindow.h`

```cpp
#ifndef TAGMANAGERWINDOW_H
#define TAGMANAGERWINDOW_H

#include "FramelessDialog.h"
#include <QTableWidget>
#include <QLineEdit>
#include <QPushButton>
#include <QVBoxLayout>
#include <QLabel>
#include <QPoint>

class TagManagerWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit TagManagerWindow(QWidget* parent = nullptr);
    ~TagManagerWindow();

public slots:
    void refreshData();


private:
    void initUI();
    void handleRename();
    void handleDelete();
    void handleSearch(const QString& text);

    QTableWidget* m_tagTable;
    QLineEdit* m_searchEdit;
    QPoint m_dragPos;
};

#endif // TAGMANAGERWINDOW_H
```

## 文件: `src/ui/TimePasteWindow.cpp`

```cpp
#include "TimePasteWindow.h"
#include "IconHelper.h"
#include "../core/KeyboardHook.h"
#include <QDateTime>
#include <QMouseEvent>
#include <QApplication>
#include <QClipboard>
#include <QPushButton>
#include <QPainter>
#include <QPainterPath>

#ifdef Q_OS_WIN
#include <windows.h>
#endif

TimePasteWindow::TimePasteWindow(QWidget* parent) : FramelessDialog("时间输出工具", parent) {
    setObjectName("TimePasteWindow");
    setFixedSize(380, 330); 

    loadWindowSettings();
    initUI();

    m_timer = new QTimer(this);
    connect(m_timer, &QTimer::timeout, this, &TimePasteWindow::updateDateTime);
    m_timer->start(100);
    updateDateTime();

    // 使用 QueuedConnection 确保钩子回调立即返回，避免阻塞导致按键泄漏
    connect(&KeyboardHook::instance(), &KeyboardHook::digitPressed, this, &TimePasteWindow::onDigitPressed, Qt::QueuedConnection);
}

TimePasteWindow::~TimePasteWindow() {
}

void TimePasteWindow::initUI() {
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(20, 10, 20, 20);
    layout->setSpacing(10);

    m_dateLabel = new QLabel();
    m_dateLabel->setAlignment(Qt::AlignCenter);
    m_dateLabel->setStyleSheet("color: #B0B0B0; font-size: 16px; padding: 5px;");
    layout->addWidget(m_dateLabel);

    m_timeLabel = new QLabel();
    m_timeLabel->setAlignment(Qt::AlignCenter);
    m_timeLabel->setStyleSheet("color: #E0E0E0; font-size: 28px; font-weight: bold; padding: 5px; font-family: 'Consolas', 'Monaco', monospace;");
    layout->addWidget(m_timeLabel);

    auto* sep = new QLabel();
    sep->setFixedHeight(2);
    sep->setStyleSheet("background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 transparent, stop:0.5 #555555, stop:1 transparent);");
    layout->addWidget(sep);

    m_buttonGroup = new QButtonGroup(this);
    m_radioPrev = new QRadioButton("退 (往前 N 分钟)");
    m_radioPrev->setChecked(true);
    m_radioPrev->setStyleSheet(getRadioStyle());
    m_buttonGroup->addButton(m_radioPrev, 0);
    layout->addWidget(m_radioPrev);

    m_radioNext = new QRadioButton("进 (往后 N 分钟)");
    m_radioNext->setStyleSheet(getRadioStyle());
    m_buttonGroup->addButton(m_radioNext, 1);
    layout->addWidget(m_radioNext);

    auto* tip = new QLabel("按主键盘数字键 0-9 输出时间");
    tip->setAlignment(Qt::AlignCenter);
    tip->setStyleSheet("color: #666666; font-size: 11px; padding: 5px;");
    layout->addWidget(tip);

}

QString TimePasteWindow::getRadioStyle() {
    return "QRadioButton { color: #E0E0E0; font-size: 14px; padding: 6px; spacing: 8px; } "
           "QRadioButton::indicator { width: 18px; height: 18px; border-radius: 9px; border: 2px solid #555555; background: #2A2A2A; } "
           "QRadioButton::indicator:checked { background: qradialgradient(cx:0.5, cy:0.5, radius:0.5, fx:0.5, fy:0.5, stop:0 #4A9EFF, stop:0.7 #4A9EFF, stop:1 #2A2A2A); border: 2px solid #4A9EFF; } "
           "QRadioButton::indicator:hover { border: 2px solid #4A9EFF; }";
}

void TimePasteWindow::updateDateTime() {
    QDateTime now = QDateTime::currentDateTime();
    m_dateLabel->setText(now.toString("yyyy-MM-dd"));
    m_timeLabel->setText(now.toString("HH:mm:ss"));
}

void TimePasteWindow::onDigitPressed(int digit) {
    if (!isVisible()) return;

    QDateTime target = QDateTime::currentDateTime();
    if (m_radioPrev->isChecked())
        target = target.addSecs(-digit * 60);
    else
        target = target.addSecs(digit * 60);
    
    QString timeStr = target.toString("HH:mm");

    // 1. 立即更新剪贴板（满足用户同步需求）
    QApplication::clipboard()->setText(timeStr);

    // 2. 异步延迟处理，确保系统剪贴板通知完成且焦点稳定
    QTimer::singleShot(100, this, [timeStr]() {
#ifdef Q_OS_WIN
        // A. 显式释放所有修饰键 (L/R Ctrl, Shift, Alt, Win)，防止干扰模拟输入
        INPUT releaseInputs[8];
        memset(releaseInputs, 0, sizeof(releaseInputs));
        BYTE keys[] = { VK_LCONTROL, VK_RCONTROL, VK_LSHIFT, VK_RSHIFT, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN };
        for (int i = 0; i < 8; ++i) {
            releaseInputs[i].type = INPUT_KEYBOARD;
            releaseInputs[i].ki.wVk = keys[i];
            releaseInputs[i].ki.dwFlags = KEYEVENTF_KEYUP;
        }
        SendInput(8, releaseInputs, sizeof(INPUT));

        // B. 使用 Unicode 方式模拟打字输入 (比 Ctrl+V 稳定，不产生剪贴板竞争)
        int len = timeStr.length();
        QVector<INPUT> inputs(len * 2);
        for (int i = 0; i < len; ++i) {
            inputs[i*2].type = INPUT_KEYBOARD;
            inputs[i*2].ki.wVk = 0;
            inputs[i*2].ki.wScan = timeStr[i].unicode();
            inputs[i*2].ki.dwFlags = KEYEVENTF_UNICODE;
            
            inputs[i*2+1] = inputs[i*2];
            inputs[i*2+1].ki.dwFlags |= KEYEVENTF_KEYUP;
        }
        SendInput(inputs.size(), inputs.data(), sizeof(INPUT));
#endif
    });
}

void TimePasteWindow::showEvent(QShowEvent* event) {
    FramelessDialog::showEvent(event);
    KeyboardHook::instance().setDigitInterceptEnabled(true);

#ifdef Q_OS_WIN
    // 设置 WS_EX_NOACTIVATE 使得点击窗口时（如切换加减模式）不会夺取当前编辑器的焦点
    HWND hwnd = (HWND)winId();
    SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_NOACTIVATE);
#endif
}

void TimePasteWindow::hideEvent(QHideEvent* event) {
    KeyboardHook::instance().setDigitInterceptEnabled(false);
    FramelessDialog::hideEvent(event);
}
```

## 文件: `src/ui/TimePasteWindow.h`

```cpp
#ifndef TIMEPASTEWINDOW_H
#define TIMEPASTEWINDOW_H

#include "FramelessDialog.h"
#include <QLabel>
#include <QRadioButton>
#include <QButtonGroup>
#include <QTimer>

class TimePasteWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit TimePasteWindow(QWidget* parent = nullptr);
    ~TimePasteWindow();

protected:
    void showEvent(QShowEvent* event) override;
    void hideEvent(QHideEvent* event) override;

private slots:
    void updateDateTime();
    void onDigitPressed(int digit);

private:
    void initUI();
    QString getRadioStyle();

    QLabel* m_dateLabel;
    QLabel* m_timeLabel;
    QRadioButton* m_radioPrev;
    QRadioButton* m_radioNext;
    QButtonGroup* m_buttonGroup;
    QTimer* m_timer;
    QPoint m_dragPos;
};

#endif // TIMEPASTEWINDOW_H
```

## 文件: `src/ui/TitleEditorDialog.h`

```cpp
#ifndef TITLEEDITORDIALOG_H
#define TITLEEDITORDIALOG_H

#include <QDialog>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QTextEdit>
#include <QPushButton>
#include <QGraphicsDropShadowEffect>
#include <QCursor>

/**
 * @brief 通用标题编辑对话框，用于元数据面板和笔记编辑窗口的标题快速编辑。
 */
class TitleEditorDialog : public QDialog {
    Q_OBJECT
public:
    explicit TitleEditorDialog(const QString& currentText, QWidget* parent = nullptr) : QDialog(parent) {
        setWindowFlags(Qt::FramelessWindowHint | Qt::Popup | Qt::NoDropShadowWindowHint);
        setAttribute(Qt::WA_TranslucentBackground);
        setFixedSize(400, 170);

        auto* layout = new QVBoxLayout(this);
        // [CRITICAL] 边距调整为 20px 以容纳阴影，防止出现“断崖式”阴影截止
        layout->setContentsMargins(20, 20, 20, 20);

        auto* container = new QWidget(this);
        container->setObjectName("container");
        container->setStyleSheet("QWidget#container { background-color: #1e1e1e; border: 1px solid #333; border-radius: 10px; }");
        layout->addWidget(container);

        auto* innerLayout = new QVBoxLayout(container);
        innerLayout->setContentsMargins(12, 12, 12, 10);
        innerLayout->setSpacing(8);

        m_textEdit = new QTextEdit();
        m_textEdit->setText(currentText);
        m_textEdit->setPlaceholderText("请输入标题...");
        m_textEdit->setStyleSheet("QTextEdit { background-color: #252526; border: 1px solid #444; border-radius: 6px; color: white; font-size: 14px; padding: 8px; } QTextEdit:focus { border: 1px solid #4a90e2; }");
        innerLayout->addWidget(m_textEdit);

        auto* btnLayout = new QHBoxLayout();
        btnLayout->addStretch();
        auto* btnSave = new QPushButton("完成");
        btnSave->setFixedSize(64, 30);
        btnSave->setCursor(Qt::PointingHandCursor);
        btnSave->setStyleSheet("QPushButton { background-color: #4a90e2; color: white; border: none; border-radius: 4px; font-weight: bold; } QPushButton:hover { background-color: #357abd; }");
        connect(btnSave, &QPushButton::clicked, this, &QDialog::accept);
        btnLayout->addWidget(btnSave);
        innerLayout->addLayout(btnLayout);

        // 1:1 匹配 QuickWindow 阴影规范 (同步修复模糊截止问题)
        auto* shadow = new QGraphicsDropShadowEffect(this);
        shadow->setBlurRadius(20);
        shadow->setColor(QColor(0, 0, 0, 120));
        shadow->setOffset(0, 4);
        container->setGraphicsEffect(shadow);
    }

    QString getText() const { return m_textEdit->toPlainText().trimmed(); }

    void showAtCursor() {
        QPoint pos = QCursor::pos();
        // 尝试居中显示在鼠标点击位置附近
        move(pos.x() - width() / 2, pos.y() - 40);
        show();
        m_textEdit->setFocus();
        m_textEdit->selectAll();
    }

private:
    QTextEdit* m_textEdit;
};

#endif // TITLEEDITORDIALOG_H
```

## 文件: `src/ui/Toolbox.cpp`

```cpp
#include "Toolbox.h"
#include "ToolTipOverlay.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QScreen>
#include <QApplication>
#include <QGuiApplication>
#include <QMouseEvent>
#include <QToolTip>
#include <QSettings>
#include <QCheckBox>
#include <QDialog>
#include <QWindow>

Toolbox::Toolbox(QWidget* parent) : FramelessDialog("工具箱", parent) {
    setObjectName("ToolboxLauncher");
    
    // [CRITICAL] 强制开启非活动窗口的 ToolTip 显示。
    // setAttribute(Qt::WA_AlwaysShowToolTips); // Custom tooltip doesn't need this
    
    // 设置为工具窗口：任务栏不显示，且置顶
    setWindowFlags(windowFlags() | Qt::Tool | Qt::WindowStaysOnTopHint);

    // 关键修复：强制注入 ToolTip 样式。
    // 在 Windows 平台下，Qt::Tool 窗口的子控件在弹出 ToolTip 时往往无法正确继承全局 QSS。
    this->setStyleSheet("");
    
    // 允许通过拉伸边缘来调整大小
    setMinimumSize(40, 40);

    // [FINAL FIX] 从政策层面彻底禁绝右键菜单生成，配合 eventFilter 拦截全链路。
    setContextMenuPolicy(Qt::NoContextMenu);

    // 修改工具箱圆角为 6px
    QWidget* container = findChild<QWidget*>("DialogContainer");
    if (container) {
        container->setStyleSheet(container->styleSheet().replace("border-radius: 12px;", "border-radius: 6px;"));
    }

    initUI();
    loadSettings();
    updateLayout(m_orientation);
}

Toolbox::~Toolbox() {
    saveSettings();
}

void Toolbox::showEvent(QShowEvent* event) {
    saveSettings();
    FramelessDialog::showEvent(event);
}

void Toolbox::hideEvent(QHideEvent* event) {
    saveSettings();
    FramelessDialog::hideEvent(event);
}

void Toolbox::initUI() {
    // 隐藏默认标题文字，因为我们要把图标放上去
    m_titleLabel->hide();

    // 置顶按钮在工具箱中永久隐藏
    if (m_btnPin) m_btnPin->hide();

    // 将最小化按钮改为移动手柄
    if (m_minBtn) {
        // 仅断开与基类的连接，避免使用通配符 disconnect() 触发 destroyed 信号警告
        m_minBtn->disconnect(this); 
        m_minBtn->setIcon(IconHelper::getIcon("move", "#888888"));
        // m_minBtn->setToolTip("按住移动");
        m_minBtn->setToolTip(""); // [CRITICAL] 清除基类的“最小化”原生 Tooltip，避免与下方的 tooltipText 冲突
        m_minBtn->setProperty("tooltipText", "按住移动");
        m_minBtn->setCursor(Qt::SizeAllCursor);
        // 保留 Hover 背景提供视觉反馈
        m_minBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } "
                             "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }");
        
        // 安装事件过滤器以实现拖拽
        m_minBtn->installEventFilter(this);
    }
    
    // 清空内容区原有边距
    m_contentArea->layout() ? delete m_contentArea->layout() : (void)0;

    // 创建按钮列表
    auto addTool = [&](const QString& id, const QString& tip, const QString& icon, const QString& color, auto signal) {
        ToolInfo info;
        info.id = id;
        info.tip = tip;
        info.icon = icon;
        info.color = color;
        info.callback = [this, signal]() { emit (this->*signal)(); };
        info.btn = createToolButton(tip, icon, color);
        connect(info.btn, &QPushButton::clicked, this, info.callback);
        m_toolInfos.append(info);
    };

    addTool("time", "时间输出", "clock", "#1abc9c", &Toolbox::showTimePasteRequested);
    addTool("password", "密码生成器", "password_generator", "#3498db", &Toolbox::showPasswordGeneratorRequested);
    addTool("ocr", "批量识别", "text", "#4a90e2", &Toolbox::showOCRRequested);
    addTool("immediate_ocr", "截图取文", "screenshot_ocr", "#3498db", &Toolbox::startOCRRequested);
    addTool("tag", "标签管理", "tag", "#f1c40f", &Toolbox::showTagManagerRequested);
    addTool("file_storage", "存储文件", "file_managed", "#e67e22", &Toolbox::showFileStorageRequested);
    addTool("file_search", "查找文件", "search", "#95a5a6", &Toolbox::showFileSearchRequested);
    addTool("keyword_search", "查找关键字", "find_keyword", "#3498db", &Toolbox::showKeywordSearchRequested);
    addTool("color_picker", "颜色提取器", "paint_bucket", "#ff6b81", &Toolbox::showColorPickerRequested);
    addTool("pixel_ruler", "标尺", "pixel_ruler", "#e67e22", &Toolbox::showPixelRulerRequested);
    addTool("immediate_color_picker", "选取颜色", "screen_picker", "#ff4757", &Toolbox::startColorPickerRequested);
    addTool("screenshot", "截图", "camera", "#e74c3c", &Toolbox::screenshotRequested);
    addTool("main_window", "主界面", "maximize", "#4FACFE", &Toolbox::showMainWindowRequested);
    addTool("quick_window", "快速笔记", "zap", "#F1C40F", &Toolbox::showQuickWindowRequested);

    m_btnRotate = createToolButton("切换布局", "rotate", "#aaaaaa");
    connect(m_btnRotate, &QPushButton::clicked, this, &Toolbox::toggleOrientation);

    m_btnMenu = createToolButton("配置按钮", "menu_dots", "#aaaaaa");
    connect(m_btnMenu, &QPushButton::clicked, this, &Toolbox::showConfigPanel);
}

void Toolbox::updateLayout(Orientation orientation) {
    m_orientation = orientation;
    
    // 获取控制按钮 (使用基类成员)
    auto* btnPin = m_btnPin;
    auto* minBtn = m_minBtn; // 在工具箱中作为“移动”手柄
    auto* closeBtn = m_closeBtn;

    // 根据方向设置菜单图标（垂直模式下旋转90度变为横向三点）
    if (m_btnMenu) {
        m_btnMenu->setIcon(IconHelper::getIcon("menu_dots", "#aaaaaa"));
        if (orientation == Orientation::Vertical) {
            QPixmap pix = m_btnMenu->icon().pixmap(32, 32);
            QTransform trans;
            trans.rotate(90);
            m_btnMenu->setIcon(QIcon(pix.transformed(trans, Qt::SmoothTransformation)));
        }
    }

    // 寻找标题栏 widget
    QWidget* titleBar = nullptr;
    if (m_mainLayout->count() > 0) {
        titleBar = m_mainLayout->itemAt(0)->widget();
    }
    if (!titleBar) return;

    // 彻底重置标题栏布局与尺寸限制，防止横纵切换冲突导致的 squashed 状态
    titleBar->setMinimumSize(0, 0);
    titleBar->setMaximumSize(16777215, 16777215);
    
    // 移除基类默认的 10px 底部边距，确保尺寸严格受控
    m_mainLayout->setContentsMargins(0, 0, 0, 0);

    if (titleBar->layout()) {
        QLayoutItem* item;
        while ((item = titleBar->layout()->takeAt(0)) != nullptr) {
            // 不删除 widget，只移除
        }
        delete titleBar->layout();
    }

    // 统一隐藏内容区，所有按钮都放在标题栏内以便在纵向时能正确拉伸且顺序一致
    m_contentArea->hide();

    int visibleCount = 0;
    for (const auto& info : m_toolInfos) if (info.visible) visibleCount++;

    if (orientation == Orientation::Horizontal) {
        titleBar->setFixedHeight(42);
        titleBar->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
        titleBar->setStyleSheet("background-color: transparent; border: none;");
        auto* layout = new QHBoxLayout(titleBar);
        layout->setContentsMargins(8, 0, 8, 0);
        layout->setSpacing(2); // 紧凑间距
        
        // 1. 功能按钮
        for (auto& info : m_toolInfos) {
            if (info.visible) {
                layout->addWidget(info.btn, 0, Qt::AlignVCenter);
                info.btn->show();
            } else {
                info.btn->hide();
            }
        }
        // 2. 旋转与配置按钮
        layout->addWidget(m_btnRotate, 0, Qt::AlignVCenter);
        layout->addWidget(m_btnMenu, 0, Qt::AlignVCenter);
        
        // 4. 系统控制按钮 (统一间距，移除 Stretch)
        if (minBtn) layout->addWidget(minBtn, 0, Qt::AlignVCenter);
        if (closeBtn) layout->addWidget(closeBtn, 0, Qt::AlignVCenter);

        // 确保 m_mainLayout 正确分配空间
        m_mainLayout->setStretchFactor(titleBar, 0);
    } else {
        titleBar->setFixedWidth(42);
        titleBar->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Expanding);
        titleBar->setStyleSheet("background-color: transparent; border: none;");
        auto* layout = new QVBoxLayout(titleBar);
        layout->setContentsMargins(0, 8, 0, 8);
        layout->setSpacing(2); // 紧凑间距
        layout->setAlignment(Qt::AlignHCenter);

        // 垂直模式下，顺序完全反转：系统按钮在最上方
        if (closeBtn) layout->addWidget(closeBtn, 0, Qt::AlignHCenter);
        if (minBtn) layout->addWidget(minBtn, 0, Qt::AlignHCenter);
        // 置顶按钮在垂直模式也隐藏

        // 旋转与配置按钮 (反转顺序，移除 Stretch 实现统一间距)
        layout->addWidget(m_btnMenu, 0, Qt::AlignHCenter);
        layout->addWidget(m_btnRotate, 0, Qt::AlignHCenter);

        // 功能工具按钮 (反转顺序)
        for (int i = m_toolInfos.size() - 1; i >= 0; --i) {
            auto& info = m_toolInfos[i];
            if (info.visible) {
                layout->addWidget(info.btn, 0, Qt::AlignHCenter);
                info.btn->show();
            } else {
                info.btn->hide();
            }
        }

        // 在纵向模式下，让 titleBar 填满整个布局
        m_mainLayout->setStretchFactor(titleBar, 1);
    }

    // 强制触发布局计算与尺寸同步，确保 sizeHint 有效且不触发 Windows 渲染报错
    titleBar->updateGeometry();
    m_mainLayout->activate();
    
    setMinimumSize(0, 0);
    setMaximumSize(16777215, 16777215);

    // 先通过 adjustSize 让窗口系统同步布局，再锁定固定尺寸，防止 UpdateLayeredWindowIndirect 报错
    adjustSize();
    setFixedSize(sizeHint());
    update();
}

void Toolbox::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_pressPos = event->globalPosition().toPoint();
        m_dragOffset = event->globalPosition().toPoint() - frameGeometry().topLeft();
        m_isDragging = false;
        event->accept();
    }
    FramelessDialog::mousePressEvent(event);
}

void Toolbox::contextMenuEvent(QContextMenuEvent* event) {
    // 拦截右键菜单事件，防止在工具箱上点击右键时弹出系统菜单
    event->accept();
}

void Toolbox::mouseMoveEvent(QMouseEvent* event) {
    if (event->buttons() & Qt::LeftButton) {
        if (!m_isDragging) {
            if ((event->globalPosition().toPoint() - m_pressPos).manhattanLength() > QApplication::startDragDistance()) {
                m_isDragging = true;
            }
        }
        
        if (m_isDragging) {
            move(event->globalPosition().toPoint() - m_dragOffset);
            event->accept();
            return;
        }
    }
}

void Toolbox::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        if (m_isDragging) {
            m_isDragging = false;
            checkSnapping();
            saveSettings();
            event->accept();
            return;
        }
    } else if (event->button() == Qt::RightButton) {
        // [BLOCK] 吞掉右键释放，确保右键操作在工具箱内完全无感
        event->accept();
        return;
    }
    checkSnapping();
    saveSettings();
}

void Toolbox::moveEvent(QMoveEvent* event) {
    FramelessDialog::moveEvent(event);
    // 移除 moveEvent 中的 saveSettings 以消除拖拽卡顿
}

bool Toolbox::eventFilter(QObject* watched, QEvent* event) {
    // [ULTIMATE BLOCK] 拦截所有 ContextMenu 事件，确保右键不会触发任何系统或第三方菜单
    if (event->type() == QEvent::ContextMenu) {
        event->accept();
        return true;
    }

    // 处理所有按钮的拖拽重定向
    QPushButton* btn = qobject_cast<QPushButton*>(watched);
    if (btn) {
        if (event->type() == QEvent::MouseButtonPress) {
            auto* me = static_cast<QMouseEvent*>(event);
            if (me->button() == Qt::LeftButton) {
                m_pressPos = me->globalPosition().toPoint();
                m_dragOffset = me->globalPosition().toPoint() - frameGeometry().topLeft();
                m_isDragging = false;
                // 不拦截 Press，允许按钮显示按下效果
            } else if (me->button() == Qt::RightButton) {
                return true; // 拦截右键按下，防止触发潜在行为
            }
        } else if (event->type() == QEvent::MouseMove) {
            auto* me = static_cast<QMouseEvent*>(event);
            if (me->buttons() & Qt::LeftButton) {
                if (!m_isDragging) {
                    if ((me->globalPosition().toPoint() - m_pressPos).manhattanLength() > QApplication::startDragDistance()) {
                        m_isDragging = true;
                    }
                }
                if (m_isDragging) {
                    move(me->globalPosition().toPoint() - m_dragOffset);
                    return true; // 拦截 Move，防止按钮处理
                }
            }
        } else if (event->type() == QEvent::MouseButtonRelease) {
            auto* me = static_cast<QMouseEvent*>(event);
            if (me->button() == Qt::LeftButton) {
                if (m_isDragging) {
                    m_isDragging = false;
                    checkSnapping();
                    saveSettings();
                    return true; // 拦截 Release，防止触发按钮点击信号
                }
                // 对于移动手柄，即使没拖动也要拦截 Release 防止误触逻辑（如果基类有的话）
                if (watched == m_minBtn) return true;
            } else if (me->button() == Qt::RightButton) {
                return true; // 拦截右键释放
            }
        }
    }
    
    if (event->type() == QEvent::HoverEnter) {
        QString text = watched->property("tooltipText").toString();
        if (!text.isEmpty()) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), text);
            // Don't return true, let buttons process hover for style updates
        }
    } else if (event->type() == QEvent::HoverLeave) {
        ToolTipOverlay::hideTip();
    }
    
    return FramelessDialog::eventFilter(watched, event);
}

void Toolbox::checkSnapping() {
    QScreen *screen = QGuiApplication::primaryScreen();
    if (!screen) return;

    QRect screenGeom = screen->availableGeometry();
    QRect winGeom = frameGeometry();
    const int threshold = 40;

    int targetX = winGeom.x();
    int targetY = winGeom.y();
    Orientation newOrientation = m_orientation;

    bool snapped = false;

    // 考虑 FramelessDialog 的 15px 外部边距 (用于阴影)
    const int margin = 15;

    // 检查左右边缘
    if (winGeom.left() + margin - screenGeom.left() < threshold) {
        targetX = screenGeom.left() - margin;
        newOrientation = Orientation::Vertical;
        snapped = true;
    } else if (screenGeom.right() - (winGeom.right() - margin) < threshold) {
        targetX = screenGeom.right() - winGeom.width() + margin;
        newOrientation = Orientation::Vertical;
        snapped = true;
    }

    // 检查上下边缘
    if (winGeom.top() + margin - screenGeom.top() < threshold) {
        targetY = screenGeom.top() - margin;
        if (!snapped) newOrientation = Orientation::Horizontal;
        snapped = true;
    } else if (screenGeom.bottom() - (winGeom.bottom() - margin) < threshold) {
        targetY = screenGeom.bottom() - winGeom.height() + margin;
        if (!snapped) newOrientation = Orientation::Horizontal;
        snapped = true;
    }

    if (snapped) {
        if (newOrientation != m_orientation) {
            updateLayout(newOrientation);
            adjustSize(); // 确保获取更新布局后的最新尺寸
            // 切换布局后再次校验边界，防止超出屏幕 (针对 Requirement 4)
            QRect newWinGeom = frameGeometry();
            if (targetX + newWinGeom.width() - margin > screenGeom.right()) {
                targetX = screenGeom.right() - newWinGeom.width() + margin;
            }
            if (targetY + newWinGeom.height() - margin > screenGeom.bottom()) {
                targetY = screenGeom.bottom() - newWinGeom.height() + margin;
            }
        }
        move(targetX, targetY);
        saveSettings(); // 吸附后显式保存，确保位置被记录
    }
}

void Toolbox::toggleOrientation() {
    Orientation next = (m_orientation == Orientation::Horizontal) ? Orientation::Vertical : Orientation::Horizontal;
    updateLayout(next);
    // 旋转后立即触发吸附与边界检测，防止因高度/宽度增加而溢出屏幕
    checkSnapping();
    saveSettings();
}

void Toolbox::showConfigPanel() {
    auto* panel = new QDialog(this, Qt::Popup | Qt::FramelessWindowHint);
    panel->setAttribute(Qt::WA_TranslucentBackground, true);
    
    auto* mainLayout = new QVBoxLayout(panel);
    mainLayout->setContentsMargins(0, 0, 0, 0);

    // 引入背景容器 QFrame，彻底解决圆角处直角溢出的问题
    auto* bgFrame = new QFrame(panel);
    bgFrame->setObjectName("ConfigBgFrame");
    bgFrame->setAttribute(Qt::WA_StyledBackground, true);
    
    // 移除 500 像素硬编码宽度，改回自适应内容宽度
    panel->setMinimumWidth(150);

    bgFrame->setStyleSheet(
        "#ConfigBgFrame { background-color: #252526; border: 1px solid #444; border-radius: 10px; }"
        "QLabel { color: #888; border: none; font-size: 11px; font-weight: bold; padding: 2px 5px; background: transparent; }"
        "QCheckBox { background-color: #333336; color: #bbb; border: 1px solid #444; font-size: 11px; padding: 4px 15px; margin: 2px 0px; border-radius: 12px; spacing: 8px; }"
        "QCheckBox:hover { background-color: #404044; color: #fff; border-color: #555; }"
        "QCheckBox::indicator { width: 0px; height: 0px; } " // 胶囊样式下隐藏复选框勾选图标
        "QCheckBox:checked { background-color: rgba(0, 122, 204, 0.3); color: #fff; font-weight: bold; border-color: #007ACC; }"
        "QCheckBox:checked:hover { background-color: rgba(0, 122, 204, 0.4); border-color: #0098FF; }"
    );

    auto* contentLayout = new QVBoxLayout(bgFrame);
    contentLayout->setContentsMargins(12, 12, 12, 12);
    contentLayout->setSpacing(6);

    mainLayout->addWidget(bgFrame);

    auto* titleLabel = new QLabel("显示/隐藏功能按钮");
    contentLayout->addWidget(titleLabel);

    for (int i = 0; i < m_toolInfos.size(); ++i) {
        auto* cb = new QCheckBox(m_toolInfos[i].tip);
        cb->setIcon(IconHelper::getIcon(m_toolInfos[i].icon, m_toolInfos[i].color));
        cb->setIconSize(QSize(18, 18));
        cb->setCursor(Qt::PointingHandCursor);
        cb->setChecked(m_toolInfos[i].visible);
        connect(cb, &QCheckBox::toggled, this, [this, i](bool checked) {
            m_toolInfos[i].visible = checked;
            saveSettings();
            updateLayout(m_orientation);
        });
        contentLayout->addWidget(cb);
    }

    panel->adjustSize();

    QPoint pos = m_btnMenu->mapToGlobal(QPoint(0, 0));
    
    // 获取当前屏幕可用区域，确保不超出边界
    QScreen *screen = QGuiApplication::primaryScreen();
    if (this->window() && this->window()->windowHandle()) {
        screen = this->window()->windowHandle()->screen();
    }
    QRect screenGeom = screen ? screen->availableGeometry() : QRect(0, 0, 1920, 1080);

    int x = pos.x();
    int y = pos.y();

    if (m_orientation == Orientation::Horizontal) {
        // 优先向上弹出
        y = pos.y() - panel->height() - 5;
        if (y < screenGeom.top()) {
            // 空间不足则向下弹出
            y = pos.y() + m_btnMenu->height() + 5;
        }
        // 水平修正，保持在按钮附近
        if (x + panel->width() > screenGeom.right()) {
            x = screenGeom.right() - panel->width() - 5;
        }
    } else {
        // 纵向模式下，向左弹出
        x = pos.x() - panel->width() - 5;
        if (x < screenGeom.left()) {
            // 空间不足则向右弹出
            x = pos.x() + m_btnMenu->width() + 5;
        }
        // 垂直修正
        if (y + panel->height() > screenGeom.bottom()) {
            y = screenGeom.bottom() - panel->height() - 5;
        }
    }

    panel->move(x, y);
    panel->show();
}

void Toolbox::loadSettings() {
    QSettings settings("RapidNotes", "Toolbox");
    m_orientation = (Orientation)settings.value("orientation", (int)Orientation::Vertical).toInt();
    
    if (settings.value("isOpen", false).toBool()) {
        show();
    }

    // 恢复位置
    if (settings.contains("pos")) {
        move(settings.value("pos").toPoint());
    } else {
        // 首次运行：默认停靠在屏幕右侧
        QScreen *screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect geom = screen->availableGeometry();
            move(geom.right() - 50, geom.center().y() - 150);
        }
    }

    for (auto& info : m_toolInfos) {
        info.visible = settings.value("visible_" + info.id, true).toBool();
    }
}

void Toolbox::saveSettings() {
    QSettings settings("RapidNotes", "Toolbox");
    settings.setValue("orientation", (int)m_orientation);
    settings.setValue("isOpen", isVisible());
    
    // 记录最后一次有效位置
    if (isVisible() && !isMinimized()) {
        settings.setValue("pos", pos());
    }
    
    for (const auto& info : m_toolInfos) {
        settings.setValue("visible_" + info.id, info.visible);
    }
}

QPushButton* Toolbox::createToolButton(const QString& tooltip, const QString& iconName, const QString& color) {
    auto* btn = new QPushButton();
    // 显式屏蔽子按钮的菜单策略
    btn->setContextMenuPolicy(Qt::NoContextMenu);
    btn->setIcon(IconHelper::getIcon(iconName, color));
    btn->setIconSize(QSize(20, 20));
    btn->setFixedSize(32, 32);
    // 使用简单的 HTML 包装以确保在所有平台上触发 QSS 样式化的富文本渲染
    // btn->setToolTip(tooltip);
    btn->setProperty("tooltipText", tooltip);
    btn->installEventFilter(this);
    btn->setCursor(Qt::PointingHandCursor);
    btn->setFocusPolicy(Qt::NoFocus);
    
    btn->setStyleSheet("QPushButton {"
        "  background-color: transparent;"
        "  border: none;"
        "  border-radius: 6px;"
        "}"
        "QPushButton:hover {"
        "  background-color: rgba(255, 255, 255, 0.08);"
        "}"
        "QPushButton:pressed {"
        "  background-color: rgba(255, 255, 255, 0.15);"
        "}"
    );
    
    return btn;
}
```

## 文件: `src/ui/Toolbox.h`

```cpp
#ifndef TOOLBOX_H
#define TOOLBOX_H

#include "FramelessDialog.h"
#include <QPushButton>
#include <QPoint>
#include <QMoveEvent>
#include <QBoxLayout>
#include <functional>

class ToolTipOverlay;

class Toolbox : public FramelessDialog {
    Q_OBJECT
public:
    explicit Toolbox(QWidget* parent = nullptr);
    ~Toolbox();

    enum class Orientation {
        Horizontal,
        Vertical
    };

signals:
    void showMainWindowRequested();
    void showQuickWindowRequested();
    void showTimePasteRequested();
    void showPasswordGeneratorRequested();
    void showOCRRequested();
    void startOCRRequested();
    void showTagManagerRequested();
    void showFileStorageRequested();
    void showFileSearchRequested();
    void showKeywordSearchRequested();
    void showColorPickerRequested();
    void startColorPickerRequested();
    void showPixelRulerRequested();
    void showHelpRequested();
    void screenshotRequested();

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void moveEvent(QMoveEvent* event) override;
    void contextMenuEvent(QContextMenuEvent* event) override;
    void showEvent(QShowEvent* event) override;
    void hideEvent(QHideEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

    // 工具箱自身始终置顶且由构造函数控制，跳过基类的通用置顶记忆逻辑
    void loadWindowSettings() override {}
    void saveWindowSettings() override {}

private slots:
    void toggleOrientation();
    void showConfigPanel();

private:
    void initUI();
    void updateLayout(Orientation orientation);
    void checkSnapping();
    QPushButton* createToolButton(const QString& tooltip, const QString& iconName, const QString& color);
    void loadSettings();
    void saveSettings();

    Orientation m_orientation = Orientation::Vertical;
    
    // 拖拽平滑化状态
    QPoint m_pressPos;
    bool m_isDragging = false;
    QPoint m_dragOffset;

    struct ToolInfo {
        QString id;
        QString tip;
        QString icon;
        QString color;
        std::function<void()> callback;
        QPushButton* btn = nullptr;
        bool visible = true;
    };
    QList<ToolInfo> m_toolInfos;

    QPushButton* m_btnRotate = nullptr;
    QPushButton* m_btnMenu = nullptr;
};

#endif // TOOLBOX_H
```

## 文件: `src/ui/ToolTipOverlay.h`

```cpp
#ifndef TOOLTIPOVERLAY_H
#define TOOLTIPOVERLAY_H

#include <QWidget>
#include <QPainter>
#include <QScreen>
#include <QGuiApplication>
#include <QApplication>
#include <QTimer>
#include <QFontMetrics>
#include <QTextDocument>
#include <QPointer>
#include <QPainterPath>
#include <QColor>
#include <QPen>
#include <QBrush>
#include <QRectF>

// ----------------------------------------------------------------------------
// ToolTipOverlay: 全局统一的自定义 Tooltip
// [CRITICAL] 本项目严禁使用任何形式的“Windows 系统默认 Tip 样式”！
// [RULE] 1. 杜绝原生内容带来的系统阴影和不透明度。
// [RULE] 2. 所有的 ToolTip 逻辑必须通过此 ToolTipOverlay 渲染。
// [RULE] 3. 此组件必须保持扁平化 (Flat)，严禁添加任何阴影特效。
// ----------------------------------------------------------------------------
class ToolTipOverlay : public QWidget {
    Q_OBJECT
public:
    static ToolTipOverlay* instance() {
        static QPointer<ToolTipOverlay> inst;
        if (!inst) {
            inst = new ToolTipOverlay();
        }
        return inst;
    }

    void showText(const QPoint& globalPos, const QString& text, int timeout = 3000, const QColor& borderColor = QColor("#B0B0B0")) {
        if (text.isEmpty()) { hide(); return; }
        m_currentBorderColor = borderColor;

        // [BLOCKER FIX] 之前的逻辑仅判断 startsWith("<") 极其不稳
        // 现在统一使用标准的 HTML 包装器，并确保内部文字颜色强制覆盖
        QString htmlBody;
        if (text.contains("<") && text.contains(">")) {
            // 如果疑似 HTML，尝试去除可能存在的 body/html 标签（简单处理）
            htmlBody = text;
        } else {
            // 纯文本：进行 HTML 转义并保留换行
            htmlBody = text.toHtmlEscaped().replace("\n", "<br>");
        }

        m_text = QString(
            "<html><head><style>div, p, span, body { color: #EEEEEE !important; }</style></head>"
            "<body style='margin:0; padding:0; color:#EEEEEE; font-family:\"Microsoft YaHei\",\"Segoe UI\",sans-serif;'>"
            "<div style='color:#EEEEEE !important;'>%1</div>"
            "</body></html>"
        ).arg(htmlBody);
        
        m_doc.setHtml(m_text);
        m_doc.setDocumentMargin(0); // 彻底消除文档默认边距，保证边距完全由 pad 决定
        
        // 1. 弹性计算尺寸
        m_doc.setTextWidth(-1); // 先恢复自然宽度
        qreal idealW = m_doc.idealWidth();
        
        if (idealW > 450) {
            m_doc.setTextWidth(450); // 超过限制则强制折行
        } else {
            m_doc.setTextWidth(idealW); // 否则保持内容宽度
        }
        
        QSize textSize = m_doc.size().toSize();
        
        int padX = 12; 
        int padY = 8;
        
        int w = textSize.width() + padX * 2;
        int h = textSize.height() + padY * 2;
        
        // 最小宽高限制
        w = qMax(w, 40);
        h = qMax(h, 24);
        
        resize(w, h);
        
        // 2. 位置计算 (视觉偏移 15, 15)
        QPoint pos = globalPos + QPoint(15, 15);
        
        // 3. 边缘检测
        QScreen* screen = QGuiApplication::screenAt(globalPos);
        if (!screen) screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect screenGeom = screen->geometry();
            if (pos.x() + width() > screenGeom.right()) {
                pos.setX(globalPos.x() - width() - 15);
            }
            if (pos.y() + height() > screenGeom.bottom()) {
                pos.setY(globalPos.y() - height() - 15);
            }
        }
        
        move(pos);
        show();
        raise();
        update();

        // 自动隐藏逻辑：如果是正数则启动定时器
        if (timeout > 0) {
            m_hideTimer.start(timeout);
        } else {
            m_hideTimer.stop();
        }
    }

    static void hideTip() {
        if (instance()) instance()->hide();
    }

protected:
    explicit ToolTipOverlay() : QWidget(nullptr) {
        // [CRITICAL] 彻底杜绝系统阴影：必须显式包含 Qt::NoDropShadowWindowHint 标志。
        setWindowFlags(Qt::ToolTip | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | 
                      Qt::WindowTransparentForInput | Qt::NoDropShadowWindowHint);
        // 显式禁用阴影（特定于某些环境）
        setObjectName("ToolTipOverlay");
        setAttribute(Qt::WA_TranslucentBackground);
        setAttribute(Qt::WA_ShowWithoutActivating);
        
        m_doc.setUndoRedoEnabled(false);
        // [ULTIMATE FIX] 强制锁定调色板颜色，防止继承自全局黑色的 QSS。
        QPalette pal = palette();
        pal.setColor(QPalette::WindowText, QColor("#EEEEEE"));
        pal.setColor(QPalette::Text, QColor("#EEEEEE"));
        pal.setColor(QPalette::ButtonText, QColor("#EEEEEE"));
        setPalette(pal);

        // 终极样式兜底：针对所有可能的标签应用颜色，并使用 !important
        m_doc.setDefaultStyleSheet("body, div, p, span, b, i { color: #EEEEEE !important; font-family: 'Microsoft YaHei', 'Segoe UI'; }"); 
        setStyleSheet("QWidget { color: #EEEEEE !important; background: transparent; }");

        QFont f = font();
        f.setPointSize(9);
        m_doc.setDefaultFont(f);

        m_hideTimer.setSingleShot(true);
        connect(&m_hideTimer, &QTimer::timeout, this, &ToolTipOverlay::hide);

        hide();
    }

    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        p.setRenderHint(QPainter::Antialiasing);
        
        // 彻底去阴影，保持扁平矩形风格
        // 1 像素物理偏移校准位
        QRectF rectF(0.5, 0.5, width() - 1, height() - 1);
        
        // 背景色: #2B2B2B
        // 边框色: 动态传入, 默认 #B0B0B0, 宽度 1px
        p.setPen(QPen(m_currentBorderColor, 1));
        p.setBrush(QColor("#2B2B2B"));
        p.drawRoundedRect(rectF, 4, 4);
        
        // 绘制内容预览
        p.save();
        p.translate(12, 8); // Padding Offset
        p.setPen(QColor("#EEEEEE")); // 备用画笔颜色
        m_doc.drawContents(&p);
        p.restore();
    }

private:
    QString m_text;
    QTextDocument m_doc;
    QTimer m_hideTimer;
    QColor m_currentBorderColor = QColor("#B0B0B0");
};

#endif // TOOLTIPOVERLAY_H
```

## 文件: `src/core/Win32System.h`

```cpp
#ifndef WIN32SYSTEM_H
#define WIN32SYSTEM_H

#include "IPlatformSystem.h"
#include <windows.h>
#include <psapi.h>
#include <QFileInfo>

class Win32System : public IPlatformSystem {
public:
    bool isBrowserActive() override {
        HWND hwnd = GetForegroundWindow();
        if (!hwnd) return false;

        DWORD pid;
        GetWindowThreadProcessId(hwnd, &pid);
        
        HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
        if (!process) return false;

        wchar_t buffer[MAX_PATH];
        if (GetModuleFileNameExW(process, NULL, buffer, MAX_PATH)) {
            QString exeName = QFileInfo(QString::fromWCharArray(buffer)).fileName().toLower();
            static const QStringList browserExes = {
                "chrome.exe", "msedge.exe", "firefox.exe", "brave.exe", 
                "opera.exe", "iexplore.exe", "vivaldi.exe", "safari.exe"
            };
            CloseHandle(process);
            return browserExes.contains(exeName);
        }

        CloseHandle(process);
        return false;
    }

    QString getForegroundAppPath() override {
        HWND hwnd = GetForegroundWindow();
        if (!hwnd) return "";
        DWORD pid;
        GetWindowThreadProcessId(hwnd, &pid);
        HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
        if (!process) return "";
        wchar_t buffer[MAX_PATH];
        QString path;
        if (GetModuleFileNameExW(process, NULL, buffer, MAX_PATH)) {
            path = QString::fromWCharArray(buffer);
        }
        CloseHandle(process);
        return path;
    }

    void simulateCopy() override {
        // 显式释放修饰键，防止干扰 Ctrl+C
        keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
        keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0); // Alt

        keybd_event(VK_CONTROL, 0, 0, 0);
        keybd_event('C', 0, 0, 0);
        keybd_event('C', 0, KEYEVENTF_KEYUP, 0);
        keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
    }

    void simulateSelectAll() override {
        keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
        keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);

        keybd_event(VK_CONTROL, 0, 0, 0);
        keybd_event('A', 0, 0, 0);
        keybd_event('A', 0, KEYEVENTF_KEYUP, 0);
        keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
    }

    void simulateKeyStroke(int vk, bool alt = false, bool ctrl = false, bool shift = false) override {
        if (ctrl) keybd_event(VK_CONTROL, 0, 0, 0);
        if (alt) keybd_event(VK_MENU, 0, 0, 0);
        if (shift) keybd_event(VK_SHIFT, 0, 0, 0);

        keybd_event(vk, 0, 0, 0);
        keybd_event(vk, 0, KEYEVENTF_KEYUP, 0);

        if (shift) keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
        if (alt) keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);
        if (ctrl) keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
    }

public:

    bool registerGlobalHotkey(int id, uint modifiers, uint vk) override {
        return RegisterHotKey(nullptr, id, modifiers, vk);
    }

    bool unregisterGlobalHotkey(int id) override {
        return UnregisterHotKey(nullptr, id);
    }
};

#endif // WIN32SYSTEM_H
```

## 文件: `src/ui/WritingAnimation.cpp`

```cpp
#include "WritingAnimation.h"
```

## 文件: `src/ui/WritingAnimation.h`

```cpp
#ifndef WRITINGANIMATION_H
#define WRITINGANIMATION_H

#include <QWidget>
#include <QTimer>
#include <QPainter>
#include <QPainterPath>
#include <QLinearGradient>
#include <QtMath>

class WritingAnimation : public QWidget {
    Q_OBJECT
public:
    explicit WritingAnimation(QWidget* parent = nullptr) : QWidget(parent) {
        setFixedSize(40, 40);
        m_timer = new QTimer(this);
        connect(m_timer, &QTimer::timeout, this, &WritingAnimation::updatePhysics);
    }

    void start() {
        m_time = 0;
        m_timer->start(20);
        show();
    }

protected:
    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        p.setRenderHint(QPainter::Antialiasing);
        
        float cx = width() / 2.0f;
        float cy = height() / 2.0f;

        // 1. 绘制书本
        p.save();
        p.translate(cx, cy + m_bookY);
        p.scale(0.4, 0.4);
        drawBook(&p);
        p.restore();

        // 2. 绘制钢笔
        p.save();
        p.translate(cx + m_penX, cy + m_penY - 5);
        p.scale(0.4, 0.4);
        p.rotate(m_angle);
        drawPen(&p);
        p.restore();
    }

private:
    void drawBook(QPainter* p) {
        // 模仿 Python 版的 Mocha 书本
        p->setPen(Qt::NoPen);
        p->setBrush(QColor("#f5f0e1")); // 纸张
        p->drawRoundedRect(QRectF(-22, -32, 56, 76), 3, 3);
        
        QLinearGradient grad(-28, -38, 28, 38);
        grad.setColorAt(0, QColor("#5a3c32"));
        grad.setColorAt(1, QColor("#321e19"));
        p->setBrush(grad); // 封面
        p->drawRoundedRect(QRectF(-28, -38, 56, 76), 3, 3);
        
        p->setBrush(QColor("#78141e")); // 书脊装饰
        p->drawRect(QRectF(13, -38, 8, 76));
    }

    void drawPen(QPainter* p) {
        // 模仿 Python 版的通用钢笔
        p->setPen(Qt::NoPen);
        QLinearGradient bodyGrad(-6, 0, 6, 0);
        bodyGrad.setColorAt(0, QColor("#b43c46"));
        bodyGrad.setColorAt(0.5, QColor("#8c141e"));
        bodyGrad.setColorAt(1, QColor("#3c050a"));
        p->setBrush(bodyGrad);
        p->drawRoundedRect(QRectF(-6, -23, 12, 46), 5, 5);

        // 笔尖
        QPainterPath tipPath;
        tipPath.moveTo(-3, 23);
        tipPath.lineTo(3, 23);
        tipPath.lineTo(0, 37);
        tipPath.closeSubpath();
        p->setBrush(QColor("#f0e6b4"));
        p->drawPath(tipPath);
    }

private slots:
    void updatePhysics() {
        m_time += 0.1;
        
        // 模拟物理惯性与书写抖动
        float targetAngle = -65.0f;
        float speed = m_time * 3.0f;
        float targetX = qSin(speed) * 4.0f;
        float targetY = 2.0f + qCos(speed * 2.0f) * 1.0f;

        float easing = 0.1f;
        m_angle += (targetAngle - m_angle) * easing;
        m_penX += (targetX - m_penX) * easing;
        m_penY += (targetY - m_penY) * easing;
        m_bookY += (-1.0f - m_bookY) * easing;

        update();
        if (m_time > 5.0) {
            m_timer->stop();
            hide();
        }
    }

private:
    QTimer* m_timer;
    float m_time = 0;
    float m_angle = -45;
    float m_penX = 0, m_penY = 0, m_bookY = 0;
};

#endif // WRITINGANIMATION_H
```

## 文件: `Combine/旧版本.md`

```markdown
# 代码导出结果 - 20260218_103403

**项目路径**: `G:\C++\Inspirenote\H 合并`

**文件总数**: 113

## 文件: `src/ui/AdvancedTagSelector.cpp`

```cpp
#include "AdvancedTagSelector.h"
#include "IconHelper.h"
#include <QPushButton>
#include <QLabel>
#include <QKeyEvent>
#include <QGuiApplication>
#include <QScreen>
#include <QGraphicsDropShadowEffect>
#include <QScrollArea>
#include <QTimer>
#include <QRegularExpression>

AdvancedTagSelector::AdvancedTagSelector(QWidget* parent) 
    : QWidget(parent, Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint) 
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_DeleteOnClose);
    
    // 1:1 匹配 QuickWindow 的整体架构
    setFixedSize(400, 500); 

    auto* mainLayout = new QVBoxLayout(this);
    // [CRITICAL] 边距调整为 20px 以容纳阴影，防止出现“断崖式”阴影截止
    mainLayout->setContentsMargins(20, 20, 20, 20); 
    mainLayout->setSpacing(0);

    // 内部容器
    auto* container = new QWidget();
    container->setObjectName("container");
    container->setMouseTracking(true);
    container->setStyleSheet(
        "QWidget#container { background: #1E1E1E; border-radius: 10px; border: 1px solid #333; }"
    );

    // 阴影效果: 严格 1:1 复制 QuickWindow 参数 (同步修复模糊截止问题)
    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(20);
    shadow->setColor(QColor(0, 0, 0, 120));
    shadow->setOffset(0, 4);
    container->setGraphicsEffect(shadow);

    mainLayout->addWidget(container);

    // 容器内部布局
    auto* layout = new QVBoxLayout(container);
    layout->setContentsMargins(16, 16, 16, 16);
    layout->setSpacing(12);

    // 1. 搜索框
    m_search = new QLineEdit();
    m_search->setPlaceholderText("搜索或新建...");
    m_search->setStyleSheet(
        "QLineEdit {"
        "  background-color: #2D2D2D;"
        "  border: none;"
        "  border-bottom: 1px solid #444;"
        "  border-radius: 4px;"
        "  padding: 8px;"
        "  font-size: 13px;"
        "  color: #DDD;"
        "}"
        "QLineEdit:focus { border-bottom: 1px solid #4a90e2; }"
    );
    
    connect(m_search, &QLineEdit::textChanged, this, &AdvancedTagSelector::updateList);
    connect(m_search, &QLineEdit::returnPressed, this, [this](){
        QString text = m_search->text().trimmed();
        if (!text.isEmpty()) {
            // [CRITICAL] 支持使用中英文逗号分割标签，提升批量输入体验
            QStringList newTags = text.split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
            bool changed = false;
            for (QString& tag : newTags) {
                tag = tag.trimmed();
                if (!tag.isEmpty() && !m_selected.contains(tag)) {
                    m_selected.append(tag);
                    changed = true;
                }
            }
            
            if (changed) {
                emit tagsChanged();
            }
            // 关键：先清空搜索框，再刷新列表，确保新添加的标签出现在“最近使用”列表首位
            m_search->clear(); 
            updateList();
        }
    });
    layout->addWidget(m_search);

    // 2. 提示标签
    m_tipsLabel = new QLabel("最近使用");
    m_tipsLabel->setStyleSheet("color: #888; font-size: 12px; font-weight: bold; margin-top: 5px;");
    layout->addWidget(m_tipsLabel);

    // 3. 滚动区域
    auto* scroll = new QScrollArea();
    scroll->setWidgetResizable(true);
    scroll->setFrameShape(QFrame::NoFrame);
    scroll->setStyleSheet(
        "QScrollArea { background: transparent; border: none; }"
        "QScrollBar:vertical { width: 6px; background: transparent; }"
        "QScrollBar::handle:vertical { background: #444; border-radius: 3px; }"
    );

    m_tagContainer = new QWidget();
    m_tagContainer->setStyleSheet("background: transparent;");
    
    m_flow = new FlowLayout(m_tagContainer, 0, 8, 8);
    scroll->setWidget(m_tagContainer);
    layout->addWidget(scroll);
}

void AdvancedTagSelector::setup(const QList<QVariantMap>& recentTags, const QStringList& allTags, const QStringList& selectedTags) {
    m_recentTags = recentTags;
    m_allTags = allTags;
    m_selected = selectedTags;
    updateList();
}

void AdvancedTagSelector::setTags(const QStringList& allTags, const QStringList& selectedTags) {
    m_allTags = allTags;
    m_recentTags.clear();
    for (const QString& t : allTags) {
        QVariantMap m;
        m["name"] = t;
        m["count"] = 0;
        m_recentTags.append(m);
    }
    m_selected = selectedTags;
    updateList();
}

void AdvancedTagSelector::updateList() {
    // 清空现有项
    QLayoutItem* child;
    while ((child = m_flow->takeAt(0)) != nullptr) {
        if (child->widget()) {
            child->widget()->deleteLater();
        }
        delete child;
    }

    QString filter = m_search->text().trimmed();
    QString filterLower = filter.toLower();
    
    QList<QVariantMap> displayList;

    if (filter.isEmpty()) {
        m_tipsLabel->setText(QString("最近使用 (%1)").arg(m_recentTags.count()));
        
        // 整理显示列表：优先显示已选中的标签（新操作的排在最前）
        QStringList seen;
        
        // 1. 已选中的标签（按最后添加顺序逆序，最新添加的在第一位）
        for (int i = m_selected.size() - 1; i >= 0; --i) {
            QString name = m_selected[i];
            if (!seen.contains(name)) {
                QVariantMap m;
                m["name"] = name;
                int count = 0;
                for (const auto& rm : m_recentTags) {
                    if (rm["name"].toString() == name) {
                        count = rm["count"].toInt();
                        break;
                    }
                }
                m["count"] = count;
                displayList.append(m);
                seen << name;
            }
        }

        // 2. 数据库返回的其他最近标签
        for (const auto& rm : m_recentTags) {
            QString name = rm["name"].toString();
            if (!seen.contains(name)) {
                displayList.append(rm);
                seen << name;
            }
        }
    } else {
        // 搜索模式
        for (const QString& tag : m_allTags) {
            if (tag.toLower().contains(filterLower)) {
                QVariantMap m;
                m["name"] = tag;
                int count = 0;
                for (const auto& rm : m_recentTags) {
                    if (rm["name"].toString() == tag) {
                        count = rm["count"].toInt();
                        break;
                    }
                }
                m["count"] = count;
                displayList.append(m);
            }
        }
        m_tipsLabel->setText(QString("搜索结果 (%1)").arg(displayList.count()));
    }

    for (const auto& tagData : displayList) {
        QString tag = tagData["name"].toString();
        int count = tagData["count"].toInt();

        bool isSelected = m_selected.contains(tag);
        
        auto* btn = new QPushButton();
        btn->setCheckable(true);
        btn->setChecked(isSelected);
        btn->setCursor(Qt::PointingHandCursor);
        btn->setProperty("tag_name", tag);
        btn->setProperty("tag_count", count);
        
        updateChipState(btn, isSelected);
        
        connect(btn, &QPushButton::clicked, this, [this, btn, tag](){ 
            toggleTag(tag); 
        });
        m_flow->addWidget(btn);
    }
}

void AdvancedTagSelector::updateChipState(QPushButton* btn, bool checked) {
    QString name = btn->property("tag_name").toString();
    int count = btn->property("tag_count").toInt();
    
    QString text = name;
    if (count > 0) text += QString(" (%1)").arg(count);
    btn->setText(text);
    
    QIcon icon = checked ? IconHelper::getIcon("select", "#ffffff", 14) 
                         : IconHelper::getIcon("clock", "#bbbbbb", 14);
    btn->setIcon(icon);
    btn->setIconSize(QSize(14, 14));

    if (checked) {
        btn->setStyleSheet(
            "QPushButton {"
            "  background-color: #4a90e2;"
            "  color: white;"
            "  border: 1px solid #4a90e2;"
            "  border-radius: 14px;"
            "  padding: 6px 12px;"
            "  font-size: 12px;"
            "  font-family: 'Segoe UI', 'Microsoft YaHei';"
            "}"
        );
    } else {
        btn->setStyleSheet(
            "QPushButton {"
            "  background-color: #2D2D2D;"
            "  color: #BBB;"
            "  border: 1px solid #444;"
            "  border-radius: 14px;"
            "  padding: 6px 12px;"
            "  font-size: 12px;"
            "  font-family: 'Segoe UI', 'Microsoft YaHei';"
            "}"
            "QPushButton:hover {"
            "  background-color: #383838;"
            "  border-color: #666;"
            "  color: white;"
            "}"
        );
    }
}

void AdvancedTagSelector::toggleTag(const QString& tag) {
    if (m_selected.contains(tag)) {
        m_selected.removeAll(tag);
    } else {
        m_selected.append(tag);
    }
    emit tagsChanged();
    updateList();
    m_search->setFocus();
}

void AdvancedTagSelector::showAtCursor() {
    QPoint pos = QCursor::pos();
    QScreen *screen = QGuiApplication::screenAt(pos);
    if (screen) {
        QRect geo = screen->geometry();
        int x = pos.x() - 40; 
        int y = pos.y() - 10;
        if (x + width() > geo.right()) x = geo.right() - width();
        if (x < geo.left()) x = geo.left();
        if (y + height() > geo.bottom()) y = geo.bottom() - height();
        if (y < geo.top()) y = geo.top();
        move(x, y);
    }
    m_confirmed = false;
    show();
    raise();
    activateWindow();
    
    // 增加延迟确保焦点获取成功，解决“无法激活”的问题
    QTimer::singleShot(50, m_search, qOverload<>(&QWidget::setFocus));
}

void AdvancedTagSelector::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Escape) {
        close();
    } else if (event->modifiers() == Qt::ControlModifier && event->key() == Qt::Key_W) {
        close();
    } else {
        QWidget::keyPressEvent(event);
    }
}

void AdvancedTagSelector::hideEvent(QHideEvent* event) {
    if (!m_confirmed) {
        m_confirmed = true;
        emit tagsConfirmed(m_selected);
    }
    // 确保隐藏后能够自动销毁，避免内存累积或下次双击无法激活
    deleteLater();
    QWidget::hideEvent(event);
}
```

## 文件: `src/ui/AdvancedTagSelector.h`

```cpp
#ifndef ADVANCEDTAGSELECTOR_H
#define ADVANCEDTAGSELECTOR_H

#include <QWidget>
#include <QStringList>
#include <QList>
#include <QMap>
#include <QVariant>
#include <QVBoxLayout>
#include <QLineEdit>
#include <QLabel>
#include <QScrollArea>
#include <QPushButton>
#include "FlowLayout.h"

class AdvancedTagSelector : public QWidget {
    Q_OBJECT
public:
    explicit AdvancedTagSelector(QWidget* parent = nullptr);
    // 修复构造函数匹配问题，支持初始化数据
    void setup(const QList<QVariantMap>& recentTags, const QStringList& allTags, const QStringList& selectedTags);
    
    void setTags(const QStringList& allTags, const QStringList& selectedTags);
    QStringList selectedTags() const { return m_selected; }

    // 修复缺失的 showAtCursor 方法
    void showAtCursor();

signals:
    void tagsChanged();
    void tagsConfirmed(const QStringList& tags); // 修复缺失的信号

protected:
    void keyPressEvent(QKeyEvent* event) override;
    void hideEvent(QHideEvent* event) override;

private:
    void updateList();
    void toggleTag(const QString& tag);
    void updateChipState(QPushButton* btn, bool checked);

    QList<QVariantMap> m_recentTags;
    QStringList m_allTags;
    QStringList m_selected;
    bool m_confirmed = false;
    QLineEdit* m_search;
    QLabel* m_tipsLabel; // 新增提示标签
    QWidget* m_tagContainer;
    FlowLayout* m_flow;
};

#endif // ADVANCEDTAGSELECTOR_H
```

## 文件: `src/core/AES.cpp`

```cpp
#include "AES.h"
#include <cstring>
#include <algorithm>
#include <cstdint>

// S-Box, Inverse S-Box, Rcon... (Standard AES lookup tables)
static const std::uint8_t sbox[256] = {
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

static const std::uint8_t rsbox[256] = {
  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

static const std::uint8_t Rcon[11] = {
  0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
};

AES::AES(KeyLength keyLength) {
    m_nk = keyLength / 4;
    m_nb = 4;
    if (keyLength == AES_128) m_nr = 10;
    else if (keyLength == AES_192) m_nr = 12;
    else m_nr = 14;
}

AES::~AES() {}

void AES::keyExpansion(const std::uint8_t* key, std::uint8_t* w) {
    std::uint8_t temp[4];
    for (int i = 0; i < m_nk; ++i) {
        w[4 * i] = key[4 * i];
        w[4 * i + 1] = key[4 * i + 1];
        w[4 * i + 2] = key[4 * i + 2];
        w[4 * i + 3] = key[4 * i + 3];
    }
    for (int i = m_nk; i < m_nb * (m_nr + 1); ++i) {
        temp[0] = w[4 * (i - 1)];
        temp[1] = w[4 * (i - 1) + 1];
        temp[2] = w[4 * (i - 1) + 2];
        temp[3] = w[4 * (i - 1) + 3];
        if (i % m_nk == 0) {
            std::uint8_t t = temp[0];
            temp[0] = sbox[temp[1]] ^ Rcon[i / m_nk];
            temp[1] = sbox[temp[2]];
            temp[2] = sbox[temp[3]];
            temp[3] = sbox[t];
        } else if (m_nk > 6 && i % m_nk == 4) {
            temp[0] = sbox[temp[0]];
            temp[1] = sbox[temp[1]];
            temp[2] = sbox[temp[2]];
            temp[3] = sbox[temp[3]];
        }
        w[4 * i] = w[4 * (i - m_nk)] ^ temp[0];
        w[4 * i + 1] = w[4 * (i - m_nk) + 1] ^ temp[1];
        w[4 * i + 2] = w[4 * (i - m_nk) + 2] ^ temp[2];
        w[4 * i + 3] = w[4 * (i - m_nk) + 3] ^ temp[3];
    }
}

static std::uint8_t gmul(std::uint8_t a, std::uint8_t b) {
    std::uint8_t p = 0;
    for (int i = 0; i < 8; ++i) {
        if (b & 1) p ^= a;
        bool hi_bit_set = (a & 0x80);
        a <<= 1;
        if (hi_bit_set) a ^= 0x1b;
        b >>= 1;
    }
    return p;
}

void AES::cipher(const std::uint8_t in[16], std::uint8_t out[16], const std::uint8_t* w) {
    std::uint8_t state[4][4];
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            state[j][i] = in[i * 4 + j] ^ w[i * 4 + j];

    for (int round = 1; round < m_nr; ++round) {
        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                state[i][j] = sbox[state[i][j]];

        std::uint8_t temp = state[1][0];
        state[1][0] = state[1][1]; state[1][1] = state[1][2]; state[1][2] = state[1][3]; state[1][3] = temp;
        temp = state[2][0]; std::uint8_t temp2 = state[2][1];
        state[2][0] = state[2][2]; state[2][1] = state[2][3]; state[2][2] = temp; state[2][3] = temp2;
        temp = state[3][0]; temp2 = state[3][1]; std::uint8_t temp3 = state[3][2];
        state[3][0] = state[3][3]; state[3][1] = temp; state[3][2] = temp2; state[3][3] = temp3;

        for (int j = 0; j < 4; ++j) {
            std::uint8_t a = state[0][j], b = state[1][j], c = state[2][j], d = state[3][j];
            state[0][j] = gmul(a, 2) ^ gmul(b, 3) ^ c ^ d;
            state[1][j] = a ^ gmul(b, 2) ^ gmul(c, 3) ^ d;
            state[2][j] = a ^ b ^ gmul(c, 2) ^ gmul(d, 3);
            state[3][j] = gmul(a, 3) ^ b ^ c ^ gmul(d, 2);
        }

        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                state[j][i] ^= w[round * 16 + i * 4 + j];
    }

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            state[i][j] = sbox[state[i][j]];

    std::uint8_t temp = state[1][0];
    state[1][0] = state[1][1]; state[1][1] = state[1][2]; state[1][2] = state[1][3]; state[1][3] = temp;
    temp = state[2][0]; std::uint8_t temp2 = state[2][1];
    state[2][0] = state[2][2]; state[2][1] = state[2][3]; state[2][2] = temp; state[2][3] = temp2;
    temp = state[3][0]; temp2 = state[3][1]; std::uint8_t temp3 = state[3][2];
    state[3][0] = state[3][3]; state[3][1] = temp; state[3][2] = temp2; state[3][3] = temp3;

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            out[i * 4 + j] = state[j][i] ^ w[m_nr * 16 + i * 4 + j];
}

void AES::invCipher(const std::uint8_t in[16], std::uint8_t out[16], const std::uint8_t* w) {
    std::uint8_t state[4][4];
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            state[j][i] = in[i * 4 + j] ^ w[m_nr * 16 + i * 4 + j];

    for (int round = m_nr - 1; round > 0; --round) {
        std::uint8_t temp = state[1][3];
        state[1][3] = state[1][2]; state[1][2] = state[1][1]; state[1][1] = state[1][0]; state[1][0] = temp;
        temp = state[2][2]; std::uint8_t temp2 = state[2][3];
        state[2][2] = state[2][0]; state[2][3] = state[2][1]; state[2][0] = temp; state[2][1] = temp2;
        temp = state[3][0]; temp2 = state[3][1]; std::uint8_t temp3 = state[3][2];
        state[3][0] = state[3][1]; state[3][1] = state[3][2]; state[3][2] = state[3][3]; state[3][3] = temp;

        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                state[i][j] = rsbox[state[i][j]];

        for (int i = 0; i < 4; ++i)
            for (int j = 0; j < 4; ++j)
                state[j][i] ^= w[round * 16 + i * 4 + j];

        for (int j = 0; j < 4; ++j) {
            std::uint8_t a = state[0][j], b = state[1][j], c = state[2][j], d = state[3][j];
            state[0][j] = gmul(a, 14) ^ gmul(b, 11) ^ gmul(c, 13) ^ gmul(d, 9);
            state[1][j] = gmul(a, 9) ^ gmul(b, 14) ^ gmul(c, 11) ^ gmul(d, 13);
            state[2][j] = gmul(a, 13) ^ gmul(b, 9) ^ gmul(c, 14) ^ gmul(d, 11);
            state[3][j] = gmul(a, 11) ^ gmul(b, 13) ^ gmul(c, 9) ^ gmul(d, 14);
        }
    }

    std::uint8_t temp = state[1][3];
    state[1][3] = state[1][2]; state[1][2] = state[1][1]; state[1][1] = state[1][0]; state[1][0] = temp;
    temp = state[2][2]; std::uint8_t temp2 = state[2][3];
    state[2][2] = state[2][0]; state[2][3] = state[2][1]; state[2][0] = temp; state[2][1] = temp2;
    temp = state[3][0]; temp2 = state[3][1]; std::uint8_t temp3 = state[3][2];
    state[3][0] = state[3][1]; state[3][1] = state[3][2]; state[3][2] = state[3][3]; state[3][3] = temp;

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            state[i][j] = rsbox[state[i][j]];

    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            out[i * 4 + j] = state[j][i] ^ w[i * 4 + j];
}

std::vector<std::uint8_t> AES::encryptCBC(const std::vector<std::uint8_t>& input, const std::vector<std::uint8_t>& key, const std::vector<std::uint8_t>& iv) {
    std::vector<std::uint8_t> w(m_nb * (m_nr + 1) * 4);
    keyExpansion(key.data(), w.data());

    // PKCS#7 Padding
    std::size_t paddingLen = 16 - (input.size() % 16);
    std::vector<std::uint8_t> paddedInput = input;
    for (std::size_t i = 0; i < paddingLen; ++i) paddedInput.push_back((std::uint8_t)paddingLen);

    std::vector<std::uint8_t> output(paddedInput.size());
    std::uint8_t prevBlock[16];
    std::memcpy(prevBlock, iv.data(), 16);

    for (std::size_t i = 0; i < paddedInput.size(); i += 16) {
        std::uint8_t block[16];
        for (int j = 0; j < 16; ++j) block[j] = paddedInput[i + j] ^ prevBlock[j];
        cipher(block, &output[i], w.data());
        std::memcpy(prevBlock, &output[i], 16);
    }
    return output;
}

std::vector<std::uint8_t> AES::decryptCBC(const std::vector<std::uint8_t>& input, const std::vector<std::uint8_t>& key, const std::vector<std::uint8_t>& iv) {
    if (input.empty() || input.size() % 16 != 0) return {};
    std::vector<std::uint8_t> w(m_nb * (m_nr + 1) * 4);
    keyExpansion(key.data(), w.data());

    std::vector<std::uint8_t> output(input.size());
    std::uint8_t prevBlock[16];
    std::memcpy(prevBlock, iv.data(), 16);

    for (std::size_t i = 0; i < input.size(); i += 16) {
        std::uint8_t block[16];
        invCipher(&input[i], block, w.data());
        for (int j = 0; j < 16; ++j) output[i + j] = block[j] ^ prevBlock[j];
        std::memcpy(prevBlock, &input[i], 16);
    }

    // PKCS#7 Unpadding
    std::uint8_t paddingLen = output.back();
    if (paddingLen > 0 && paddingLen <= 16) {
        bool valid = true;
        for (std::size_t i = 0; i < paddingLen; ++i) {
            if (output[output.size() - 1 - i] != paddingLen) { valid = false; break; }
        }
        if (valid) output.resize(output.size() - paddingLen);
    }
    return output;
}
```

## 文件: `src/core/AES.h`

```cpp
#ifndef AES_H
#define AES_H

#include <vector>
#include <cstdint>

class AES {
public:
    enum KeyLength { AES_128 = 16, AES_192 = 24, AES_256 = 32 };

    explicit AES(KeyLength keyLength);
    ~AES();

    // CBC 加密
    std::vector<std::uint8_t> encryptCBC(const std::vector<std::uint8_t>& input, const std::vector<std::uint8_t>& key, const std::vector<std::uint8_t>& iv);
    // CBC 解密
    std::vector<std::uint8_t> decryptCBC(const std::vector<std::uint8_t>& input, const std::vector<std::uint8_t>& key, const std::vector<std::uint8_t>& iv);

private:
    void cipher(const std::uint8_t in[16], std::uint8_t out[16], const std::uint8_t* w);
    void invCipher(const std::uint8_t in[16], std::uint8_t out[16], const std::uint8_t* w);
    void keyExpansion(const std::uint8_t* key, std::uint8_t* w);
    
    int m_nb;
    int m_nk;
    int m_nr;
};

#endif // AES_H
```

## 文件: `src/ui/CategoryDelegate.h`

```cpp
#ifndef CATEGORYDELEGATE_H
#define CATEGORYDELEGATE_H

#include <QStyledItemDelegate>
#include <QPainter>
#include <QApplication>
#include "../models/CategoryModel.h"

class CategoryDelegate : public QStyledItemDelegate {
public:
    using QStyledItemDelegate::QStyledItemDelegate;
    
    void paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        if (!index.isValid()) return;

        bool selected = option.state & QStyle::State_Selected;
        bool hover = option.state & QStyle::State_MouseOver;
        bool isSelectable = index.flags() & Qt::ItemIsSelectable;

        if (isSelectable && (selected || hover)) {
            painter->save();
            painter->setRenderHint(QPainter::Antialiasing);

            QString colorHex = index.data(CategoryModel::ColorRole).toString();
            QColor baseColor = colorHex.isEmpty() ? QColor("#4a90e2") : QColor(colorHex);
            QColor bg = selected ? baseColor : QColor("#2a2d2e");
            if (selected) bg.setAlphaF(0.2); // 选中时应用 20% 透明度联动分类颜色

            // 精准计算高亮区域：联合图标与文字区域，避开左侧缩进/箭头区域
            QStyle* style = option.widget ? option.widget->style() : QApplication::style();
            QRect decoRect = style->subElementRect(QStyle::SE_ItemViewItemDecoration, &option, option.widget);
            QRect textRect = style->subElementRect(QStyle::SE_ItemViewItemText, &option, option.widget);
            
            // 联合区域并与当前行 rect 取交集，防止溢出
            QRect contentRect = decoRect.united(textRect);
            contentRect = contentRect.intersected(option.rect);
            
            // 向左右微调 (padding)，并保持上下略有间隙以体现圆角效果
            contentRect.adjust(-6, 1, 6, -1);
            
            painter->setBrush(bg);
            painter->setPen(Qt::NoPen);
            painter->drawRoundedRect(contentRect, 5, 5);
            painter->restore();
        }

        // 绘制原内容 (图标、文字)
        QStyleOptionViewItem opt = option;
        // 关键：移除 Selected 状态，由我们自己控制背景，防止 QStyle 绘制默认的蓝色/灰色整行高亮
        opt.state &= ~QStyle::State_Selected;
        opt.state &= ~QStyle::State_MouseOver;
        
        // 选中时文字强制设为白色以确保清晰度
        if (selected) {
            opt.palette.setColor(QPalette::Text, Qt::white);
            opt.palette.setColor(QPalette::HighlightedText, Qt::white);
        }
        
        QStyledItemDelegate::paint(painter, opt, index);
    }
};

#endif // CATEGORYDELEGATE_H
```

## 文件: `src/ui/CategoryLockWidget.cpp`

```cpp
#include "CategoryLockWidget.h"
#include "IconHelper.h"
#include "../core/DatabaseManager.h"
#include <QGraphicsDropShadowEffect>

CategoryLockWidget::CategoryLockWidget(QWidget* parent) : QWidget(parent) {
    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setAlignment(Qt::AlignCenter);

    auto* container = new QWidget();
    auto* layout = new QVBoxLayout(container);
    layout->setContentsMargins(10, 10, 10, 10);
    layout->setAlignment(Qt::AlignCenter);
    layout->setSpacing(8);

    // 1. 锁图标 (精简至 32x32)
    auto* lockIcon = new QLabel();
    lockIcon->setPixmap(IconHelper::getIcon("lock_secure", "#aaaaaa").pixmap(32, 32));
    lockIcon->setAlignment(Qt::AlignCenter);
    layout->addWidget(lockIcon);

    // 2. 提示文字 (精简至 13px)
    auto* titleLabel = new QLabel("输入密码查看内容");
    titleLabel->setStyleSheet("color: #999999; font-size: 13px; font-weight: bold; background: transparent;");
    titleLabel->setAlignment(Qt::AlignCenter);
    layout->addWidget(titleLabel);

    // 3. 密码提示 (精简至 11px)
    m_hintLabel = new QLabel("密码提示: ");
    m_hintLabel->setStyleSheet("color: #555555; font-size: 11px; background: transparent;");
    m_hintLabel->setAlignment(Qt::AlignCenter);
    layout->addWidget(m_hintLabel);

    layout->addSpacing(2);

    // 4. 密码输入框 (收紧至 180px)
    m_pwdEdit = new QLineEdit();
    m_pwdEdit->setPlaceholderText("输入密码");
    m_pwdEdit->setEchoMode(QLineEdit::Password);
    m_pwdEdit->setFixedWidth(180);
    m_pwdEdit->setFixedHeight(28);
    m_pwdEdit->setStyleSheet(
        "QLineEdit {"
        "  background-color: #121212; border: 1px solid #333; border-radius: 4px;"
        "  padding: 0 8px; color: white; font-size: 12px;"
        "}"
        "QLineEdit:focus { border: 1px solid #3a90ff; }"
    );
    connect(m_pwdEdit, &QLineEdit::returnPressed, this, &CategoryLockWidget::onVerify);
    layout->addWidget(m_pwdEdit, 0, Qt::AlignHCenter);

    mainLayout->addWidget(container);

    // 移除强制背景色，使其自然融合到父容器 (#1e1e1e) 中
    setStyleSheet("background: transparent;");
}

void CategoryLockWidget::setCategory(int id, const QString& hint) {
    if (m_catId == id && isVisible()) return; // 关键修复：防止因数据刷新导致的输入框重置
    
    m_catId = id;
    m_hintLabel->setText(QString("密码提示: %1").arg(hint.isEmpty() ? "无" : hint));
    m_pwdEdit->clear();
    m_pwdEdit->setFocus();
}

void CategoryLockWidget::clearInput() {
    m_pwdEdit->clear();
    m_pwdEdit->setFocus();
}

void CategoryLockWidget::onVerify() {
    if (m_catId == -1) return;
    
    if (DatabaseManager::instance().verifyCategoryPassword(m_catId, m_pwdEdit->text())) {
        emit unlocked(m_catId);
    } else {
        m_pwdEdit->setStyleSheet(m_pwdEdit->styleSheet() + "border: 1px solid #e74c3c;");
        m_pwdEdit->selectAll();
    }
}
```

## 文件: `src/ui/CategoryLockWidget.h`

```cpp
#ifndef CATEGORYLOCKWIDGET_H
#define CATEGORYLOCKWIDGET_H

#include <QWidget>
#include <QLineEdit>
#include <QLabel>
#include <QVBoxLayout>

class CategoryLockWidget : public QWidget {
    Q_OBJECT
public:
    explicit CategoryLockWidget(QWidget* parent = nullptr);
    
    void setCategory(int id, const QString& hint);
    void clearInput();

signals:
    void unlocked(int id);

private slots:
    void onVerify();

private:
    int m_catId = -1;
    QLabel* m_hintLabel;
    QLineEdit* m_pwdEdit;
};

#endif // CATEGORYLOCKWIDGET_H
```

## 文件: `src/models/CategoryModel.cpp`

```cpp
#include "CategoryModel.h"
#include "../core/DatabaseManager.h"
#include "../ui/IconHelper.h"
#include <QMimeData>
#include <QFont>
#include <QTimer>
#include <QSet>

CategoryModel::CategoryModel(Type type, QObject* parent) 
    : QStandardItemModel(parent), m_type(type) 
{
    refresh();
}

void CategoryModel::refresh() {
    clear();
    QStandardItem* root = invisibleRootItem();
    QVariantMap counts = DatabaseManager::instance().getCounts();

    if (m_type == System || m_type == Both) {
        auto addSystemItem = [&](const QString& name, const QString& type, const QString& icon, const QString& color = "#aaaaaa") {
            int count = counts.value(type, 0).toInt();
            QString display = QString("%1 (%2)").arg(name).arg(count);
            QStandardItem* item = new QStandardItem(display);
            item->setData(type, TypeRole);
            item->setData(name, NameRole);
            item->setData(color, ColorRole); // 设置颜色角色
            item->setEditable(false); // 系统项目不可重命名
            item->setIcon(IconHelper::getIcon(icon, color));
            root->appendRow(item);
        };

        addSystemItem("全部数据", "all", "all_data", "#3498db");
        addSystemItem("今日数据", "today", "today", "#2ecc71");
        addSystemItem("昨日数据", "yesterday", "today", "#f39c12"); // 使用橙色区分
        addSystemItem("最近访问", "recently_visited", "clock", "#9b59b6");
        addSystemItem("未分类", "uncategorized", "uncategorized", "#e67e22");
        addSystemItem("未标签", "untagged", "untagged", "#95a5a6");
        addSystemItem("书签", "bookmark", "bookmark", "#e74c3c");
        addSystemItem("回收站", "trash", "trash", "#7f8c8d");
    }
    
    if (m_type == User || m_type == Both) {
        // 用户分类
        QStandardItem* userGroup = new QStandardItem("我的分区");
        userGroup->setSelectable(false);
        userGroup->setEditable(false);
        userGroup->setFlags(userGroup->flags() | Qt::ItemIsDropEnabled);
        userGroup->setIcon(IconHelper::getIcon("branch", "#FFFFFF"));
        
        // 设为粗体白色
        QFont font = userGroup->font();
        font.setBold(true);
        userGroup->setFont(font);
        userGroup->setForeground(QColor("#FFFFFF"));
        
        root->appendRow(userGroup);

        auto categories = DatabaseManager::instance().getAllCategories();
        QMap<int, QStandardItem*> itemMap;

        for (const auto& cat : categories) {
            int id = cat["id"].toInt();
            int count = counts.value("cat_" + QString::number(id), 0).toInt();
            QString name = cat["name"].toString();
            QString display = QString("%1 (%2)").arg(name).arg(count);
            QStandardItem* item = new QStandardItem(display);
            item->setData("category", TypeRole);
            item->setData(id, IdRole);
            item->setData(cat["color"], ColorRole);
            item->setData(name, NameRole);
            item->setFlags(item->flags() | Qt::ItemIsDragEnabled | Qt::ItemIsDropEnabled);
            
            if (DatabaseManager::instance().isCategoryLocked(id)) {
                item->setIcon(IconHelper::getIcon("lock", "#aaaaaa"));
            } else {
                item->setIcon(IconHelper::getIcon("circle_filled", cat["color"].toString()));
            }
            itemMap[cat["id"].toInt()] = item;
        }

        for (const auto& cat : categories) {
            int id = cat["id"].toInt();
            int parentId = cat["parent_id"].toInt();
            if (parentId > 0 && itemMap.contains(parentId)) {
                itemMap[parentId]->appendRow(itemMap[id]);
            } else {
                userGroup->appendRow(itemMap[id]);
            }
        }
    }
}

Qt::DropActions CategoryModel::supportedDropActions() const {
    return Qt::MoveAction;
}

bool CategoryModel::dropMimeData(const QMimeData* data, Qt::DropAction action, int row, int column, const QModelIndex& parent) {
    QModelIndex actualParent = parent;
    
    // 核心修复：处理正在拖拽分类的情况（m_draggingId != -1）
    if (m_draggingId != -1) {
        bool needsRedirect = false;
        if (!actualParent.isValid()) {
            needsRedirect = true;
        } else {
            QStandardItem* targetItem = itemFromIndex(actualParent);
            QString type = targetItem->data(TypeRole).toString();
            // 如果释放到了系统项或非分类区域，强制重定向到 "我的分区"
            if (type != "category" && targetItem->text() != "我的分区") {
                needsRedirect = true;
            }
        }

        if (needsRedirect) {
            // 寻找 "我的分区" 容器索引
            for (int i = 0; i < rowCount(); ++i) {
                QStandardItem* it = item(i);
                if (it->text() == "我的分区") {
                    actualParent = index(i, 0);
                    break;
                }
            }
        }
    }

    // 再次检查重定向后的合法性
    if (actualParent.isValid()) {
        QStandardItem* parentItem = itemFromIndex(actualParent);
        QString type = parentItem->data(TypeRole).toString();
        if (type != "category" && parentItem->text() != "我的分区") {
            return false; // 依然非法则拒绝，防止回弹
        }
    } else {
        return false; // 根部非法释放
    }

    bool ok = QStandardItemModel::dropMimeData(data, action, row, column, actualParent);
    if (ok && action == Qt::MoveAction) {
        QPersistentModelIndex persistentParent = actualParent;
        QTimer::singleShot(0, this, [this, persistentParent]() {
            syncOrders(persistentParent);
        });
    } else {
        m_draggingId = -1; 
    }
    return ok;
}

void CategoryModel::syncOrders(const QModelIndex& parent) {
    QStandardItem* parentItem = parent.isValid() ? itemFromIndex(parent) : invisibleRootItem();
    
    // 核心修复：无论在 User 还是 Both 模式下，如果落在根部或无效区，尝试找到 "我的分区" 同步
    if (parentItem == invisibleRootItem() || (parentItem->data(TypeRole).toString() != "category" && parentItem->text() != "我的分区")) {
        for (int i = 0; i < rowCount(); ++i) {
            QStandardItem* it = item(i);
            if (it->text() == "我的分区") {
                parentItem = it;
                break;
            }
        }
    }

    QList<int> categoryIds;
    int parentId = -1;
    
    // 再次确认父节点类型，确保同步到正确的数据库父 ID
    QString parentType = parentItem->data(TypeRole).toString();
    if (parentType == "category") {
        parentId = parentItem->data(IdRole).toInt();
    } else if (parentItem->text() == "我的分区") {
        parentId = -1; // 顶级分类
    } else {
        return; // 依然找不到有效的用户分类容器，放弃同步以防破坏数据
    }

    // 收集所有分类 ID，维护当前物理顺序
    QSet<int> seenIds;
    for (int i = 0; i < parentItem->rowCount(); ++i) {
        QStandardItem* child = parentItem->child(i);
        if (child->data(TypeRole).toString() == "category") {
            int id = child->data(IdRole).toInt();
            if (seenIds.contains(id)) continue; // 深度防御：跳过重复项
            seenIds.insert(id);
            categoryIds << id;
        }
    }
    
    if (!categoryIds.isEmpty()) {
        DatabaseManager::instance().updateCategoryOrder(parentId, categoryIds);
    }
    
    m_draggingId = -1; // 完成同步后重置
}
```

## 文件: `src/models/CategoryModel.h`

```cpp
#ifndef CATEGORYMODEL_H
#define CATEGORYMODEL_H

#include <QStandardItemModel>

class CategoryModel : public QStandardItemModel {
    Q_OBJECT
public:
    enum Type { System, User, Both };
    enum Roles {
        TypeRole = Qt::UserRole,
        IdRole,
        ColorRole,
        NameRole
    };
    explicit CategoryModel(Type type, QObject* parent = nullptr);
    void refresh();
    void setDraggingId(int id) { m_draggingId = id; }

    // D&D support
    Qt::DropActions supportedDropActions() const override;
    bool dropMimeData(const QMimeData* data, Qt::DropAction action, int row, int column, const QModelIndex& parent) override;

private:
    void syncOrders(const QModelIndex& parent);
    Type m_type;
    int m_draggingId = -1;
};

#endif // CATEGORYMODEL_H
```

## 文件: `src/ui/CategoryPasswordDialog.cpp`

```cpp
#include "CategoryPasswordDialog.h"
#include <QTextEdit>
#include <QVBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QTimer>

CategoryPasswordDialog::CategoryPasswordDialog(const QString& title, QWidget* parent)
    : FramelessDialog(title, parent)
{
    setFixedSize(360, 435);

    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(20, 15, 20, 20);
    layout->setSpacing(12);

    QString labelStyle = "color: #eee; font-size: 13px; font-weight: bold;";
    QString editStyle = 
        "QLineEdit, QTextEdit {"
        "  background-color: #121212; border: 1px solid #333; border-radius: 6px;"
        "  padding: 8px; color: white; selection-background-color: #4a90e2;"
        "}"
        "QLineEdit:focus, QTextEdit:focus { border: 1px solid #3a90ff; }";

    // 密码
    auto* lblPwd = new QLabel("密码");
    lblPwd->setStyleSheet(labelStyle);
    layout->addWidget(lblPwd);

    m_pwdEdit = new QLineEdit();
    m_pwdEdit->setEchoMode(QLineEdit::Password);
    m_pwdEdit->setStyleSheet(editStyle);
    layout->addWidget(m_pwdEdit);

    // 密码确认
    auto* lblConfirm = new QLabel("密码确认");
    lblConfirm->setStyleSheet(labelStyle);
    layout->addWidget(lblConfirm);

    m_confirmEdit = new QLineEdit();
    m_confirmEdit->setEchoMode(QLineEdit::Password);
    m_confirmEdit->setStyleSheet(editStyle);
    layout->addWidget(m_confirmEdit);

    // 密码提示
    auto* lblHint = new QLabel("密码提示");
    lblHint->setStyleSheet(labelStyle);
    layout->addWidget(lblHint);

    m_hintEdit = new QTextEdit();
    m_hintEdit->setFixedHeight(80);
    m_hintEdit->setStyleSheet(editStyle);
    layout->addWidget(m_hintEdit);

    layout->addStretch();
    layout->addSpacing(15);

    // 保存按钮
    auto* btnSave = new QPushButton("保存密码设置");
    btnSave->setAutoDefault(false);
    btnSave->setFixedHeight(44);
    btnSave->setCursor(Qt::PointingHandCursor);
    btnSave->setStyleSheet(
        "QPushButton {"
        "  background-color: #3a90ff; color: white; border: none; border-radius: 8px;"
        "  font-weight: bold; font-size: 14px;"
        "}"
        "QPushButton:hover { background-color: #2b7ae6; }"
        "QPushButton:pressed { background-color: #1a5dbf; }"
    );
    connect(btnSave, &QPushButton::clicked, this, [this](){
        if (m_pwdEdit->text() != m_confirmEdit->text()) {
            // 这里以后可以加个提示，但按用户要求尽量简洁
            m_confirmEdit->setStyleSheet(m_confirmEdit->styleSheet() + "border: 1px solid #e74c3c;");
            return;
        }
        accept();
    });
    layout->addWidget(btnSave);
}

void CategoryPasswordDialog::showEvent(QShowEvent* event) {
    FramelessDialog::showEvent(event);
    // 使用 QTimer 确保在窗口完全显示后获取焦点，增加延迟至 100ms 以应对复杂的菜单关闭场景
    QTimer::singleShot(100, m_pwdEdit, qOverload<>(&QWidget::setFocus));
}

void CategoryPasswordDialog::setInitialData(const QString& hint) {
    m_hintEdit->setPlainText(hint);
}

QString CategoryPasswordDialog::password() const {
    return m_pwdEdit->text();
}

QString CategoryPasswordDialog::confirmPassword() const {
    return m_confirmEdit->text();
}

QString CategoryPasswordDialog::passwordHint() const {
    return m_hintEdit->toPlainText();
}
```

## 文件: `src/ui/CategoryPasswordDialog.h`

```cpp
#ifndef CATEGORYPASSWORDDIALOG_H
#define CATEGORYPASSWORDDIALOG_H

#include "FramelessDialog.h"
#include <QLineEdit>
#include <QTextEdit>

class CategoryPasswordDialog : public FramelessDialog {
    Q_OBJECT
public:
    explicit CategoryPasswordDialog(const QString& title, QWidget* parent = nullptr);
    
    void setInitialData(const QString& hint);
    
    QString password() const;
    QString confirmPassword() const;
    QString passwordHint() const;

protected:
    void showEvent(QShowEvent* event) override;

private:
    QLineEdit* m_pwdEdit;
    QLineEdit* m_confirmEdit;
    QTextEdit* m_hintEdit;
};

#endif // CATEGORYPASSWORDDIALOG_H
```

## 文件: `src/ui/CleanListView.cpp`

```cpp
#include "CleanListView.h"
#include <QDrag>
#include <QPixmap>
#include <QMimeData>

CleanListView::CleanListView(QWidget* parent) : QListView(parent) {}

void CleanListView::startDrag(Qt::DropActions supportedActions) {
    QModelIndexList indexes = selectedIndexes();
    if (indexes.isEmpty()) return;

    QMimeData* data = model()->mimeData(indexes);
    if (!data) return;

    QDrag* drag = new QDrag(this);
    drag->setMimeData(data);
    
    // 关键：在这里设置一个 1x1 像素的透明 Pixmap 用以消除臃肿的截图
    QPixmap transparentPixmap(1, 1);
    transparentPixmap.fill(Qt::transparent);
    drag->setPixmap(transparentPixmap);
    drag->setHotSpot(QPoint(0, 0));

    drag->exec(supportedActions, Qt::MoveAction);
}
```

## 文件: `src/ui/CleanListView.h`

```cpp
#ifndef CLEANLISTVIEW_H
#define CLEANLISTVIEW_H

#include <QListView>

class CleanListView : public QListView {
    Q_OBJECT
public:
    explicit CleanListView(QWidget* parent = nullptr);

protected:
    void startDrag(Qt::DropActions supportedActions) override;
};

#endif // CLEANLISTVIEW_H
```

## 文件: `src/ui/ClickableLineEdit.h`

```cpp
#ifndef CLICKABLELINEEDIT_H
#define CLICKABLELINEEDIT_H

#include <QLineEdit>
#include <QMouseEvent>

class ClickableLineEdit : public QLineEdit {
    Q_OBJECT
public:
    using QLineEdit::QLineEdit;
signals:
    void doubleClicked();
protected:
    void mouseDoubleClickEvent(QMouseEvent* event) override {
        if (event->button() == Qt::LeftButton) emit doubleClicked();
        QLineEdit::mouseDoubleClickEvent(event);
    }
};

#endif // CLICKABLELINEEDIT_H
```

## 文件: `src/core/ClipboardMonitor.cpp`

```cpp
#include "ClipboardMonitor.h"
#include <QMimeData>
#include <QDebug>

ClipboardMonitor& ClipboardMonitor::instance() {
    static ClipboardMonitor inst;
    return inst;
}

ClipboardMonitor::ClipboardMonitor(QObject* parent) : QObject(parent) {
    connect(QGuiApplication::clipboard(), &QClipboard::dataChanged, this, &ClipboardMonitor::onClipboardChanged);
    qDebug() << "[ClipboardMonitor] 初始化完成，开始监听...";
}

#include <QApplication>
#include <QImage>
#include <QBuffer>
#include <QUrl>
#include <QFileInfo>
#include <QDir>
#include <QCryptographicHash>

#ifdef Q_OS_WIN
#include <windows.h>
#include <psapi.h>
#endif

void ClipboardMonitor::onClipboardChanged() {
    emit clipboardChanged();

    bool forced = m_forceNext;
    QString forcedType = m_forcedType;
    m_forceNext = false;
    m_forcedType = "";

    if (m_skipNext) {
        m_skipNext = false;
        return;
    }

    // 抓取来源窗口信息 (对标 Ditto)
    QString sourceApp = forced ? "RapidNotes (内建工具)" : "未知应用";
    QString sourceTitle = "未知窗口";

    // 1. 过滤本程序自身的复制 (通过进程 ID 判定，比 activeWindow 更可靠)
#ifdef Q_OS_WIN
    HWND hwnd = GetForegroundWindow();
    if (hwnd) {
        DWORD processId;
        GetWindowThreadProcessId(hwnd, &processId);
        
        // 既然已经拿到了 HWND 和 PID，直接抓取标题和应用名，避免重复调用系统 API
        wchar_t title[512];
        if (GetWindowTextW(hwnd, title, 512)) {
            sourceTitle = QString::fromWCharArray(title);
        }

        // [CRITICAL] 过滤逻辑精细化：仅针对主窗口和极速窗口的常规复制操作进行拦截（防止回环）。
        // 如果开启了 forced (forceNext)，说明是内建工具的主动行为，必须予以记录，无论当前窗口是谁。
        if (processId == GetCurrentProcessId()) {
            if (!forced) {
                // [NOTE] 如果没有强制标志，且活跃窗口是主界面，则判定为需要过滤的内部回环
                if (sourceTitle == "RapidNotes" || sourceTitle == "快速笔记") {
                    return;
                }
            } else {
                // 如果是强制记录，确保来源 App 显示为内建工具
                sourceApp = "RapidNotes (内建工具)";
            }
        }

        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processId);
        if (hProcess) {
            wchar_t exePath[MAX_PATH];
            if (GetModuleFileNameExW(hProcess, NULL, exePath, MAX_PATH)) {
                sourceApp = QFileInfo(QString::fromWCharArray(exePath)).baseName();
            }
            CloseHandle(hProcess);
        }
    }
#else
    QWidget* activeWin = QApplication::activeWindow();
    if (activeWin && !forced) {
        QString title = activeWin->windowTitle();
        if (title == "RapidNotes" || title == "快速笔记") {
            return;
        }
    }
#endif

    const QMimeData* mimeData = QGuiApplication::clipboard()->mimeData();
    if (!mimeData) return;

    QString type;
    QString content;
    QByteArray dataBlob;

    // 优先级 1: 本地文件
    if (mimeData->hasUrls()) {
        QStringList paths;
        for (const QUrl& url : mimeData->urls()) {
            if (url.isLocalFile()) {
                paths << QDir::toNativeSeparators(url.toLocalFile());
            }
        }
        if (!paths.isEmpty()) {
            type = "file";
            content = paths.join(";");
        }
    }

    // 优先级 2: 图片 (仅当不是文件时)
    if (type.isEmpty() && mimeData->hasImage()) {
        QImage img = qvariant_cast<QImage>(mimeData->imageData());
        if (!img.isNull()) {
            type = "image";
            content = "[图片]";
            QBuffer buffer(&dataBlob);
            buffer.open(QIODevice::WriteOnly);
            img.save(&buffer, "PNG");
        }
    }

    // 优先级 3: 文本 (包括网页链接)
    if (type.isEmpty() && mimeData->hasText() && !mimeData->text().trimmed().isEmpty()) {
        type = "text";
        content = mimeData->text();
    }

    // 如果都没有识别出来，则忽略
    if (type.isEmpty()) return;

    // [CRITICAL] 如果指定了强制类型，则覆盖，用于区分普通文本与图片识别出的文字
    if (forced && !forcedType.isEmpty()) {
        type = forcedType;
    }

    // SHA256 去重
    QByteArray hashData = dataBlob.isEmpty() ? content.toUtf8() : dataBlob;
    QString currentHash = QCryptographicHash::hash(hashData, QCryptographicHash::Sha256).toHex();
    
    if (currentHash == m_lastHash) return;
    m_lastHash = currentHash;

    qDebug() << "[ClipboardMonitor] 捕获新内容 (来自:" << sourceApp << "):" << type << content.left(30);
    emit newContentDetected(content, type, dataBlob, sourceApp, sourceTitle);
}
```

## 文件: `src/core/ClipboardMonitor.h`

```cpp
#ifndef CLIPBOARDMONITOR_H
#define CLIPBOARDMONITOR_H

#include <QObject>
#include <QClipboard>
#include <QGuiApplication>
#include <QCryptographicHash>
#include <QStringList>

class ClipboardMonitor : public QObject {
    Q_OBJECT
public:
    static ClipboardMonitor& instance();
    void skipNext() { m_skipNext = true; }
    // [CRITICAL] forceNext 支持传入预设类型（如 ocr_text），确保识别出的文字使用专用图标
    void forceNext(const QString& type = "") { m_forceNext = true; m_forcedType = type; }

signals:
    void newContentDetected(const QString& content, const QString& type, const QByteArray& data = QByteArray(),
                            const QString& sourceApp = "", const QString& sourceTitle = "");
    void clipboardChanged();

private slots:
    void onClipboardChanged();

private:
    ClipboardMonitor(QObject* parent = nullptr);
    QString m_lastHash;
    bool m_skipNext = false;
    bool m_forceNext = false;
    // [CRITICAL] 记录强制触发时的预设类型
    QString m_forcedType;
};

#endif // CLIPBOARDMONITOR_H
```

## 文件: `CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.16)

project(RapidNotes VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

find_package(Qt6 REQUIRED COMPONENTS Core Gui Widgets Sql Network Concurrent Svg)

# 源代码列表 - 确保 NoteEditWindow 相关的两个文件都在这里
set(SOURCES
    src/core/AES.cpp
    src/core/AES.h
    src/core/ClipboardMonitor.cpp
    src/core/ClipboardMonitor.h
    src/core/DatabaseManager.cpp
    src/core/DatabaseManager.h
    src/core/FileCryptoHelper.cpp
    src/core/FileCryptoHelper.h
    src/core/HotkeyManager.cpp
    src/core/HotkeyManager.h
    src/core/KeyboardHook.cpp
    src/core/KeyboardHook.h
    src/core/MessageCaptureHandler.cpp
    src/core/MessageCaptureHandler.h
    src/core/OCRManager.cpp
    src/core/OCRManager.h
    src/core/ShortcutManager.cpp
    src/core/ShortcutManager.h
    src/main.cpp
    src/models/CategoryModel.cpp
    src/models/CategoryModel.h
    src/models/NoteModel.cpp
    src/models/NoteModel.h
    src/ui/AdvancedTagSelector.cpp
    src/ui/AdvancedTagSelector.h
    src/ui/CategoryDelegate.h
    src/ui/CategoryLockWidget.cpp
    src/ui/CategoryLockWidget.h
    src/ui/CategoryPasswordDialog.cpp
    src/ui/CategoryPasswordDialog.h
    src/ui/CleanListView.cpp
    src/ui/CleanListView.h
    src/ui/ClickableLineEdit.h
    src/ui/ColorPickerWindow.cpp
    src/ui/ColorPickerWindow.h
    src/ui/DropTreeView.cpp
    src/ui/DropTreeView.h
    src/ui/Editor.cpp
    src/ui/Editor.h
    src/ui/FileSearchWindow.cpp
    src/ui/FileSearchWindow.h
    src/ui/FileStorageWindow.cpp
    src/ui/FileStorageWindow.h
    src/ui/FilterPanel.cpp
    src/ui/FilterPanel.h
    src/ui/FireworksOverlay.cpp
    src/ui/FireworksOverlay.h
    src/ui/FloatingBall.cpp
    src/ui/FloatingBall.h
    src/ui/FlowLayout.cpp
    src/ui/FlowLayout.h
    src/ui/FramelessDialog.cpp
    src/ui/FramelessDialog.h
    src/ui/HeaderBar.cpp
    src/ui/HeaderBar.h
    src/ui/HelpWindow.cpp
    src/ui/HelpWindow.h
    src/ui/IconHelper.h
    src/ui/KeywordSearchWindow.cpp
    src/ui/KeywordSearchWindow.h
    src/ui/MainWindow.cpp
    src/ui/MainWindow.h
    src/ui/MetadataPanel.cpp
    src/ui/MetadataPanel.h
    src/ui/NoteDelegate.h
    src/ui/NoteEditWindow.cpp
    src/ui/NoteEditWindow.h
    src/ui/OCRResultWindow.cpp
    src/ui/OCRResultWindow.h
    src/ui/OCRWindow.cpp
    src/ui/OCRWindow.h
    src/ui/PasswordGeneratorWindow.cpp
    src/ui/PasswordGeneratorWindow.h
    src/ui/PixelRulerOverlay.cpp
    src/ui/PixelRulerOverlay.h
    src/ui/QuickNoteDelegate.h
    src/ui/QuickPreview.h
    src/ui/QuickWindow.cpp
    src/ui/QuickWindow.h
    src/ui/ResizeHandle.cpp
    src/ui/ResizeHandle.h
    src/ui/ScreenshotTool.cpp
    src/ui/ScreenshotTool.h
    src/ui/SearchLineEdit.cpp
    src/ui/SearchLineEdit.h
    src/ui/SettingsWindow.cpp
    src/ui/SettingsWindow.h
    src/ui/StringUtils.h
    src/ui/SvgIcons.h
    src/ui/SystemTray.cpp
    src/ui/SystemTray.h
    src/ui/TagEditDialog.cpp
    src/ui/TitleEditorDialog.h
    src/ui/TagEditDialog.h
    src/ui/TagEditorWidget.cpp
    src/ui/TagEditorWidget.h
    src/ui/TagManagerWindow.cpp
    src/ui/TagManagerWindow.h
    src/ui/TimePasteWindow.cpp
    src/ui/TimePasteWindow.h
    src/ui/ToolTipOverlay.h
    src/ui/Toolbox.cpp
    src/ui/Toolbox.h
    src/ui/WritingAnimation.cpp
    src/ui/WritingAnimation.h
    resources/resources.qrc
)

if(WIN32)
    list(APPEND SOURCES resources/app_icon.rc)
endif()

add_executable(RapidNotes ${SOURCES})

target_link_libraries(RapidNotes PRIVATE
    Qt6::Core
    Qt6::Gui
    Qt6::Widgets
    Qt6::Sql
    Qt6::Network
    Qt6::Concurrent
    Qt6::Svg
)

if(WIN32)
    target_link_libraries(RapidNotes PRIVATE user32 shell32 psapi dwmapi)
    set_target_properties(RapidNotes PROPERTIES
        WIN32_EXECUTABLE TRUE
    )
endif()
```

## 文件: `src/ui/ColorPickerWindow.cpp`

```cpp
#include "ColorPickerWindow.h"
#include "ToolTipOverlay.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include "../core/DatabaseManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QApplication>
#include <QScreen>
#include <QGuiApplication>
#include <QMouseEvent>
#include <QCursor>
#include <QClipboard>
#include <QMimeData>
#include <QSettings>
#include <QPainter>
#include <QBuffer>
#include <QImageReader>
#include <QToolTip>
#include <QSet>
#include <QScrollArea>
#include <QFrame>
#include <QTimer>
#include <QFileDialog>
#include <QMenu>
#include <QProcess>
#include <QDesktopServices>
#include <QJsonDocument>
#include <QJsonArray>
#include <QJsonObject>
#include <QFile>
#include <QPainterPath>
#include <cmath>
#include <algorithm>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#include <QPropertyAnimation>
#include <QGraphicsOpacityEffect>
#include <QColorDialog>
#include <QGridLayout>
#include <QStackedWidget>
#include <QSlider>
#include "FlowLayout.h"
#include "PixelRulerOverlay.h"

#ifdef Q_OS_WIN
#include <windows.h>
#endif

// ----------------------------------------------------------------------------
// ToolTipOverlay: 自定义绘制的 Tooltip 覆盖层
// ----------------------------------------------------------------------------
// 已移至 ToolTipOverlay.h

// ----------------------------------------------------------------------------
// ScreenColorPickerOverlay: 屏幕取色器 (多显示器/HighDPI 稳定版)
// ----------------------------------------------------------------------------
class ScreenColorPickerOverlay : public QWidget {
    Q_OBJECT
    struct ScreenCapture {
        QPixmap pixmap;
        QImage image;
        QRect geometry;
        qreal dpr;
    };
public:
    explicit ScreenColorPickerOverlay(std::function<void(QString)> callback, QWidget* parent = nullptr) 
        : QWidget(nullptr), m_callback(callback) 
    {
        setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool);
        setAttribute(Qt::WA_DeleteOnClose);
        setAttribute(Qt::WA_NoSystemBackground);
        setAttribute(Qt::WA_TranslucentBackground); 
        
        QRect totalRect;
        const auto screens = QGuiApplication::screens();
        for (QScreen* screen : screens) {
            QRect geom = screen->geometry();
            totalRect = totalRect.united(geom);
            
            ScreenCapture cap;
            cap.geometry = geom;
            cap.dpr = screen->devicePixelRatio();
            // [CRITICAL] 核心修复：必须使用本地坐标 (0,0) 抓取。
            // QScreen::grabWindow 的坐标参数在 WId 为 0 时是相对于该屏幕的，使用全局坐标会导致多屏采样偏移。
            cap.pixmap = screen->grabWindow(0, 0, 0, geom.width(), geom.height());
            cap.pixmap.setDevicePixelRatio(cap.dpr);
            cap.image = cap.pixmap.toImage();
            m_captures.append(cap);
        }
        setGeometry(totalRect);

        setCursor(Qt::BlankCursor);
        setMouseTracking(true);
        
        QTimer* timer = new QTimer(this);
        connect(timer, &QTimer::timeout, this, QOverload<>::of(&ScreenColorPickerOverlay::update));
        timer->start(16);
    }

protected:
    void showEvent(QShowEvent* event) override {
        QWidget::showEvent(event);
        QTimer::singleShot(50, this, [this]() {
            if (isVisible()) {
                this->grabMouse();
                this->grabKeyboard();
            }
        });
    }

    void mousePressEvent(QMouseEvent* event) override {
        if (event->button() == Qt::LeftButton) {
            if (m_callback) m_callback(m_currentColorHex);
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("已颜色提取器: %1\n(右键可退出取色模式)").arg(m_currentColorHex));
        } else if (event->button() == Qt::RightButton) {
            cancelPicker();
        }
    }

    void keyPressEvent(QKeyEvent* event) override {
        if (event->key() == Qt::Key_Escape) {
            cancelPicker();
        }
    }

    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        
        QPoint globalPos = QCursor::pos();
        QPoint localPos = mapFromGlobal(globalPos);
        
        // 1. 寻找当前鼠标所在的屏幕捕捉
        const ScreenCapture* currentCap = nullptr;
        for (const auto& cap : m_captures) {
            if (cap.geometry.contains(globalPos)) {
                currentCap = &cap;
                break;
            }
        }
        if (!currentCap && !m_captures.isEmpty()) currentCap = &m_captures[0];
        if (!currentCap) return;

        // 2. 绘制所有屏幕背景 (保持相对位置)
        for (const auto& cap : m_captures) {
            p.drawPixmap(cap.geometry.topLeft() - geometry().topLeft(), cap.pixmap);
        }

        // 3. 采样颜色：使用物理像素坐标，使用 qFloor 确保对齐
        QPoint relativePos = globalPos - currentCap->geometry.topLeft();
        // [CRITICAL] 精确采样坐标计算：必须结合 DPR 并使用 qFloor，防止缩放环境下采样点发生亚像素偏移。
        QPoint pixelPos(qFloor(relativePos.x() * currentCap->dpr), qFloor(relativePos.y() * currentCap->dpr));
        
        QColor centerColor = Qt::black;
        if (pixelPos.x() >= 0 && pixelPos.x() < currentCap->image.width() && 
            pixelPos.y() >= 0 && pixelPos.y() < currentCap->image.height()) {
            centerColor = currentCap->image.pixelColor(pixelPos);
        }
        centerColor.setAlpha(255); // 强制不透明，确保预览颜色准确
        m_currentColorHex = centerColor.name().toUpper();

        // 4. 更新光标样式为针筒
        QString syringeColor = (centerColor.lightness() > 128) ? "#000000" : "#FFFFFF";
        if (syringeColor != m_lastSyringeColor) {
            QPixmap syringe = IconHelper::getIcon("screen_picker", syringeColor).pixmap(32, 32);
            setCursor(QCursor(syringe, 3, 29)); // 针尖对准点击位置
            m_lastSyringeColor = syringeColor;
        }

        // 5. 绘制放大镜
        int grabRadius = 8;
        int grabSize = grabRadius * 2 + 1;
        int lensSize = 160; 
        
        int lensX = localPos.x() + 25;
        int lensY = localPos.y() + 25;
        if (lensX + lensSize > width()) lensX = localPos.x() - lensSize - 25;
        if (lensY + lensSize > height()) lensY = localPos.y() - lensSize - 25;

        QRect lensRect(lensX, lensY, lensSize, lensSize);
        p.setRenderHint(QPainter::Antialiasing);

        p.setPen(Qt::NoPen);
        p.setBrush(QColor(0, 0, 0, 150));
        p.drawRoundedRect(lensRect.adjusted(3, 3, 3, 3), 10, 10);

        QPainterPath path;
        path.addRoundedRect(lensRect, 10, 10);
        // 核心修复：移除暗色背景填充，改用黑色底色，并确保像素网格完全覆盖
        p.fillPath(path, Qt::black); 
        p.setPen(QPen(QColor(100, 100, 100), 2));
        p.drawPath(path);

        // 绘制像素网格 (确保采样源一致且不透明)
        p.save();
        QRect gridArea = lensRect.adjusted(2, 2, -2, -50);
        p.setClipRect(gridArea);
        // [CRITICAL] 核心修复：必须关闭抗锯齿，防止高 DPI 下像素块边缘颜色插值导致采样色变暗或模糊。
        p.setRenderHint(QPainter::Antialiasing, false);
        // [CRITICAL] 核心修复：必须清除之前的画刷残留，否则 drawRect 会使用旧的半透明阴影画刷对像素格进行二次填充。
        p.setBrush(Qt::NoBrush);

        for(int j = 0; j < grabSize; ++j) {
            for(int i = 0; i < grabSize; ++i) {
                int px = pixelPos.x() + i - grabRadius;
                int py = pixelPos.y() + j - grabRadius;
                QColor c = Qt::black;
                if (px >= 0 && px < currentCap->image.width() && py >= 0 && py < currentCap->image.height()) {
                    c = currentCap->image.pixelColor(px, py);
                }
                c.setAlpha(255);
                
                int x1 = gridArea.left() + i * gridArea.width() / grabSize;
                int x2 = gridArea.left() + (i + 1) * gridArea.width() / grabSize;
                int y1 = gridArea.top() + j * gridArea.height() / grabSize;
                int y2 = gridArea.top() + (j + 1) * gridArea.height() / grabSize;
                
                p.fillRect(x1, y1, x2 - x1, y2 - y1, c);
                p.setPen(QPen(QColor(255, 255, 255, 15), 1));
                p.drawRect(x1, y1, x2 - x1, y2 - y1);
            }
        }
        
        // 中心高亮框，同样使用精确计算的坐标
        int cx1 = gridArea.left() + grabRadius * gridArea.width() / grabSize;
        int cx2 = gridArea.left() + (grabRadius + 1) * gridArea.width() / grabSize;
        int cy1 = gridArea.top() + grabRadius * gridArea.height() / grabSize;
        int cy2 = gridArea.top() + (grabRadius + 1) * gridArea.height() / grabSize;
        p.setPen(QPen(Qt::red, 2));
        p.drawRect(cx1, cy1, cx2 - cx1, cy2 - cy1);
        p.restore();

        // 信息栏：预览色块必须与 centerColor 完全一致
        QRect infoRect = lensRect;
        infoRect.setTop(lensRect.bottom() - 50);
        p.setPen(QPen(QColor(176, 176, 176), 1));
        p.drawLine(infoRect.left(), infoRect.top(), infoRect.right(), infoRect.top());

        QRect colorRect(infoRect.left() + 10, infoRect.top() + 12, 26, 26);
        p.setBrush(centerColor); // 使用 Brush 确保填充效果
        p.setPen(QPen(Qt::white, 1));
        p.drawRect(colorRect);

        p.setPen(Qt::white);
        p.setRenderHint(QPainter::TextAntialiasing);
        QFont font = p.font();
        font.setBold(true);
        font.setPixelSize(14);
        p.setFont(font);
        p.drawText(infoRect.left() + 45, infoRect.top() + 22, m_currentColorHex);

        font.setPixelSize(11);
        font.setBold(false);
        p.setFont(font);
        QString rgbText = QString("RGB: %1, %2, %3").arg(centerColor.red()).arg(centerColor.green()).arg(centerColor.blue());
        p.drawText(infoRect.left() + 45, infoRect.top() + 40, rgbText);
    }

private:
    void cancelPicker() {
        releaseMouse();
        releaseKeyboard();
        close();
    }

    std::function<void(QString)> m_callback;
    QString m_currentColorHex = "#FFFFFF";
    QString m_lastSyringeColor;
    QList<ScreenCapture> m_captures;
};


// ----------------------------------------------------------------------------
// ColorWheel: 基于 HSV 的圆形色轮
// ----------------------------------------------------------------------------
class ColorWheel : public QWidget {
    Q_OBJECT
public:
    explicit ColorWheel(QWidget* parent = nullptr) : QWidget(parent) {
        setFixedSize(320, 320);
        // [FIX] 使用 ARGB32_Premultiplied 支持透明背景，Format_RGB32 会导致 transparent 变成黑色
        m_wheelImg = QImage(320, 320, QImage::Format_ARGB32_Premultiplied);
        m_wheelImg.fill(Qt::transparent);
        
        int center = 160;
        int radius = 150;
        for (int y = 0; y < 320; ++y) {
            for (int x = 0; x < 320; ++x) {
                int dx = x - center;
                // [FIX] 翻转 y 轴，使得红色(0度)在右侧，与其通常习惯一致（可选，保持原样也可，这里仅优化计算）
                int dy = y - center; 
                double dist = std::sqrt((double)dx*dx + (double)dy*dy);
                
                // [FIX] 增加简单的边缘抗锯齿 (1px 范围内 alpha 渐变)
                if (dist <= radius + 1.0) {
                    double angle = std::atan2((double)dy, (double)dx);
                    double hue = (angle + M_PI) / (2 * M_PI);
                    double sat = dist / radius;
                    if (sat > 1.0) sat = 1.0; // clamp for internal correctness within AA region

                    QColor c = QColor::fromHsvF(hue, sat, 1.0);
                    
                    // 边缘平滑处理
                    if (dist > radius - 1.0) {
                        double alpha = (radius + 1.0 - dist) / 2.0; // Simple linear falloff
                        if (alpha > 1.0) alpha = 1.0;
                        if (alpha < 0.0) alpha = 0.0;
                        c.setAlphaF(alpha);
                    }
                    
                    m_wheelImg.setPixelColor(x, y, c);
                }
            }
        }
    }

signals:
    void colorChanged(double hue, double sat);

protected:
    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        p.setRenderHint(QPainter::Antialiasing); // [FIX] 开启抗锯齿，让选中点圆圈更平滑
        p.drawImage(0, 0, m_wheelImg);
        if (m_hue >= 0) {
            int center = 160;
            int radius = 150;
            double angle = m_hue * 2 * M_PI - M_PI;
            double dist = m_sat * radius;
            int cx = center + std::cos(angle) * dist;
            int cy = center + std::sin(angle) * dist;
            p.setPen(QPen(Qt::black, 2));
            p.setBrush(Qt::white);
            p.drawEllipse(QPoint(cx, cy), 6, 6);
        }
    }

    void mousePressEvent(QMouseEvent* event) override { handleMouse(event); }
    void mouseMoveEvent(QMouseEvent* event) override { if (event->buttons() & Qt::LeftButton) handleMouse(event); }

private:
    void handleMouse(QMouseEvent* event) {
        int center = 160;
        int dx = event->pos().x() - center;
        int dy = event->pos().y() - center;
        double dist = std::sqrt((double)dx*dx + (double)dy*dy);
        if (dist <= 160) {
            double angle = std::atan2((double)dy, (double)dx);
            m_hue = (angle + M_PI) / (2 * M_PI);
            m_sat = std::min(dist / 150.0, 1.0);
            emit colorChanged(m_hue, m_sat);
            update();
        }
    }
    QImage m_wheelImg;
    double m_hue = 0.0;
    double m_sat = 0.0;
};

// ----------------------------------------------------------------------------
// ColorPickerDialog: 独立选色弹窗
// ----------------------------------------------------------------------------
class ColorPickerDialog : public QDialog {
    Q_OBJECT
public:
    ColorPickerDialog(QWidget* parent, std::function<void(QString)> callback) 
        : QDialog(parent, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool), m_callback(callback) 
    {
        setFixedSize(500, 600);
        setAttribute(Qt::WA_TranslucentBackground);
        
        auto* container = new QWidget(this);
        container->setObjectName("container");
        container->setStyleSheet("QWidget#container { background: #1a1a1a; border-radius: 15px; border: 1px solid #444; }");
        auto* mainL = new QVBoxLayout(this);
        mainL->setContentsMargins(0,0,0,0);
        mainL->addWidget(container);

        auto* l = new QVBoxLayout(container);
        l->setContentsMargins(20, 20, 20, 20);
        l->setSpacing(15);

        auto* headerLayout = new QHBoxLayout();
        // [FIX] 使用占位控件平衡右侧关闭按钮，确保标题视觉绝对居中
        auto* spacerBtn = new QWidget();
        spacerBtn->setFixedSize(28, 28);
        spacerBtn->setStyleSheet("background: transparent;");
        headerLayout->addWidget(spacerBtn);

        headerLayout->addStretch();
        auto* title = new QLabel("颜色选择器");
        title->setStyleSheet("color: white; font-weight: bold; font-size: 16px; border: none; background: transparent;");
        headerLayout->addWidget(title);
        headerLayout->addStretch();

        auto* closeTopBtn = new QPushButton();
        closeTopBtn->setFixedSize(28, 28);
        closeTopBtn->setIcon(IconHelper::getIcon("close", "#aaaaaa", 16));
        closeTopBtn->setCursor(Qt::PointingHandCursor);
        closeTopBtn->setStyleSheet("QPushButton { background: transparent; border-radius: 4px; border: none; } QPushButton:hover { background-color: #E81123; }");
        connect(closeTopBtn, &QPushButton::clicked, this, &QDialog::reject);
        headerLayout->addWidget(closeTopBtn);

        l->addLayout(headerLayout);

        m_wheel = new ColorWheel();
        connect(m_wheel, &ColorWheel::colorChanged, this, &ColorPickerDialog::onWheelChanged);
        l->addWidget(m_wheel, 0, Qt::AlignCenter);

        auto* bRow = new QHBoxLayout();
        auto* blbl = new QLabel("亮度:");
        blbl->setStyleSheet("color: white; border: none; background: transparent;");
        bRow->addWidget(blbl);
        m_brightSlider = new QSlider(Qt::Horizontal);
        m_brightSlider->setRange(0, 100);
        m_brightSlider->setValue(100);
        m_brightSlider->setStyleSheet("QSlider::groove:horizontal { height: 6px; background: #444; border-radius: 3px; } QSlider::handle:horizontal { background: white; width: 16px; margin: -5px 0; border-radius: 8px; }");
        connect(m_brightSlider, &QSlider::valueChanged, this, &ColorPickerDialog::updatePreview);
        bRow->addWidget(m_brightSlider);
        l->addLayout(bRow);

        m_preview = new QFrame();
        m_preview->setFixedHeight(60);
        m_preview->setStyleSheet("border-radius: 10px; background: white; border: 1px solid #555;");
        auto* pl = new QVBoxLayout(m_preview);
        m_hexLabel = new QLabel("#FFFFFF");
        m_hexLabel->setStyleSheet("color: #1a1a1a; font-weight: bold; font-size: 18px; border: none; background: transparent;");
        m_hexLabel->setAlignment(Qt::AlignCenter);
        pl->addWidget(m_hexLabel);
        l->addWidget(m_preview);

        auto* btnRow = new QHBoxLayout();
        auto* btnClose = new QPushButton("取消");
        btnClose->setAutoDefault(false);
        btnClose->setFixedHeight(36);
        btnClose->setStyleSheet("background: #444; color: white; border-radius: 6px; border: none;");
        connect(btnClose, &QPushButton::clicked, this, &QDialog::reject);
        btnRow->addWidget(btnClose);
        
        auto* btnConfirm = new QPushButton("确认选择");
        btnConfirm->setAutoDefault(false);
        btnConfirm->setFixedHeight(36);
        btnConfirm->setStyleSheet("background: #3b8ed0; color: white; border-radius: 6px; border: none; font-weight: bold;");
        connect(btnConfirm, &QPushButton::clicked, this, &ColorPickerDialog::onConfirm);
        btnRow->addWidget(btnConfirm);
        l->addLayout(btnRow);
    }

private slots:
    void onWheelChanged(double h, double s) { m_hue = h; m_sat = s; updatePreview(); }
    void updatePreview() {
        QColor c = QColor::fromHsvF(m_hue, m_sat, m_brightSlider->value() / 100.0);
        m_selectedHex = c.name().toUpper();
        m_preview->setStyleSheet(QString("border-radius: 10px; background: %1; border: 1px solid #555;").arg(m_selectedHex));
        m_hexLabel->setText(m_selectedHex);
        m_hexLabel->setStyleSheet(QString("color: %1; font-weight: bold; font-size: 18px; border: none; background: transparent;")
            .arg(c.lightness() > 128 ? "#1a1a1a" : "white"));
    }
    void onConfirm() { m_callback(m_selectedHex); accept(); }

private:
    std::function<void(QString)> m_callback;
    ColorWheel* m_wheel;
    QSlider* m_brightSlider;
    QFrame* m_preview;
    QLabel* m_hexLabel;
    double m_hue = 0, m_sat = 0;
    QString m_selectedHex = "#FFFFFF";
};

// ----------------------------------------------------------------------------
// ColorPickerWindow 实现
// ----------------------------------------------------------------------------

ColorPickerWindow::ColorPickerWindow(QWidget* parent)
    : FramelessDialog("颜色提取器", parent)
{
    setObjectName("ColorPickerWindow");
    setWindowTitle("颜色提取器");
    // [CRITICAL] 缩小窗口默认大小以适应更多屏幕。从 1400x900 调整。
    resize(1000, 750);
    setMinimumSize(850, 600);
    setAcceptDrops(true);
    m_favorites = loadFavorites();
    loadWindowSettings();
    initUI();
    QSettings s("RapidNotes", "ColorPicker");
    QString lastColor = s.value("lastColor", "#D64260").toString();
    useColor(lastColor);
}

ColorPickerWindow::~ColorPickerWindow() {
    saveFavorites();
}

void ColorPickerWindow::initUI() {
    setStyleSheet(R"(
        QWidget { font-family: "Microsoft YaHei", "Segoe UI", sans-serif; color: #E0E0E0; }
        QLineEdit { background-color: #2A2A2A; border: 1px solid #444; color: #FFFFFF; border-radius: 6px; padding: 4px; font-weight: bold; }
        QLineEdit:focus { border: 1px solid #3b8ed0; }
        QPushButton { background-color: #333; border: 1px solid #444; border-radius: 4px; padding: 6px; outline: none; }
        QPushButton:hover { background-color: #444; }
        QPushButton:pressed { background-color: #222; }
        QScrollArea { background: transparent; border: none; }
        QScrollBar:vertical { background: transparent; width: 8px; }
        QScrollBar::handle:vertical { background: #444; border-radius: 4px; min-height: 20px; }
        QScrollBar::handle:vertical:hover { background: #555; }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }
    )");

    auto* mainVLayout = new QVBoxLayout(m_contentArea);
    mainVLayout->setContentsMargins(20, 20, 20, 20);
    mainVLayout->setSpacing(15);

    // --- 第一排：颜色预览 ①、输入框 ②、输入框 ③、工具按钮 ④ ---
    auto* row1 = new QHBoxLayout();
    row1->setSpacing(10);

    // ① 颜色预览 (200x50)
    auto* previewContainer = new QFrame();
    previewContainer->setFixedSize(200, 50);
    previewContainer->setStyleSheet("background: #1e1e1e; border-radius: 8px; border: 1px solid #333;");
    auto* pl = new QVBoxLayout(previewContainer);
    pl->setContentsMargins(2, 2, 2, 2);
    m_colorDisplay = new QWidget();
    m_colorDisplay->setObjectName("mainPreview");
    m_colorDisplay->setStyleSheet("border-radius: 6px; background: #D64260;");
    auto* cl = new QVBoxLayout(m_colorDisplay);
    cl->setContentsMargins(0, 0, 0, 0);
    m_colorLabel = new QLabel("#D64260");
    m_colorLabel->setCursor(Qt::PointingHandCursor);
    m_colorLabel->setAlignment(Qt::AlignCenter);
    m_colorLabel->setStyleSheet("font-family: Consolas; font-size: 18px; font-weight: bold; border: none; background: transparent;");
    // m_colorLabel->setToolTip("当前 HEX 颜色");
    m_colorLabel->setProperty("tooltipText", "当前 HEX 颜色");
    m_colorLabel->installEventFilter(this);
    cl->addWidget(m_colorLabel);
    pl->addWidget(m_colorDisplay);
    row1->addWidget(previewContainer);

    // ② HEX 框 (含复制按钮)
    auto* hexLayout = new QHBoxLayout();
    hexLayout->setSpacing(2);
    m_hexEntry = new QLineEdit();
    m_hexEntry->setPlaceholderText("HEX");
    m_hexEntry->setFixedWidth(80);
    m_hexEntry->setFixedHeight(36);
    m_hexEntry->setAlignment(Qt::AlignCenter);
    // m_hexEntry->setToolTip("输入 HEX 代码并回车应用");
    m_hexEntry->setProperty("tooltipText", "输入 HEX 代码并回车应用");
    m_hexEntry->installEventFilter(this);
    connect(m_hexEntry, &QLineEdit::returnPressed, this, &ColorPickerWindow::applyHexColor);
    hexLayout->addWidget(m_hexEntry);
    
    auto* btnCopyHex = new QPushButton();
    btnCopyHex->setAutoDefault(false);
    btnCopyHex->setIcon(IconHelper::getIcon("copy", "#CCCCCC"));
    btnCopyHex->setFixedSize(28, 36);
    // btnCopyHex->setToolTip("复制 HEX 代码");
    btnCopyHex->setProperty("tooltipText", "复制 HEX 代码");
    btnCopyHex->installEventFilter(this);
    btnCopyHex->setStyleSheet("QPushButton { background: transparent; border: none; } QPushButton:hover { background: rgba(255,255,255,0.1); }");
    connect(btnCopyHex, &QPushButton::clicked, this, &ColorPickerWindow::copyHexValue);
    hexLayout->addWidget(btnCopyHex);
    row1->addLayout(hexLayout);

    // ③ RGB 框 (含复制按钮)
    auto* rgbContainer = new QWidget();
    rgbContainer->setFixedHeight(36);
    auto* rl = new QHBoxLayout(rgbContainer);
    rl->setContentsMargins(0, 0, 0, 0); rl->setSpacing(2);
    m_rEntry = new QLineEdit(); m_rEntry->setFixedWidth(35); m_rEntry->setFixedHeight(36); m_rEntry->setAlignment(Qt::AlignCenter); m_rEntry->setPlaceholderText("R");
    m_gEntry = new QLineEdit(); m_gEntry->setFixedWidth(35); m_gEntry->setFixedHeight(36); m_gEntry->setAlignment(Qt::AlignCenter); m_gEntry->setPlaceholderText("G");
    m_bEntry = new QLineEdit(); m_bEntry->setFixedWidth(35); m_bEntry->setFixedHeight(36); m_bEntry->setAlignment(Qt::AlignCenter); m_bEntry->setPlaceholderText("B");
    connect(m_rEntry, &QLineEdit::returnPressed, this, &ColorPickerWindow::applyRgbColor);
    connect(m_gEntry, &QLineEdit::returnPressed, this, &ColorPickerWindow::applyRgbColor);
    connect(m_bEntry, &QLineEdit::returnPressed, this, &ColorPickerWindow::applyRgbColor);
    rl->addWidget(m_rEntry);
    rl->addWidget(m_gEntry);
    rl->addWidget(m_bEntry);
    
    auto* btnCopyRgb = new QPushButton();
    btnCopyRgb->setAutoDefault(false);
    btnCopyRgb->setIcon(IconHelper::getIcon("copy", "#CCCCCC"));
    btnCopyRgb->setFixedSize(28, 36);
    // btnCopyRgb->setToolTip("复制 RGB 代码");
    btnCopyRgb->setProperty("tooltipText", "复制 RGB 代码");
    btnCopyRgb->installEventFilter(this);
    btnCopyRgb->setStyleSheet("QPushButton { background: transparent; border: none; } QPushButton:hover { background: rgba(255,255,255,0.1); }");
    connect(btnCopyRgb, &QPushButton::clicked, this, &ColorPickerWindow::copyRgbValue);
    rl->addWidget(btnCopyRgb);
    row1->addWidget(rgbContainer);

    // ④ 工具按钮 (整合进首排)
    auto* toolsLayout = new QHBoxLayout();
    toolsLayout->setSpacing(6);
    auto createToolBtn = [&](const QString& iconName, std::function<void()> cmd, QString color, QString tip) {
        auto* btn = new QPushButton();
        btn->setAutoDefault(false);
        btn->setIcon(IconHelper::getIcon(iconName, "#FFFFFF"));
        btn->setIconSize(QSize(18, 18));
        btn->setFixedSize(36, 36);
        btn->setStyleSheet(QString("QPushButton { background: %1; border: none; border-radius: 6px; } QPushButton:hover { opacity: 0.8; }").arg(color));
        // btn->setToolTip(tip);
        btn->setProperty("tooltipText", tip);
        btn->installEventFilter(this);
        connect(btn, &QPushButton::clicked, cmd);
        toolsLayout->addWidget(btn);
    };
    createToolBtn("palette", [this](){ openColorPicker(); }, "#3b8ed0", "色轮");
    createToolBtn("screen_picker", [this](){ startScreenPicker(); }, "#9b59b6", "吸色器");
    createToolBtn("pixel_ruler", [this](){ openPixelRuler(); }, "#e67e22", "标尺");
    createToolBtn("image", [this](){ extractFromImage(); }, "#2ecc71", "提取图片");
    createToolBtn("star", [this](){ addToFavorites(); }, "#f39c12", "收藏");
    row1->addLayout(toolsLayout);
    
    row1->addStretch();
    mainVLayout->addLayout(row1);

    // --- 第二排：渐变生成器 ⑤ (摊平成一行) ---
    auto* gradBox = new QFrame();
    gradBox->setObjectName("gradBox");
    gradBox->setFixedHeight(50);
    gradBox->setStyleSheet("QFrame#gradBox { background: #252526; border-radius: 8px; border: 1px solid #383838; }");
    auto* gl = new QHBoxLayout(gradBox);
    gl->setContentsMargins(15, 0, 15, 0);
    gl->setSpacing(8);

    auto* gt = new QLabel("渐变生成器");
    gt->setStyleSheet("font-weight: bold; font-size: 12px; color: #888; background: transparent;");
    gl->addWidget(gt);

    auto addGradInput = [&](const QString& label, QLineEdit*& entry, int width) {
        auto* lbl = new QLabel(label);
        lbl->setStyleSheet("font-size: 11px; color: #666; background: transparent;");
        gl->addWidget(lbl);
        entry = new QLineEdit();
        entry->setFixedWidth(width);
        entry->setFixedHeight(28);
        gl->addWidget(entry);
    };
    addGradInput("起始", m_gradStart, 80);
    addGradInput("结束", m_gradEnd, 80);
    
    auto* stepslbl = new QLabel("步数");
    stepslbl->setStyleSheet("color: #666; font-size: 11px; background: transparent; border: none;");
    gl->addWidget(stepslbl);
    
    m_gradSteps = new QLineEdit("7");
    m_gradSteps->setFixedWidth(77);
    m_gradSteps->setFixedHeight(28);
    m_gradSteps->setAlignment(Qt::AlignCenter);
    gl->addWidget(m_gradSteps);
    
    auto* sl = new QVBoxLayout();
    sl->setContentsMargins(0, 4, 0, 4);
    sl->setSpacing(0);
    
    QString spinBtnStyle = "QPushButton { background: transparent; border: none; padding: 0px; margin: 0px; } "
                           "QPushButton:hover { background: rgba(255, 255, 255, 0.1); border-radius: 2px; }";

    auto* btnUp = new QPushButton();
    btnUp->setFixedSize(16, 12);
    btnUp->setCursor(Qt::PointingHandCursor);
    btnUp->setIcon(IconHelper::getIcon("arrow_up", "#aaaaaa", 12));
    btnUp->setIconSize(QSize(12, 12));
    btnUp->setStyleSheet(spinBtnStyle);
    connect(btnUp, &QPushButton::clicked, [this](){
        int val = m_gradSteps->text().toInt();
        m_gradSteps->setText(QString::number(val + 1));
    });
    
    auto* btnDown = new QPushButton();
    btnDown->setFixedSize(16, 12);
    btnDown->setCursor(Qt::PointingHandCursor);
    btnDown->setIcon(IconHelper::getIcon("arrow_down", "#aaaaaa", 12));
    btnDown->setIconSize(QSize(12, 12));
    btnDown->setStyleSheet(spinBtnStyle);
    connect(btnDown, &QPushButton::clicked, [this](){
        int val = m_gradSteps->text().toInt();
        if (val > 2) m_gradSteps->setText(QString::number(val - 1));
    });
    
    sl->addWidget(btnUp);
    sl->addWidget(btnDown);
    
    gl->addSpacing(-6); 
    gl->addLayout(sl);

    gl->addSpacing(5);
    auto createModeBtn = [&](const QString& mode) {
        auto* btn = new QPushButton(mode);
        btn->setAutoDefault(false);
        btn->setCheckable(true);
        btn->setFixedWidth(45);
        btn->setFixedHeight(26);
        btn->setStyleSheet(
            "QPushButton { background: #333; border: 1px solid #444; border-radius: 4px; font-size: 11px; padding: 0; } "
            "QPushButton:hover { background: #444; } "
            "QPushButton:checked { background: #007ACC; color: white; border-color: #007ACC; }"
        );
        if (m_gradMode == mode) btn->setChecked(true);
        connect(btn, &QPushButton::clicked, [this, mode, gradBox](){
            m_gradMode = mode;
            for(auto* b : gradBox->findChildren<QPushButton*>()) {
                if(b->isCheckable()) b->setChecked(b->text() == mode);
            }
        });
        return btn;
    };
    gl->addWidget(createModeBtn("变暗"));
    gl->addWidget(createModeBtn("变亮"));
    gl->addWidget(createModeBtn("饱和"));

    auto* btnGrad = new QPushButton("生成渐变");
    btnGrad->setAutoDefault(false);
    btnGrad->setFixedSize(80, 28);
    btnGrad->setStyleSheet("background: #007ACC; font-weight: bold; color: white; border: none; border-radius: 4px;");
    connect(btnGrad, &QPushButton::clicked, this, &ColorPickerWindow::generateGradient);
    gl->addWidget(btnGrad);
    gl->addStretch();
    
    mainVLayout->addWidget(gradBox);

    // --- 图片预览区域 (从左侧面板移出，由逻辑触发显示) ---
    m_imagePreviewFrame = new QFrame();
    m_imagePreviewFrame->setObjectName("imagePreviewFrame");
    m_imagePreviewFrame->setStyleSheet("QFrame#imagePreviewFrame { background: #1e1e1e; border: 1px dashed #555; border-radius: 12px; }");
    m_imagePreviewFrame->setFixedHeight(120);
    auto* ipl = new QHBoxLayout(m_imagePreviewFrame);
    ipl->setContentsMargins(10, 5, 10, 5);
    m_imagePreviewLabel = new QLabel("暂无图片");
    m_imagePreviewLabel->setAlignment(Qt::AlignCenter);
    m_imagePreviewLabel->setStyleSheet("color: #666; border: none; background: transparent;");
    ipl->addWidget(m_imagePreviewLabel, 1);
    auto* btnClearImg = new QPushButton("重置图片提取");
    btnClearImg->setAutoDefault(false);
    btnClearImg->setFixedSize(120, 30);
    btnClearImg->setStyleSheet("color: #888; border: 1px solid #444; background: #2A2A2A; font-size: 11px; border-radius: 4px;");
    connect(btnClearImg, &QPushButton::clicked, [this](){
        m_imagePreviewFrame->hide();
        m_imagePreviewLabel->setPixmap(QPixmap());
        qDeleteAll(m_extractGridContainer->findChildren<QWidget*>(QString(), Qt::FindDirectChildrenOnly));
        m_dropHintContainer->show();
        showNotification("已重置图片提取");
    });
    ipl->addWidget(btnClearImg);
    mainVLayout->addWidget(m_imagePreviewFrame);
    m_imagePreviewFrame->hide();

    // --- 第三排：导航切换 ---
    auto* navBar = new QHBoxLayout();
    navBar->setSpacing(10);
    auto createNavBtn = [&](const QString& text) {
        auto* btn = new QPushButton(text);
        btn->setAutoDefault(false);
        btn->setFixedHeight(36);
        btn->setFixedWidth(120);
        btn->setStyleSheet(
            "QPushButton { background: #333; border-radius: 6px; font-weight: bold; border: 1px solid #444; } "
            "QPushButton:hover { background: #444; } "
            "QPushButton:checked { background: #007ACC; color: white; border-color: #007ACC; }"
        );
        btn->setCheckable(true);
        connect(btn, &QPushButton::clicked, [this, text, navBar, btn](){ 
            for(int i=0; i<navBar->count(); i++) {
                auto* b = qobject_cast<QPushButton*>(navBar->itemAt(i)->widget());
                if(b) b->setChecked(false);
            }
            btn->setChecked(true);
            switchView(text); 
        });
        if(text=="我的收藏") btn->setChecked(true);
        return btn;
    };
    navBar->addStretch();
    navBar->addWidget(createNavBtn("我的收藏"));
    navBar->addWidget(createNavBtn("渐变预览"));
    navBar->addWidget(createNavBtn("图片提取"));
    navBar->addStretch();
    mainVLayout->addLayout(navBar);

    // --- 第四排：内容区域 (Stacked Widget) ---
    createRightPanel(m_contentArea);
    mainVLayout->addWidget(m_stack, 1);
}

void ColorPickerWindow::createRightPanel(QWidget* parent) {
    m_stack = new QStackedWidget();
    auto createScroll = [&](QWidget*& content) {
        auto* scroll = new QScrollArea();
        scroll->setWidgetResizable(true);
        scroll->setFrameShape(QFrame::NoFrame);
        scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        content = new QWidget();
        content->setStyleSheet("background: transparent;");
        scroll->setWidget(content);
        return scroll;
    };
    m_favScroll = createScroll(m_favContent);
    m_gradScroll = createScroll(m_gradContent);
    m_extractScroll = createScroll(m_extractContent);
    
    auto* fl = new QVBoxLayout(m_favContent);
    fl->setContentsMargins(20, 20, 25, 20);
    fl->setSpacing(15);
    auto* ft = new QLabel("我的收藏");
    ft->setStyleSheet("font-size: 20px; font-weight: bold; color: white; border: none;");
    fl->addWidget(ft);
    
    m_favGridContainer = new QFrame();
    m_favGridContainer->setObjectName("cardContainer");
    m_favGridContainer->setStyleSheet("QFrame#cardContainer { background: #252526; border-radius: 12px; }");
    m_favGridContainer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    new FlowLayout(m_favGridContainer, 10, 5, 5); 
    fl->addWidget(m_favGridContainer);
    fl->addStretch();

    auto* gl = new QVBoxLayout(m_gradContent);
    gl->setContentsMargins(20, 20, 25, 20);
    gl->setSpacing(15);
    auto* gt = new QLabel("渐变预览");
    gt->setStyleSheet("font-size: 20px; font-weight: bold; color: white; border: none;");
    gl->addWidget(gt);

    auto* gt2 = new QLabel("生成结果 (左键应用 / 右键收藏)");
    gt2->setStyleSheet("font-weight: bold; font-size: 14px; border: none; background: transparent; color: #888;");
    gl->addWidget(gt2);

    m_gradGridContainer = new QFrame();
    m_gradGridContainer->setObjectName("cardContainer");
    m_gradGridContainer->setStyleSheet("QFrame#cardContainer { background: #252526; border-radius: 12px; }");
    m_gradGridContainer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    new FlowLayout(m_gradGridContainer, 10, 5, 5);
    gl->addWidget(m_gradGridContainer);
    gl->addStretch();

    auto* el = new QVBoxLayout(m_extractContent);
    el->setContentsMargins(20, 20, 25, 20);
    el->setSpacing(15);
    auto* et = new QLabel("图片提取");
    et->setStyleSheet("font-size: 20px; font-weight: bold; color: white; border: none;");
    el->addWidget(et);

    auto* et2 = new QLabel("提取结果 (左键应用 / 右键收藏)");
    et2->setStyleSheet("font-weight: bold; font-size: 14px; border: none; background: transparent; color: #888;");
    el->addWidget(et2);

    m_dropHintContainer = new QFrame();
    m_dropHintContainer->setStyleSheet("background: transparent; border: 3px dashed #555; border-radius: 15px;");
    m_dropHintContainer->setFixedHeight(300);
    auto* hl = new QVBoxLayout(m_dropHintContainer);
    hl->setAlignment(Qt::AlignCenter);
    
    auto* iconHint = new QLabel();
    iconHint->setPixmap(IconHelper::getIcon("image", "#444444").pixmap(64, 64));
    iconHint->setAlignment(Qt::AlignCenter);
    iconHint->setStyleSheet("border: none; background: transparent;");
    hl->addWidget(iconHint);

    auto* hint = new QLabel("拖放图片到软件任意位置\n\n或\n\nCtrl+V 粘贴\n点击左侧相机图标");
    hint->setStyleSheet("color: #666; font-size: 16px; border: none; background: transparent; margin-top: 10px;");
    hint->setAlignment(Qt::AlignCenter);
    hl->addWidget(hint);
    el->addWidget(m_dropHintContainer);

    m_extractGridContainer = new QFrame();
    m_extractGridContainer->setObjectName("cardContainer");
    m_extractGridContainer->setStyleSheet("QFrame#cardContainer { background: #252526; border-radius: 12px; }");
    m_extractGridContainer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    new FlowLayout(m_extractGridContainer, 10, 5, 5);
    el->addWidget(m_extractGridContainer);
    el->addStretch();

    m_stack->addWidget(m_favScroll);
    m_stack->addWidget(m_gradScroll);
    m_stack->addWidget(m_extractScroll);
    
    updateFavoritesDisplay();
}

void ColorPickerWindow::switchView(const QString& value) {
    if (value == "我的收藏") { m_stack->setCurrentWidget(m_favScroll); updateFavoritesDisplay(); }
    else if (value == "渐变预览") { m_stack->setCurrentWidget(m_gradScroll); }
    else if (value == "图片提取") { m_stack->setCurrentWidget(m_extractScroll); }
}

void ColorPickerWindow::updateColorDisplay() {
    m_colorDisplay->setStyleSheet(QString("border-radius: 6px; background: %1;").arg(m_currentColor));
    m_colorLabel->setText(m_currentColor);
    QColor c = hexToColor(m_currentColor);
    m_colorLabel->setStyleSheet(QString("font-family: Consolas; font-size: 18px; font-weight: bold; border: none; background: transparent; color: %1;")
        .arg(c.lightness() > 128 ? "#1a1a1a" : "white"));
    m_hexEntry->setText(m_currentColor);
    m_rEntry->setText(QString::number(c.red()));
    m_gEntry->setText(QString::number(c.green()));
    m_bEntry->setText(QString::number(c.blue()));
    if(m_gradStart->text().isEmpty()) m_gradStart->setText(m_currentColor);
}

void ColorPickerWindow::useColor(const QString& hex) {
    m_currentColor = hex.toUpper();
    QSettings s("RapidNotes", "ColorPicker");
    s.setValue("lastColor", m_currentColor);
    updateColorDisplay();
}

void ColorPickerWindow::applyHexColor() {
    QString h = m_hexEntry->text().trimmed();
    if (!h.startsWith("#")) h = "#" + h;
    QColor c(h);
    if (c.isValid()) useColor(c.name().toUpper());
    else showNotification("无效的 HEX 颜色代码", true);
}

void ColorPickerWindow::applyRgbColor() {
    int r = m_rEntry->text().toInt();
    int g = m_gEntry->text().toInt();
    int b = m_bEntry->text().toInt();
    QColor c(r, g, b);
    if (c.isValid()) useColor(c.name().toUpper());
    else showNotification("RGB 值必须在 0-255 之间", true);
}

void ColorPickerWindow::copyHexValue() {
    ClipboardMonitor::instance().forceNext();
    QApplication::clipboard()->setText(m_currentColor);
    showNotification("已复制 " + m_currentColor);
}

void ColorPickerWindow::copyRgbValue() {
    QColor c = hexToColor(m_currentColor);
    QString rgb = QString("rgb(%1, %2, %3)").arg(c.red()).arg(c.green()).arg(c.blue());
    ClipboardMonitor::instance().forceNext();
    QApplication::clipboard()->setText(rgb);
    showNotification("已复制 " + rgb);
}

void ColorPickerWindow::startScreenPicker() {
    auto* picker = new ScreenColorPickerOverlay([this](QString hex){
        useColor(hex);
        addSpecificColorToFavorites(hex);
    }, nullptr);
    picker->show();
}

void ColorPickerWindow::openPixelRuler() {
    auto* ruler = new PixelRulerOverlay(nullptr);
    ruler->setAttribute(Qt::WA_DeleteOnClose);
    ruler->show();
}

void ColorPickerWindow::openColorPicker() {
    auto* dlg = new ColorPickerDialog(this, [this](QString hex){ useColor(hex); });
    dlg->show();
}

void ColorPickerWindow::addToFavorites() {
    addSpecificColorToFavorites(m_currentColor);
}

void ColorPickerWindow::addSpecificColorToFavorites(const QString& color) {
    if (!m_favorites.contains(color)) {
        m_favorites.prepend(color);
        saveFavorites();
        updateFavoritesDisplay();
        showNotification("已收藏: " + color);

        // 同步存入数据库，以便全局查找
        QStringList tags;
        tags << "颜色" << "收藏" << "色码" << "色值" << "颜值" << "颜色码";
        if (color.startsWith("#")) tags << "HEX";
        
        DatabaseManager::instance().addNoteAsync(
            color,              // 标题用颜色码
            color,              // 内容用颜色码
            tags,               // 标签
            color,              // 笔记卡片背景色直接设为该颜色
            -1,                 // 默认分类
            "color"             // 类型设为 color
        );
    } else {
        showNotification(color + " 已在收藏中", true);
    }
}

void ColorPickerWindow::removeFavorite(const QString& color) {
    m_favorites.removeAll(color);
    saveFavorites();
    updateFavoritesDisplay();
}

void ColorPickerWindow::updateFavoritesDisplay() {
    auto* flow = qobject_cast<FlowLayout*>(m_favGridContainer->layout());
    if (!flow) return;
    
    QLayoutItem *child;
    while ((child = flow->takeAt(0)) != nullptr) {
        if (child->widget()) child->widget()->deleteLater();
        delete child;
    }
    
    if (m_favorites.isEmpty()) {
        auto* lbl = new QLabel("暂无收藏\n右键点击任何颜色块即可收藏");
        lbl->setStyleSheet("color: #666; font-size: 16px; border: none; background: transparent; padding: 40px;");
        lbl->setAlignment(Qt::AlignCenter);
        flow->addWidget(lbl);
        return;
    }

    for (int i = 0; i < m_favorites.size(); ++i) {
        QWidget* tile = createFavoriteTile(m_favGridContainer, m_favorites[i]);
        flow->addWidget(tile);
    }
    m_favGridContainer->updateGeometry();
}

QWidget* ColorPickerWindow::createFavoriteTile(QWidget* parent, const QString& colorHex) {
    auto* tile = new QFrame(parent);
    // [CRITICAL] 将收藏项改为 30*30 的纯色方块，视觉更整洁
    tile->setFixedSize(30, 30);
    
    tile->setStyleSheet(QString(
        "QFrame { background-color: %1; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); }"
        "QFrame:hover { border: 1px solid white; }"
    ).arg(colorHex));
    
    // 悬停显示 HEX 值
    // tile->setToolTip(colorHex);
    tile->setProperty("tooltipText", colorHex);
    tile->setCursor(Qt::PointingHandCursor);
    tile->setProperty("color", colorHex);
    tile->installEventFilter(this);

    return tile;
}

void ColorPickerWindow::generateGradient() {
    QString startHex = m_gradStart->text().trimmed();
    if (!startHex.startsWith("#")) startHex = "#" + startHex;
    QColor start = QColor(startHex);
    if (!start.isValid()) { showNotification("起始色无效", true); return; }
    QString endHex = m_gradEnd->text().trimmed();
    int steps = m_gradSteps->text().toInt();
    if (steps < 2) steps = 2;
    QStringList colors;
    if (endHex.isEmpty()) {
        float h, s, v;
        start.getHsvF(&h, &s, &v);
        for (int i = 0; i < steps; ++i) {
            double ratio = (double)i / (steps - 1);
            QColor c;
            if (m_gradMode == "变暗") c = QColor::fromHsvF(h, s, v * (1 - ratio * 0.7));
            else if (m_gradMode == "变亮") c = QColor::fromHsvF(h, s, v + (1 - v) * ratio);
            else if (m_gradMode == "饱和") c = QColor::fromHsvF(h, std::min(1.0f, std::max(0.0f, s + (1 - s) * (float)ratio * (s < 0.5f ? 1.0f : -1.0f))), v);
            colors << c.name().toUpper();
        }
    } else {
        if (!endHex.startsWith("#")) endHex = "#" + endHex;
        QColor end = QColor(endHex);
        if (!end.isValid()) { showNotification("结束色无效", true); return; }
        for (int i = 0; i < steps; ++i) {
            double r = (double)i / (steps - 1);
            int red = start.red() + (end.red() - start.red()) * r;
            int green = start.green() + (end.green() - start.green()) * r;
            int blue = start.blue() + (end.blue() - start.blue()) * r;
            colors << QColor(red, green, blue).name().toUpper();
        }
    }
    
    auto* flow = qobject_cast<FlowLayout*>(m_gradGridContainer->layout());
    if (!flow) return;

    QLayoutItem *child;
    while ((child = flow->takeAt(0)) != nullptr) {
        if (child->widget()) child->widget()->deleteLater();
        delete child;
    }
    
    for (int i = 0; i < colors.size(); ++i) {
        QWidget* tile = createColorTile(m_gradGridContainer, colors[i]);
        flow->addWidget(tile);
    }
    m_gradGridContainer->updateGeometry();
    switchView("渐变预览");
}

QWidget* ColorPickerWindow::createColorTile(QWidget* parent, const QString& colorHex) {
    auto* tile = new QFrame(parent);
    // 同步修改为 30*30 色块以保持视觉统一
    tile->setFixedSize(30, 30); 
    
    tile->setStyleSheet(QString(
        "QFrame { background-color: %1; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); }"
        "QFrame:hover { border: 1px solid white; }"
    ).arg(colorHex));
    
    // tile->setToolTip(colorHex);
    tile->setProperty("tooltipText", colorHex);
    tile->setCursor(Qt::PointingHandCursor);
    tile->setProperty("color", colorHex);
    tile->installEventFilter(this);
    
    return tile;
}

void ColorPickerWindow::extractFromImage() {
    QString path = QFileDialog::getOpenFileName(this, "选择图片", "", "Images (*.png *.jpg *.jpeg *.bmp *.webp)");
    if (!path.isEmpty()) processImage(path);
}

void ColorPickerWindow::processImage(const QString& filePath, const QImage& image) {
    m_currentImagePath = filePath;
    QImage img = image;
    if (img.isNull() && !filePath.isEmpty()) {
        img.load(filePath);
    }
    if (img.isNull()) return;

    m_imagePreviewFrame->show();
    m_imagePreviewLabel->setPixmap(QPixmap::fromImage(img).scaled(340, 180, Qt::KeepAspectRatio, Qt::SmoothTransformation));
    m_imagePreviewLabel->setText("");
    
    m_dropHintContainer->hide();
    m_extractGridContainer->show();

    auto* flow = qobject_cast<FlowLayout*>(m_extractGridContainer->layout());
    if (!flow) return;

    QLayoutItem *child;
    while ((child = flow->takeAt(0)) != nullptr) {
        if (child->widget()) child->widget()->deleteLater();
        delete child;
    }
    
    QStringList colors = extractDominantColors(img, 24);
    for (int i = 0; i < colors.size(); ++i) {
        QWidget* tile = createColorTile(m_extractGridContainer, colors[i]);
        flow->addWidget(tile);
    }
    m_extractGridContainer->updateGeometry();
    
    switchView("图片提取");
    showNotification("图片已加载，调色板生成完毕");
}

void ColorPickerWindow::pasteImage() {
    const QMimeData* mime = QApplication::clipboard()->mimeData();
    if (!mime) return;

    if (mime->hasImage()) {
        QImage img = qvariant_cast<QImage>(mime->imageData());
        if (!img.isNull()) {
            processImage("", img);
            return;
        }
    }
    
    if (mime->hasUrls()) {
        QString path = mime->urls().first().toLocalFile();
        if (!path.isEmpty()) {
            QImage img(path);
            if (!img.isNull()) {
                processImage(path, img);
                return;
            }
        }
    }

    if (mime->hasFormat("image/png") || mime->hasFormat("image/jpeg") || mime->hasFormat("image/bmp")) {
        QImage img;
        if (img.loadFromData(mime->data("image/png"), "PNG") || 
            img.loadFromData(mime->data("image/jpeg"), "JPG") ||
            img.loadFromData(mime->data("image/bmp"), "BMP")) {
            processImage("", img);
            return;
        }
    }

    showNotification("剪贴板中没有图片或格式不支持", true);
}

QStringList ColorPickerWindow::extractDominantColors(const QImage& img, int num) {
    QImage small = img.scaled(120, 120, Qt::IgnoreAspectRatio, Qt::FastTransformation).convertToFormat(QImage::Format_RGB32);
    QMap<QRgb, int> counts;
    for (int y = 0; y < small.height(); ++y) {
        for (int x = 0; x < small.width(); ++x) { counts[small.pixel(x, y)]++; }
    }
    QList<QRgb> sorted = counts.keys();
    std::sort(sorted.begin(), sorted.end(), [&](QRgb a, QRgb b){ return counts[a] > counts[b]; });
    
    QStringList result;
    for (QRgb rgb : sorted) {
        QColor c(rgb);
        bool distinct = true;
        for(const QString& ex : result) {
            QColor exc(ex);
            int diff = abs(exc.red() - c.red()) + abs(exc.green() - c.green()) + abs(exc.blue() - c.blue());
            if(diff < 20) { distinct = false; break; }
        }
        if(distinct) {
            result << c.name().toUpper(); 
            if (result.size() >= num) break;
        }
    }
    return result;
}

void ColorPickerWindow::showNotification(const QString& message, bool isError) {
    if (m_notification) {
        m_notification->hide();
        m_notification->deleteLater();
    }
    
    m_notification = new QFrame(this);
    m_notification->setObjectName("notification");
    m_notification->setStyleSheet(QString("QFrame#notification { background: %1; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); }")
        .arg(isError ? "#e74c3c" : "#2ecc71"));
    
    auto* l = new QHBoxLayout(m_notification);
    l->setContentsMargins(15, 8, 15, 8);
    l->setSpacing(10);
    
    auto* icon = new QLabel();
    icon->setPixmap(IconHelper::getIcon(isError ? "close" : "select", "#FFFFFF").pixmap(18, 18));
    icon->setStyleSheet("border: none; background: transparent;");
    l->addWidget(icon);
    
    auto* lbl = new QLabel(message);
    lbl->setStyleSheet("color: white; font-weight: bold; font-size: 13px; border: none; background: transparent;");
    l->addWidget(lbl);
    
    m_notification->adjustSize();
    m_notification->move(width()/2 - m_notification->width()/2, height() - 80);
    m_notification->show();
    m_notification->raise();
    
    QTimer::singleShot(2500, m_notification, &QWidget::hide);
}

void ColorPickerWindow::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls() || event->mimeData()->hasImage()) event->acceptProposedAction();
}

void ColorPickerWindow::dropEvent(QDropEvent* event) {
    if (event->mimeData()->hasImage()) {
        QImage img = qvariant_cast<QImage>(event->mimeData()->imageData());
        if (!img.isNull()) processImage("", img);
    } else if (event->mimeData()->hasUrls()) {
        processImage(event->mimeData()->urls().first().toLocalFile());
    }
}

void ColorPickerWindow::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_V && (event->modifiers() & Qt::ControlModifier)) pasteImage();
    else FramelessDialog::keyPressEvent(event);
}

void ColorPickerWindow::hideEvent(QHideEvent* event) {
    QList<QWidget*> overlays = findChildren<QWidget*>();
    for (auto* w : overlays) {
        if (qobject_cast<ScreenColorPickerOverlay*>(w) || qobject_cast<PixelRulerOverlay*>(w)) {
            w->close();
        }
    }
    FramelessDialog::hideEvent(event);
}

bool ColorPickerWindow::eventFilter(QObject* watched, QEvent* event) {
    if (event->type() == QEvent::HoverEnter) {
        QString text = watched->property("tooltipText").toString();
        if (!text.isEmpty()) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), text);
            return true;
        }
    } else if (event->type() == QEvent::HoverLeave) {
        ToolTipOverlay::hideTip();
    } else if (event->type() == QEvent::MouseMove) {
        // [FIX] 拦截色块的鼠标移动事件，防止冒泡到父窗口触发错误的拖拽逻辑导致窗口跳动
        if (!watched->property("color").toString().isEmpty()) {
            return true;
        }
    } else if (event->type() == QEvent::MouseButtonPress) {
        auto* me = static_cast<QMouseEvent*>(event);
        QString color = watched->property("color").toString();
        if (!color.isEmpty()) {
            if (me->button() == Qt::LeftButton) {
                useColor(color);
                ClipboardMonitor::instance().forceNext();
                QApplication::clipboard()->setText(color);
                showNotification("已应用并复制 " + color);
                return true;
            } else if (me->button() == Qt::RightButton) {
                // 右键弹出菜单，包含“从收藏中移除”
                showColorContextMenu(color, me->globalPosition().toPoint());
                return true;
            }
        } else if (watched == m_colorLabel) {
            if (me->button() == Qt::LeftButton) {
                // 根据用户要求：主预览标签点击不再自动复制，仅作展示
            } else if (me->button() == Qt::RightButton) {
                showColorContextMenu(m_currentColor, me->globalPosition().toPoint());
            }
            return true;
        }
    }
    return FramelessDialog::eventFilter(watched, event);
}

void ColorPickerWindow::showColorContextMenu(const QString& colorHex, const QPoint& globalPos) {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       "QMenu::item { padding: 6px 20px 6px 10px; border-radius: 3px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    menu.addAction(IconHelper::getIcon("copy", "#1abc9c", 18), "复制 HEX 代码", [this, colorHex]() {
        ClipboardMonitor::instance().forceNext();
        QApplication::clipboard()->setText(colorHex);
        showNotification("已复制 HEX: " + colorHex);
    });

    QColor c(colorHex);
    QString rgb = QString("rgb(%1, %2, %3)").arg(c.red()).arg(c.green()).arg(c.blue());
    menu.addAction(IconHelper::getIcon("copy", "#3498db", 18), "复制 RGB 代码", [this, rgb]() {
        ClipboardMonitor::instance().forceNext();
        QApplication::clipboard()->setText(rgb);
        showNotification("已复制 RGB: " + rgb);
    });

    if (m_favorites.contains(colorHex)) {
        menu.addAction(IconHelper::getIcon("close", "#e74c3c", 18), "从收藏中移除", [this, colorHex]() {
            removeFavorite(colorHex);
        });
    } else {
        menu.addAction(IconHelper::getIcon("star", "#f1c40f", 18), "收藏此颜色", [this, colorHex]() {
            addSpecificColorToFavorites(colorHex);
        });
    }

    if (!m_currentImagePath.isEmpty() && m_stack->currentWidget() == m_extractScroll) {
        menu.addSeparator();
        QString path = m_currentImagePath;
        
        menu.addAction(IconHelper::getIcon("link", "#9b59b6", 18), "复制图片路径", [this, path]() {
            ClipboardMonitor::instance().forceNext();
            QApplication::clipboard()->setText(path);
            showNotification("已复制路径");
        });

        menu.addAction(IconHelper::getIcon("file", "#34495e", 18), "复制图片文件", [path]() {
            QMimeData* data = new QMimeData;
            QList<QUrl> urls;
            urls << QUrl::fromLocalFile(path);
            data->setUrls(urls);
            ClipboardMonitor::instance().forceNext();
            QApplication::clipboard()->setMimeData(data);
        });

        menu.addAction(IconHelper::getIcon("search", "#e67e22", 18), "定位图片文件", [path]() {
            QProcess::startDetached("explorer.exe", { "/select,", QDir::toNativeSeparators(path) });
        });

        menu.addAction(IconHelper::getIcon("folder", "#f39c12", 18), "定位文件夹", [path]() {
            QFileInfo fi(path);
            QDesktopServices::openUrl(QUrl::fromLocalFile(fi.absolutePath()));
        });
    }

    menu.exec(globalPos);
}

QString ColorPickerWindow::rgbToHex(int r, int g, int b) { return QColor(r, g, b).name().toUpper(); }
QColor ColorPickerWindow::hexToColor(const QString& hex) { return QColor(hex); }
QString ColorPickerWindow::colorToHex(const QColor& c) { return c.name().toUpper(); }

QStringList ColorPickerWindow::loadFavorites() {
    QSettings s("RapidNotes", "ColorPicker");
    return s.value("favorites").toStringList();
}

void ColorPickerWindow::saveFavorites() {
    QSettings s("RapidNotes", "ColorPicker");
    s.setValue("favorites", m_favorites);
}

#include "ColorPickerWindow.moc"
```

## 文件: `src/ui/ColorPickerWindow.h`

```cpp
#ifndef COLORPICKERWINDOW_H
#define COLORPICKERWINDOW_H

#include "FramelessDialog.h"
#include <QPushButton>
#include <QLabel>
#include <QLineEdit>
#include <QListWidget>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QStackedWidget>
#include <QScrollArea>
#include <QTimer>
#include <QFrame>

/**
 * @brief 专业颜色管理器 Pro
 */
class ColorPickerWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit ColorPickerWindow(QWidget* parent = nullptr);
    ~ColorPickerWindow();

    void showNotification(const QString& message, bool isError = false);
    void useColor(const QString& hex);

public slots:
    void startScreenPicker();   

protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dropEvent(QDropEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void hideEvent(QHideEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

private slots:
    // 工具按钮槽
    void openColorPicker();      
    void openPixelRuler();      
    void extractFromImage();     
    void addToFavorites();       

    // 颜色更新槽
    void applyHexColor();
    void applyRgbColor();
    void copyHexValue();
    void copyRgbValue();
    
    // 渐变生成
    void generateGradient();

    // 视图切换
    void switchView(const QString& value);

    // 右键菜单
    void showColorContextMenu(const QString& colorHex, const QPoint& globalPos);

    // 图片处理
    void processImage(const QString& filePath, const QImage& image = QImage());
    void pasteImage();

private:
    void initUI();
    void createRightPanel(QWidget* parent);
    void updateColorDisplay();
    
    // 辅助组件创建
    QWidget* createColorTile(QWidget* parent, const QString& color);
    QWidget* createFavoriteTile(QWidget* parent, const QString& color);
    
    // 数据持久化
    QStringList loadFavorites();
    void saveFavorites();
    void updateFavoritesDisplay();
    void addSpecificColorToFavorites(const QString& color);
    void removeFavorite(const QString& color);

    // 颜色计算辅助
    QString rgbToHex(int r, int g, int b);
    QColor hexToColor(const QString& hex);
    QString colorToHex(const QColor& c);
    QStringList extractDominantColors(const QImage& img, int num);

    // --- UI 组件 ---
    // 左侧
    // [CRITICAL] 核心状态变量，记录当前吸取的颜色。
    QString m_currentColor = "#D64260";
    QWidget* m_colorDisplay;
    QLabel* m_colorLabel;
    QLineEdit* m_hexEntry;
    QLineEdit* m_rEntry;
    QLineEdit* m_gEntry;
    QLineEdit* m_bEntry;
    
    QLineEdit* m_gradStart;
    QLineEdit* m_gradEnd;
    QLineEdit* m_gradSteps;
    QString m_gradMode = "变暗";

    QWidget* m_imagePreviewFrame;
    QLabel* m_imagePreviewLabel;

    // 右侧
    QStackedWidget* m_stack;
    QScrollArea* m_favScroll;
    QScrollArea* m_gradScroll;
    QScrollArea* m_extractScroll;
    
    QWidget* m_favContent;
    QWidget* m_gradContent;
    QWidget* m_extractContent;
    
    QWidget* m_dropHintContainer;
    QWidget* m_favGridContainer;
    QWidget* m_gradGridContainer;
    QWidget* m_extractGridContainer;

    // 状态
    QString m_currentImagePath = "";
    // [CRITICAL] 收藏夹列表，持久化存储用户喜爱的颜色。
    QStringList m_favorites;
    QFrame* m_notification = nullptr;

};

#endif // COLORPICKERWINDOW_H
```

## 文件: `src/core/DatabaseManager.cpp`

```cpp
#include "DatabaseManager.h"
#include <QDebug>
#include <QSqlRecord>
#include <QCoreApplication>
#include <QDateTime>
#include <QFile>
#include <QDir>
#include <QCryptographicHash>
#include <QRandomGenerator>
#include <QRegularExpression>
#include <QFileInfo>
#include <QStandardPaths>
#include "FileCryptoHelper.h"

DatabaseManager& DatabaseManager::instance() {
    static DatabaseManager inst;
    return inst;
}

QStringList DatabaseManager::s_tagClipboard;
QMutex DatabaseManager::s_tagClipboardMutex;

void DatabaseManager::setTagClipboard(const QStringList& tags) {
    QMutexLocker locker(&s_tagClipboardMutex);
    s_tagClipboard = tags;
}

QStringList DatabaseManager::getTagClipboard() {
    QMutexLocker locker(&s_tagClipboardMutex);
    return s_tagClipboard;
}

DatabaseManager::DatabaseManager(QObject* parent) : QObject(parent) {}

DatabaseManager::~DatabaseManager() {
    if (m_db.isOpen()) {
        m_db.close();
    }
}

bool DatabaseManager::init(const QString& dbPath) {
    QMutexLocker locker(&m_mutex);
    
    // 1. 确定路径
    // 外壳路径: 程序目录下的 inspiration.db
    m_realDbPath = dbPath; 
    
    // 内核路径: 用户 AppData 目录 (隐藏路径，用户通常不会去删这里)
    QString appDataPath = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    if (appDataPath.isEmpty()) {
        appDataPath = QCoreApplication::applicationDirPath() + "/data";
    }
    QDir().mkpath(appDataPath);
    m_dbPath = appDataPath + "/rapidnotes_kernel.db";
    
    qDebug() << "[DB] 外壳路径 (Shell):" << m_realDbPath;
    qDebug() << "[DB] 内核路径 (Kernel):" << m_dbPath;

    // 2. 自动迁移逻辑 (Legacy support)
    QString legacyDbPath = QFileInfo(m_realDbPath).absolutePath() + "/notes.db";
    if (!QFile::exists(m_realDbPath) && QFile::exists(legacyDbPath) && !QFile::exists(m_dbPath)) {
        qDebug() << "[DB] 检测到旧版 notes.db，且无新版内核，正在自动迁移至新的三层保护体系...";
        if (QFile::copy(legacyDbPath, m_dbPath)) {
            qDebug() << "[DB] 旧版数据已拷贝至内核，等待退出时加密合壳。";
        }
    }

    // 3. 解壳加载逻辑
    bool kernelExists = QFile::exists(m_dbPath);
    bool shellExists = QFile::exists(m_realDbPath);

    if (kernelExists) {
        // 如果 AppData 下的内核还在，即使外壳被删了，也会从这里加载并“复活”外壳
        qDebug() << "[DB] 检测到残留内核文件 (可能是上次异常退出或仅删除了外壳)，优先加载以恢复数据。";
    } else if (shellExists) {
        qDebug() << "[DB] 发现外壳文件，尝试加载...";
        
        QString key = FileCryptoHelper::getCombinedKey();
        
        if (FileCryptoHelper::decryptFileWithShell(m_realDbPath, m_dbPath, key)) {
            qDebug() << "[DB] 现代解密成功。";
        } else {
            qDebug() << "[DB] 现代解密失败 (未发现魔数标记)，尝试旧版解密 (Legacy)...";
            if (FileCryptoHelper::decryptFileLegacy(m_realDbPath, m_dbPath, key)) {
                qDebug() << "[DB] 旧版解密成功。";
            } else {
                qDebug() << "[DB] 旧版解密也失败 (密码错误或数据损坏)，尝试明文检测...";
                QFile file(m_realDbPath);
                if (file.open(QIODevice::ReadOnly)) {
                    QByteArray header = file.read(16);
                    file.close();
                    if (header.startsWith("SQLite format 3")) {
                        qDebug() << "[DB] 检测到明文数据库，执行直接加载。";
                        QFile::copy(m_realDbPath, m_dbPath);
                    } else {
                        qCritical() << "[DB] 外壳文件已损坏或格式完全无法识别。";
                        return false;
                    }
                } else {
                    qCritical() << "[DB] 无法读取外壳文件。";
                    return false;
                }
            }
        }
    } else {
        qDebug() << "[DB] 未发现现有数据库及内核，将创建新数据库。";
    }

    // 4. 打开数据库
    if (m_db.isOpen()) m_db.close();
    
    QString connectionName = "RapidNotes_Main_Conn";
    if (QSqlDatabase::contains(connectionName)) {
        m_db = QSqlDatabase::database(connectionName);
    } else {
        m_db = QSqlDatabase::addDatabase("QSQLITE", connectionName);
    }
    
    m_db.setDatabaseName(m_dbPath);

    if (!m_db.open()) {
        qCritical() << "无法打开数据库内核:" << m_db.lastError().text();
        return false;
    }

    if (!createTables()) return false;

    return true;
}

void DatabaseManager::closeAndPack() {
    QMutexLocker locker(&m_mutex);
    
    QString connName = m_db.connectionName();
    if (m_db.isOpen()) {
        m_db.close();
    }
    m_db = QSqlDatabase(); 
    if (!connName.isEmpty()) {
        QSqlDatabase::removeDatabase(connName);
    }
    
    if (QFile::exists(m_dbPath)) {
        qDebug() << "[DB] 正在执行退出合壳 (将内核加密保存至外壳文件)...";
        if (FileCryptoHelper::encryptFileWithShell(m_dbPath, m_realDbPath, FileCryptoHelper::getCombinedKey())) {
            if (QFile::exists(m_realDbPath) && QFileInfo(m_realDbPath).size() > 0) {
                if (FileCryptoHelper::secureDelete(m_dbPath)) {
                    qDebug() << "[DB] 合壳完成，安全擦除内核文件。";
                }
            }
        } else {
            qCritical() << "[DB] 合壳失败！数据保留在内核文件中。";
        }
    }
}

bool DatabaseManager::createTables() {
    QSqlQuery query(m_db);
    QString createNotesTable = R"(
        CREATE TABLE IF NOT EXISTS notes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT,
            content TEXT,
            tags TEXT,
            color TEXT DEFAULT '#2d2d2d',
            category_id INTEGER,
            item_type TEXT DEFAULT 'text',
            data_blob BLOB,
            content_hash TEXT,
            rating INTEGER DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            is_pinned INTEGER DEFAULT 0,
            is_locked INTEGER DEFAULT 0,
            is_favorite INTEGER DEFAULT 0,
            is_deleted INTEGER DEFAULT 0,
            source_app TEXT,
            source_title TEXT,
            last_accessed_at DATETIME
        )
    )";
    if (!query.exec(createNotesTable)) return false;

    QString createCategoriesTable = R"(
        CREATE TABLE IF NOT EXISTS categories (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            parent_id INTEGER,
            color TEXT DEFAULT '#808080',
            sort_order INTEGER DEFAULT 0,
            preset_tags TEXT,
            password TEXT,
            password_hint TEXT
        )
    )";
    query.exec(createCategoriesTable);
    query.exec("CREATE TABLE IF NOT EXISTS tags (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE NOT NULL)");
    query.exec("CREATE TABLE IF NOT EXISTS note_tags (note_id INTEGER, tag_id INTEGER, PRIMARY KEY (note_id, tag_id))");
    query.exec("CREATE INDEX IF NOT EXISTS idx_notes_content_hash ON notes(content_hash)");
    QString createFtsTable = R"(
        CREATE VIRTUAL TABLE IF NOT EXISTS notes_fts USING fts5(
            title, content, content='notes', content_rowid='id'
        )
    )";
    query.exec(createFtsTable);

    // 试用期与使用次数表
    query.exec("CREATE TABLE IF NOT EXISTS system_config (key TEXT PRIMARY KEY, value TEXT)");
    
    // 初始化试用信息
    QSqlQuery checkLaunch(m_db);
    checkLaunch.prepare("SELECT value FROM system_config WHERE key = 'first_launch_date'");
    if (checkLaunch.exec() && !checkLaunch.next()) {
        QSqlQuery initQuery(m_db);
        initQuery.prepare("INSERT INTO system_config (key, value) VALUES ('first_launch_date', :date)");
        initQuery.bindValue(":date", QDateTime::currentDateTime().toString(Qt::ISODate));
        initQuery.exec();
        
        initQuery.prepare("INSERT INTO system_config (key, value) VALUES ('usage_count', '0')");
        initQuery.exec();
    }

    return true;
}

int DatabaseManager::addNote(const QString& title, const QString& content, const QStringList& tags,
                            const QString& color, int categoryId,
                            const QString& itemType, const QByteArray& dataBlob,
                            const QString& sourceApp, const QString& sourceTitle) {
    // 试用限制检查
    QVariantMap trial = getTrialStatus();
    if (trial["expired"].toBool() || trial["usage_limit_reached"].toBool()) {
        qWarning() << "[DB] 试用已结束或达到使用上限，停止新增灵感。";
        return 0;
    }

    QVariantMap newNoteMap;
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    QByteArray hashData = dataBlob.isEmpty() ? content.toUtf8() : dataBlob;
    QString contentHash = QCryptographicHash::hash(hashData, QCryptographicHash::Sha256).toHex();
    {   
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return 0;

        QString finalColor = color.isEmpty() ? "#2d2d2d" : color;
        QStringList finalTags = tags;

        // 查重：如果内容已存在，则更新标题和标签
        QSqlQuery checkQuery(m_db);
        checkQuery.prepare("SELECT id FROM notes WHERE content_hash = :hash AND is_deleted = 0 LIMIT 1");
        checkQuery.bindValue(":hash", contentHash);
        if (checkQuery.exec() && checkQuery.next()) {
            int existingId = checkQuery.value(0).toInt();

            QSqlQuery updateQuery(m_db);
            // [CRITICAL] 重复内容时，旧的标题和标签直接“不理会”，更新为当前的新标题和新标签
            updateQuery.prepare("UPDATE notes SET title = :title, tags = :tags, updated_at = :now, source_app = :app, source_title = :stitle WHERE id = :id");
            updateQuery.bindValue(":title", title);
            updateQuery.bindValue(":tags", finalTags.join(","));
            updateQuery.bindValue(":now", currentTime);
            updateQuery.bindValue(":app", sourceApp);
            updateQuery.bindValue(":stitle", sourceTitle);
            updateQuery.bindValue(":id", existingId);
            
            if (updateQuery.exec()) success = true;
            if (success) { 
                locker.unlock(); 
                emit noteUpdated(); 
                return existingId; 
            }
        }
        if (categoryId != -1) {
            QSqlQuery catQuery(m_db);
            catQuery.prepare("SELECT color, preset_tags FROM categories WHERE id = :id");
            catQuery.bindValue(":id", categoryId);
            if (catQuery.exec() && catQuery.next()) {
                if (color.isEmpty()) finalColor = catQuery.value(0).toString();
                QString preset = catQuery.value(1).toString();
                if (!preset.isEmpty()) {
                    QStringList pTags = preset.split(",", Qt::SkipEmptyParts);
                    for (const QString& t : pTags) {
                        QString trimmed = t.trimmed();
                        if (!finalTags.contains(trimmed)) finalTags << trimmed;
                    }
                }
            }
        }
        QSqlQuery query(m_db);
        query.prepare("INSERT INTO notes (title, content, tags, color, category_id, item_type, data_blob, content_hash, created_at, updated_at, source_app, source_title) VALUES (:title, :content, :tags, :color, :category_id, :item_type, :data_blob, :hash, :created_at, :updated_at, :source_app, :source_title)");
        query.bindValue(":title", title);
        query.bindValue(":content", content);
        query.bindValue(":tags", finalTags.join(","));
        query.bindValue(":color", finalColor);
        query.bindValue(":category_id", categoryId == -1 ? QVariant(QMetaType::fromType<int>()) : categoryId);
        query.bindValue(":item_type", itemType);
        query.bindValue(":data_blob", dataBlob);
        query.bindValue(":hash", contentHash);
        query.bindValue(":created_at", currentTime);
        query.bindValue(":updated_at", currentTime);
        query.bindValue(":source_app", sourceApp);
        query.bindValue(":source_title", sourceTitle);
        if (query.exec()) {
            success = true;
            QVariant lastId = query.lastInsertId();
            QSqlQuery fetch(m_db);
            fetch.prepare("SELECT * FROM notes WHERE id = :id");
            fetch.bindValue(":id", lastId);
            if (fetch.exec() && fetch.next()) {
                QSqlRecord rec = fetch.record();
                for (int i = 0; i < rec.count(); ++i) newNoteMap[rec.fieldName(i)] = fetch.value(i);
            }
        }
    }
    if (success && !newNoteMap.isEmpty()) {
        int newId = newNoteMap["id"].toInt();
        syncFts(newId, title, content);
        incrementUsageCount(); // 每次增加笔记视为一次使用
        emit noteAdded(newNoteMap);
        return newId;
    }
    return 0;
}

bool DatabaseManager::updateNote(int id, const QString& title, const QString& content, const QStringList& tags, const QString& color, int categoryId) {
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        QString sql = "UPDATE notes SET title=:title, content=:content, tags=:tags, updated_at=:updated_at";
        if (!color.isEmpty()) sql += ", color=:color";
        else if (categoryId != -1) {
            QSqlQuery catQuery(m_db);
            catQuery.prepare("SELECT color FROM categories WHERE id = :id");
            catQuery.bindValue(":id", categoryId);
            if (catQuery.exec() && catQuery.next()) sql += ", color=:color";
        }
        if (categoryId != -1) sql += ", category_id=:category_id";
        sql += " WHERE id=:id";
        query.prepare(sql);
        query.bindValue(":title", title);
        query.bindValue(":content", content);
        query.bindValue(":tags", tags.join(","));
        query.bindValue(":updated_at", currentTime);
        if (!color.isEmpty()) query.bindValue(":color", color);
        else if (categoryId != -1) {
            QSqlQuery catQuery(m_db);
            catQuery.prepare("SELECT color FROM categories WHERE id = :id");
            catQuery.bindValue(":id", categoryId);
            if (catQuery.exec() && catQuery.next()) query.bindValue(":color", catQuery.value(0).toString());
        }
        if (categoryId != -1) query.bindValue(":category_id", categoryId);
        query.bindValue(":id", id);
        success = query.exec();
    }
    if (success) { syncFts(id, title, content); emit noteUpdated(); }
    return success;
}

bool DatabaseManager::reorderCategories(int parentId, bool ascending) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    QSqlQuery query(m_db);
    if (parentId <= 0) query.prepare("SELECT id, name FROM categories WHERE parent_id IS NULL OR parent_id <= 0");
    else { query.prepare("SELECT id, name FROM categories WHERE parent_id = :pid"); query.bindValue(":pid", parentId); }
    if (!query.exec()) return false;
    struct CatInfo { int id; QString name; };
    QList<CatInfo> list;
    while (query.next()) list.append({query.value(0).toInt(), query.value(1).toString()});
    if (list.isEmpty()) return true;
    std::sort(list.begin(), list.end(), [ascending](const CatInfo& a, const CatInfo& b) {
        if (ascending) return a.name.localeAwareCompare(b.name) < 0;
        return a.name.localeAwareCompare(b.name) > 0;
    });
    m_db.transaction();
    QSqlQuery update(m_db);
    for (int i = 0; i < list.size(); ++i) {
        update.prepare("UPDATE categories SET sort_order = :val WHERE id = :id");
        update.bindValue(":val", i);
        update.bindValue(":id", list[i].id);
        update.exec();
    }
    bool ok = m_db.commit();
    if (ok) emit categoriesChanged();
    return ok;
}

bool DatabaseManager::updateCategoryOrder(int parentId, const QList<int>& categoryIds) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    if (!m_db.transaction()) return false;
    QSqlQuery query(m_db);
    query.prepare("UPDATE categories SET parent_id = :pid, sort_order = :order WHERE id = :id");
    for (int i = 0; i < categoryIds.size(); ++i) {
        query.bindValue(":pid", parentId <= 0 ? QVariant() : parentId);
        query.bindValue(":order", i);
        query.bindValue(":id", categoryIds[i]);
        if (!query.exec()) { m_db.rollback(); return false; }
    }
    bool ok = m_db.commit();
    if (ok) emit categoriesChanged();
    return ok;
}

bool DatabaseManager::reorderAllCategories(bool ascending) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    QSqlQuery query(m_db);
    query.exec("SELECT DISTINCT parent_id FROM categories");
    QList<int> parents;
    bool hasRoot = false;
    while (query.next()) {
        if (query.value(0).isNull() || query.value(0).toInt() <= 0) hasRoot = true;
        else parents.append(query.value(0).toInt());
    }
    bool success = true;
    if (hasRoot) success &= reorderCategories(-1, ascending);
    for (int pid : parents) success &= reorderCategories(pid, ascending);
    return success;
}

bool DatabaseManager::setCategoryPassword(int id, const QString& password, const QString& hint) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QString hashedPassword = QString(QCryptographicHash::hash(password.toUtf8(), QCryptographicHash::Sha256).toHex());
        QSqlQuery query(m_db);
        query.prepare("UPDATE categories SET password=:password, password_hint=:hint WHERE id=:id");
        query.bindValue(":password", hashedPassword);
        query.bindValue(":hint", hint);
        query.bindValue(":id", id);
        success = query.exec();
    }
    if (success) emit categoriesChanged();
    return success;
}

bool DatabaseManager::removeCategoryPassword(int id) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        query.prepare("UPDATE categories SET password=NULL, password_hint=NULL WHERE id=:id");
        query.bindValue(":id", id);
        success = query.exec();
        if (success) m_unlockedCategories.remove(id);
    }
    if (success) emit categoriesChanged();
    return success;
}

bool DatabaseManager::verifyCategoryPassword(int id, const QString& password) {
    bool correct = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QString hashedPassword = QString(QCryptographicHash::hash(password.toUtf8(), QCryptographicHash::Sha256).toHex());
        QSqlQuery query(m_db);
        query.prepare("SELECT password FROM categories WHERE id=:id");
        query.bindValue(":id", id);
        if (query.exec() && query.next()) {
            if (query.value(0).toString() == hashedPassword) correct = true;
        }
    }
    if (correct) unlockCategory(id);
    return correct;
}

bool DatabaseManager::isCategoryLocked(int id) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    if (m_unlockedCategories.contains(id)) return false;
    QSqlQuery query(m_db);
    query.prepare("SELECT password FROM categories WHERE id=:id");
    query.bindValue(":id", id);
    if (query.exec() && query.next()) return !query.value(0).toString().isEmpty();
    return false;
}

void DatabaseManager::lockCategory(int id) { { QMutexLocker locker(&m_mutex); m_unlockedCategories.remove(id); } emit categoriesChanged(); }
void DatabaseManager::unlockCategory(int id) { { QMutexLocker locker(&m_mutex); m_unlockedCategories.insert(id); } emit categoriesChanged(); }

bool DatabaseManager::restoreAllFromTrash() {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        success = query.exec("UPDATE notes SET is_deleted = 0, category_id = NULL, color = '#0A362F' WHERE is_deleted = 1");
    }
    if (success) { emit noteUpdated(); emit categoriesChanged(); }
    return success;
}

bool DatabaseManager::updateNoteState(int id, const QString& column, const QVariant& value) {
    bool success = false;
    QString title, content;
    bool needsFts = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        // [CRITICAL] 必须包含 item_type 以支持从图片识别提取的文字类型标记
        QStringList allowedColumns = {"is_pinned", "is_locked", "is_favorite", "is_deleted", "tags", "rating", "category_id", "color", "content", "title", "item_type"};
        if (!allowedColumns.contains(column)) return false;
        QSqlQuery query(m_db);
        if (column == "is_favorite") {
            bool fav = value.toBool();
            QString color = fav ? "#ff6b81" : ""; 
            if (!fav) {
                QSqlQuery catQuery(m_db);
                catQuery.prepare("SELECT c.color FROM categories c JOIN notes n ON n.category_id = c.id WHERE n.id = :id");
                catQuery.bindValue(":id", id);
                if (catQuery.exec() && catQuery.next()) color = catQuery.value(0).toString();
                else color = "#0A362F"; 
            }
            query.prepare("UPDATE notes SET is_favorite = :val, color = :color, updated_at = :now WHERE id = :id");
            query.bindValue(":color", color);
        } else if (column == "is_deleted") {
            bool del = value.toBool();
            QString color = del ? "#2d2d2d" : "#0A362F";
            query.prepare("UPDATE notes SET is_deleted = :val, color = :color, category_id = NULL, updated_at = :now WHERE id = :id");
            query.bindValue(":color", color);
        } else if (column == "category_id") {
            int catId = value.isNull() ? -1 : value.toInt();
            QString color = "#0A362F"; 
            if (catId != -1) {
                QSqlQuery catQuery(m_db);
                catQuery.prepare("SELECT color FROM categories WHERE id = :id");
                catQuery.bindValue(":id", catId);
                if (catQuery.exec() && catQuery.next()) color = catQuery.value(0).toString();
            }
            query.prepare("UPDATE notes SET category_id = :val, color = :color, is_deleted = 0, updated_at = :now WHERE id = :id");
            query.bindValue(":color", color);
        } else {
            query.prepare(QString("UPDATE notes SET %1 = :val, updated_at = :now WHERE id = :id").arg(column));
        }
        query.bindValue(":val", value);
        query.bindValue(":now", currentTime);
        query.bindValue(":id", id);
        success = query.exec();
        if (success && (column == "content" || column == "title")) {
            needsFts = true;
            QSqlQuery fetch(m_db);
            fetch.prepare("SELECT title, content FROM notes WHERE id = ?");
            fetch.addBindValue(id);
            if (fetch.exec() && fetch.next()) { title = fetch.value(0).toString(); content = fetch.value(1).toString(); }
        }
    } 
    if (success) { if (needsFts) syncFts(id, title, content); emit noteUpdated(); }
    return success;
}

bool DatabaseManager::updateNoteStateBatch(const QList<int>& ids, const QString& column, const QVariant& value) {
    if (ids.isEmpty()) return true;
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QStringList allowedColumns = {"is_pinned", "is_locked", "is_favorite", "is_deleted", "tags", "rating", "category_id"};
        if (!allowedColumns.contains(column)) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        if (column == "category_id") {
            int catId = value.isNull() ? -1 : value.toInt();
            QString color = "#0A362F";
            if (catId != -1) {
                QSqlQuery catQuery(m_db);
                catQuery.prepare("SELECT color FROM categories WHERE id = :id");
                catQuery.bindValue(":id", catId);
                if (catQuery.exec() && catQuery.next()) color = catQuery.value(0).toString();
            }
            query.prepare("UPDATE notes SET category_id = :val, color = :color, is_deleted = 0, updated_at = :updated_at WHERE id = :id");
            for (int id : ids) {
                query.bindValue(":val", value);
                query.bindValue(":color", color);
                query.bindValue(":updated_at", currentTime);
                query.bindValue(":id", id);
                query.exec();
            }
        } else {
            QString sql = QString("UPDATE notes SET %1 = :val, updated_at = :updated_at WHERE id = :id").arg(column);
            query.prepare(sql);
            for (int id : ids) {
                query.bindValue(":val", value);
                query.bindValue(":updated_at", currentTime);
                query.bindValue(":id", id);
                query.exec();
            }
        }
        success = m_db.commit();
    }
    if (success) emit noteUpdated();
    return success;
}

bool DatabaseManager::recordAccess(int id) {
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        query.prepare("UPDATE notes SET last_accessed_at = :now WHERE id = :id");
        query.bindValue(":now", currentTime);
        query.bindValue(":id", id);
        success = query.exec();
    }
    return success;
}

bool DatabaseManager::toggleNoteState(int id, const QString& column) {
    QVariant currentVal;
    {
        QMutexLocker locker(&m_mutex);
        QSqlQuery query(m_db);
        query.prepare(QString("SELECT %1 FROM notes WHERE id = :id").arg(column));
        query.bindValue(":id", id);
        if (query.exec() && query.next()) currentVal = query.value(0);
    }
    if (currentVal.isValid()) return updateNoteState(id, column, !currentVal.toBool());
    return false;
}

bool DatabaseManager::moveNotesToCategory(const QList<int>& noteIds, int catId) {
    if (noteIds.isEmpty()) return true;
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QString catColor = "#0A362F"; 
        QString presetTags;
        if (catId != -1) {
            QSqlQuery catQuery(m_db);
            catQuery.prepare("SELECT color, preset_tags FROM categories WHERE id = :id");
            catQuery.bindValue(":id", catId);
            if (catQuery.exec() && catQuery.next()) { catColor = catQuery.value(0).toString(); presetTags = catQuery.value(1).toString(); }
        }
        QSqlQuery query(m_db);
        query.prepare("UPDATE notes SET category_id = :cat_id, color = :color, is_deleted = 0, updated_at = :now WHERE id = :id");
        QString now = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
        for (int id : noteIds) {
            query.bindValue(":cat_id", catId == -1 ? QVariant() : catId);
            query.bindValue(":color", catColor);
            query.bindValue(":now", now);
            query.bindValue(":id", id);
            query.exec();
            if (!presetTags.isEmpty()) {
                QSqlQuery fetchTags(m_db);
                fetchTags.prepare("SELECT tags FROM notes WHERE id = :id");
                fetchTags.bindValue(":id", id);
                if (fetchTags.exec() && fetchTags.next()) {
                    QString existing = fetchTags.value(0).toString();
                    QStringList tagList = existing.split(",", Qt::SkipEmptyParts);
                    QStringList newTags = presetTags.split(",", Qt::SkipEmptyParts);
                    bool changed = false;
                    for (const QString& t : newTags) { if (!tagList.contains(t.trimmed())) { tagList.append(t.trimmed()); changed = true; } }
                    if (changed) { QSqlQuery updateTags(m_db); updateTags.prepare("UPDATE notes SET tags = :tags WHERE id = :id"); updateTags.bindValue(":tags", tagList.join(",")); updateTags.bindValue(":id", id); updateTags.exec(); }
                }
            }
        }
        success = m_db.commit();
    }
    if (success) emit noteUpdated();
    return success;
}

bool DatabaseManager::deleteNotesBatch(const QList<int>& ids) {
    if (ids.isEmpty()) return true;
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("DELETE FROM notes WHERE id=:id");
        for (int id : ids) { query.bindValue(":id", id); if (query.exec()) removeFts(id); }
        success = m_db.commit();
    }
    if (success) emit noteUpdated();
    return success;
}

bool DatabaseManager::softDeleteNotes(const QList<int>& ids) {
    if (ids.isEmpty()) return true;
    bool success = false;
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("UPDATE notes SET is_deleted = 1, category_id = NULL, color = '#2d2d2d', is_pinned = 0, is_favorite = 0, updated_at = :now WHERE id = :id");
        for (int id : ids) { query.bindValue(":now", currentTime); query.bindValue(":id", id); query.exec(); }
        success = m_db.commit();
    }
    if (success) emit noteUpdated();
    return success;
}

void DatabaseManager::addNoteAsync(const QString& title, const QString& content, const QStringList& tags, const QString& color, int categoryId, const QString& itemType, const QByteArray& dataBlob, const QString& sourceApp, const QString& sourceTitle) {
    QMetaObject::invokeMethod(this, [this, title, content, tags, color, categoryId, itemType, dataBlob, sourceApp, sourceTitle]() { addNote(title, content, tags, color, categoryId, itemType, dataBlob, sourceApp, sourceTitle); }, Qt::QueuedConnection);
}

QList<QVariantMap> DatabaseManager::searchNotes(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page, int pageSize, const QVariantMap& criteria) {
    QMutexLocker locker(&m_mutex);
    QList<QVariantMap> results;
    if (!m_db.isOpen()) return results;
    QString baseSql = "SELECT notes.* FROM notes ";
    QString whereClause;
    QVariantList params;
    applyCommonFilters(whereClause, params, filterType, filterValue, criteria);
    
    if (!keyword.isEmpty()) {
        whereClause += "AND (notes.tags LIKE ? OR notes.title LIKE ? OR notes.content LIKE ?) ";
        QString likeVal = "%" + keyword + "%";
        params << likeVal << likeVal << likeVal;
    }
    
    QString finalSql = baseSql + whereClause + "ORDER BY ";
    if (!keyword.isEmpty()) { 
        finalSql += "CASE WHEN notes.tags LIKE ? THEN 0 ELSE 1 END, "; 
        params << "%" + keyword + "%"; 
    }
    
    if (filterType == "recently_visited") finalSql += "is_pinned DESC, last_accessed_at DESC";
    else finalSql += "is_pinned DESC, updated_at DESC";
    
    if (page > 0 && filterType != "trash") finalSql += QString(" LIMIT %1 OFFSET %2").arg(pageSize).arg((page - 1) * pageSize);
    
    QSqlQuery query(m_db);
    query.prepare(finalSql);
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    
    if (query.exec()) { 
        while (query.next()) { 
            QVariantMap map; 
            QSqlRecord rec = query.record(); 
            for (int i = 0; i < rec.count(); ++i) map[rec.fieldName(i)] = query.value(i); 
            results.append(map); 
        } 
    }
    else qCritical() << "searchNotes failed:" << query.lastError().text();
    return results;
}

int DatabaseManager::getNotesCount(const QString& keyword, const QString& filterType, const QVariant& filterValue, const QVariantMap& criteria) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return 0;
    QString baseSql = "SELECT COUNT(*) FROM notes ";
    QString whereClause;
    QVariantList params;
    applyCommonFilters(whereClause, params, filterType, filterValue, criteria);
    
    if (!keyword.isEmpty()) {
        whereClause += "AND (notes.tags LIKE ? OR notes.title LIKE ? OR notes.content LIKE ?) ";
        QString likeVal = "%" + keyword + "%";
        params << likeVal << likeVal << likeVal;
    }
    
    QSqlQuery query(m_db);
    query.prepare(baseSql + whereClause);
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { if (query.next()) return query.value(0).toInt(); }
    else qCritical() << "getNotesCount failed:" << query.lastError().text();
    return 0;
}

QStringList DatabaseManager::getAllTags() {
    QMutexLocker locker(&m_mutex);
    QStringList allTags;
    if (!m_db.isOpen()) return allTags;
    QSqlQuery query(m_db);
    if (query.exec("SELECT tags FROM notes WHERE tags != '' AND is_deleted = 0")) { while (query.next()) { QString tagsStr = query.value(0).toString(); QStringList parts = tagsStr.split(",", Qt::SkipEmptyParts); for (const QString& part : parts) { QString trimmed = part.trimmed(); if (!allTags.contains(trimmed)) allTags.append(trimmed); } } }
    allTags.sort();
    return allTags;
}

QList<QVariantMap> DatabaseManager::getRecentTagsWithCounts(int limit) {
    QMutexLocker locker(&m_mutex);
    QList<QVariantMap> results;
    if (!m_db.isOpen()) return results;
    struct TagData { QString name; int count = 0; QDateTime lastUsed; };
    QMap<QString, TagData> tagMap;
    QSqlQuery query(m_db);
    if (query.exec("SELECT tags, updated_at FROM notes WHERE tags != '' AND is_deleted = 0")) { while (query.next()) { QString tagsStr = query.value(0).toString(); QDateTime updatedAt = query.value(1).toDateTime(); QStringList parts = tagsStr.split(",", Qt::SkipEmptyParts); for (const QString& part : parts) { QString name = part.trimmed(); if (name.isEmpty()) continue; if (!tagMap.contains(name)) tagMap[name] = {name, 1, updatedAt}; else { tagMap[name].count++; if (updatedAt > tagMap[name].lastUsed) tagMap[name].lastUsed = updatedAt; } } } }
    QList<TagData> sortedList = tagMap.values();
    std::sort(sortedList.begin(), sortedList.end(), [](const TagData& a, const TagData& b) { if (a.lastUsed != b.lastUsed) return a.lastUsed > b.lastUsed; return a.count > b.count; });
    int actualLimit = qMin(limit, (int)sortedList.size());
    for (int i = 0; i < actualLimit; ++i) { QVariantMap m; m["name"] = sortedList[i].name; m["count"] = sortedList[i].count; results.append(m); }
    return results;
}

int DatabaseManager::addCategory(const QString& name, int parentId, const QString& color) {
    int lastId = -1;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return -1;
        int maxOrder = 0;
        QSqlQuery orderQuery(m_db);
        if (parentId == -1) orderQuery.exec("SELECT MAX(sort_order) FROM categories WHERE parent_id IS NULL OR parent_id = -1");
        else { orderQuery.prepare("SELECT MAX(sort_order) FROM categories WHERE parent_id = :pid"); orderQuery.bindValue(":pid", parentId); orderQuery.exec(); }
        if (orderQuery.next()) maxOrder = orderQuery.value(0).toInt();
        QString chosenColor = color;
        if (chosenColor.isEmpty()) { static const QStringList palette = { "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEEAD", "#D4A5A5", "#9B59B6", "#3498DB", "#E67E22", "#2ECC71", "#E74C3C", "#F1C40F", "#1ABC9C", "#34495E", "#95A5A6" }; chosenColor = palette.at(QRandomGenerator::global()->bounded(palette.size())); }
        QSqlQuery query(m_db);
        query.prepare("INSERT INTO categories (name, parent_id, color, sort_order) VALUES (:name, :parent_id, :color, :sort_order)");
        query.bindValue(":name", name);
        query.bindValue(":parent_id", parentId == -1 ? QVariant(QMetaType::fromType<int>()) : parentId);
        query.bindValue(":color", chosenColor);
        query.bindValue(":sort_order", maxOrder + 1);
        if (query.exec()) lastId = query.lastInsertId().toInt();
    }
    if (lastId != -1) emit categoriesChanged();
    return lastId;
}

bool DatabaseManager::renameCategory(int id, const QString& name) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        query.prepare("UPDATE categories SET name=:name WHERE id=:id");
        query.bindValue(":name", name);
        query.bindValue(":id", id);
        success = query.exec();
    }
    if (success) emit categoriesChanged();
    return success;
}

bool DatabaseManager::setCategoryColor(int id, const QString& color) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery treeQuery(m_db);
        treeQuery.prepare(R"(WITH RECURSIVE category_tree(id) AS (SELECT :id UNION ALL SELECT c.id FROM categories c JOIN category_tree ct ON c.parent_id = ct.id) SELECT id FROM category_tree)");
        treeQuery.bindValue(":id", id);
        QList<int> allIds;
        if (treeQuery.exec()) { while (treeQuery.next()) allIds << treeQuery.value(0).toInt(); }
        if (!allIds.isEmpty()) {
            QString placeholders;
            for(int i=0; i<allIds.size(); ++i) placeholders += (i==0 ? "?" : ",?");
            QSqlQuery updateNotes(m_db);
            updateNotes.prepare(QString("UPDATE notes SET color = ? WHERE category_id IN (%1)").arg(placeholders));
            updateNotes.addBindValue(color);
            for(int cid : allIds) updateNotes.addBindValue(cid);
            updateNotes.exec();
            QSqlQuery updateCats(m_db);
            updateCats.prepare(QString("UPDATE categories SET color = ? WHERE id IN (%1)").arg(placeholders));
            updateCats.addBindValue(color);
            for(int cid : allIds) updateCats.addBindValue(cid);
            updateCats.exec();
        }
        success = m_db.commit();
    }
    if (success) { emit categoriesChanged(); emit noteUpdated(); }
    return success;
}

bool DatabaseManager::deleteCategory(int id) {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        query.prepare("DELETE FROM categories WHERE id=:id");
        query.bindValue(":id", id);
        if (query.exec()) { QSqlQuery updateNotes(m_db); updateNotes.prepare("UPDATE notes SET category_id = NULL WHERE category_id = :id"); updateNotes.bindValue(":id", id); updateNotes.exec(); success = true; }
    }
    if (success) emit categoriesChanged();
    return success;
}

bool DatabaseManager::moveCategory(int id, MoveDirection direction) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return false;
    int parentId = -1;
    QSqlQuery parentQuery(m_db);
    parentQuery.prepare("SELECT parent_id FROM categories WHERE id = :id");
    parentQuery.bindValue(":id", id);
    if (parentQuery.exec() && parentQuery.next()) parentId = parentQuery.value(0).isNull() ? -1 : parentQuery.value(0).toInt();
    else return false;
    QSqlQuery siblingsQuery(m_db);
    if (parentId == -1) siblingsQuery.prepare("SELECT id FROM categories WHERE parent_id IS NULL OR parent_id = -1 ORDER BY sort_order ASC");
    else { siblingsQuery.prepare("SELECT id FROM categories WHERE parent_id = :pid ORDER BY sort_order ASC"); siblingsQuery.bindValue(":pid", parentId); }
    if (!siblingsQuery.exec()) return false;
    QList<int> siblings;
    while (siblingsQuery.next()) siblings << siblingsQuery.value(0).toInt();
    int currentIndex = siblings.indexOf(id);
    if (currentIndex == -1) return false;
    switch (direction) {
        case Up: if (currentIndex > 0) std::swap(siblings[currentIndex], siblings[currentIndex - 1]); else return false; break;
        case Down: if (currentIndex < siblings.size() - 1) std::swap(siblings[currentIndex], siblings[currentIndex + 1]); else return false; break;
        case Top: if (currentIndex > 0) { siblings.removeAt(currentIndex); siblings.prepend(id); } else return false; break;
        case Bottom: if (currentIndex < siblings.size() - 1) { siblings.removeAt(currentIndex); siblings.append(id); } else return false; break;
    }
    return updateCategoryOrder(parentId, siblings);
}

QList<QVariantMap> DatabaseManager::getAllCategories() {
    QMutexLocker locker(&m_mutex);
    QList<QVariantMap> results;
    if (!m_db.isOpen()) return results;
    QSqlQuery query(m_db);
    if (query.exec("SELECT * FROM categories ORDER BY sort_order")) { while (query.next()) { QVariantMap map; QSqlRecord rec = query.record(); for (int i = 0; i < rec.count(); ++i) map[rec.fieldName(i)] = query.value(i); results.append(map); } }
    return results;
}

bool DatabaseManager::emptyTrash() {
    bool success = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        QSqlQuery query(m_db);
        success = query.exec("DELETE FROM notes WHERE is_deleted = 1");
    }
    if (success) emit noteUpdated();
    return success;
}

bool DatabaseManager::setCategoryPresetTags(int catId, const QString& tags) {
    bool ok = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("UPDATE categories SET preset_tags=:tags WHERE id=:id");
        query.bindValue(":tags", tags);
        query.bindValue(":id", catId);
        if (!query.exec()) { m_db.rollback(); return false; }
        if (!tags.isEmpty()) {
            QStringList newTagsList = tags.split(",", Qt::SkipEmptyParts);
            QSqlQuery fetchNotes(m_db);
            fetchNotes.prepare("SELECT id, tags FROM notes WHERE category_id = :catId AND is_deleted = 0");
            fetchNotes.bindValue(":catId", catId);
            if (fetchNotes.exec()) {
                while (fetchNotes.next()) {
                    int noteId = fetchNotes.value(0).toInt();
                    QString existingTagsStr = fetchNotes.value(1).toString();
                    QStringList existingTags = existingTagsStr.split(",", Qt::SkipEmptyParts);
                    bool changed = false;
                    for (const QString& t : newTagsList) { QString trimmed = t.trimmed(); if (!trimmed.isEmpty() && !existingTags.contains(trimmed)) { existingTags.append(trimmed); changed = true; } }
                    if (changed) { QSqlQuery updateNote(m_db); updateNote.prepare("UPDATE notes SET tags = :tags WHERE id = :id"); updateNote.bindValue(":tags", existingTags.join(",")); updateNote.bindValue(":id", noteId); updateNote.exec(); }
                }
            }
        }
        ok = m_db.commit();
    }
    if (ok) { emit categoriesChanged(); emit noteUpdated(); }
    return ok;
}

QString DatabaseManager::getCategoryPresetTags(int catId) {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return "";
    QSqlQuery query(m_db);
    query.prepare("SELECT preset_tags FROM categories WHERE id=:id");
    query.bindValue(":id", catId);
    if (query.exec() && query.next()) return query.value(0).toString();
    return "";
}

QVariantMap DatabaseManager::getNoteById(int id) {
    QMutexLocker locker(&m_mutex);
    QVariantMap map;
    if (!m_db.isOpen()) return map;
    QSqlQuery query(m_db);
    query.prepare("SELECT * FROM notes WHERE id = :id");
    query.bindValue(":id", id);
    if (query.exec() && query.next()) { QSqlRecord rec = query.record(); for (int i = 0; i < rec.count(); ++i) map[rec.fieldName(i)] = query.value(i); }
    return map;
}

QVariantMap DatabaseManager::getCounts() {
    QMutexLocker locker(&m_mutex);
    QVariantMap counts;
    if (!m_db.isOpen()) return counts;
    QSqlQuery query(m_db);
    auto getCount = [&](const QString& where, bool applySecurity = true) {
        QString sql = "SELECT COUNT(*) FROM notes WHERE " + where;
        QVariantList params;
        if (applySecurity) { QString securityClause; applySecurityFilter(securityClause, params, "all"); sql += " " + securityClause; }
        QSqlQuery q(m_db);
        q.prepare(sql);
        for(int i=0; i<params.size(); ++i) q.bindValue(i, params[i]);
        if (q.exec()) { if (q.next()) return q.value(0).toInt(); }
        return 0;
    };
    counts["all"] = getCount("is_deleted = 0");
    counts["today"] = getCount("is_deleted = 0 AND date(created_at) = date('now', 'localtime')");
    counts["yesterday"] = getCount("is_deleted = 0 AND date(created_at) = date('now', '-1 day', 'localtime')");
    counts["recently_visited"] = getCount("is_deleted = 0 AND (date(last_accessed_at) = date('now', 'localtime') OR date(updated_at) = date('now', 'localtime')) AND date(created_at) < date('now', 'localtime')");
    counts["uncategorized"] = getCount("is_deleted = 0 AND category_id IS NULL");
    counts["untagged"] = getCount("is_deleted = 0 AND (tags IS NULL OR tags = '')");
    counts["bookmark"] = getCount("is_deleted = 0 AND is_favorite = 1");
    counts["trash"] = getCount("is_deleted = 1", false);
    if (query.exec("SELECT category_id, COUNT(*) FROM notes WHERE is_deleted = 0 AND category_id IS NOT NULL GROUP BY category_id")) { while (query.next()) { counts["cat_" + query.value(0).toString()] = query.value(1).toInt(); } }
    return counts;
}

QVariantMap DatabaseManager::getTrialStatus() {
    QMutexLocker locker(&m_mutex);
    QVariantMap status;
    status["expired"] = false;
    status["usage_limit_reached"] = false;
    status["days_left"] = 30;
    status["usage_count"] = 0;

    if (!m_db.isOpen()) return status;

    QSqlQuery query(m_db);
    query.exec("SELECT key, value FROM system_config");
    while (query.next()) {
        QString key = query.value(0).toString();
        QString value = query.value(1).toString();
        if (key == "first_launch_date") {
            QDateTime firstLaunch = QDateTime::fromString(value, Qt::ISODate);
            qint64 daysPassed = firstLaunch.daysTo(QDateTime::currentDateTime());
            status["days_left"] = qMax(0LL, 30 - daysPassed);
            if (daysPassed > 30) status["expired"] = true;
        } else if (key == "usage_count") {
            int count = value.toInt();
            status["usage_count"] = count;
            if (count >= 100) status["usage_limit_reached"] = true;
        }
    }
    return status;
}

void DatabaseManager::incrementUsageCount() {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return;
    QSqlQuery query(m_db);
    query.exec("UPDATE system_config SET value = CAST(CAST(value AS INTEGER) + 1 AS TEXT) WHERE key = 'usage_count'");
}

void DatabaseManager::resetUsageCount() {
    QMutexLocker locker(&m_mutex);
    if (!m_db.isOpen()) return;
    QSqlQuery query(m_db);
    query.prepare("UPDATE system_config SET value = '0' WHERE key = 'usage_count'");
    query.exec();
}

QVariantMap DatabaseManager::getFilterStats(const QString& keyword, const QString& filterType, const QVariant& filterValue, const QVariantMap& criteria) {
    QMutexLocker locker(&m_mutex);
    QVariantMap stats;
    if (!m_db.isOpen()) return stats;
    QString whereClause;
    QVariantList params;
    applyCommonFilters(whereClause, params, filterType, filterValue, criteria);
    
    if (!keyword.isEmpty()) {
        whereClause += "AND (tags LIKE ? OR title LIKE ? OR content LIKE ?) ";
        QString likeVal = "%" + keyword + "%";
        params << likeVal << likeVal << likeVal;
    }
    QSqlQuery query(m_db);
    QMap<int, int> stars;
    query.prepare("SELECT rating, COUNT(*) FROM notes " + whereClause + " GROUP BY rating");
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { while (query.next()) stars[query.value(0).toInt()] = query.value(1).toInt(); }
    QVariantMap starsMap;
    for (auto it = stars.begin(); it != stars.end(); ++it) starsMap[QString::number(it.key())] = it.value();
    stats["stars"] = starsMap;
    QMap<QString, int> colors;
    query.prepare("SELECT color, COUNT(*) FROM notes " + whereClause + " GROUP BY color");
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { while (query.next()) colors[query.value(0).toString()] = query.value(1).toInt(); }
    QVariantMap colorsMap;
    for (auto it = colors.begin(); it != colors.end(); ++it) colorsMap[it.key()] = it.value();
    stats["colors"] = colorsMap;
    QMap<QString, int> types;
    query.prepare("SELECT item_type, COUNT(*) FROM notes " + whereClause + " GROUP BY item_type");
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { while (query.next()) types[query.value(0).toString()] = query.value(1).toInt(); }
    QVariantMap typesMap;
    for (auto it = types.begin(); it != types.end(); ++it) typesMap[it.key()] = it.value();
    stats["types"] = typesMap;
    QMap<QString, int> tags;
    query.prepare("SELECT tags FROM notes " + whereClause);
    for (int i = 0; i < params.size(); ++i) query.bindValue(i, params[i]);
    if (query.exec()) { while (query.next()) { QStringList parts = query.value(0).toString().split(",", Qt::SkipEmptyParts); for (const QString& t : parts) tags[t.trimmed()]++; } }
    QVariantMap tagsMap;
    for (auto it = tags.begin(); it != tags.end(); ++it) tagsMap[it.key()] = it.value();
    stats["tags"] = tagsMap;
    QVariantMap dateStats;
    auto getCountDate = [&](const QString& dateCond) {
        QSqlQuery q(m_db);
        q.prepare("SELECT COUNT(*) FROM notes " + whereClause + " AND " + dateCond);
        for (int i = 0; i < params.size(); ++i) q.bindValue(i, params[i]);
        if (q.exec() && q.next()) return q.value(0).toInt();
        return 0;
    };
    dateStats["today"] = getCountDate("date(created_at) = date('now', 'localtime')");
    dateStats["yesterday"] = getCountDate("date(created_at) = date('now', '-1 day', 'localtime')");
    dateStats["week"] = getCountDate("date(created_at) >= date('now', '-6 days', 'localtime')");
    dateStats["month"] = getCountDate("strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now', 'localtime')");
    stats["date_create"] = dateStats;
    return stats;
}

bool DatabaseManager::addTagsToNote(int noteId, const QStringList& tags) { QVariantMap note = getNoteById(noteId); if (note.isEmpty()) return false; QStringList existing = note["tags"].toString().split(",", Qt::SkipEmptyParts); for (const QString& t : tags) { if (!existing.contains(t.trimmed())) existing.append(t.trimmed()); } return updateNoteState(noteId, "tags", existing.join(",")); }
bool DatabaseManager::renameTagGlobally(const QString& oldName, const QString& newName) {
    if (oldName.trimmed().isEmpty() || oldName == newName) return true;
    bool ok = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("SELECT id, tags FROM notes WHERE (',' || tags || ',') LIKE ? AND is_deleted = 0");
        query.addBindValue("%," + oldName.trimmed() + ",%");
        if (query.exec()) {
            while (query.next()) {
                int noteId = query.value(0).toInt(); QString tagsStr = query.value(1).toString(); QStringList tagList = tagsStr.split(",", Qt::SkipEmptyParts);
                for (int i = 0; i < tagList.size(); ++i) { if (tagList[i].trimmed() == oldName.trimmed()) tagList[i] = newName.trimmed(); }
                tagList.removeDuplicates();
                QSqlQuery updateQuery(m_db); updateQuery.prepare("UPDATE notes SET tags = ? WHERE id = ?"); updateQuery.addBindValue(tagList.join(",")); updateQuery.addBindValue(noteId); updateQuery.exec();
            }
        }
        ok = m_db.commit();
    }
    if (ok) emit noteUpdated();
    return ok;
}

bool DatabaseManager::deleteTagGlobally(const QString& tagName) {
    if (tagName.trimmed().isEmpty()) return true;
    bool ok = false;
    {
        QMutexLocker locker(&m_mutex);
        if (!m_db.isOpen()) return false;
        m_db.transaction();
        QSqlQuery query(m_db);
        query.prepare("SELECT id, tags FROM notes WHERE (',' || tags || ',') LIKE ? AND is_deleted = 0");
        query.addBindValue("%," + tagName.trimmed() + ",%");
        if (query.exec()) {
            while (query.next()) {
                int noteId = query.value(0).toInt(); QString tagsStr = query.value(1).toString(); QStringList tagList = tagsStr.split(",", Qt::SkipEmptyParts);
                tagList.removeAll(tagName.trimmed());
                QSqlQuery updateQuery(m_db); updateQuery.prepare("UPDATE notes SET tags = ? WHERE id = ?"); updateQuery.addBindValue(tagList.join(",")); updateQuery.addBindValue(noteId); updateQuery.exec();
            }
        }
        ok = m_db.commit();
    }
    if (ok) emit noteUpdated();
    return ok;
}

void DatabaseManager::syncFts(int id, const QString& title, const QString& content) {
    QString plainTitle = title; QString plainContent = stripHtml(content);
    QMutexLocker locker(&m_mutex);
    QSqlQuery query(m_db);
    query.prepare("DELETE FROM notes_fts WHERE rowid = ?"); query.addBindValue(id); query.exec();
    query.prepare("INSERT INTO notes_fts(rowid, title, content) VALUES (?, ?, ?)"); query.addBindValue(id); query.addBindValue(plainTitle); query.addBindValue(plainContent); query.exec();
}

void DatabaseManager::removeFts(int id) { QSqlQuery query(m_db); query.prepare("DELETE FROM notes_fts WHERE rowid = ?"); query.addBindValue(id); query.exec(); }

void DatabaseManager::applySecurityFilter(QString& whereClause, QVariantList& params, const QString& filterType) {
    if (filterType == "category" || filterType == "trash" || filterType == "uncategorized") return;
    QSqlQuery catQuery(m_db);
    catQuery.exec("SELECT id FROM categories WHERE password IS NOT NULL AND password != ''");
    QList<int> lockedIds;
    while (catQuery.next()) { int cid = catQuery.value(0).toInt(); if (!m_unlockedCategories.contains(cid)) lockedIds.append(cid); }
    if (!lockedIds.isEmpty()) {
        QStringList placeholders; for (int i = 0; i < lockedIds.size(); ++i) placeholders << "?";
        whereClause += QString("AND (category_id IS NULL OR category_id NOT IN (%1)) ").arg(placeholders.join(","));
        for (int id : lockedIds) params << id;
    }
}

QString DatabaseManager::stripHtml(const QString& html) {
    if (!html.contains("<") && !html.contains("&")) return html;
    QString plain = html;
    plain.remove(QRegularExpression("<style.*?>.*?</style>", QRegularExpression::DotMatchesEverythingOption | QRegularExpression::CaseInsensitiveOption));
    plain.remove(QRegularExpression("<script.*?>.*?</script>", QRegularExpression::DotMatchesEverythingOption | QRegularExpression::CaseInsensitiveOption));
    plain.remove(QRegularExpression("<[^>]*>"));
    plain.replace("&nbsp;", " ", Qt::CaseInsensitive);
    plain.replace("&lt;", "<", Qt::CaseInsensitive);
    plain.replace("&gt;", ">", Qt::CaseInsensitive);
    plain.replace("&amp;", "&", Qt::CaseInsensitive);
    plain.replace("&quot;", "\"", Qt::CaseInsensitive);
    plain.replace("&#39;", "'");
    return plain.simplified();
}

void DatabaseManager::applyCommonFilters(QString& whereClause, QVariantList& params, const QString& filterType, const QVariant& filterValue, const QVariantMap& criteria) {
    if (filterType == "trash") {
        whereClause = "WHERE is_deleted = 1 ";
    } else {
        whereClause = "WHERE is_deleted = 0 ";
        applySecurityFilter(whereClause, params, filterType);
        
        if (filterType == "category") { 
            if (filterValue.toInt() == -1) whereClause += "AND category_id IS NULL "; 
            else { whereClause += "AND category_id = ? "; params << filterValue.toInt(); } 
        }
        else if (filterType == "uncategorized") whereClause += "AND category_id IS NULL ";
        else if (filterType == "today") whereClause += "AND date(created_at) = date('now', 'localtime') ";
        else if (filterType == "yesterday") whereClause += "AND date(created_at) = date('now', '-1 day', 'localtime') ";
        else if (filterType == "recently_visited") whereClause += "AND (date(last_accessed_at) = date('now', 'localtime') OR date(updated_at) = date('now', 'localtime')) AND date(created_at) < date('now', 'localtime') ";
        else if (filterType == "bookmark") whereClause += "AND is_favorite = 1 ";
        else if (filterType == "untagged") whereClause += "AND (tags IS NULL OR tags = '') ";
    }
    
    if (filterType != "trash" && !criteria.isEmpty()) {
        if (criteria.contains("stars")) { 
            QStringList stars = criteria.value("stars").toStringList(); 
            if (!stars.isEmpty()) whereClause += QString("AND rating IN (%1) ").arg(stars.join(",")); 
        }
        if (criteria.contains("types")) { 
            QStringList types = criteria.value("types").toStringList(); 
            if (!types.isEmpty()) { 
                QStringList placeholders; 
                for (const auto& t : types) { placeholders << "?"; params << t; } 
                whereClause += QString("AND item_type IN (%1) ").arg(placeholders.join(",")); 
            } 
        }
        if (criteria.contains("colors")) { 
            QStringList colors = criteria.value("colors").toStringList(); 
            if (!colors.isEmpty()) { 
                QStringList placeholders; 
                for (const auto& c : colors) { placeholders << "?"; params << c; } 
                whereClause += QString("AND color IN (%1) ").arg(placeholders.join(",")); 
            } 
        }
        if (criteria.contains("tags")) { 
            QStringList tags = criteria.value("tags").toStringList(); 
            if (!tags.isEmpty()) { 
                QStringList tagConds; 
                for (const auto& t : tags) { tagConds << "(',' || tags || ',') LIKE ?"; params << "%," + t.trimmed() + ",%"; } 
                whereClause += QString("AND (%1) ").arg(tagConds.join(" OR ")); 
            } 
        }
        if (criteria.contains("date_create")) { 
            QStringList dates = criteria.value("date_create").toStringList(); 
            if (!dates.isEmpty()) { 
                QStringList dateConds; 
                for (const auto& d : dates) { 
                    if (d == "today") dateConds << "date(created_at) = date('now', 'localtime')"; 
                    else if (d == "yesterday") dateConds << "date(created_at) = date('now', '-1 day', 'localtime')"; 
                    else if (d == "week") dateConds << "date(created_at) >= date('now', '-6 days', 'localtime')"; 
                    else if (d == "month") dateConds << "strftime('%Y-%m', created_at) = strftime('%Y-%m', 'now', 'localtime')"; 
                } 
                if (!dateConds.isEmpty()) whereClause += QString("AND (%1) ").arg(dateConds.join(" OR ")); 
            } 
        }
    }
}
```

## 文件: `src/core/DatabaseManager.h`

```cpp
#ifndef DATABASEMANAGER_H
#define DATABASEMANAGER_H

#include <QObject>
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QSqlError>
#include <QDateTime>
#include <QVariant>
#include <QVariantList>
#include <QRecursiveMutex>
#include <QStringList>
#include <QSet>
#include <QMutex>

class DatabaseManager : public QObject {
    Q_OBJECT
public:
    static DatabaseManager& instance();

    bool init(const QString& dbPath = "rapid_notes.db");
    void closeAndPack();
    
    // 核心 CRUD 操作
    int addNote(const QString& title, const QString& content, const QStringList& tags = QStringList(), 
                const QString& color = "", int categoryId = -1, 
                const QString& itemType = "text", const QByteArray& dataBlob = QByteArray(),
                const QString& sourceApp = "", const QString& sourceTitle = "");
    bool updateNote(int id, const QString& title, const QString& content, const QStringList& tags, 
                    const QString& color = "", int categoryId = -1);
    bool deleteNotesBatch(const QList<int>& ids);
    bool updateNoteState(int id, const QString& column, const QVariant& value);
    bool updateNoteStateBatch(const QList<int>& ids, const QString& column, const QVariant& value);
    // 批量软删除 (放入回收站)
    bool softDeleteNotes(const QList<int>& ids);
    bool toggleNoteState(int id, const QString& column);
    bool moveNotesToCategory(const QList<int>& noteIds, int catId);
    bool recordAccess(int id);

    // 分类管理
    enum MoveDirection { Up, Down, Top, Bottom };
    int addCategory(const QString& name, int parentId = -1, const QString& color = "");
    bool renameCategory(int id, const QString& name);
    bool setCategoryColor(int id, const QString& color);
    bool deleteCategory(int id);
    bool moveCategory(int id, MoveDirection direction);
    bool reorderCategories(int parentId, bool ascending);
    bool reorderAllCategories(bool ascending);
    bool updateCategoryOrder(int parentId, const QList<int>& categoryIds);
    QList<QVariantMap> getAllCategories();
    bool emptyTrash();
    bool restoreAllFromTrash();

    // 分类密码保护
    bool setCategoryPassword(int id, const QString& password, const QString& hint);
    bool removeCategoryPassword(int id);
    bool verifyCategoryPassword(int id, const QString& password);
    bool isCategoryLocked(int id);
    void lockCategory(int id);
    void unlockCategory(int id);

    // 预设标签
    bool setCategoryPresetTags(int catId, const QString& tags);
    QString getCategoryPresetTags(int catId);

    // 标签管理
    bool addTagsToNote(int noteId, const QStringList& tags);
    bool renameTagGlobally(const QString& oldName, const QString& newName);
    bool deleteTagGlobally(const QString& tagName);

    // 搜索与查询
    QList<QVariantMap> searchNotes(const QString& keyword, const QString& filterType = "all", const QVariant& filterValue = -1, int page = -1, int pageSize = 20, const QVariantMap& criteria = QVariantMap());
    int getNotesCount(const QString& keyword, const QString& filterType = "all", const QVariant& filterValue = -1, const QVariantMap& criteria = QVariantMap());
    QStringList getAllTags();
    QList<QVariantMap> getRecentTagsWithCounts(int limit = 20);
    QVariantMap getNoteById(int id);

    // 统计
    QVariantMap getCounts();
    QVariantMap getFilterStats(const QString& keyword = "", const QString& filterType = "all", const QVariant& filterValue = -1, const QVariantMap& criteria = QVariantMap());

    // 试用期与使用次数管理
    QVariantMap getTrialStatus();
    void incrementUsageCount();
    void resetUsageCount();

    // 异步操作
    void addNoteAsync(const QString& title, const QString& content, const QStringList& tags = QStringList(),
                      const QString& color = "", int categoryId = -1,
                      const QString& itemType = "text", const QByteArray& dataBlob = QByteArray(),
                      const QString& sourceApp = "", const QString& sourceTitle = "");

signals:
    // 【修改】现在信号携带具体数据，实现增量更新
    void noteAdded(const QVariantMap& note);
    void noteUpdated(); // 用于普通刷新
    void categoriesChanged();

private:
    DatabaseManager(QObject* parent = nullptr);
    ~DatabaseManager();
    DatabaseManager(const DatabaseManager&) = delete;
    DatabaseManager& operator=(const DatabaseManager&) = delete;

    bool createTables();
    void syncFts(int id, const QString& title, const QString& content);
    void removeFts(int id);
    QString stripHtml(const QString& html);
    void applySecurityFilter(QString& whereClause, QVariantList& params, const QString& filterType);
    void applyCommonFilters(QString& whereClause, QVariantList& params, const QString& filterType, const QVariant& filterValue, const QVariantMap& criteria);
    
    QSqlDatabase m_db;
    QString m_dbPath;      // 当前正在使用的内核路径 (.notes_core)
    QString m_realDbPath;  // 最终持久化的外壳路径 (notes.db)
    QRecursiveMutex m_mutex;

    QSet<int> m_unlockedCategories; // 仅存储当前会话已解锁的分类 ID

    // 标签剪贴板 (全局静态)
    static QStringList s_tagClipboard;
    static QMutex s_tagClipboardMutex;

public:
    static void setTagClipboard(const QStringList& tags);
    static QStringList getTagClipboard();
};

#endif // DATABASEMANAGER_H
```

## 文件: `src/ui/DropTreeView.cpp`

```cpp
#include "DropTreeView.h"
#include "../models/CategoryModel.h"
#include <QDrag>
#include <QPixmap>

DropTreeView::DropTreeView(QWidget* parent) : QTreeView(parent) {
    setAcceptDrops(true);
    setDropIndicatorShown(true);
}

void DropTreeView::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasFormat("application/x-note-ids")) {
        event->acceptProposedAction();
    } else {
        QTreeView::dragEnterEvent(event);
    }
}

void DropTreeView::dragMoveEvent(QDragMoveEvent* event) {
    if (event->mimeData()->hasFormat("application/x-note-ids")) {
        event->acceptProposedAction();
    } else {
        QTreeView::dragMoveEvent(event);
    }
}

void DropTreeView::dropEvent(QDropEvent* event) {
    if (event->mimeData()->hasFormat("application/x-note-ids")) {
        QByteArray data = event->mimeData()->data("application/x-note-ids");
        QStringList idStrs = QString::fromUtf8(data).split(",", Qt::SkipEmptyParts);
        QList<int> ids;
        for (const QString& s : idStrs) ids << s.toInt();

        QModelIndex index = indexAt(event->position().toPoint());
        emit notesDropped(ids, index);
        event->acceptProposedAction();
    } else {
        QTreeView::dropEvent(event);
    }
}

void DropTreeView::startDrag(Qt::DropActions supportedActions) {
    // 追踪拖拽 ID
    auto* catModel = qobject_cast<CategoryModel*>(model());
    if (catModel && !selectedIndexes().isEmpty()) {
        catModel->setDraggingId(selectedIndexes().first().data(CategoryModel::IdRole).toInt());
    }

    // 禁用默认的快照卡片预览，改用 1x1 透明占位符
    QDrag* drag = new QDrag(this);
    drag->setMimeData(model()->mimeData(selectedIndexes()));
    
    QPixmap pix(1, 1);
    pix.fill(Qt::transparent);
    drag->setPixmap(pix);
    drag->setHotSpot(QPoint(0, 0));
    
    drag->exec(supportedActions, Qt::MoveAction);
}
```

## 文件: `src/ui/DropTreeView.h`

```cpp
#ifndef DROPTREEVIEW_H
#define DROPTREEVIEW_H

#include <QTreeView>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QMimeData>

class DropTreeView : public QTreeView {
    Q_OBJECT
public:
    explicit DropTreeView(QWidget* parent = nullptr);

signals:
    void notesDropped(const QList<int>& noteIds, const QModelIndex& targetIndex);

protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
    void startDrag(Qt::DropActions supportedActions) override;
};

#endif // DROPTREEVIEW_H
```

## 文件: `src/ui/Editor.cpp`

```cpp
#include "Editor.h"
#include <QMimeData>
#include <QFileInfo>
#include <utility>
#include <QUrl>
#include <QTextList>

MarkdownHighlighter::MarkdownHighlighter(QTextDocument* parent) : QSyntaxHighlighter(parent) {
    HighlightingRule rule;

    // 标题 (Headers) - 蓝色
    QTextCharFormat headerFormat;
    headerFormat.setForeground(QColor("#569CD6"));
    headerFormat.setFontWeight(QFont::Bold);
    rule.pattern = QRegularExpression("^#{1,6}\\s.*");
    rule.format = headerFormat;
    m_highlightingRules.append(rule);

    // 粗体 (**bold**) - 红色
    QTextCharFormat boldFormat;
    boldFormat.setFontWeight(QFont::Bold);
    boldFormat.setForeground(QColor("#E06C75"));
    rule.pattern = QRegularExpression("\\*\\*.*?\\*\\*");
    rule.format = boldFormat;
    m_highlightingRules.append(rule);

    // 待办事项 ([ ] [x]) - 黄色/绿色
    QTextCharFormat uncheckedFormat;
    uncheckedFormat.setForeground(QColor("#E5C07B"));
    rule.pattern = QRegularExpression("-\\s\\[\\s\\]");
    rule.format = uncheckedFormat;
    m_highlightingRules.append(rule);

    QTextCharFormat checkedFormat;
    checkedFormat.setForeground(QColor("#6A9955"));
    rule.pattern = QRegularExpression("-\\s\\[x\\]");
    rule.format = checkedFormat;
    m_highlightingRules.append(rule);

    // 代码 (Code) - 绿色
    QTextCharFormat codeFormat;
    codeFormat.setForeground(QColor("#98C379"));
    codeFormat.setFontFamilies({"Consolas", "Monaco", "monospace"});
    rule.pattern = QRegularExpression("`[^`]+`|```.*");
    rule.format = codeFormat;
    m_highlightingRules.append(rule);

    // 引用 (> Quote) - 灰色
    QTextCharFormat quoteFormat;
    quoteFormat.setForeground(QColor("#808080"));
    quoteFormat.setFontItalic(true);
    rule.pattern = QRegularExpression("^\\s*>.*");
    rule.format = quoteFormat;
    m_highlightingRules.append(rule);
    
    // 列表 (Lists) - 紫色
    QTextCharFormat listFormat;
    listFormat.setForeground(QColor("#C678DD"));
    rule.pattern = QRegularExpression("^\\s*[\\-\\*]\\s");
    rule.format = listFormat;
    m_highlightingRules.append(rule);

    // 链接 (Links) - 浅蓝
    QTextCharFormat linkFormat;
    linkFormat.setForeground(QColor("#61AFEF"));
    linkFormat.setFontUnderline(true);
    rule.pattern = QRegularExpression("\\[.*?\\]\\(.*?\\)|https?://\\S+");
    rule.format = linkFormat;
    m_highlightingRules.append(rule);
}

void MarkdownHighlighter::highlightBlock(const QString& text) {
    for (const HighlightingRule& rule : m_highlightingRules) {
        QRegularExpressionMatchIterator matchIterator = rule.pattern.globalMatch(text);
        while (matchIterator.hasNext()) {
            QRegularExpressionMatch match = matchIterator.next();
            setFormat(match.capturedStart(), match.capturedLength(), rule.format);
        }
    }
}

#include <QVBoxLayout>
#include <QFrame>
#include <QMimeData>
#include <QUrl>

InternalEditor::InternalEditor(QWidget* parent) : QTextEdit(parent) {
    setStyleSheet("background: #1E1E1E; color: #D4D4D4; font-family: 'Consolas', 'Courier New'; font-size: 13pt; border: none; outline: none; padding: 10px;");
    setAcceptRichText(true); // 允许富文本以支持高亮和图片
}

void InternalEditor::insertTodo() {
    QTextCursor cursor = textCursor();
    if (!cursor.atBlockStart()) {
        cursor.insertText("\n");
    }
    cursor.insertText("- [ ] ");
    setTextCursor(cursor);
    setFocus();
}

void InternalEditor::highlightSelection(const QColor& color) {
    QTextCursor cursor = textCursor();
    if (!cursor.hasSelection()) return;
    QTextCharFormat format;
    format.setBackground(color);
    cursor.mergeCharFormat(format);
    setTextCursor(cursor);
}

void InternalEditor::insertFromMimeData(const QMimeData* source) {
    if (source->hasImage()) {
        QImage image = qvariant_cast<QImage>(source->imageData());
        if (!image.isNull()) {
            // 自动缩放宽图
            if (image.width() > 600) {
                image = image.scaledToWidth(600, Qt::SmoothTransformation);
            }
            textCursor().insertImage(image);
            return;
        }
    }
    if (source->hasUrls()) {
        for (const QUrl& url : source->urls()) {
            if (url.isLocalFile()) insertPlainText(QString("\n[文件引用: %1]\n").arg(url.toLocalFile()));
            else insertPlainText(QString("\n[链接: %1]\n").arg(url.toString()));
        }
        return;
    }
    QTextEdit::insertFromMimeData(source);
}

Editor::Editor(QWidget* parent) : QWidget(parent) {
    auto* layout = new QVBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0); 

    m_stack = new QStackedWidget(this);
    m_stack->setStyleSheet("background: transparent; border: none;");
    
    m_edit = new InternalEditor(this);
    m_edit->setStyleSheet("background: transparent; color: #D4D4D4; font-family: 'Consolas', 'Courier New'; font-size: 13pt; border: none; outline: none; padding: 15px;");
    m_highlighter = new MarkdownHighlighter(m_edit->document());

    m_preview = new QTextEdit(this);
    m_preview->setReadOnly(true);
    m_preview->setStyleSheet("background: transparent; color: #D4D4D4; padding: 15px; border: none; outline: none;");

    m_stack->addWidget(m_edit);
    m_stack->addWidget(m_preview);
    
    layout->addWidget(m_stack);
}

void Editor::setNote(const QVariantMap& note, bool isPreview) {
    m_currentNote = note;
    QString title = note.value("title").toString();
    QString content = note.value("content").toString();
    QString type = note.value("item_type").toString();
    QByteArray blob = note.value("data_blob").toByteArray();

    m_edit->clear();
    
    // 增强 HTML 检测：采用更严谨的启发式算法，识别 Qt 生成的 HTML 模式
    // Qt 生成的 HTML 通常以 <!DOCTYPE HTML 开始，或者包含大量的 <style>
    QString trimmed = content.trimmed();
    m_isRichText = trimmed.startsWith("<!DOCTYPE", Qt::CaseInsensitive) || 
                   trimmed.startsWith("<html", Qt::CaseInsensitive) || 
                   trimmed.contains("<style", Qt::CaseInsensitive) ||
                   Qt::mightBeRichText(content);

    if (m_isRichText) {
        // 如果是 HTML 内容，加载为 HTML
        m_edit->setHtml(content);
        if (isPreview) {
            // 在预览模式下，为富文本笔记也通过插入方式添加标题头，避免破坏 HTML 结构
            QTextCursor previewCursor(m_edit->document());
            previewCursor.movePosition(QTextCursor::Start);
            previewCursor.insertHtml(QString("<h1 style='color: #569CD6; margin-bottom: 5px;'>%1</h1>"
                                             "<hr style='border: 0; border-top: 1px solid #333; margin-bottom: 15px;'>")
                                             .arg(title.toHtmlEscaped()));
        }
        return;
    }

    // 纯文本/Markdown 逻辑
    QTextCursor cursor = m_edit->textCursor();

    // 物理隔离：仅在预览模式下注入预览头
    if (isPreview) {
        // 使用特殊颜色标识预览头，让用户知道这是自动生成的
        QTextCharFormat fmt;
        fmt.setForeground(QColor("#569CD6"));
        fmt.setFontWeight(QFont::Bold);
        cursor.setCharFormat(fmt);
        cursor.insertText("# " + title + "\n\n");
        
        // 恢复默认格式
        cursor.setCharFormat(QTextCharFormat());
    }

    if (type == "image" && !blob.isEmpty()) {
        QImage img;
        img.loadFromData(blob);
        if (!img.isNull()) {
            if (img.width() > 550) {
                img = img.scaledToWidth(550, Qt::SmoothTransformation);
            }
            cursor.insertImage(img);
            cursor.insertText("\n\n");
        }
    } else if (type == "local_file" || type == "local_folder" || type == "local_batch") {
        QTextCharFormat linkFmt;
        linkFmt.setForeground(QColor("#569CD6"));
        linkFmt.setFontUnderline(true);
        cursor.setCharFormat(linkFmt);
        cursor.insertText("📂 本地托管项目: " + title + "\n");
        cursor.setCharFormat(QTextCharFormat());
        cursor.insertText("相对路径: " + content + "\n\n");
        cursor.insertText("(双击左侧列表项可直接在资源管理器中打开)\n\n");
    } else if (type == "color") {
        cursor.insertHtml(QString("<div style='margin: 20px; text-align: center;'>"
                                  "  <div style='background-color: %1; width: 100%; height: 200px; border-radius: 12px; border: 1px solid #555;'></div>"
                                  "  <h1 style='color: white; margin-top: 20px; font-family: Consolas; font-size: 32px;'>%1</h1>"
                                  "</div>").arg(content));
    } else {
        cursor.insertText(content);
    }
    
    // 滚动到顶部
    m_edit->moveCursor(QTextCursor::Start);
}

void Editor::setPlainText(const QString& text) {
    m_currentNote.clear();
    m_edit->setPlainText(text);
}

QString Editor::toPlainText() const {
    return m_edit->toPlainText();
}

QString Editor::toHtml() const {
    return m_edit->toHtml();
}

void Editor::setPlaceholderText(const QString& text) {
    m_edit->setPlaceholderText(text);
}

void Editor::clearFormatting() {
    QTextCursor cursor = m_edit->textCursor();
    if (cursor.hasSelection()) {
        QTextCharFormat format;
        m_edit->setCurrentCharFormat(format);
        cursor.setCharFormat(format);
    } else {
        m_edit->setCurrentCharFormat(QTextCharFormat());
    }
}

void Editor::toggleList(bool ordered) {
    QTextCursor cursor = m_edit->textCursor();
    cursor.beginEditBlock();
    QTextList* list = cursor.currentList();
    QTextListFormat format;
    format.setStyle(ordered ? QTextListFormat::ListDecimal : QTextListFormat::ListDisc);
    
    if (list) {
        if (list->format().style() == format.style()) {
            QTextBlockFormat blockFmt;
            blockFmt.setObjectIndex(-1);
            cursor.setBlockFormat(blockFmt);
        } else {
            list->setFormat(format);
        }
    } else {
        cursor.createList(format);
    }
    cursor.endEditBlock();
}

bool Editor::findText(const QString& text, bool backward) {
    if (text.isEmpty()) return false;
    QTextDocument::FindFlags flags;
    if (backward) flags |= QTextDocument::FindBackward;
    
    bool found = m_edit->find(text, flags);
    if (!found) {
        // 循环搜索
        QTextCursor cursor = m_edit->textCursor();
        cursor.movePosition(backward ? QTextCursor::End : QTextCursor::Start);
        m_edit->setTextCursor(cursor);
        found = m_edit->find(text, flags);
    }
    return found;
}

void Editor::togglePreview(bool preview) {
    if (preview) {
        if (m_isRichText) {
            // 如果已经是富文本，直接同步 HTML 到预览框
            m_preview->setHtml(m_edit->toHtml());
            m_stack->setCurrentWidget(m_preview);
            return;
        }

        QString text = m_edit->toPlainText();
        QString html = "<html><head><style>"
                       "body { font-family: 'Microsoft YaHei'; color: #ddd; background-color: #1e1e1e; line-height: 1.6; padding: 20px; }"
                       "h1 { color: #569CD6; border-bottom: 1px solid #333; padding-bottom: 5px; }"
                       "h2 { color: #569CD6; border-bottom: 1px solid #222; }"
                       "code { background-color: #333; padding: 2px 4px; border-radius: 3px; font-family: Consolas; color: #98C379; }"
                       "pre { background-color: #252526; padding: 10px; border-radius: 5px; border: 1px solid #444; }"
                       "blockquote { border-left: 4px solid #569CD6; padding-left: 15px; color: #888; font-style: italic; background: #252526; margin: 10px 0; }"
                       "p { margin: 10px 0; }"
                       "img { max-width: 100%; border-radius: 5px; border: 1px solid #333; margin: 10px 0; }"
                       "</style></head><body>";

        // 如果是图片笔记，且 text 没有包含图片标记（目前逻辑下 text 是 H1 + content）
        // 我们在预览模式下根据 m_currentNote 显式渲染
        QString type = m_currentNote["item_type"].toString();
        QByteArray blob = m_currentNote["data_blob"].toByteArray();
        
        QStringList lines = text.split("\n");
        bool inCodeBlock = false;
        bool imageRendered = false;

        for (const QString& line : std::as_const(lines)) {
            // 如果这一行是标题且我们还没渲染过图片，对于图片笔记，我们可以在标题后插入图片
            if (line.startsWith("# ") && type == "image" && !blob.isEmpty() && !imageRendered) {
                html += "<h1>" + line.mid(2).toHtmlEscaped() + "</h1>";
                html += "<div style='text-align: center;'><img src='data:image/png;base64," + QString(blob.toBase64()) + "'></div>";
                html += "<hr style='border: 0; border-top: 1px solid #333;'>";
                imageRendered = true;
                continue;
            }

            if (line.startsWith("```")) {
                if (!inCodeBlock) { html += "<pre><code>"; inCodeBlock = true; }
                else { html += "</code></pre>"; inCodeBlock = false; }
                continue;
            }
            
            if (inCodeBlock) {
                html += line.toHtmlEscaped() + "<br>";
                continue;
            }

            if (line.startsWith("###### ")) html += "<h6>" + line.mid(7).toHtmlEscaped() + "</h6>";
            else if (line.startsWith("##### ")) html += "<h5>" + line.mid(6).toHtmlEscaped() + "</h5>";
            else if (line.startsWith("#### ")) html += "<h4>" + line.mid(5).toHtmlEscaped() + "</h4>";
            else if (line.startsWith("### ")) html += "<h3>" + line.mid(4).toHtmlEscaped() + "</h3>";
            else if (line.startsWith("## ")) html += "<h2>" + line.mid(3).toHtmlEscaped() + "</h2>";
            else if (line.startsWith("# ")) html += "<h1>" + line.mid(2).toHtmlEscaped() + "</h1>";
            else if (line.startsWith("> ")) html += "<blockquote>" + line.mid(2).toHtmlEscaped() + "</blockquote>";
            else if (line.startsWith("- [ ] ")) html += "<p><span style='color:#E5C07B;'>☐</span> " + line.mid(6).toHtmlEscaped() + "</p>";
            else if (line.startsWith("- [x] ")) html += "<p><span style='color:#6A9955;'>☑</span> " + line.mid(6).toHtmlEscaped() + "</p>";
            else if (line.isEmpty()) html += "<br>";
            else {
                // 处理行内代码 `code`
                QString processedLine = line.toHtmlEscaped();
                QRegularExpression inlineCode("`(.*?)`");
                processedLine.replace(inlineCode, "<code>\\1</code>");
                html += "<p>" + processedLine + "</p>";
            }
        }
        
        html += "</body></html>";
        m_preview->setHtml(html);
        m_stack->setCurrentWidget(m_preview);
    } else {
        m_stack->setCurrentWidget(m_edit);
    }
}

void Editor::setReadOnly(bool ro) {
    m_edit->setReadOnly(ro);
}
```

## 文件: `src/ui/Editor.h`

```cpp
#ifndef EDITOR_H
#define EDITOR_H

#include <QTextEdit>
#include <QSyntaxHighlighter>
#include <QRegularExpression>

class MarkdownHighlighter : public QSyntaxHighlighter {
    Q_OBJECT
public:
    explicit MarkdownHighlighter(QTextDocument* parent = nullptr);
protected:
    void highlightBlock(const QString& text) override;
private:
    struct HighlightingRule {
        QRegularExpression pattern;
        QTextCharFormat format;
    };
    QList<HighlightingRule> m_highlightingRules;
};

#include <QStackedWidget>

class InternalEditor : public QTextEdit {
    Q_OBJECT
public:
    explicit InternalEditor(QWidget* parent = nullptr);
    void insertTodo();
    void highlightSelection(const QColor& color);
protected:
    void insertFromMimeData(const QMimeData* source) override;
};

class Editor : public QWidget {
    Q_OBJECT
public:
    explicit Editor(QWidget* parent = nullptr);
    void setNote(const QVariantMap& note, bool isPreview = false);
    void setPlainText(const QString& text);
    QString toPlainText() const;
    QString toHtml() const;
    void setPlaceholderText(const QString& text);
    void togglePreview(bool preview);
    void setReadOnly(bool ro);
    
    // 代理 InternalEditor 的功能
    void undo() { m_edit->undo(); }
    void redo() { m_edit->redo(); }
    void insertTodo() { m_edit->insertTodo(); }
    void highlightSelection(const QColor& color) { m_edit->highlightSelection(color); }
    void clearFormatting();
    void toggleList(bool ordered);
    
    // 搜索功能
    bool findText(const QString& text, bool backward = false);

private:
    QStackedWidget* m_stack;
    InternalEditor* m_edit;
    QTextEdit* m_preview;
    MarkdownHighlighter* m_highlighter;
    QVariantMap m_currentNote;
    bool m_isRichText = false;
};

#endif // EDITOR_H
```

## 文件: `src/core/FileCryptoHelper.cpp`

```cpp
#include "FileCryptoHelper.h"
#include "AES.h"
#include <QDebug>
#include <QCryptographicHash>
#include <QRandomGenerator>
#include <QSysInfo>
#include <QThread>
#include <cstdint>

#define MAGIC_HEADER_SIZE 16
#define SALT_SIZE 16
#define IV_SIZE 16
#define KEY_SIZE 32
#define PBKDF2_ITERATIONS 5000 

static const char SHELL_MAGIC[MAGIC_HEADER_SIZE] = {'R', 'A', 'P', 'I', 'D', 'N', 'O', 'T', 'E', 'S', 'S', 'H', 'E', 'L', 'L', '!'};

QByteArray FileCryptoHelper::deriveKey(const QString& password, const QByteArray& salt) {
    QByteArray key = password.toUtf8();
    for (int i = 0; i < PBKDF2_ITERATIONS; ++i) {
        key = QCryptographicHash::hash(key + salt, QCryptographicHash::Sha256);
    }
    return key;
}

bool FileCryptoHelper::decryptFileLegacy(const QString& sourcePath, const QString& destPath, const QString& password) {
    QFile src(sourcePath);
    if (!src.open(QIODevice::ReadOnly)) return false;

    QByteArray salt = src.read(SALT_SIZE);
    QByteArray iv = src.read(IV_SIZE);
    QByteArray encryptedData = src.readAll();
    src.close();

    if (salt.size() != SALT_SIZE || iv.size() != IV_SIZE) return false;

    QByteArray key = deriveKey(password, salt);

    AES aes(AES::AES_256);
    std::vector<std::uint8_t> input((const std::uint8_t*)encryptedData.constData(), (const std::uint8_t*)encryptedData.constData() + encryptedData.size());
    std::vector<std::uint8_t> keyVec((const std::uint8_t*)key.constData(), (const std::uint8_t*)key.constData() + key.size());
    std::vector<std::uint8_t> ivVec((const std::uint8_t*)iv.constData(), (const std::uint8_t*)iv.constData() + iv.size());

    std::vector<std::uint8_t> decrypted = aes.decryptCBC(input, keyVec, ivVec);
    if (decrypted.empty()) return false;

    QFile dest(destPath);
    if (!dest.open(QIODevice::WriteOnly)) return false;
    dest.write((const char*)decrypted.data(), decrypted.size());
    dest.close();

    return true;
}

bool FileCryptoHelper::encryptFileWithShell(const QString& sourcePath, const QString& destPath, const QString& password) {
    QFile src(sourcePath);
    if (!src.open(QIODevice::ReadOnly)) return false;
    QByteArray srcData = src.readAll();
    src.close();

    QByteArray salt(SALT_SIZE, 0);
    QByteArray iv(IV_SIZE, 0);
    for(int i=0; i<SALT_SIZE; ++i) salt[i] = (char)QRandomGenerator::global()->bounded(256);
    for(int i=0; i<IV_SIZE; ++i) iv[i] = (char)QRandomGenerator::global()->bounded(256);

    QByteArray key = deriveKey(password, salt);

    AES aes(AES::AES_256);
    std::vector<std::uint8_t> input((const std::uint8_t*)srcData.constData(), (const std::uint8_t*)srcData.constData() + srcData.size());
    std::vector<std::uint8_t> keyVec((const std::uint8_t*)key.constData(), (const std::uint8_t*)key.constData() + key.size());
    std::vector<std::uint8_t> ivVec((const std::uint8_t*)iv.constData(), (const std::uint8_t*)iv.constData() + iv.size());
    
    std::vector<std::uint8_t> encrypted = aes.encryptCBC(input, keyVec, ivVec);

    QFile dest(destPath);
    if (!dest.open(QIODevice::WriteOnly)) return false;
    dest.write(SHELL_MAGIC, MAGIC_HEADER_SIZE);
    dest.write(salt);
    dest.write(iv);
    dest.write((const char*)encrypted.data(), encrypted.size());
    dest.close();

    return true;
}

bool FileCryptoHelper::decryptFileWithShell(const QString& sourcePath, const QString& destPath, const QString& password) {
    QFile src(sourcePath);
    if (!src.open(QIODevice::ReadOnly)) return false;

    QByteArray header = src.read(MAGIC_HEADER_SIZE);
    if (header != QByteArray(SHELL_MAGIC, MAGIC_HEADER_SIZE)) {
        src.close();
        return false;
    }

    QByteArray salt = src.read(SALT_SIZE);
    QByteArray iv = src.read(IV_SIZE);
    QByteArray encryptedData = src.readAll();
    src.close();

    if (salt.size() != SALT_SIZE || iv.size() != IV_SIZE) return false;

    QByteArray key = deriveKey(password, salt);

    AES aes(AES::AES_256);
    std::vector<std::uint8_t> input((const std::uint8_t*)encryptedData.constData(), (const std::uint8_t*)encryptedData.constData() + encryptedData.size());
    std::vector<std::uint8_t> keyVec((const std::uint8_t*)key.constData(), (const std::uint8_t*)key.constData() + key.size());
    std::vector<std::uint8_t> ivVec((const std::uint8_t*)iv.constData(), (const std::uint8_t*)iv.constData() + iv.size());

    std::vector<std::uint8_t> decrypted = aes.decryptCBC(input, keyVec, ivVec);
    if (decrypted.empty()) return false;

    QFile dest(destPath);
    if (!dest.open(QIODevice::WriteOnly)) return false;
    dest.write((const char*)decrypted.data(), decrypted.size());
    dest.close();

    return true;
}

QString FileCryptoHelper::getCombinedKey() {
    QString hardcode = "RapidNotes-Internal-Secret-Key-2024";
    QString fingerprint = QSysInfo::machineUniqueId();
    if (fingerprint.isEmpty()) fingerprint = QSysInfo::bootUniqueId();
    if (fingerprint.isEmpty()) fingerprint = "RapidNotes-Fallback-Fingerprint-v1";
    
    return QCryptographicHash::hash((hardcode + fingerprint).toUtf8(), QCryptographicHash::Sha256).toHex();
}

bool FileCryptoHelper::secureDelete(const QString& filePath) {
    QFile file(filePath);
    if (!file.exists()) return true;
    
    // 尝试多次删除 (处理 SQLite 延迟释放)
    for (int retry = 0; retry < 3; ++retry) {
        if (file.open(QIODevice::ReadWrite)) {
            qint64 size = file.size();
            if (size > 0) {
                QByteArray junk(4096, 0);
                for (qint64 i = 0; i < size; i += junk.size()) {
                    for(int j=0; j<junk.size(); ++j) junk[j] = (char)QRandomGenerator::global()->bounded(256);
                    file.write(junk);
                }
                file.flush();
            }
            file.close();
            if (QFile::remove(filePath)) return true;
        }
        QThread::msleep(100);
    }
    
    return QFile::remove(filePath);
}
```

## 文件: `src/core/FileCryptoHelper.h`

```cpp
#ifndef FILECRYPTOHELPER_H
#define FILECRYPTOHELPER_H

#include <QString>
#include <QByteArray>
#include <QFile>

class FileCryptoHelper {
public:
    // 三层架构专用：带魔数的壳加密/解密
    static bool encryptFileWithShell(const QString& sourcePath, const QString& destPath, const QString& password);
    static bool decryptFileWithShell(const QString& sourcePath, const QString& destPath, const QString& password);
    
    // 旧版解密 (Legacy): 不检查魔数
    static bool decryptFileLegacy(const QString& sourcePath, const QString& destPath, const QString& password);
    
    // 获取设备指纹与内置 Hardcode 结合的密钥
    static QString getCombinedKey();

    // 安全删除文件（覆盖后再删除）
    static bool secureDelete(const QString& filePath);

private:
    static QByteArray deriveKey(const QString& password, const QByteArray& salt);
};

#endif // FILECRYPTOHELPER_H
```

## 文件: `src/ui/FileSearchWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "FileSearchWindow.h"
#include "StringUtils.h"
#include "../core/ShortcutManager.h"

#include "IconHelper.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFileDialog>
#include <QDirIterator>
#include <QDesktopServices>
#include <QUrl>
#include <QFileInfo>
#include <QLabel>
#include <QProcess>
#include <QClipboard>
#include <QApplication>
#include <QMouseEvent>
#include <QPainter>
#include <QDir>
#include <QFile>
#include <QToolTip>
#include <QSettings>
#include <QSplitter>
#include <QMenu>
#include <QAction>
#include <QToolButton>
#include <QMimeData>
#include <QDropEvent>
#include <QDragEnterEvent>
#include <QDragMoveEvent>
#include <QGraphicsDropShadowEffect>
#include <QPropertyAnimation>
#include <QScrollArea>
#include <functional>
#include <utility>
#include <QSet>
#include <QDateTime>

// ----------------------------------------------------------------------------
// 合并逻辑相关常量与辅助函数
// ----------------------------------------------------------------------------
static const QSet<QString> SUPPORTED_EXTENSIONS = {
    ".py", ".pyw", ".cpp", ".cc", ".cxx", ".c", ".h", ".hpp", ".hxx",
    ".java", ".js", ".jsx", ".ts", ".tsx", ".cs", ".go", ".rs", ".swift",
    ".kt", ".kts", ".php", ".rb", ".lua", ".r", ".m", ".scala", ".sh",
    ".bash", ".zsh", ".ps1", ".bat", ".cmd", ".html", ".htm", ".css",
    ".scss", ".sass", ".less", ".xml", ".svg", ".vue", ".json", ".yaml",
    ".yml", ".toml", ".ini", ".cfg", ".conf", ".env", ".properties",
    ".cmake", ".gradle", ".make", ".mk", ".dockerfile", ".md", ".markdown",
    ".txt", ".rst", ".qml", ".qrc", ".qss", ".ui", ".sql", ".graphql",
    ".gql", ".proto", ".asm", ".s", ".v", ".vh", ".vhdl", ".vhd"
};

static const QSet<QString> SPECIAL_FILENAMES = {
    "Makefile", "makefile", "Dockerfile", "dockerfile", "CMakeLists.txt",
    "Rakefile", "Gemfile", ".gitignore", ".dockerignore", ".editorconfig",
    ".eslintrc", ".prettierrc"
};

static QString getFileLanguage(const QString& filePath) {
    QFileInfo fi(filePath);
    QString basename = fi.fileName();
    QString ext = "." + fi.suffix().toLower();
    
    static const QMap<QString, QString> specialMap = {
        {"Makefile", "makefile"}, {"makefile", "makefile"},
        {"Dockerfile", "dockerfile"}, {"dockerfile", "dockerfile"},
        {"CMakeLists.txt", "cmake"}
    };
    if (specialMap.contains(basename)) return specialMap[basename];

    static const QMap<QString, QString> extMap = {
        {".py", "python"}, {".pyw", "python"}, {".cpp", "cpp"}, {".cc", "cpp"},
        {".cxx", "cpp"}, {".c", "c"}, {".h", "cpp"}, {".hpp", "cpp"},
        {".hxx", "cpp"}, {".java", "java"}, {".js", "javascript"},
        {".jsx", "jsx"}, {".ts", "typescript"}, {".tsx", "tsx"},
        {".cs", "csharp"}, {".go", "go"}, {".rs", "rust"}, {".swift", "swift"},
        {".kt", "kotlin"}, {".kts", "kotlin"}, {".php", "php"}, {".rb", "ruby"},
        {".lua", "lua"}, {".r", "r"}, {".m", "objectivec"}, {".scala", "scala"},
        {".sh", "bash"}, {".bash", "bash"}, {".zsh", "zsh"}, {".ps1", "powershell"},
        {".bat", "batch"}, {".cmd", "batch"}, {".html", "html"}, {".htm", "html"},
        {".css", "css"}, {".scss", "scss"}, {".sass", "sass"}, {".less", "less"},
        {".xml", "xml"}, {".svg", "svg"}, {".vue", "vue"}, {".json", "json"},
        {".yaml", "yaml"}, {".yml", "yaml"}, {".toml", "toml"}, {".ini", "ini"},
        {".cfg", "ini"}, {".conf", "conf"}, {".env", "bash"},
        {".properties", "properties"}, {".cmake", "cmake"}, {".gradle", "gradle"},
        {".make", "makefile"}, {".mk", "makefile"}, {".dockerfile", "dockerfile"},
        {".md", "markdown"}, {".markdown", "markdown"}, {".txt", "text"},
        {".rst", "restructuredtext"}, {".qml", "qml"}, {".qrc", "xml"},
        {".qss", "css"}, {".ui", "xml"}, {".sql", "sql"}, {".graphql", "graphql"},
        {".gql", "graphql"}, {".proto", "protobuf"}, {".asm", "asm"},
        {".s", "asm"}, {".v", "verilog"}, {".vh", "verilog"}, {".vhdl", "vhdl"},
        {".vhd", "vhdl"}
    };
    return extMap.value(ext, ext.mid(1).isEmpty() ? "text" : ext.mid(1));
}

static bool isSupportedFile(const QString& filePath) {
    QFileInfo fi(filePath);
    if (SPECIAL_FILENAMES.contains(fi.fileName())) return true;
    return SUPPORTED_EXTENSIONS.contains("." + fi.suffix().toLower());
}

// ----------------------------------------------------------------------------
// PathHistory 相关辅助类 (复刻 SearchHistoryPopup 逻辑)
// ----------------------------------------------------------------------------
class PathChip : public QFrame {
    Q_OBJECT
public:
    PathChip(const QString& text, QWidget* parent = nullptr) : QFrame(parent), m_text(text) {
        setAttribute(Qt::WA_StyledBackground);
        setCursor(Qt::PointingHandCursor);
        setObjectName("PathChip");
        
        auto* layout = new QHBoxLayout(this);
        layout->setContentsMargins(10, 6, 10, 6);
        layout->setSpacing(10);
        
        auto* lbl = new QLabel(text);
        lbl->setStyleSheet("border: none; background: transparent; color: #DDD; font-size: 13px;");
        layout->addWidget(lbl);
        layout->addStretch();
        
        auto* btnDel = new QPushButton();
        btnDel->setIcon(IconHelper::getIcon("close", "#666", 16));
        btnDel->setIconSize(QSize(10, 10));
        btnDel->setFixedSize(16, 16);
        btnDel->setCursor(Qt::PointingHandCursor);
        btnDel->setStyleSheet(
            "QPushButton { background-color: transparent; border-radius: 4px; padding: 0px; }"
            "QPushButton:hover { background-color: #E74C3C; }"
        );
        
        connect(btnDel, &QPushButton::clicked, this, [this](){ emit deleted(m_text); });
        layout->addWidget(btnDel);

        setStyleSheet(
            "#PathChip { background-color: transparent; border: none; border-radius: 4px; }"
            "#PathChip:hover { background-color: #3E3E42; }"
        );
    }
    
    void mousePressEvent(QMouseEvent* e) override { 
        if(e->button() == Qt::LeftButton) emit clicked(m_text); 
        QFrame::mousePressEvent(e);
    }

signals:
    void clicked(const QString& text);
    void deleted(const QString& text);
private:
    QString m_text;
};

// ----------------------------------------------------------------------------
// Sidebar ListWidget subclass for Drag & Drop
// ----------------------------------------------------------------------------
class FileSidebarListWidget : public QListWidget {
    Q_OBJECT
public:
    explicit FileSidebarListWidget(QWidget* parent = nullptr) : QListWidget(parent) {
        setAcceptDrops(true);
    }
signals:
    void folderDropped(const QString& path);
protected:
    void dragEnterEvent(QDragEnterEvent* event) override {
        if (event->mimeData()->hasUrls() || event->mimeData()->hasText()) {
            event->acceptProposedAction();
        }
    }
    void dragMoveEvent(QDragMoveEvent* event) override {
        event->acceptProposedAction();
    }
    void dropEvent(QDropEvent* event) override {
        QString path;
        if (event->mimeData()->hasUrls()) {
            path = event->mimeData()->urls().at(0).toLocalFile();
        } else if (event->mimeData()->hasText()) {
            path = event->mimeData()->text();
        }
        
        if (!path.isEmpty() && QDir(path).exists()) {
            emit folderDropped(path);
            event->acceptProposedAction();
        }
    }
};

// ----------------------------------------------------------------------------
// FileCollectionListWidget 实现 (右侧边栏，支持多选和拖拽文件)
// ----------------------------------------------------------------------------
FileCollectionListWidget::FileCollectionListWidget(QWidget* parent) : QListWidget(parent) {
    setAcceptDrops(true);
    setSelectionMode(QAbstractItemView::ExtendedSelection); // 支持多选
}

void FileCollectionListWidget::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls() || event->mimeData()->hasText()) {
        event->acceptProposedAction();
    }
}

void FileCollectionListWidget::dragMoveEvent(QDragMoveEvent* event) {
    event->acceptProposedAction();
}

void FileCollectionListWidget::dropEvent(QDropEvent* event) {
    QStringList paths;
    if (event->mimeData()->hasUrls()) {
        for (const QUrl& url : event->mimeData()->urls()) {
            QString p = url.toLocalFile();
            if (!p.isEmpty() && QFileInfo(p).isFile()) paths << p;
        }
    } else if (event->mimeData()->hasText()) {
        QStringList texts = event->mimeData()->text().split("\n", Qt::SkipEmptyParts);
        for (const QString& t : texts) {
            QString p = t.trimmed();
            if (!p.isEmpty() && QFileInfo(p).isFile()) paths << p;
        }
    }
    
    if (!paths.isEmpty()) {
        emit filesDropped(paths);
        event->acceptProposedAction();
    } else if (event->source() && event->source() != this) {
        // 支持从中间列表拖拽 (通过 QListWidget 内部机制)
        QListWidget* sourceList = qobject_cast<QListWidget*>(event->source());
        if (sourceList) {
            QStringList sourcePaths;
            for (auto* item : sourceList->selectedItems()) {
                QString p = item->data(Qt::UserRole).toString();
                if (!p.isEmpty()) sourcePaths << p;
            }
            if (!sourcePaths.isEmpty()) {
                emit filesDropped(sourcePaths);
                event->acceptProposedAction();
            }
        }
    }
}

class FileSearchHistoryPopup : public QWidget {
    Q_OBJECT
public:
    enum Type { Path, Filename };

    explicit FileSearchHistoryPopup(FileSearchWindow* window, QLineEdit* edit, Type type) 
        : QWidget(window->window(), Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint) 
    {
        m_window = window;
        m_edit = edit;
        m_type = type;
        setAttribute(Qt::WA_TranslucentBackground);
        
        auto* rootLayout = new QVBoxLayout(this);
        rootLayout->setContentsMargins(12, 12, 12, 12);
        
        auto* container = new QFrame();
        container->setObjectName("PopupContainer");
        container->setStyleSheet(
            "#PopupContainer { background-color: #252526; border: 1px solid #444; border-radius: 10px; }"
        );
        rootLayout->addWidget(container);

        auto* layout = new QVBoxLayout(container);
        layout->setContentsMargins(12, 12, 12, 12);
        layout->setSpacing(10);

        auto* top = new QHBoxLayout();
        auto* icon = new QLabel();
        icon->setPixmap(IconHelper::getIcon("clock", "#888").pixmap(14, 14));
        icon->setStyleSheet("border: none; background: transparent;");
        top->addWidget(icon);

        auto* title = new QLabel(m_type == Path ? "最近扫描路径" : "最近搜索文件名");
        title->setStyleSheet("color: #888; font-weight: bold; font-size: 11px; background: transparent; border: none;");
        top->addWidget(title);
        top->addStretch();
        auto* clearBtn = new QPushButton("清空");
        clearBtn->setCursor(Qt::PointingHandCursor);
        clearBtn->setStyleSheet("QPushButton { background: transparent; color: #666; border: none; font-size: 11px; } QPushButton:hover { color: #E74C3C; }");
        connect(clearBtn, &QPushButton::clicked, [this](){
            if (m_type == Path) m_window->clearHistory();
            else m_window->clearSearchHistory();
            refreshUI();
        });
        top->addWidget(clearBtn);
        layout->addLayout(top);

        auto* scroll = new QScrollArea();
        scroll->setWidgetResizable(true);
        scroll->setStyleSheet(
            "QScrollArea { background-color: transparent; border: none; }"
            "QScrollArea > QWidget > QWidget { background-color: transparent; }"
        );
        scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

        m_chipsWidget = new QWidget();
        m_chipsWidget->setStyleSheet("background-color: transparent;");
        m_vLayout = new QVBoxLayout(m_chipsWidget);
        m_vLayout->setContentsMargins(0, 0, 0, 0);
        m_vLayout->setSpacing(2);
        m_vLayout->addStretch();
        scroll->setWidget(m_chipsWidget);
        layout->addWidget(scroll);

        m_opacityAnim = new QPropertyAnimation(this, "windowOpacity");
        m_opacityAnim->setDuration(200);
    }

    void refreshUI() {
        QLayoutItem* item;
        while ((item = m_vLayout->takeAt(0))) {
            if(item->widget()) item->widget()->deleteLater();
            delete item;
        }
        m_vLayout->addStretch();
        
        QStringList history = (m_type == Path) ? m_window->getHistory() : m_window->getSearchHistory();
        if(history.isEmpty()) {
            auto* lbl = new QLabel("暂无历史记录");
            lbl->setAlignment(Qt::AlignCenter);
            lbl->setStyleSheet("color: #555; font-style: italic; margin: 20px; border: none;");
            m_vLayout->insertWidget(0, lbl);
        } else {
            for(const QString& val : std::as_const(history)) {
                auto* chip = new PathChip(val);
                chip->setFixedHeight(32);
                connect(chip, &PathChip::clicked, this, [this](const QString& v){ 
                    if (m_type == Path) m_window->useHistoryPath(v);
                    else m_edit->setText(v);
                    close(); 
                });
                connect(chip, &PathChip::deleted, this, [this](const QString& v){ 
                    if (m_type == Path) m_window->removeHistoryEntry(v);
                    else m_window->removeSearchHistoryEntry(v);
                    refreshUI(); 
                });
                m_vLayout->insertWidget(m_vLayout->count() - 1, chip);
            }
        }
        
        int targetWidth = m_edit->width();
        // 统一高度为 410px，确保视觉一致性，不论记录多少（如同图一的效果）
        int contentHeight = 410;
        resize(targetWidth + 24, contentHeight);
    }

    void showAnimated() {
        refreshUI();
        QPoint pos = m_edit->mapToGlobal(QPoint(0, m_edit->height()));
        move(pos.x() - 12, pos.y() - 7);
        setWindowOpacity(0);
        show();
        m_opacityAnim->setStartValue(0);
        m_opacityAnim->setEndValue(1);
        m_opacityAnim->start();
    }

private:
    FileSearchWindow* m_window;
    QLineEdit* m_edit;
    Type m_type;
    QWidget* m_chipsWidget;
    QVBoxLayout* m_vLayout;
    QPropertyAnimation* m_opacityAnim;
};

// ----------------------------------------------------------------------------
// ScannerThread 实现
// ----------------------------------------------------------------------------
ScannerThread::ScannerThread(const QString& folderPath, QObject* parent)
    : QThread(parent), m_folderPath(folderPath) {}

void ScannerThread::stop() {
    m_isRunning = false;
    wait();
}

void ScannerThread::run() {
    int count = 0;
    if (m_folderPath.isEmpty() || !QDir(m_folderPath).exists()) {
        emit finished(0);
        return;
    }

    QStringList ignored = {".git", ".idea", "__pycache__", "node_modules", "$RECYCLE.BIN", "System Volume Information"};
    
    // 使用 std::function 实现递归扫描，支持目录剪枝
    std::function<void(const QString&)> scanDir = [&](const QString& currentPath) {
        if (!m_isRunning) return;

        QDir dir(currentPath);
        // 1. 获取当前目录下所有文件
        QFileInfoList files = dir.entryInfoList(QDir::Files | QDir::NoDotAndDotDot | QDir::Hidden);
        for (const auto& fi : std::as_const(files)) {
            if (!m_isRunning) return;
            bool hidden = fi.isHidden();
            // 在某些平台上，以 . 开头的文件可能没被标记为 hidden，但通常我们也视为隐性文件
            if (!hidden && fi.fileName().startsWith('.')) hidden = true;
            
            emit fileFound(fi.fileName(), fi.absoluteFilePath(), hidden);
            count++;
        }

        // 2. 获取子目录并递归 (排除忽略列表)
        QFileInfoList subDirs = dir.entryInfoList(QDir::Dirs | QDir::NoDotAndDotDot | QDir::Hidden);
        for (const auto& di : std::as_const(subDirs)) {
            if (!m_isRunning) return;
            if (!ignored.contains(di.fileName())) {
                scanDir(di.absoluteFilePath());
            }
        }
    };

    scanDir(m_folderPath);
    emit finished(count);
}

// ----------------------------------------------------------------------------
// FileSearchWindow 实现
// ----------------------------------------------------------------------------
FileSearchWindow::FileSearchWindow(QWidget* parent) 
    : FramelessDialog("查找文件", parent) 
{
    setObjectName("FileSearchWindow");
    loadWindowSettings();
    resize(1200, 680); // 增加默认宽度以容纳两个侧边栏
    setupStyles();
    initUI();
    loadFavorites();
    loadCollection(); // 加载收藏文件
    m_resizeHandle = new ResizeHandle(this, this);
    m_resizeHandle->raise();
}

FileSearchWindow::~FileSearchWindow() {
    if (m_scanThread) {
        m_scanThread->stop();
        m_scanThread->deleteLater();
    }
}

void FileSearchWindow::setupStyles() {
    // 1:1 复刻 Python 脚本中的 STYLESHEET
    setStyleSheet(R"(
        QWidget {
            font-family: "Microsoft YaHei", "Segoe UI", sans-serif;
            font-size: 14px;
            color: #E0E0E0;
            outline: none;
        }
        QSplitter::handle {
            background-color: #333;
        }
        QListWidget {
            background-color: #252526; 
            border: 1px solid #333333;
            border-radius: 6px;
            padding: 4px;
        }
        QListWidget::item {
            min-height: 20px;
            max-height: 20px;
            padding-left: 8px;
            border-radius: 4px;
            color: #CCCCCC;
        }
        QListWidget::item:selected {
            background-color: #37373D;
            border-left: 3px solid #007ACC;
            color: #FFFFFF;
        }
        #SidebarList::item:selected {
            background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #007ACC, stop:0.015 #007ACC, stop:0.016 #37373D, stop:1 #37373D);
            color: #FFFFFF;
            border-radius: 4px;
        }
        QListWidget::item:hover {
            background-color: #2A2D2E;
        }
        QLineEdit {
            background-color: #333333;
            border: 1px solid #444444;
            color: #FFFFFF;
            border-radius: 6px;
            padding: 8px;
            selection-background-color: #264F78;
        }
        QLineEdit:focus {
            border: 1px solid #007ACC;
            background-color: #2D2D2D;
        }
        #ActionBtn {
            background-color: #007ACC;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
        }
        #ActionBtn:hover {
            background-color: #0062A3;
        }
        QScrollBar:vertical {
            background: transparent;
            width: 8px;
            margin: 0px;
        }
        QScrollBar::handle:vertical {
            background: #555555;
            min-height: 20px;
            border-radius: 4px;
        }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
            height: 0px;
        }
    )");
}

void FileSearchWindow::initUI() {
    auto* mainLayout = new QHBoxLayout(m_contentArea);
    mainLayout->setContentsMargins(10, 10, 10, 10);
    mainLayout->setSpacing(0);

    auto* splitter = new QSplitter(Qt::Horizontal);
    splitter->setHandleWidth(1); // 细分界线
    mainLayout->addWidget(splitter);

    // --- 左侧边栏 ---
    auto* sidebarWidget = new QWidget();
    auto* sidebarLayout = new QVBoxLayout(sidebarWidget);
    sidebarLayout->setContentsMargins(0, 0, 10, 0); // 增加右侧间距，与 splitter handle 配合
    sidebarLayout->setSpacing(10);

    auto* headerLayout = new QHBoxLayout();
    headerLayout->setSpacing(5);
    auto* sidebarIcon = new QLabel();
    sidebarIcon->setPixmap(IconHelper::getIcon("folder", "#888").pixmap(14, 14));
    sidebarIcon->setStyleSheet("border: none; background: transparent;");
    headerLayout->addWidget(sidebarIcon);

    auto* sidebarHeader = new QLabel("收藏夹 (可拖入)");
    sidebarHeader->setStyleSheet("color: #888; font-weight: bold; font-size: 12px; border: none; background: transparent;");
    headerLayout->addWidget(sidebarHeader);
    headerLayout->addStretch();
    sidebarLayout->addLayout(headerLayout);

    auto* sidebar = new FileSidebarListWidget();
    m_sidebar = sidebar;
    m_sidebar->setObjectName("SidebarList");
    m_sidebar->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_sidebar->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_sidebar->setMinimumWidth(200);
    m_sidebar->setDragEnabled(false);
    m_sidebar->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(sidebar, &FileSidebarListWidget::folderDropped, this, &FileSearchWindow::addFavorite);
    connect(m_sidebar, &QListWidget::itemClicked, this, &FileSearchWindow::onSidebarItemClicked);
    connect(m_sidebar, &QListWidget::customContextMenuRequested, this, &FileSearchWindow::showSidebarContextMenu);
    sidebarLayout->addWidget(m_sidebar);

    auto* btnAddFav = new QPushButton("收藏当前路径");
    btnAddFav->setFixedHeight(32);
    btnAddFav->setCursor(Qt::PointingHandCursor);
    btnAddFav->setStyleSheet(
        "QPushButton { background-color: #2D2D30; border: 1px solid #444; color: #AAA; border-radius: 4px; font-size: 12px; }"
        "QPushButton:hover { background-color: #3E3E42; color: #FFF; border-color: #666; }"
    );
    connect(btnAddFav, &QPushButton::clicked, this, [this](){
        QString p = m_pathInput->text().trimmed();
        if (QDir(p).exists()) addFavorite(p);
    });
    sidebarLayout->addWidget(btnAddFav);

    splitter->addWidget(sidebarWidget);

    // --- 右侧主区域 ---
    auto* rightWidget = new QWidget();
    auto* layout = new QVBoxLayout(rightWidget);
    layout->setContentsMargins(10, 0, 10, 0); // 两侧保留间距
    layout->setSpacing(10);

    // 第一行：路径输入与浏览
    auto* pathLayout = new QHBoxLayout();
    m_pathInput = new QLineEdit();
    m_pathInput->setPlaceholderText("双击查看历史，或在此粘贴路径...");
    m_pathInput->setClearButtonEnabled(true);
    m_pathInput->installEventFilter(this);
    connect(m_pathInput, &QLineEdit::returnPressed, this, &FileSearchWindow::onPathReturnPressed);
    
    auto* btnScan = new QToolButton();
    btnScan->setIcon(IconHelper::getIcon("scan", "#1abc9c", 18));
    btnScan->setToolTip("开始扫描");
    btnScan->setFixedSize(38, 38);
    btnScan->setCursor(Qt::PointingHandCursor);
    btnScan->setStyleSheet("QToolButton { border: 1px solid #444; background: #2D2D30; border-radius: 6px; }"
                           "QToolButton:hover { background-color: #3E3E42; border-color: #007ACC; }");
    connect(btnScan, &QToolButton::clicked, this, &FileSearchWindow::onPathReturnPressed);

    auto* btnBrowse = new QToolButton();
    btnBrowse->setObjectName("ActionBtn");
    btnBrowse->setIcon(IconHelper::getIcon("folder", "#ffffff", 18));
    btnBrowse->setToolTip("浏览文件夹");
    btnBrowse->setFixedSize(38, 38);
    btnBrowse->setCursor(Qt::PointingHandCursor);
    connect(btnBrowse, &QToolButton::clicked, this, &FileSearchWindow::selectFolder);

    pathLayout->addWidget(m_pathInput);
    pathLayout->addWidget(btnScan);
    pathLayout->addWidget(btnBrowse);
    layout->addLayout(pathLayout);

    // 第二行：搜索过滤与后缀名
    auto* searchLayout = new QHBoxLayout();
    m_searchInput = new QLineEdit();
    m_searchInput->setPlaceholderText("输入文件名过滤...");
    m_searchInput->setClearButtonEnabled(true);
    m_searchInput->installEventFilter(this);
    connect(m_searchInput, &QLineEdit::textChanged, this, &FileSearchWindow::refreshList);
    connect(m_searchInput, &QLineEdit::returnPressed, this, [this](){
        addSearchHistoryEntry(m_searchInput->text().trimmed());
    });

    m_extInput = new QLineEdit();
    m_extInput->setPlaceholderText("后缀 (如 py)");
    m_extInput->setClearButtonEnabled(true);
    m_extInput->setFixedWidth(120);
    connect(m_extInput, &QLineEdit::textChanged, this, &FileSearchWindow::refreshList);

    searchLayout->addWidget(m_searchInput);
    searchLayout->addWidget(m_extInput);
    layout->addLayout(searchLayout);

    // 信息标签与显示隐藏文件勾选
    auto* infoLayout = new QHBoxLayout();
    m_infoLabel = new QLabel("等待操作...");
    m_infoLabel->setStyleSheet("color: #888888; font-size: 12px;");
    
    m_showHiddenCheck = new QCheckBox("显示隐性文件");
    m_showHiddenCheck->setStyleSheet(R"(
        QCheckBox { color: #888; font-size: 12px; spacing: 5px; }
        QCheckBox::indicator { width: 15px; height: 15px; border: 1px solid #444; border-radius: 3px; background: #2D2D30; }
        QCheckBox::indicator:checked { background-color: #007ACC; border-color: #007ACC; }
        QCheckBox::indicator:hover { border-color: #666; }
    )");
    connect(m_showHiddenCheck, &QCheckBox::toggled, this, &FileSearchWindow::refreshList);

    infoLayout->addWidget(m_infoLabel);
    infoLayout->addWidget(m_showHiddenCheck);
    infoLayout->addStretch();
    layout->addLayout(infoLayout);

    // 列表标题与复制全部按钮
    auto* listHeaderLayout = new QHBoxLayout();
    listHeaderLayout->setContentsMargins(0, 0, 0, 0);
    auto* listTitle = new QLabel("搜索结果");
    listTitle->setStyleSheet("color: #888; font-size: 11px; font-weight: bold; border: none; background: transparent;");
    
    auto* btnCopyAll = new QToolButton();
    btnCopyAll->setIcon(IconHelper::getIcon("copy", "#1abc9c", 14));
    btnCopyAll->setToolTip("复制全部搜索结果的路径");
    btnCopyAll->setFixedSize(20, 20);
    btnCopyAll->setCursor(Qt::PointingHandCursor);
    btnCopyAll->setStyleSheet("QToolButton { border: none; background: transparent; padding: 2px; }"
                               "QToolButton:hover { background-color: #3E3E42; border-radius: 4px; }");
    connect(btnCopyAll, &QToolButton::clicked, this, [this](){
        if (m_fileList->count() == 0) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 结果列表为空</b>");
            return;
        }
        QStringList paths;
        for (int i = 0; i < m_fileList->count(); ++i) {
            QString p = m_fileList->item(i)->data(Qt::UserRole).toString();
            if (!p.isEmpty()) paths << p;
        }
        if (paths.isEmpty()) return;
        QApplication::clipboard()->setText(paths.join("\n"));
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 已复制全部搜索结果</b>");
    });

    listHeaderLayout->addWidget(listTitle);
    listHeaderLayout->addStretch();
    listHeaderLayout->addWidget(btnCopyAll);
    layout->addLayout(listHeaderLayout);

    // 文件列表
    m_fileList = new QListWidget();
    m_fileList->setObjectName("FileList");
    m_fileList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_fileList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_fileList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    m_fileList->setContextMenuPolicy(Qt::CustomContextMenu);
    m_fileList->setDragEnabled(true);
    m_fileList->setDragDropMode(QAbstractItemView::DragOnly);
    connect(m_fileList, &QListWidget::customContextMenuRequested, this, &FileSearchWindow::showFileContextMenu);
    
    // 快捷键支持
    m_actionSelectAll = new QAction(this);
    m_actionSelectAll->setShortcutContext(Qt::WidgetShortcut);
    connect(m_actionSelectAll, &QAction::triggered, [this](){ m_fileList->selectAll(); });
    m_fileList->addAction(m_actionSelectAll);

    m_actionCopy = new QAction(this);
    m_actionCopy->setShortcutContext(Qt::WidgetShortcut);
    connect(m_actionCopy, &QAction::triggered, this, [this](){ copySelectedFiles(); });
    m_fileList->addAction(m_actionCopy);

    m_actionDelete = new QAction(this);
    m_actionDelete->setShortcutContext(Qt::WidgetShortcut);
    connect(m_actionDelete, &QAction::triggered, this, [this](){ onDeleteFile(); });
    m_fileList->addAction(m_actionDelete);

    m_actionScan = new QAction(this);
    connect(m_actionScan, &QAction::triggered, this, &FileSearchWindow::onPathReturnPressed);
    addAction(m_actionScan);

    updateShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &FileSearchWindow::updateShortcuts);

    layout->addWidget(m_fileList);

    splitter->addWidget(rightWidget);

    // --- 右侧边栏 (文件收藏) ---
    auto* collectionWidget = new QWidget();
    auto* collectionLayout = new QVBoxLayout(collectionWidget);
    collectionLayout->setContentsMargins(10, 0, 0, 0); // 增加左侧间距
    collectionLayout->setSpacing(10);

    auto* collHeaderLayout = new QHBoxLayout();
    collHeaderLayout->setSpacing(5);
    auto* collIcon = new QLabel();
    collIcon->setPixmap(IconHelper::getIcon("file", "#888").pixmap(14, 14));
    collIcon->setStyleSheet("border: none; background: transparent;");
    collHeaderLayout->addWidget(collIcon);

    auto* collHeader = new QLabel("文件收藏 (可多选/拖入)");
    collHeader->setStyleSheet("color: #888; font-weight: bold; font-size: 12px; border: none; background: transparent;");
    collHeaderLayout->addWidget(collHeader);
    collHeaderLayout->addStretch();
    collectionLayout->addLayout(collHeaderLayout);

    m_collectionSidebar = new FileCollectionListWidget();
    m_collectionSidebar->setObjectName("SidebarList"); // 复用样式
    m_collectionSidebar->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_collectionSidebar->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_collectionSidebar->setMinimumWidth(200);
    m_collectionSidebar->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_collectionSidebar, &FileCollectionListWidget::filesDropped, this, [this](const QStringList& paths){
        for(const QString& p : paths) addCollectionItem(p);
    });
    connect(m_collectionSidebar, &QListWidget::itemClicked, this, &FileSearchWindow::onCollectionItemClicked);
    connect(m_collectionSidebar, &QListWidget::customContextMenuRequested, this, &FileSearchWindow::showCollectionContextMenu);
    collectionLayout->addWidget(m_collectionSidebar);

    auto* btnMergeColl = new QPushButton("合并收藏内容");
    btnMergeColl->setFixedHeight(32);
    btnMergeColl->setCursor(Qt::PointingHandCursor);
    btnMergeColl->setStyleSheet(
        "QPushButton { background-color: #2D2D30; border: 1px solid #444; color: #AAA; border-radius: 4px; font-size: 12px; }"
        "QPushButton:hover { background-color: #3E3E42; color: #FFF; border-color: #666; }"
    );
    connect(btnMergeColl, &QPushButton::clicked, this, &FileSearchWindow::onMergeCollectionFiles);
    collectionLayout->addWidget(btnMergeColl);

    splitter->addWidget(collectionWidget);

    splitter->setStretchFactor(0, 0); // 左侧固定
    splitter->setStretchFactor(1, 1); // 中间伸缩
    splitter->setStretchFactor(2, 0); // 右侧固定
}

void FileSearchWindow::selectFolder() {
    QString d = QFileDialog::getExistingDirectory(this, "选择文件夹");
    if (!d.isEmpty()) {
        m_pathInput->setText(d);
        startScan(d);
    }
}

void FileSearchWindow::onPathReturnPressed() {
    QString p = m_pathInput->text().trimmed();
    if (QDir(p).exists()) {
        startScan(p);
    } else {
        m_infoLabel->setText("路径不存在");
        m_pathInput->setStyleSheet("border: 1px solid #FF3333;");
    }
}

void FileSearchWindow::startScan(const QString& path) {
    m_pathInput->setStyleSheet("");
    if (m_scanThread) {
        m_scanThread->stop();
        m_scanThread->deleteLater();
    }

    m_fileList->clear();
    m_filesData.clear();
    m_visibleCount = 0;
    m_hiddenCount = 0;
    m_infoLabel->setText("正在扫描: " + path);

    m_scanThread = new ScannerThread(path, this);
    connect(m_scanThread, &ScannerThread::fileFound, this, &FileSearchWindow::onFileFound);
    connect(m_scanThread, &ScannerThread::finished, this, &FileSearchWindow::onScanFinished);
    m_scanThread->start();
}

void FileSearchWindow::onFileFound(const QString& name, const QString& path, bool isHidden) {
    m_filesData.append({name, path, isHidden});
    if (isHidden) m_hiddenCount++;
    else m_visibleCount++;

    if (m_filesData.size() % 300 == 0) {
        m_infoLabel->setText(QString("已发现 %1 个文件 (可见:%2 隐性:%3)...").arg(m_filesData.size()).arg(m_visibleCount).arg(m_hiddenCount));
    }
}

void FileSearchWindow::onScanFinished(int count) {
    m_infoLabel->setText(QString("扫描结束，共 %1 个文件 (可见:%2 隐性:%3)").arg(count).arg(m_visibleCount).arg(m_hiddenCount));
    addHistoryEntry(m_pathInput->text().trimmed());
    
    // 按文件名排序 (不按目录)
    std::sort(m_filesData.begin(), m_filesData.end(), [](const FileData& a, const FileData& b){
        return a.name.localeAwareCompare(b.name) < 0;
    });

    refreshList();
}

void FileSearchWindow::refreshList() {
    m_fileList->clear();
    QString txt = m_searchInput->text().toLower();
    QString ext = m_extInput->text().toLower().trimmed();
    if (ext.startsWith(".")) ext = ext.mid(1);

    bool showHidden = m_showHiddenCheck->isChecked();

    int limit = 500;
    int shown = 0;

    for (const auto& data : std::as_const(m_filesData)) {
        if (!showHidden && data.isHidden) continue;
        if (!ext.isEmpty() && !data.name.toLower().endsWith("." + ext)) continue;
        if (!txt.isEmpty() && !data.name.toLower().contains(txt)) continue;

        auto* item = new QListWidgetItem(data.name);
        item->setData(Qt::UserRole, data.path);
        item->setToolTip(data.path);
        m_fileList->addItem(item);
        
        shown++;
        if (shown >= limit) {
            auto* warn = new QListWidgetItem("--- 结果过多，仅显示前 500 条 ---");
            warn->setForeground(QColor(255, 170, 0));
            warn->setTextAlignment(Qt::AlignCenter);
            warn->setFlags(Qt::NoItemFlags);
            m_fileList->addItem(warn);
            break;
        }
    }
}

void FileSearchWindow::showFileContextMenu(const QPoint& pos) {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        auto* item = m_fileList->itemAt(pos);
        if (item) {
            item->setSelected(true);
            selectedItems << item;
        }
    }

    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) paths << p;
    }

    if (paths.isEmpty()) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D30; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #3E3E42; }");
    
    if (selectedItems.size() == 1) {
        QString filePath = paths.first();
        menu.addAction(IconHelper::getIcon("folder", "#F1C40F"), "定位文件夹", [filePath](){
            QDesktopServices::openUrl(QUrl::fromLocalFile(QFileInfo(filePath).absolutePath()));
        });
        menu.addAction(IconHelper::getIcon("search", "#4A90E2"), "定位文件", [filePath](){
#ifdef Q_OS_WIN
            QStringList args;
            args << "/select," << QDir::toNativeSeparators(filePath);
            QProcess::startDetached("explorer.exe", args);
#endif
        });
        menu.addAction(IconHelper::getIcon("edit", "#3498DB"), "编辑", [this](){ onEditFile(); });
        menu.addSeparator();
    }

    QString copyPathText = selectedItems.size() > 1 ? "复制选中路径" : "复制完整路径";
    menu.addAction(IconHelper::getIcon("copy", "#2ECC71"), copyPathText, [paths](){
        QApplication::clipboard()->setText(paths.join("\n"));
    });

    if (selectedItems.size() == 1) {
        QString fileName = QFileInfo(paths.first()).fileName();
        menu.addAction(IconHelper::getIcon("copy", "#F39C12"), "复制文件名", [fileName](){
            QApplication::clipboard()->setText(fileName);
            ToolTipOverlay::instance()->showText(QCursor::pos(), "✔ 已复制文件名");
        });
    }

    QString copyFileText = selectedItems.size() > 1 ? "复制选中文件" : "复制文件";
    menu.addAction(IconHelper::getIcon("file", "#4A90E2"), copyFileText, [this](){ copySelectedFiles(); });

    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并选中内容", [this](){ onMergeSelectedFiles(); });

    menu.addSeparator();

    menu.addAction(IconHelper::getIcon("star", "#F1C40F"), "加入收藏", [this](){
        auto selectedItems = m_fileList->selectedItems();
        for (auto* item : selectedItems) {
            QString p = item->data(Qt::UserRole).toString();
            if (!p.isEmpty()) addCollectionItem(p);
        }
    });

    menu.addSeparator();
    menu.addAction(IconHelper::getIcon("cut", "#E67E22"), "剪切", [this](){ onCutFile(); });
    menu.addAction(IconHelper::getIcon("trash", "#E74C3C"), "删除", [this](){ onDeleteFile(); });

    menu.exec(m_fileList->mapToGlobal(pos));
}

void FileSearchWindow::onEditFile() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 请先选择要操作的内容</b>");
        return;
    }

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) paths << p;
    }
    if (paths.isEmpty()) return;

    QSettings settings("RapidNotes", "ExternalEditor");
    QString editorPath = settings.value("EditorPath").toString();

    // 尝试寻找 Notepad++
    if (editorPath.isEmpty() || !QFile::exists(editorPath)) {
        QStringList commonPaths = {
            "C:/Program Files/Notepad++/notepad++.exe",
            "C:/Program Files (x86)/Notepad++/notepad++.exe"
        };
        for (const QString& p : commonPaths) {
            if (QFile::exists(p)) {
                editorPath = p;
                break;
            }
        }
    }

    // 如果还没找到，让用户选择
    if (editorPath.isEmpty() || !QFile::exists(editorPath)) {
        editorPath = QFileDialog::getOpenFileName(this, "选择编辑器 (推荐 Notepad++)", "C:/Program Files", "Executable (*.exe)");
        if (editorPath.isEmpty()) return;
        settings.setValue("EditorPath", editorPath);
    }

    for (const QString& filePath : paths) {
        QProcess::startDetached(editorPath, { QDir::toNativeSeparators(filePath) });
    }
}

void FileSearchWindow::copySelectedFiles() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 请先选择要操作的内容</b>");
        return;
    }

    QList<QUrl> urls;
    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) {
            urls << QUrl::fromLocalFile(p);
            paths << p;
        }
    }
    if (urls.isEmpty()) return;

    QMimeData* mimeData = new QMimeData();
    mimeData->setUrls(urls);
    mimeData->setText(paths.join("\n"));

    QApplication::clipboard()->setMimeData(mimeData);

    QString msg = selectedItems.size() > 1 ? QString("✔ 已复制 %1 个文件").arg(selectedItems.size()) : "✔ 已复制到剪贴板";
    ToolTipOverlay::instance()->showText(QCursor::pos(), msg);
}

void FileSearchWindow::onCutFile() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 请先选择要操作的内容</b>");
        return;
    }

    QList<QUrl> urls;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) urls << QUrl::fromLocalFile(p);
    }
    if (urls.isEmpty()) return;

    QMimeData* mimeData = new QMimeData();
    mimeData->setUrls(urls);
    
#ifdef Q_OS_WIN
    // 设置 Preferred DropEffect 为 2 (DROPEFFECT_MOVE)，通知资源管理器这是“剪切”操作
    QByteArray data;
    data.resize(4);
    data[0] = 2; // DROPEFFECT_MOVE
    data[1] = 0;
    data[2] = 0;
    data[3] = 0;
    mimeData->setData("Preferred DropEffect", data);
#endif

    QApplication::clipboard()->setMimeData(mimeData);

    QString msg = selectedItems.size() > 1 ? QString("✔ 已剪切 %1 个文件").arg(selectedItems.size()) : "✔ 已剪切到剪贴板";
    ToolTipOverlay::instance()->showText(QCursor::pos(), msg);
}

void FileSearchWindow::onDeleteFile() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 请先选择要操作的内容</b>");
        return;
    }

    int successCount = 0;
    for (auto* item : std::as_const(selectedItems)) {
        QString filePath = item->data(Qt::UserRole).toString();
        if (filePath.isEmpty()) continue;

        if (QFile::moveToTrash(filePath)) {
            successCount++;
            // 从内存数据中移除
            for (int i = 0; i < m_filesData.size(); ++i) {
                if (m_filesData[i].path == filePath) {
                    m_filesData.removeAt(i);
                    break;
                }
            }
            delete item; // 从界面移除 (QListWidget 负责管理内存)
        }
    }

    if (successCount > 0) {
        QString msg = selectedItems.size() > 1 ? QString("✔ %1 个文件已移至回收站").arg(successCount) : "✔ 文件已移至回收站";
        ToolTipOverlay::instance()->showText(QCursor::pos(), msg);
        m_infoLabel->setText(msg);
    } else if (!selectedItems.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 无法删除文件，请检查是否被占用</b>");
    }
}

void FileSearchWindow::onMergeFiles(const QStringList& filePaths, const QString& rootPath, bool useCombineDir) {
    if (filePaths.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 没有可合并的文件</b>");
        return;
    }

    QString targetDir = rootPath;
    if (useCombineDir) {
        // 获取程序运行目录下的 Combine 文件夹
        targetDir = QCoreApplication::applicationDirPath() + "/Combine";
        QDir dir(targetDir);
        if (!dir.exists()) dir.mkpath(".");
    }

    QString ts = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
    QString outName = QString("%1_code_export.md").arg(ts);
    QString outPath = QDir(targetDir).filePath(outName);

    QFile outFile(outPath);
    if (!outFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 无法创建输出文件</b>");
        return;
    }

    QTextStream out(&outFile);
    out.setEncoding(QStringConverter::Utf8);

    out << "# 代码导出结果 - " << ts << "\n\n";
    out << "**项目路径**: `" << rootPath << "`\n\n";
    out << "**文件总数**: " << filePaths.size() << "\n\n";

    QMap<QString, int> fileStats;
    for (const QString& fp : filePaths) {
        QString lang = getFileLanguage(fp);
        fileStats[lang]++;
    }

    out << "## 文件类型统计\n\n";
    QStringList langs = fileStats.keys();
    std::sort(langs.begin(), langs.end(), [&](const QString& a, const QString& b){
        return fileStats.value(a) > fileStats.value(b);
    });
    for (const QString& lang : std::as_const(langs)) {
        out << "- **" << lang << "**: " << fileStats.value(lang) << " 个文件\n";
    }
    out << "\n---\n\n";

    for (const QString& fp : filePaths) {
        QString relPath = QDir(rootPath).relativeFilePath(fp);
        QString lang = getFileLanguage(fp);

        out << "## 文件: `" << relPath << "`\n\n";
        out << "```" << lang << "\n";

        QFile inFile(fp);
        if (inFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QByteArray content = inFile.readAll();
            out << QString::fromUtf8(content);
            if (!content.endsWith('\n')) out << "\n";
        } else {
            out << "# 读取文件失败\n";
        }
        out << "```\n\n";
    }

    outFile.close();
    
    QString msg = QString("✔ 已保存: %1 (%2个文件)").arg(outName).arg(filePaths.size());
    ToolTipOverlay::instance()->showText(QCursor::pos(), msg);
}

void FileSearchWindow::onMergeSelectedFiles() {
    auto selectedItems = m_fileList->selectedItems();
    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty() && isSupportedFile(p)) {
            paths << p;
        }
    }
    
    if (paths.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 选中项中没有支持的文件类型</b>");
        return;
    }

    QString rootPath = m_pathInput->text().trimmed();
    if (!QDir(rootPath).exists()) {
        rootPath = QFileInfo(paths.first()).absolutePath();
    }

    onMergeFiles(paths, rootPath);
}

void FileSearchWindow::onMergeFolderContent() {
    QListWidgetItem* item = m_sidebar->currentItem();
    if (!item) return;

    QString folderPath = item->data(Qt::UserRole).toString();
    if (!QDir(folderPath).exists()) return;

    QStringList filePaths;
    QDirIterator it(folderPath, QDir::Files | QDir::NoDotAndDotDot, QDirIterator::Subdirectories);
    while (it.hasNext()) {
        QString fp = it.next();
        if (isSupportedFile(fp)) {
            filePaths << fp;
        }
    }

    if (filePaths.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 文件夹中没有支持的文件类型</b>");
        return;
    }

    onMergeFiles(filePaths, folderPath);
}

void FileSearchWindow::updateShortcuts() {
    auto& sm = ShortcutManager::instance();
    if (m_actionSelectAll) m_actionSelectAll->setShortcut(sm.getShortcut("fs_select_all"));
    if (m_actionCopy) m_actionCopy->setShortcut(sm.getShortcut("fs_copy"));
    if (m_actionDelete) m_actionDelete->setShortcut(sm.getShortcut("fs_delete"));
    if (m_actionScan) m_actionScan->setShortcut(sm.getShortcut("fs_scan"));
}

void FileSearchWindow::resizeEvent(QResizeEvent* event) {
    FramelessDialog::resizeEvent(event);
    if (m_resizeHandle) {
        m_resizeHandle->move(width() - 20, height() - 20);
    }
}

// ----------------------------------------------------------------------------
// 历史记录与收藏夹 逻辑实现
// ----------------------------------------------------------------------------
void FileSearchWindow::addHistoryEntry(const QString& path) {
    if (path.isEmpty() || !QDir(path).exists()) return;
    QSettings settings("RapidNotes", "FileSearchHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(path);
    history.prepend(path);
    while (history.size() > 10) history.removeLast();
    settings.setValue("list", history);
}

QStringList FileSearchWindow::getHistory() const {
    QSettings settings("RapidNotes", "FileSearchHistory");
    return settings.value("list").toStringList();
}

void FileSearchWindow::clearHistory() {
    QSettings settings("RapidNotes", "FileSearchHistory");
    settings.setValue("list", QStringList());
}

void FileSearchWindow::removeHistoryEntry(const QString& path) {
    QSettings settings("RapidNotes", "FileSearchHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(path);
    settings.setValue("list", history);
}

void FileSearchWindow::addSearchHistoryEntry(const QString& text) {
    if (text.isEmpty()) return;
    QSettings settings("RapidNotes", "FileSearchFilenameHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(text);
    history.prepend(text);
    while (history.size() > 10) history.removeLast();
    settings.setValue("list", history);
}

QStringList FileSearchWindow::getSearchHistory() const {
    QSettings settings("RapidNotes", "FileSearchFilenameHistory");
    return settings.value("list").toStringList();
}

void FileSearchWindow::removeSearchHistoryEntry(const QString& text) {
    QSettings settings("RapidNotes", "FileSearchFilenameHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(text);
    settings.setValue("list", history);
}

void FileSearchWindow::clearSearchHistory() {
    QSettings settings("RapidNotes", "FileSearchFilenameHistory");
    settings.setValue("list", QStringList());
}

void FileSearchWindow::useHistoryPath(const QString& path) {
    m_pathInput->setText(path);
    startScan(path);
}

void FileSearchWindow::onSidebarItemClicked(QListWidgetItem* item) {
    if (!item) return;
    QString path = item->data(Qt::UserRole).toString();
    m_pathInput->setText(path);
    startScan(path);
}

void FileSearchWindow::showSidebarContextMenu(const QPoint& pos) {
    QListWidgetItem* item = m_sidebar->itemAt(pos);
    if (!item) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #252526; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #37373D; }");
    
    QAction* pinAct = menu.addAction(IconHelper::getIcon("pin", "#F1C40F"), "置顶文件夹");
    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并文件夹内容", [this](){ onMergeFolderContent(); });
    QAction* removeAct = menu.addAction(IconHelper::getIcon("close", "#E74C3C"), "取消收藏");
    
    QAction* selected = menu.exec(m_sidebar->mapToGlobal(pos));
    if (selected == pinAct) {
        int row = m_sidebar->row(item);
        if (row > 0) {
            QListWidgetItem* taken = m_sidebar->takeItem(row);
            m_sidebar->insertItem(0, taken);
            m_sidebar->setCurrentItem(taken);
            saveFavorites();
        }
    } else if (selected == removeAct) {
        delete m_sidebar->takeItem(m_sidebar->row(item));
        saveFavorites();
    }
}

void FileSearchWindow::addFavorite(const QString& path) {
    // 检查是否已存在
    for (int i = 0; i < m_sidebar->count(); ++i) {
        if (m_sidebar->item(i)->data(Qt::UserRole).toString() == path) return;
    }

    QFileInfo fi(path);
    QString displayName = fi.fileName();
    // [CRITICAL] 修复根目录（如 C:/）显示为空的问题：如果 fileName 为空，则显示本地化的完整路径。
    if (displayName.isEmpty()) displayName = QDir::toNativeSeparators(fi.absoluteFilePath());
    
    auto* item = new QListWidgetItem(IconHelper::getIcon("folder", "#F1C40F"), displayName);
    item->setData(Qt::UserRole, path);
    item->setToolTip(path);
    m_sidebar->addItem(item);
    saveFavorites();
}

void FileSearchWindow::loadFavorites() {
    QSettings settings("RapidNotes", "FileSearchFavorites");
    QStringList favs = settings.value("list").toStringList();
    for (const QString& path : std::as_const(favs)) {
        if (QDir(path).exists()) {
            QFileInfo fi(path);
            QString displayName = fi.fileName();
            // [CRITICAL] 同步修复加载时根目录显示为空的问题
            if (displayName.isEmpty()) displayName = QDir::toNativeSeparators(fi.absoluteFilePath());

            auto* item = new QListWidgetItem(IconHelper::getIcon("folder", "#F1C40F"), displayName);
            item->setData(Qt::UserRole, path);
            item->setToolTip(path);
            m_sidebar->addItem(item);
        }
    }
}

void FileSearchWindow::saveFavorites() {
    QStringList favs;
    for (int i = 0; i < m_sidebar->count(); ++i) {
        favs << m_sidebar->item(i)->data(Qt::UserRole).toString();
    }
    QSettings settings("RapidNotes", "FileSearchFavorites");
    settings.setValue("list", favs);
}

bool FileSearchWindow::eventFilter(QObject* watched, QEvent* event) {
    if (event->type() == QEvent::MouseButtonDblClick) {
        if (watched == m_pathInput) {
            auto* popup = new FileSearchHistoryPopup(this, m_pathInput, FileSearchHistoryPopup::Path);
            popup->showAnimated();
            return true;
        } else if (watched == m_searchInput) {
            auto* popup = new FileSearchHistoryPopup(this, m_searchInput, FileSearchHistoryPopup::Filename);
            popup->showAnimated();
            return true;
        }
    }
    return FramelessDialog::eventFilter(watched, event);
}

void FileSearchWindow::onCollectionItemClicked(QListWidgetItem* item) {
    // 默认点击可以实现定位文件或其他逻辑，这里目前保持选中即可
}

void FileSearchWindow::showCollectionContextMenu(const QPoint& pos) {
    auto selectedItems = m_collectionSidebar->selectedItems();
    if (selectedItems.isEmpty()) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #252526; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #37373D; }");
    
    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并选中内容", [this](){
        QStringList paths;
        for (auto* item : m_collectionSidebar->selectedItems()) {
            paths << item->data(Qt::UserRole).toString();
        }
        onMergeFiles(paths, "", true); // 使用 Combine 目录
    });

    menu.addAction(IconHelper::getIcon("close", "#E74C3C"), "取消收藏", [this](){
        for (auto* item : m_collectionSidebar->selectedItems()) {
            delete item;
        }
        saveCollection();
    });
    
    menu.exec(m_collectionSidebar->mapToGlobal(pos));
}

void FileSearchWindow::addCollectionItem(const QString& path) {
    // 检查是否已存在
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        if (m_collectionSidebar->item(i)->data(Qt::UserRole).toString() == path) return;
    }

    QFileInfo fi(path);
    auto* item = new QListWidgetItem(IconHelper::getIcon("file", "#2ECC71"), fi.fileName());
    item->setData(Qt::UserRole, path);
    item->setToolTip(path);
    m_collectionSidebar->addItem(item);
    saveCollection();
}

void FileSearchWindow::loadCollection() {
    QSettings settings("RapidNotes", "FileSearchCollection");
    QStringList coll = settings.value("list").toStringList();
    for (const QString& path : std::as_const(coll)) {
        if (QFile::exists(path)) {
            QFileInfo fi(path);
            auto* item = new QListWidgetItem(IconHelper::getIcon("file", "#2ECC71"), fi.fileName());
            item->setData(Qt::UserRole, path);
            item->setToolTip(path);
            m_collectionSidebar->addItem(item);
        }
    }
}

void FileSearchWindow::saveCollection() {
    QStringList coll;
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        coll << m_collectionSidebar->item(i)->data(Qt::UserRole).toString();
    }
    QSettings settings("RapidNotes", "FileSearchCollection");
    settings.setValue("list", coll);
}

void FileSearchWindow::onMergeCollectionFiles() {
    QStringList paths;
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        paths << m_collectionSidebar->item(i)->data(Qt::UserRole).toString();
    }
    if (paths.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#e74c3c;'>✖ 收藏夹为空</b>");
        return;
    }
    onMergeFiles(paths, "", true); // 使用 Combine 目录
}

#include "FileSearchWindow.moc"
```

## 文件: `src/ui/FileSearchWindow.h`

```cpp
#ifndef FILESEARCHWINDOW_H
#define FILESEARCHWINDOW_H

#include "FramelessDialog.h"
#include "ResizeHandle.h"
#include <QListWidget>
#include <QLineEdit>
#include <QPushButton>
#include <QCheckBox>
#include <QThread>
#include <QPair>
#include <QSplitter>
#include <atomic>

class FileSearchHistoryPopup;

/**
 * @brief 扫描线程：实现增量扫描与目录剪枝
 */
class ScannerThread : public QThread {
    Q_OBJECT
public:
    explicit ScannerThread(const QString& folderPath, QObject* parent = nullptr);
    void stop();

signals:
    void fileFound(const QString& name, const QString& path, bool isHidden);
    void finished(int count);

protected:
    void run() override;

private:
    QString m_folderPath;
    std::atomic<bool> m_isRunning{true};
};

/**
 * @brief 收藏侧边栏列表 (支持拖拽和多选)
 */
class FileCollectionListWidget : public QListWidget {
    Q_OBJECT
public:
    explicit FileCollectionListWidget(QWidget* parent = nullptr);
signals:
    void filesDropped(const QStringList& paths);
protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
};

/**
 * @brief 文件查找窗口：新增侧边栏收藏与路径历史记录
 */
class FileSearchWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit FileSearchWindow(QWidget* parent = nullptr);
    ~FileSearchWindow();

    // 历史记录操作接口 (供 Popup 调用)
    void addHistoryEntry(const QString& path);
    QStringList getHistory() const;
    void clearHistory();
    void removeHistoryEntry(const QString& path);
    void useHistoryPath(const QString& path);

    // 文件名搜索历史相关
    void addSearchHistoryEntry(const QString& text);
    QStringList getSearchHistory() const;
    void removeSearchHistoryEntry(const QString& text);
    void clearSearchHistory();

private slots:
    void selectFolder();
    void onPathReturnPressed();
    void startScan(const QString& path);
    void onFileFound(const QString& name, const QString& path, bool isHidden);
    void onScanFinished(int count);
    void refreshList();
    void showFileContextMenu(const QPoint& pos);
    void copySelectedFiles();
    void onEditFile();
    void onCutFile();
    void onDeleteFile();
    void onMergeSelectedFiles();
    void onMergeFolderContent();
    void onMergeCollectionFiles();
    
    // 侧边栏相关
    void onSidebarItemClicked(QListWidgetItem* item);
    void showSidebarContextMenu(const QPoint& pos);
    void addFavorite(const QString& path);

    // 收藏侧边栏 (右侧)
    void onCollectionItemClicked(QListWidgetItem* item);
    void showCollectionContextMenu(const QPoint& pos);
    void addCollectionItem(const QString& path);

protected:
    void resizeEvent(QResizeEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

private:
    void initUI();
    void setupStyles();
    void loadFavorites();
    void saveFavorites();
    void loadCollection();
    void saveCollection();
    void onMergeFiles(const QStringList& filePaths, const QString& rootPath, bool useCombineDir = false);
    void updateShortcuts();

    QListWidget* m_sidebar;
    FileCollectionListWidget* m_collectionSidebar;
    QAction* m_actionSelectAll = nullptr;
    QAction* m_actionCopy = nullptr;
    QAction* m_actionDelete = nullptr;
    QAction* m_actionScan = nullptr;
    QLineEdit* m_pathInput;
    QLineEdit* m_searchInput;
    QLineEdit* m_extInput;
    QLabel* m_infoLabel;
    QCheckBox* m_showHiddenCheck;
    QListWidget* m_fileList;
    
    ResizeHandle* m_resizeHandle;
    ScannerThread* m_scanThread = nullptr;
    FileSearchHistoryPopup* m_historyPopup = nullptr;
    
    struct FileData {
        QString name;
        QString path;
        bool isHidden;
    };
    QList<FileData> m_filesData;
    int m_visibleCount = 0;
    int m_hiddenCount = 0;
};

#endif // FILESEARCHWINDOW_H
```

## 文件: `src/ui/FileStorageWindow.cpp`

```cpp
#include "FileStorageWindow.h"
#include "IconHelper.h"
#include "../core/DatabaseManager.h"
#include <QDragEnterEvent>
#include <QDragLeaveEvent>
#include <QDropEvent>
#include <QMouseEvent>
#include <QMimeData>
#include <QFileInfo>
#include <QFile>
#include <QDir>
#include <utility>
#include <QApplication>
#include <QCoreApplication>
#include <QGraphicsDropShadowEffect>
#include <QHBoxLayout>
#include <QPushButton>
#include <QFrame>
#include <QFileDialog>
#include <QMenu>
#include <QToolTip>
#include <QDateTime>
#include <QDebug>

FileStorageWindow::FileStorageWindow(QWidget* parent) : FramelessDialog("存储文件", parent) {
    setObjectName("FileStorageWindow");
    loadWindowSettings();
    setAcceptDrops(true);
    resize(450, 430);

    initUI();
}

void FileStorageWindow::initUI() {
    auto* contentLayout = new QVBoxLayout(m_contentArea);
    contentLayout->setContentsMargins(20, 10, 20, 20);
    contentLayout->setSpacing(10);

    // Drop Area
    m_dropHint = new QPushButton("拖拽文件或文件夹到这里\n数据将完整拷贝至存储库");
    m_dropHint->setObjectName("DropArea");
    m_dropHint->setStyleSheet("QPushButton#DropArea { color: #888; font-size: 12px; border: 2px dashed #444; border-radius: 8px; padding: 20px; background: #181818; outline: none; } "
                               "QPushButton#DropArea:hover { border-color: #f1c40f; color: #f1c40f; background-color: rgba(241, 196, 15, 0.05); }");
    m_dropHint->setFixedHeight(100);
    connect(m_dropHint, &QPushButton::clicked, this, &FileStorageWindow::onSelectItems);
    contentLayout->addWidget(m_dropHint);

    // Status List
    m_statusList = new QListWidget();
    m_statusList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_statusList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_statusList->setStyleSheet("QListWidget { background-color: #252526; border: 1px solid #333; border-radius: 6px; color: #BBB; padding: 5px; font-size: 11px; } "
                                "QListWidget::item { padding: 4px; border-bottom: 1px solid #2d2d2d; }");
    contentLayout->addWidget(m_statusList);

    auto* tipLabel = new QLabel("文件将直接复制到 attachments 文件夹");
    tipLabel->setStyleSheet("color: #666; font-size: 10px;");
    tipLabel->setAlignment(Qt::AlignCenter);
    contentLayout->addWidget(tipLabel);
}

// ==========================================
// 1. 辅助工具函数
// ==========================================

QString FileStorageWindow::getStorageRoot() {
    QString path = QCoreApplication::applicationDirPath() + "/attachments";
    QDir dir(path);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    return path;
}

QString FileStorageWindow::getUniqueFilePath(const QString& dirPath, const QString& fileName) {
    QDir dir(dirPath);
    QString baseName = QFileInfo(fileName).completeBaseName();
    QString suffix = QFileInfo(fileName).suffix();
    if (!suffix.isEmpty()) suffix = "." + suffix;

    QString finalName = fileName;
    int counter = 1;

    while (dir.exists(finalName)) {
        finalName = QString("%1_%2%3").arg(baseName).arg(counter).arg(suffix);
        counter++;
    }
    return dir.filePath(finalName);
}

bool FileStorageWindow::copyRecursively(const QString& srcStr, const QString& dstStr) {
    QDir srcDir(srcStr);
    if (!srcDir.exists()) return false;

    QDir dstDir(dstStr);
    if (!dstDir.exists()) {
        dstDir.mkpath(".");
    }

    // 1. 复制所有文件
    for (const QString& file : srcDir.entryList(QDir::Files)) {
        QString srcFile = srcDir.filePath(file);
        QString dstFile = dstDir.filePath(file);
        if (!QFile::copy(srcFile, dstFile)) {
            return false;
        }
    }

    // 2. 递归复制子文件夹
    for (const QString& dir : srcDir.entryList(QDir::Dirs | QDir::NoDotAndDotDot)) {
        QString srcSub = srcDir.filePath(dir);
        QString dstSub = dstDir.filePath(dir);
        if (!copyRecursively(srcSub, dstSub)) {
            return false;
        }
    }
    return true;
}

// ==========================================
// 2. 核心存储逻辑
// ==========================================

void FileStorageWindow::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls()) {
        event->acceptProposedAction();
        m_dropHint->setStyleSheet("QPushButton#DropArea { color: #f1c40f; font-size: 12px; border: 2px dashed #f1c40f; border-radius: 8px; padding: 20px; background-color: rgba(241, 196, 15, 0.05); }");
    }
}

void FileStorageWindow::dragLeaveEvent(QDragLeaveEvent* event) {
    Q_UNUSED(event);
    m_dropHint->setStyleSheet("QPushButton#DropArea { color: #888; font-size: 12px; border: 2px dashed #444; border-radius: 8px; padding: 20px; background: #181818; outline: none; }");
}

void FileStorageWindow::dropEvent(QDropEvent* event) {
    const QMimeData* mimeData = event->mimeData();
    if (mimeData->hasUrls()) {
        QStringList paths;
        for (const QUrl& url : mimeData->urls()) {
            if (url.isLocalFile()) paths << url.toLocalFile();
        }
        
        if (!paths.isEmpty()) {
            processStorage(paths);
        }
    }
    m_dropHint->setStyleSheet("QPushButton#DropArea { color: #888; font-size: 12px; border: 2px dashed #444; border-radius: 8px; padding: 20px; background: #181818; outline: none; }");
}

void FileStorageWindow::processStorage(const QStringList& paths) {
    m_statusList->clear();
    if (paths.isEmpty()) return;

    if (paths.size() == 1) {
        QFileInfo info(paths.first());
        if (info.isDir()) {
            storeFolder(paths.first());
        } else {
            storeFile(paths.first());
        }
    } else {
        storeArchive(paths);
    }
}

void FileStorageWindow::storeFile(const QString& path) {
    QFileInfo info(path);
    QString storageDir = getStorageRoot();
    QString destPath = getUniqueFilePath(storageDir, info.fileName());
    
    if (QFile::copy(path, destPath)) {
        QFileInfo destInfo(destPath);
        QString relativePath = "attachments/" + destInfo.fileName();

        bool ok = DatabaseManager::instance().addNote(
            info.fileName(),
            relativePath,
            {"文件链接"},
            "#2c3e50",
            m_categoryId,
            "local_file",
            QByteArray(),
            "FileStorage",
            info.absoluteFilePath()
        );

        if (ok) {
            m_statusList->addItem("✅ 已归档: " + info.fileName());
        } else {
            m_statusList->addItem("❌ 数据库错误: " + info.fileName());
            QFile::remove(destPath);
        }
    } else {
        m_statusList->addItem("❌ 复制失败: 权限不足或文件被占用");
    }
}

void FileStorageWindow::storeFolder(const QString& path) {
    QFileInfo info(path);
    QString storageDir = getStorageRoot();
    QString destDir = getUniqueFilePath(storageDir, info.fileName());
    
    m_statusList->addItem("📂 正在导入文件夹: " + info.fileName() + "...");
    QApplication::processEvents();

    if (copyRecursively(path, destDir)) {
        QDir d(destDir);
        QString relativePath = "attachments/" + d.dirName();

        bool ok = DatabaseManager::instance().addNote(
            info.fileName(),
            relativePath,
            {"文件夹链接"},
            "#8e44ad",
            m_categoryId,
            "local_folder",
            QByteArray(),
            "FileStorage",
            info.absoluteFilePath()
        );

        if (ok) {
            m_statusList->addItem("✅ 文件夹归档成功");
        } else {
            m_statusList->addItem("❌ 数据库错误");
            QDir(destDir).removeRecursively();
        }
    } else {
        m_statusList->addItem("❌ 文件夹复制失败");
    }
}

void FileStorageWindow::storeArchive(const QStringList& paths) {
    QString timestamp = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
    QString folderName = "批量导入_" + timestamp;
    
    QString storageRoot = getStorageRoot();
    QString destDir = storageRoot + "/" + folderName;
    
    if (!QDir().mkpath(destDir)) {
        m_statusList->addItem("❌ 无法创建存储目录");
        return;
    }

    int successCount = 0;
    m_statusList->addItem("📦 正在处理 " + QString::number(paths.size()) + " 个项目...");
    QApplication::processEvents();

    for (const QString& srcPath : std::as_const(paths)) {
        QFileInfo srcInfo(srcPath);
        QString destPath = destDir + "/" + srcInfo.fileName();

        bool copyOk = false;
        if (srcInfo.isDir()) {
            copyOk = copyRecursively(srcPath, destPath);
        } else {
            copyOk = QFile::copy(srcPath, destPath);
        }

        if (copyOk) successCount++;
    }

    if (successCount > 0) {
        QString relativePath = "attachments/" + folderName;
        
        // 构建描述性标题：[数量个项目] 文件1, 文件2...
        QStringList names;
        for (const QString& p : paths) {
            names << QFileInfo(p).fileName();
        }
        QString descriptiveTitle = QString("[%1个项目] %2").arg(paths.size()).arg(names.join(", "));
        if (descriptiveTitle.length() > 120) {
            descriptiveTitle = descriptiveTitle.left(117) + "...";
        }

        bool ok = DatabaseManager::instance().addNote(
            descriptiveTitle,
            relativePath,
            {"批量导入"},
            "#34495e",
            m_categoryId,
            "local_batch",
            QByteArray(),
            "FileStorage",
            ""
        );

        if (ok) {
            m_statusList->addItem(QString("✅ 成功归档 %1/%2 个项目").arg(successCount).arg(paths.size()));
        } else {
            m_statusList->addItem("❌ 数据库写入失败");
        }
    } else {
        m_statusList->addItem("❌ 所有项目导入失败");
        QDir(destDir).removeRecursively();
    }
}


void FileStorageWindow::onSelectItems() {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       "QMenu::item { padding: 6px 20px; border-radius: 3px; } "
                       "QMenu::item:selected { background-color: #f1c40f; color: #1a1a1a; }");

    menu.addAction("选择并存入文件...", [this]() {
        QStringList files = QFileDialog::getOpenFileNames(this, "选择文件", "", "所有文件 (*.*)");
        if (!files.isEmpty()) {
            processStorage(files);
        }
    });

    menu.addAction("选择并存入文件夹...", [this]() {
        QString dir = QFileDialog::getExistingDirectory(this, "选择文件夹", "");
        if (!dir.isEmpty()) {
            processStorage({dir});
        }
    });

    menu.exec(QCursor::pos());
}
```

## 文件: `src/ui/FileStorageWindow.h`

```cpp
#ifndef FILESTORAGEWINDOW_H
#define FILESTORAGEWINDOW_H

#include "FramelessDialog.h"
#include <QLabel>
#include <QListWidget>
#include <QVBoxLayout>
#include <QPoint>

class QDragEnterEvent;
class QDragLeaveEvent;
class QDropEvent;
class QMouseEvent;
class QPushButton;

class FileStorageWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit FileStorageWindow(QWidget* parent = nullptr);
    void setCurrentCategory(int catId) { m_categoryId = catId; }

protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragLeaveEvent(QDragLeaveEvent* event) override;
    void dropEvent(QDropEvent* event) override;

private slots:
    void onSelectItems();

private:
    void initUI();
    void processStorage(const QStringList& paths);
    void storeFile(const QString& path);
    void storeFolder(const QString& path);
    void storeArchive(const QStringList& paths);

    QString getStorageRoot(); // 获取存储根目录
    QString getUniqueFilePath(const QString& dirPath, const QString& fileName); // 获取不重复的文件名
    bool copyRecursively(const QString& srcStr, const QString& dstStr); // 递归复制文件夹

    QPushButton* m_dropHint;
    QListWidget* m_statusList;
    QPoint m_dragPos;
    int m_categoryId = -1;
};

#endif // FILESTORAGEWINDOW_H
```

## 文件: `src/ui/FilterPanel.cpp`

```cpp
#include "FilterPanel.h"
#include "../core/DatabaseManager.h"
#include "IconHelper.h"
#include <QHBoxLayout>
#include <QHeaderView>
#include <QPainter>
#include <QApplication>
#include <QTimer>

FilterPanel::FilterPanel(QWidget* parent) : QWidget(parent) {
    setAttribute(Qt::WA_StyledBackground, true);
    setMouseTracking(true);
    setMinimumSize(230, 350);
    initUI();
    setupTree();
}

void FilterPanel::initUI() {
    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    // 内容容器
    auto* contentWidget = new QWidget();
    contentWidget->setStyleSheet(
        "QWidget { "
        "  background-color: transparent; "
        "  border: none; "
        "  border-bottom-left-radius: 0px; "
        "  border-bottom-right-radius: 0px; "
        "}"
    );
    auto* contentLayout = new QVBoxLayout(contentWidget);
    contentLayout->setContentsMargins(10, 8, 10, 10);
    contentLayout->setSpacing(8);

    // 树形筛选器
    m_tree = new QTreeWidget();
    m_tree->setHeaderHidden(true);
    m_tree->setIndentation(0);
    m_tree->setFocusPolicy(Qt::NoFocus);
    m_tree->setRootIsDecorated(false);
    m_tree->setUniformRowHeights(true);
    m_tree->setAnimated(true);
    m_tree->setAllColumnsShowFocus(true);
    m_tree->setStyleSheet(
        "QTreeWidget {"
        "  background-color: transparent;"
        "  color: #ddd;"
        "  border: none;"
        "  font-size: 12px;"
        "}"
        "QTreeWidget::branch { image: none; border: none; width: 0px; }"
        "QTreeWidget::item {"
        "  height: 28px;"
        "  border-radius: 4px;"
        "  margin-left: 10px;"
        "  margin-right: 10px;"
        "  padding-left: 2px;"
        "}"
        "QTreeWidget::item:hover { background-color: #2a2d2e; }"
        "QTreeWidget::item:selected { background-color: #37373d; color: white; }"
        "QTreeWidget::indicator {"
        "  width: 14px;"
        "  height: 14px;"
        "  margin-left: 20px;"
        "}"
        "QScrollBar:vertical { border: none; background: transparent; width: 6px; margin: 0px; }"
        "QScrollBar::handle:vertical { background: #444; border-radius: 3px; min-height: 20px; }"
        "QScrollBar::handle:vertical:hover { background: #555; }"
        "QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }"
        "QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { background: none; }"
    );
    connect(m_tree, &QTreeWidget::itemChanged, this, &FilterPanel::onItemChanged);
    connect(m_tree, &QTreeWidget::itemClicked, this, &FilterPanel::onItemClicked);
    m_tree->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    contentLayout->addWidget(m_tree);

    // 底部区域
    auto* bottomLayout = new QHBoxLayout();
    bottomLayout->setContentsMargins(0, 0, 0, 0);
    bottomLayout->setSpacing(4);

    m_btnReset = new QPushButton(" 重置");
    m_btnReset->setIcon(IconHelper::getIcon("refresh", "white"));
    m_btnReset->setCursor(Qt::PointingHandCursor);
    m_btnReset->setFixedWidth(80);
    m_btnReset->setStyleSheet(
        "QPushButton {"
        "  background-color: #252526;"
        "  border: 1px solid #444;"
        "  color: #888;"
        "  border-radius: 6px;"
        "  padding: 8px;"
        "  font-size: 12px;"
        "}"
        "QPushButton:hover { color: #ddd; background-color: #333; }"
    );
    connect(m_btnReset, &QPushButton::clicked, this, &FilterPanel::resetFilters);
    bottomLayout->addWidget(m_btnReset);
    bottomLayout->addStretch();

    contentLayout->addLayout(bottomLayout);
    mainLayout->addWidget(contentWidget);
}

void FilterPanel::setupTree() {
    struct Section {
        QString key;
        QString label;
        QString icon;
        QString color;
    };

    QList<Section> sections = {
        {"date_create", "创建时间", "today", "#2ecc71"},
        {"stars", "评级", "star_filled", "#f39c12"},
        {"colors", "颜色", "palette", "#e91e63"},
        {"types", "类型", "folder", "#3498db"},
        {"tags", "标签", "tag", "#e67e22"}
    };

    QFont headerFont = m_tree->font();
    headerFont.setBold(true);

    for (const auto& sec : sections) {
        auto* item = new QTreeWidgetItem(m_tree);
        item->setText(0, sec.label);
        item->setIcon(0, IconHelper::getIcon(sec.icon, sec.color));
        item->setExpanded(true);
        item->setFlags(Qt::ItemIsEnabled);
        item->setFont(0, headerFont);
        item->setForeground(0, QBrush(Qt::gray));
        m_roots[sec.key] = item;
    }

    addFixedDateOptions("date_create");
}

void FilterPanel::addFixedDateOptions(const QString& key) {
    if (!m_roots.contains(key)) return;
    auto* root = m_roots[key];

    struct Option {
        QString id;
        QString label;
        QString icon;
    };

    QList<Option> options = {
        {"today", "今日", "today"},
        {"yesterday", "昨日", "clock"},
        {"week", "本周", "today"},
        {"month", "本月", "today"}
    };

    m_blockItemClick = true;
    for (const auto& opt : options) {
        auto* item = new QTreeWidgetItem(root);
        item->setText(0, QString("%1 (0)").arg(opt.label));
        item->setData(0, Qt::UserRole, opt.id);
        item->setFlags(Qt::ItemIsUserCheckable | Qt::ItemIsEnabled | Qt::ItemIsSelectable);
        item->setCheckState(0, Qt::Unchecked);
    }
    m_blockItemClick = false;
}

void FilterPanel::updateStats(const QString& keyword, const QString& type, const QVariant& value) {
    m_tree->blockSignals(true);
    m_blockItemClick = true;

    QVariantMap stats = DatabaseManager::instance().getFilterStats(keyword, type, value);

    // 1. 评级
    QList<QVariantMap> starData;
    QVariantMap starStats = stats["stars"].toMap();
    for (int i = 5; i >= 1; --i) {
        int count = starStats[QString::number(i)].toInt();
        if (count > 0) {
            QVariantMap item;
            item["key"] = QString::number(i);
            item["label"] = QString(i, QChar(0x2605)); // ★
            item["count"] = count;
            starData.append(item);
        }
    }
    if (starStats["0"].toInt() > 0) {
        QVariantMap item;
        item["key"] = "0";
        item["label"] = "无评级";
        item["count"] = starStats["0"].toInt();
        starData.append(item);
    }
    refreshNode("stars", starData);

    // 2. 颜色
    QList<QVariantMap> colorData;
    QVariantMap colorStats = stats["colors"].toMap();
    for (auto it = colorStats.begin(); it != colorStats.end(); ++it) {
        int count = it.value().toInt();
        if (count > 0) {
            QVariantMap item;
            item["key"] = it.key();
            item["label"] = it.key();
            item["count"] = count;
            colorData.append(item);
        }
    }
    refreshNode("colors", colorData, true);

    // 3. 类型
    QMap<QString, QString> typeMap = {{"text", "文本"}, {"image", "图片"}, {"file", "文件"}};
    QList<QVariantMap> typeData;
    QVariantMap typeStats = stats["types"].toMap();
    for (auto it = typeStats.begin(); it != typeStats.end(); ++it) {
        int count = it.value().toInt();
        if (count > 0) {
            QVariantMap item;
            item["key"] = it.key();
            item["label"] = typeMap.value(it.key(), it.key());
            item["count"] = count;
            typeData.append(item);
        }
    }
    refreshNode("types", typeData);

    // 4. 标签
    QList<QVariantMap> tagData;
    QVariantMap tagStats = stats["tags"].toMap();
    for (auto it = tagStats.begin(); it != tagStats.end(); ++it) {
        QVariantMap item;
        item["key"] = it.key();
        item["label"] = it.key();
        item["count"] = it.value().toInt();
        tagData.append(item);
    }
    refreshNode("tags", tagData);

    // 5. 固定日期节点
    updateFixedNode("date_create", stats["date_create"].toMap());

    m_blockItemClick = false;
    m_tree->blockSignals(false);
}

void FilterPanel::refreshNode(const QString& key, const QList<QVariantMap>& items, bool isCol) {
    if (!m_roots.contains(key)) return;
    auto* root = m_roots[key];

    // 建立现有的 key -> item 映射
    QMap<QString, QTreeWidgetItem*> existingItems;
    for (int i = 0; i < root->childCount(); ++i) {
        auto* child = root->child(i);
        existingItems[child->data(0, Qt::UserRole).toString()] = child;
    }

    QSet<QString> currentKeys;
    for (const auto& data : items) {
        QString itemKey = data["key"].toString();
        QString label = data["label"].toString();
        int count = data["count"].toInt();
        currentKeys.insert(itemKey);

        QString newText = QString("%1 (%2)").arg(label).arg(count);
        if (existingItems.contains(itemKey)) {
            auto* child = existingItems[itemKey];
            if (child->text(0) != newText) {
                child->setText(0, newText);
            }
        } else {
            auto* child = new QTreeWidgetItem(root);
            child->setText(0, newText);
            child->setData(0, Qt::UserRole, itemKey);
            child->setFlags(Qt::ItemIsUserCheckable | Qt::ItemIsEnabled | Qt::ItemIsSelectable);
            child->setCheckState(0, Qt::Unchecked);
            
            if (isCol) {
                child->setIcon(0, IconHelper::getIcon("circle_filled", itemKey)); // 颜色项仍保留颜色圆点
            }
        }
    }

    // 移除不再需要的项目
    for (int i = root->childCount() - 1; i >= 0; --i) {
        auto* child = root->child(i);
        if (!currentKeys.contains(child->data(0, Qt::UserRole).toString())) {
            delete root->takeChild(i);
        }
    }
}

void FilterPanel::updateFixedNode(const QString& key, const QVariantMap& stats) {
    if (!m_roots.contains(key)) return;
    auto* root = m_roots[key];
    QMap<QString, QString> labels = {{"today", "今日"}, {"yesterday", "昨日"}, {"week", "本周"}, {"month", "本月"}};
    
    for (int i = 0; i < root->childCount(); ++i) {
        auto* child = root->child(i);
        QString val = child->data(0, Qt::UserRole).toString();
        int count = stats.value(val).toInt();
        QString baseLabel = labels.value(val, val);
        QString newText = QString("%1 (%2)").arg(baseLabel).arg(count);
        if (child->text(0) != newText) {
            child->setText(0, newText);
        }
    }
}

QVariantMap FilterPanel::getCheckedCriteria() const {
    QVariantMap criteria;
    for (auto it = m_roots.begin(); it != m_roots.end(); ++it) {
        QStringList checked;
        for (int i = 0; i < it.value()->childCount(); ++i) {
            auto* item = it.value()->child(i);
            if (item->checkState(0) == Qt::Checked) {
                checked << item->data(0, Qt::UserRole).toString();
            }
        }
        if (!checked.isEmpty()) {
            criteria[it.key()] = checked;
        }
    }
    return criteria;
}

void FilterPanel::resetFilters() {
    m_tree->blockSignals(true);
    for (auto* root : m_roots) {
        for (int i = 0; i < root->childCount(); ++i) {
            root->child(i)->setCheckState(0, Qt::Unchecked);
        }
    }
    m_tree->blockSignals(false);
    emit filterChanged();
}

void FilterPanel::onItemChanged(QTreeWidgetItem* item, int column) {
    if (m_blockItemClick) return;
    
    // 记录最近改变的项，用于防止 onItemClicked 重复处理
    m_lastChangedItem = item;
    QTimer::singleShot(100, [this]() { m_lastChangedItem = nullptr; });
    
    emit filterChanged();
}

void FilterPanel::onItemClicked(QTreeWidgetItem* item, int column) {
    if (!item) return;

    // 如果该项刚刚由 Qt 原生机制改变了状态（点击了复选框），则忽略此次点击事件
    if (m_lastChangedItem == item) return;

    if (item->parent() == nullptr) {
        item->setExpanded(!item->isExpanded());
    } else if (item->flags() & Qt::ItemIsUserCheckable) {
        m_blockItemClick = true;
        Qt::CheckState state = item->checkState(0);
        item->setCheckState(0, (state == Qt::Checked) ? Qt::Unchecked : Qt::Checked);
        m_blockItemClick = false;
        emit filterChanged();
    }
}
```

## 文件: `src/ui/FilterPanel.h`

```cpp
#ifndef FILTERPANEL_H
#define FILTERPANEL_H

#include <QWidget>
#include <QVariantMap>
#include <QVBoxLayout>
#include <QTreeWidget>
#include <QTreeWidgetItem>
#include <QPushButton>
#include <QLabel>
#include <QMouseEvent>
#include <QGraphicsDropShadowEffect>

class FilterPanel : public QWidget {
    Q_OBJECT
public:
    explicit FilterPanel(QWidget* parent = nullptr);
    void updateStats(const QString& keyword, const QString& type, const QVariant& value);
    QVariantMap getCheckedCriteria() const;
    void resetFilters();

signals:
    void filterChanged();

private:
    void initUI();
    void setupTree();
    void addFixedDateOptions(const QString& key);
    void onItemChanged(QTreeWidgetItem* item, int column);
    void onItemClicked(QTreeWidgetItem* item, int column);
    void refreshNode(const QString& key, const QList<QVariantMap>& items, bool isCol = false);
    void updateFixedNode(const QString& key, const QVariantMap& stats);

    QWidget* m_container;
    QTreeWidget* m_tree;
    QPushButton* m_btnReset;

    QMap<QString, QTreeWidgetItem*> m_roots;
    bool m_blockItemClick = false;
    QTreeWidgetItem* m_lastChangedItem = nullptr;
};

#endif // FILTERPANEL_H
```

## 文件: `src/ui/FireworksOverlay.cpp`

```cpp
#include "FireworksOverlay.h"
#include <QPainter>
#include <QGuiApplication>
#include <QScreen>
#include <QRandomGenerator>
#include <cmath>
#include <QDebug>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Helper to get random double in range [min, max)
static double randomDouble(double min, double max) {
    return min + QRandomGenerator::global()->generateDouble() * (max - min);
}

Particle::Particle() : gravity(0), drag(0.92), size(2.0), decay(4.0), alpha(255.0), age(0), 
    index(0), total(1), rotation(0), spin(0), widthFactor(1.0), phase(0), amp(0) {}

bool Particle::update() {
    if (style == "butterfly") {
        pos += vel;
        vel.setY(vel.y() + gravity);
        vel *= drag;
        pos.setX(pos.x() + std::sin(age * 0.2 + phase) * 0.8);
        alpha -= decay;
        age++;
    } else if (style == "dna") {
        pos.setY(pos.y() + vel.y());
        age++;
        double offset = std::sin((pos.y() * 0.05) + phase) * amp;
        pos.setX(initialPos.x() + offset);
        alpha = (offset > 0) ? 255.0 : 100.0;
        if (age > 60) alpha = 0;
    } else if (style == "lightning") {
        alpha -= decay;
    } else if (style == "confetti") {
        pos += vel;
        vel.setY(vel.y() + gravity);
        vel *= drag;
        rotation += spin;
        widthFactor = std::abs(std::cos(rotation));
        alpha -= 2.0;
    } else if (style == "void") {
        if (mode == "suck") {
            pos += vel;
            double dist = std::sqrt(std::pow(pos.x() - initialPos.x(), 2) + std::pow(pos.y() - initialPos.y(), 2));
            if (dist < 5) {
                mode = "boom";
                double angle = randomDouble(0, M_PI * 2);
                double speed = randomDouble(2.0, 8.0);
                vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
                color = Qt::white;
            }
        } else {
            pos += vel;
            alpha -= 5.0;
        }
    } else if (style == "phoenix") {
        pos += vel;
        vel.setY(vel.y() + gravity);
        vel *= drag;
        if (age > 10 && color.green() > 5) {
            color.setGreen(color.green() - 5);
        }
        alpha -= decay;
        age++;
    } else {
        pos += vel;
        vel.setY(vel.y() + gravity);
        vel *= drag;
        alpha -= decay;
    }
    return alpha > 0;
}

FireworksOverlay* FireworksOverlay::m_instance = nullptr;

FireworksOverlay::FireworksOverlay(QWidget* parent) : QWidget(parent) {
    setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool | Qt::WindowTransparentForInput);
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_ShowWithoutActivating);
    
    m_timer = new QTimer(this);
    connect(m_timer, &QTimer::timeout, this, &FireworksOverlay::animate);
    
    // Resize to cover all screens
    QRect totalRect;
    for (QScreen* screen : QGuiApplication::screens()) {
        totalRect = totalRect.united(screen->geometry());
    }
    setGeometry(totalRect);
}

FireworksOverlay* FireworksOverlay::instance() {
    if (!m_instance) {
        m_instance = new FireworksOverlay();
    }
    return m_instance;
}

void FireworksOverlay::explode(const QPoint& pos) {
    // Ensure we cover the current screen configuration
    QRect totalRect;
    for (QScreen* screen : QGuiApplication::screens()) {
        totalRect = totalRect.united(screen->geometry());
    }
    if (geometry() != totalRect) {
        setGeometry(totalRect);
    }
    
    show();
    QPoint lp = mapFromGlobal(pos);

    QStringList styles = {"neon", "gold", "butterfly", "quantum", "heart", "galaxy", "frozen", "phoenix", 
                          "matrix", "dna", "lightning", "void", "confetti", "chaos"};
    QString style = styles.at(QRandomGenerator::global()->bounded(styles.size()));

    int count = 40;
    if (style == "matrix") count = 15;
    else if (style == "dna" || style == "lightning" || style == "butterfly") count = 30;
    else if (style == "heart" || style == "galaxy") count = 60;

    for (int i = 0; i < count; ++i) {
        Particle p;
        initParticle(p, lp, style, i, count);
        m_particles.append(p);
    }

    if (!m_timer->isActive()) {
        m_timer->start(16);
    }
}

void FireworksOverlay::initParticle(Particle& p, const QPoint& pos, const QString& style, int index, int total) {
    p.pos = pos;
    p.initialPos = pos;
    p.style = style;
    p.index = index;
    p.total = total;
    
    if (style == "butterfly") {
        double angle = randomDouble(0, M_PI * 2);
        double speed = randomDouble(1.0, 3.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = 0.01;
        p.drag = 0.96;
        p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(360), 220, 255);
        p.size = randomDouble(3.0, 5.0);
        p.decay = 2.0;
        p.phase = randomDouble(0, M_PI);
    } else if (style == "matrix") {
        static QString chars = "01COPYX";
        p.character = chars.at(QRandomGenerator::global()->bounded(chars.length()));
        p.vel = QPointF(0, randomDouble(3.0, 6.0));
        p.color = QColor(0, 255, 70);
        p.size = QRandomGenerator::global()->bounded(8, 12);
        p.decay = 5.0;
    } else if (style == "dna") {
        p.vel = QPointF(0, -randomDouble(1.0, 3.0));
        p.phase = (double(index) / total) * 4 * M_PI;
        p.amp = randomDouble(10.0, 15.0);
        p.decay = 3.0;
        p.color = (index % 2 == 0) ? QColor(0, 200, 255) : QColor(255, 0, 150);
    } else if (style == "lightning") {
        double angle = randomDouble(0, M_PI * 2);
        double dist = randomDouble(20.0, 60.0);
        QPointF target(pos.x() + std::cos(angle) * dist, pos.y() + std::sin(angle) * dist);
        int steps = 4;
        for (int i = 0; i < steps; ++i) {
            double t = double(i + 1) / steps;
            QPointF next(pos.x() + (target.x() - pos.x()) * t + randomDouble(-10.0, 10.0),
                         pos.y() + (target.y() - pos.y()) * t + randomDouble(-10.0, 10.0));
            p.lightningPoints.append(next);
        }
        p.color = QColor(220, 220, 255);
        p.decay = 20.0;
    } else if (style == "confetti") {
        double angle = randomDouble(0, M_PI * 2);
        double speed = randomDouble(2.0, 6.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = 0.2;
        p.drag = 0.92;
        p.spin = randomDouble(-0.2, 0.2);
        p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(360), 200, 255);
        p.size = randomDouble(4.0, 7.0);
    } else if (style == "void") {
        double angle = randomDouble(0, M_PI * 2);
        double dist = randomDouble(40.0, 80.0);
        p.pos = QPointF(pos.x() + std::cos(angle) * dist, pos.y() + std::sin(angle) * dist);
        p.vel = (QPointF(pos) - p.pos) * 0.15;
        p.color = QColor(150, 0, 255);
        p.mode = "suck";
        p.decay = 0;
    } else if (style == "heart") {
        double t = (double(index) / total) * 2 * M_PI;
        double scale = randomDouble(1.0, 1.8);
        p.vel = QPointF((16 * std::pow(std::sin(t), 3)) * 0.1 * scale,
                        -(13 * std::cos(t) - 5 * std::cos(2*t) - 2 * std::cos(3*t) - std::cos(4*t)) * 0.1 * scale);
        p.gravity = 0.02;
        p.color = QColor(255, 80, 150);
        p.decay = 3.0;
    } else if (style == "galaxy") {
        int arm = index % 3;
        double angle = (arm * 2.09) + (double(index) / total) + randomDouble(-0.2, 0.2);
        double speed = randomDouble(1.0, 3.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(200, 301), 220, 255);
        p.decay = 4.0;
    } else if (style == "frozen") {
        double angle = randomDouble(0, M_PI * 2);
        double speed = randomDouble(5.0, 12.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = 0.05;
        p.drag = 0.80;
        p.color = QColor(200, 255, 255);
        p.decay = 5.0;
    } else if (style == "phoenix") {
        double angle = randomDouble(M_PI + 0.5, 2 * M_PI - 0.5);
        double speed = randomDouble(1.0, 4.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = -0.1;
        p.color = QColor(255, int(randomDouble(150, 256)), 50);
        p.decay = 4.0;
    } else if (style == "chaos") {
        p.vel = QPointF(randomDouble(-2.0, 2.0), randomDouble(-2.0, 2.0));
        p.drag = 0.98;
        p.color = QColor(255, 50, 50);
        p.decay = 6.0;
    } else {
        double angle = randomDouble(0, M_PI * 2);
        double speed = randomDouble(1.0, 5.0);
        p.vel = QPointF(std::cos(angle) * speed, std::sin(angle) * speed);
        p.gravity = 0.15;
        if (style == "gold") {
            p.color = QColor(255, 235, 100);
            p.gravity = 0.25;
        } else {
            p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(360), 220, 255);
        }
        if (style == "quantum") {
            p.decay = 5.0;
        }
    }
}

void FireworksOverlay::animate() {
    if (m_particles.isEmpty()) {
        m_timer->stop();
        hide();
        return;
    }
    
    for (int i = m_particles.size() - 1; i >= 0; --i) {
        if (!m_particles[i].update()) {
            m_particles.removeAt(i);
        }
    }
    update();
}

void FireworksOverlay::paintEvent(QPaintEvent* event) {
    if (m_particles.isEmpty()) return;
    
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);
    painter.setCompositionMode(QPainter::CompositionMode_Plus);
    
    for (const Particle& pt : m_particles) {
        int alphaVal = int(pt.alpha);
        // Shimmer logic
        if (pt.style != "matrix") {
            double flicker = randomDouble(0.6, 1.0);
            alphaVal = int(pt.alpha * flicker);
        }
        
        QColor c = pt.color;
        c.setAlpha(std::max(0, std::min(255, alphaVal)));
        painter.setPen(Qt::NoPen);
        painter.setBrush(c);
        
        if (pt.style == "butterfly") {
            double flap = std::abs(std::sin(pt.age * 0.3 + pt.phase));
            painter.save();
            painter.translate(pt.pos);
            double angle = std::atan2(pt.vel.y(), pt.vel.x());
            painter.rotate(angle * 180.0 / M_PI + 90);
            double w = pt.size * flap;
            double h = pt.size;
            painter.drawEllipse(QPointF(-w, 0), w, h);
            painter.drawEllipse(QPointF(w, 0), w, h);
            painter.restore();
        } else if (pt.style == "matrix") {
            painter.setPen(c);
            QFont f("Consolas", int(pt.size));
            f.setBold(true);
            painter.setFont(f);
            painter.drawText(pt.pos, QString(pt.character));
        } else if (pt.style == "lightning") {
            painter.setPen(QPen(c, 1.5));
            QPainterPath path;
            path.moveTo(pt.initialPos);
            for (const QPointF& pnt : pt.lightningPoints) {
                path.lineTo(pnt);
            }
            painter.drawPath(path);
        } else if (pt.style == "confetti") {
            painter.save();
            painter.translate(pt.pos);
            painter.rotate(pt.rotation * 180.0 / M_PI);
            double w = 6 * pt.widthFactor;
            double h = 10;
            painter.drawRect(QRectF(-w / 2, -h / 2, w, h));
            painter.restore();
        } else if (pt.style == "quantum") {
            double s = pt.size * (pt.alpha / 255.0);
            painter.drawRect(QRectF(pt.pos.x() - s / 2, pt.pos.y() - s / 2, s, s));
        } else if (pt.style == "gold") {
            painter.setPen(QPen(c, pt.size));
            painter.drawLine(pt.pos, pt.pos - pt.vel);
        } else {
            painter.drawEllipse(pt.pos, pt.size, pt.size);
        }
    }
}
```

## 文件: `src/ui/FireworksOverlay.h`

```cpp
#ifndef FIREWORKSOVERLAY_H
#define FIREWORKSOVERLAY_H

#include <QWidget>
#include <QTimer>
#include <QColor>
#include <QList>
#include <QPointF>
#include <QPainterPath>

struct Particle {
    QPointF pos;
    QPointF initialPos;
    QPointF vel;
    double gravity;
    double drag;
    double size;
    double decay;
    QColor color;
    double alpha;
    int age;
    QString style;
    int index;
    int total;
    double rotation;
    double spin;
    QChar character;
    double widthFactor;
    double phase;
    double amp;
    QList<QPointF> lightningPoints;
    QString mode; // for 'void' style

    Particle();
    bool update();
};

class FireworksOverlay : public QWidget {
    Q_OBJECT
public:
    explicit FireworksOverlay(QWidget* parent = nullptr);
    static FireworksOverlay* instance();
    
    void explode(const QPoint& pos);

protected:
    void paintEvent(QPaintEvent* event) override;

private slots:
    void animate();

private:
    void initParticle(Particle& p, const QPoint& pos, const QString& style, int index, int total);
    
    QList<Particle> m_particles;
    QTimer* m_timer;
    static FireworksOverlay* m_instance;
};

#endif // FIREWORKSOVERLAY_H
```

## 文件: `src/ui/FloatingBall.cpp`

```cpp
#include "FloatingBall.h"
#include "../core/DatabaseManager.h"
#include "IconHelper.h"
#include <QGuiApplication>
#include <QScreen>
#include <QPainterPath>
#include <QtMath>
#include <QRandomGenerator>
#include <QMouseEvent>
#include <QContextMenuEvent>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QSettings>
#include <QApplication>
#include <utility>

FloatingBall::FloatingBall(QWidget* parent) 
    : QWidget(parent, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool | Qt::X11BypassWindowManagerHint) 
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAcceptDrops(true);
    setFixedSize(120, 120); // 1:1 复刻 Python 版尺寸
    
    m_timer = new QTimer(this);
    connect(m_timer, &QTimer::timeout, this, &FloatingBall::updatePhysics);
    m_timer->start(16);

    restorePosition();
    
    QSettings settings("RapidNotes", "FloatingBall");
    QString savedSkin = settings.value("skin", "mocha").toString();
    switchSkin(savedSkin);
}

void FloatingBall::paintEvent(QPaintEvent* event) {
    Q_UNUSED(event);
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);

    float cx = width() / 2.0f;
    float cy = height() / 2.0f;

    // 1. 绘制柔和投影 (根据皮肤形状动态适配，带羽化效果)
    painter.save();
    float s = 1.0f - (m_bookY / 25.0f); // 随高度缩放
    float shadowOpacity = 40 * s;
    
    if (m_skinName == "open") {
        // 摊开手稿皮肤：较宽的柔和投影
        float sw = 84, sh = 20;
        QRadialGradient grad(cx, cy + 35, sw/2);
        grad.setColorAt(0, QColor(0, 0, 0, shadowOpacity));
        grad.setColorAt(0.8, QColor(0, 0, 0, shadowOpacity * 0.3));
        grad.setColorAt(1, Qt::transparent);
        painter.setBrush(grad);
        painter.setPen(Qt::NoPen);
        painter.drawEllipse(QRectF(cx - (sw/2)*s, cy + 30, sw*s, sh*s));
    } else {
        // 笔记本皮肤：窄长且极度羽化的投影
        float sw = 48, sh = 12;
        QRadialGradient grad(cx, cy + 42, sw/2);
        grad.setColorAt(0, QColor(0, 0, 0, shadowOpacity));
        grad.setColorAt(0.7, QColor(0, 0, 0, shadowOpacity * 0.4));
        grad.setColorAt(1, Qt::transparent);
        painter.setBrush(grad);
        painter.setPen(Qt::NoPen);
        // 严格限制宽度在本体(56px)以内，杜绝边缘露头
        painter.drawEllipse(QRectF(cx - (sw/2)*s, cy + 38, sw*s, sh*s));
    }
    painter.restore();

    // 2. 绘制粒子
    for (const auto& p : m_particles) {
        QColor c = p.color;
        c.setAlphaF(p.life);
        painter.setBrush(c);
        painter.setPen(Qt::NoPen);
        painter.drawEllipse(p.pos, p.size, p.size);
    }

    // 3. 绘制笔记本
    painter.save();
    painter.translate(cx, cy + m_bookY);
    renderBook(&painter, m_skinName, 0); // 在 paintEvent 中只有 y 偏移是 translate 处理的，book 内部绘制居中
    painter.restore();

    // 4. 绘制钢笔
    painter.save();
    // paintEvent 中 pen 的位置偏移已经在 translate 中处理了
    // 但是原始代码是 translate(cx + m_penX, cy + m_penY - 5);
    // renderPen 需要 relative 坐标吗？
    // 让我们保持 renderPen 只负责画笔本身，坐标变换在外部做。
    painter.translate(cx + m_penX, cy + m_penY - 5);
    painter.rotate(m_penAngle);
    renderPen(&painter, m_skinName, 0, 0, 0); // 坐标和旋转已在外部 Transform 中完成
    painter.restore();
}

void FloatingBall::renderBook(QPainter* p, const QString& skinName, float /*bookY*/) {
    // bookY 参数在此场景下其实不需要，因为 painter 已经 translate 了
    // 为了保持静态函数的通用性，我们保留接口
    
    p->setPen(Qt::NoPen);
    if (skinName == "open") {
        float w = 80, h = 50;
        p->rotate(-5);
        QPainterPath path;
        path.moveTo(-w/2, -h/2); path.lineTo(0, -h/2 + 4);
        path.lineTo(w/2, -h/2); path.lineTo(w/2, h/2);
        path.lineTo(0, h/2 + 4); path.lineTo(-w/2, h/2); path.closeSubpath();
        p->setBrush(QColor("#f8f8f5"));
        p->drawPath(path);
        // 中缝阴影
        QLinearGradient grad(-10, 0, 10, 0);
        grad.setColorAt(0, QColor(0,0,0,0)); grad.setColorAt(0.5, QColor(0,0,0,20)); grad.setColorAt(1, QColor(0,0,0,0));
        p->setBrush(grad);
        p->drawRect(QRectF(-5, -h/2+4, 10, h-4));
        // 横线
        p->setPen(QPen(QColor(200, 200, 200), 1));
        for (int y = (int)(-h/2)+15; y < (int)(h/2); y += 7) {
            p->drawLine(int(-w/2+5), y, -5, y+2);
            p->drawLine(5, y+2, int(w/2-5), y);
        }
    } else {
        float w = 56, h = 76;
        if (skinName == "classic") {
            p->setBrush(QColor("#ebebe6"));
            p->drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 3, 3);
            QLinearGradient grad(-w, -h, w, h);
            grad.setColorAt(0, QColor("#3c3c41")); grad.setColorAt(1, QColor("#141419"));
            p->setBrush(grad);
            p->drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3);
            p->setBrush(QColor(10, 10, 10, 200));
            p->drawRect(QRectF(w/2 - 12, -h/2, 6, h));
        } else if (skinName == "royal") {
            p->setBrush(QColor("#f0f0eb"));
            p->drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 2, 2);
            QLinearGradient grad(-w, -h, w, 0);
            grad.setColorAt(0, QColor("#282864")); grad.setColorAt(1, QColor("#0a0a32"));
            p->setBrush(grad);
            p->drawRoundedRect(QRectF(-w/2, -h/2, w, h), 2, 2);
            p->setBrush(QColor(218, 165, 32));
            float c_size = 12;
            QPolygonF poly; poly << QPointF(w/2, -h/2) << QPointF(w/2-c_size, -h/2) << QPointF(w/2, -h/2+c_size);
            p->drawPolygon(poly);
        } else if (skinName == "matcha") {
            p->setBrush(QColor("#fafaf5"));
            p->drawRoundedRect(QRectF(-w/2+5, -h/2+5, w, h), 3, 3);
            QLinearGradient grad(-w, -h, w, h);
            grad.setColorAt(0, QColor("#a0be96")); grad.setColorAt(1, QColor("#64825a"));
            p->setBrush(grad);
            p->drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3);
            p->setBrush(QColor(255, 255, 255, 200));
            p->drawRoundedRect(QRectF(-w/2+10, -20, 34, 15), 2, 2);
        } else { // mocha / default
            p->setBrush(QColor("#f5f0e1"));
            p->drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 3, 3);
            QLinearGradient grad(-w, -h, w, h);
            grad.setColorAt(0, QColor("#5a3c32")); grad.setColorAt(1, QColor("#321e19"));
            p->setBrush(grad);
            p->drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3);
            p->setBrush(QColor(120, 20, 30));
            p->drawRect(QRectF(w/2 - 15, -h/2, 8, h));
        }
    }
}

void FloatingBall::renderPen(QPainter* p, const QString& skinName, float, float, float) {
    p->setPen(Qt::NoPen);
    QColor c_light, c_mid, c_dark;
    if (skinName == "royal") {
        c_light = QColor(60, 60, 70); c_mid = QColor(20, 20, 25); c_dark = QColor(26, 26, 26);
    } else if (skinName == "classic") {
        c_light = QColor(80, 80, 80); c_mid = QColor(30, 30, 30); c_dark = QColor(10, 10, 10);
    } else if (skinName == "matcha") {
        c_light = QColor(255, 255, 250); c_mid = QColor(240, 240, 230); c_dark = QColor(200, 200, 190);
    } else {
        c_light = QColor(180, 60, 70); c_mid = QColor(140, 20, 30); c_dark = QColor(60, 5, 10);
    }

    QLinearGradient bodyGrad(-6, 0, 6, 0);
    bodyGrad.setColorAt(0.0, c_light); bodyGrad.setColorAt(0.5, c_mid); bodyGrad.setColorAt(1.0, c_dark);
    QPainterPath path_body; path_body.addRoundedRect(QRectF(-6, -23, 12, 46), 5, 5);
    p->setBrush(bodyGrad); p->drawPath(path_body);
    
    QPainterPath tipPath;
    tipPath.moveTo(-3, 23); tipPath.lineTo(3, 23); tipPath.lineTo(0, 37); tipPath.closeSubpath();
    QLinearGradient tipGrad(-5, 0, 5, 0);
    tipGrad.setColorAt(0, QColor(240, 230, 180)); tipGrad.setColorAt(1, QColor(190, 170, 100));
    p->setBrush(tipGrad); p->drawPath(tipPath);
    
    p->setBrush(QColor(220, 200, 140)); p->drawRect(QRectF(-6, 19, 12, 4));
    p->setBrush(QColor(210, 190, 130)); p->drawRoundedRect(QRectF(-1.5, -17, 3, 24), 1.5, 1.5);
}

void FloatingBall::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_pressPos = event->pos();
        m_isDragging = false; // 初始不进入拖拽，等待 move 判定
        m_penY += 3.0f; // 1:1 复刻 Python 按下弹性反馈
        update();
    }
}

void FloatingBall::mouseMoveEvent(QMouseEvent* event) {
    if (event->buttons() & Qt::LeftButton) {
        if (!m_isDragging) {
            // 只有移动距离超过系统设定的拖拽阈值才开始移动
            if ((event->pos() - m_pressPos).manhattanLength() > QApplication::startDragDistance()) {
                m_isDragging = true;
                m_offset = m_pressPos;
            }
        }
        
        if (m_isDragging) {
            QPoint newPos = event->globalPosition().toPoint() - m_offset;
            QScreen* screen = QGuiApplication::screenAt(event->globalPosition().toPoint());
            if (!screen) screen = QGuiApplication::primaryScreen();
            
            if (screen) {
                QRect ag = screen->availableGeometry();
                int x = qBound(ag.left(), newPos.x(), ag.right() - width());
                int y = qBound(ag.top(), newPos.y(), ag.bottom() - height());
                newPos = QPoint(x, y);
            }
            move(newPos);
        }
    }
}

void FloatingBall::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_isDragging = false;
        savePosition();
    }
}

void FloatingBall::mouseDoubleClickEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        emit doubleClicked();
    }
}

void FloatingBall::enterEvent(QEnterEvent* event) {
    Q_UNUSED(event);
    m_isHovering = true;
}

void FloatingBall::leaveEvent(QEvent* event) {
    Q_UNUSED(event);
    m_isHovering = false;
}

void FloatingBall::contextMenuEvent(QContextMenuEvent* event) {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet(
        "QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
        /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
        "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
        "QMenu::icon { margin-left: 6px; } "
        "QMenu::item:selected { background-color: #4a90e2; color: white; } "
        "QMenu::separator { background-color: #444; height: 1px; margin: 4px 0; }"
    );

    QMenu* skinMenu = menu.addMenu(IconHelper::getIcon("palette", "#aaaaaa", 18), "切换外观");
    skinMenu->setStyleSheet(menu.styleSheet());
    skinMenu->addAction(IconHelper::getIcon("coffee", "#BCAAA4", 18), "摩卡·勃艮第", [this](){ switchSkin("mocha"); });
    skinMenu->addAction(IconHelper::getIcon("grid", "#90A4AE", 18), "经典黑金", [this](){ switchSkin("classic"); });
    skinMenu->addAction(IconHelper::getIcon("book", "#9FA8DA", 18), "皇家蓝", [this](){ switchSkin("royal"); });
    skinMenu->addAction(IconHelper::getIcon("leaf", "#A5D6A7", 18), "抹茶绿", [this](){ switchSkin("matcha"); });
    skinMenu->addAction(IconHelper::getIcon("book_open", "#FFCC80", 18), "摊开手稿", [this](){ switchSkin("open"); });
    skinMenu->addAction("默认天蓝", [this](){ switchSkin("default"); });

    menu.addSeparator();
    menu.addAction(IconHelper::getIcon("zap", "#aaaaaa", 18), "打开快速笔记", this, &FloatingBall::requestQuickWindow);
    menu.addAction(IconHelper::getIcon("monitor", "#aaaaaa", 18), "打开主界面", this, &FloatingBall::requestMainWindow);
    menu.addAction(IconHelper::getIcon("toolbox", "#aaaaaa", 18), "打开工具箱", this, &FloatingBall::requestToolbox);
    menu.addAction(IconHelper::getIcon("add", "#aaaaaa", 18), "新建灵感", this, &FloatingBall::requestNewIdea);
    menu.addSeparator();
    menu.addAction(IconHelper::getIcon("power", "#aaaaaa", 18), "退出程序", [](){ qApp->quit(); });
    
    menu.exec(event->globalPos());
}

void FloatingBall::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasText()) {
        event->accept();
        m_isHovering = true;
    } else {
        event->ignore();
    }
}

void FloatingBall::dragLeaveEvent(QDragLeaveEvent* event) {
    Q_UNUSED(event);
    m_isHovering = false;
}

void FloatingBall::dropEvent(QDropEvent* event) {
    m_isHovering = false;
    QString text = event->mimeData()->text();
    if (!text.trimmed().isEmpty()) {
        // 提取第一个非空行作为标题
        QString title;
        QStringList lines = text.split('\n');
        for (const QString& line : std::as_const(lines)) {
            QString trimmed = line.trimmed();
            if (!trimmed.isEmpty()) {
                title = trimmed.left(40);
                if (trimmed.length() > 40) title += "...";
                break;
            }
        }

        if (title.isEmpty()) {
            title = "拖拽创建数据";
        }

        DatabaseManager::instance().addNoteAsync(title, text, {"拖拽"}, "", -1, "text");
        burstParticles();
        m_isWriting = true;
        m_writeTimer = 0;
        event->acceptProposedAction();
    }
}

QIcon FloatingBall::generateBallIcon() {
    QPixmap pixmap(120, 120);
    pixmap.fill(Qt::transparent);
    
    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);
    
    float cx = 60.0f;
    float cy = 60.0f;
    
    // 静态状态参数 (无动画)
    float bookY = 0.0f;
    float penX = 0.0f;
    float penY = 0.0f;
    float penAngle = -45.0f;
    QString skinName = "mocha";
    
    // 柔和投影 (图标模式保持静态最佳效果)
    painter.save();
    float sw = 48, sh = 12;
    QRadialGradient grad(cx, cy + 42, sw/2);
    grad.setColorAt(0, QColor(0, 0, 0, 35));
    grad.setColorAt(0.7, QColor(0, 0, 0, 15));
    grad.setColorAt(1, Qt::transparent);
    painter.setBrush(grad);
    painter.setPen(Qt::NoPen);
    painter.drawEllipse(QRectF(cx - sw/2, cy + 38, sw, sh));
    painter.restore();
    
    // 笔记本
    painter.save();
    painter.translate(cx, cy + bookY);
    renderBook(&painter, skinName, 0);
    painter.restore();
    
    // 钢笔
    painter.save();
    painter.translate(cx + penX, cy + penY - 5);
    painter.rotate(penAngle);
    renderPen(&painter, skinName, 0, 0, 0);
    painter.restore();
    
    return QIcon(pixmap);
}

void FloatingBall::switchSkin(const QString& name) {
    m_skinName = name;
    
    QSettings settings("RapidNotes", "FloatingBall");
    settings.setValue("skin", name);
    
    update();
}

void FloatingBall::burstParticles() {
    // 逻辑保持
}

void FloatingBall::updatePhysics() {
    m_timeStep += 0.05f;
    
    // 1. 待机呼吸
    float idlePenY = qSin(m_timeStep * 0.5f) * 4.0f;
    float idleBookY = qSin(m_timeStep * 0.5f - 1.0f) * 2.0f;
    
    float targetPenAngle = -45.0f;
    float targetPenX = 0.0f;
    float targetPenY = idlePenY;
    float targetBookY = idleBookY;
    
    // 2. 书写/悬停动画
    if (m_isWriting || m_isHovering) {
        m_writeTimer++;
        targetPenAngle = -65.0f;
        float writeSpeed = m_timeStep * 3.0f;
        targetPenX = qSin(writeSpeed) * 8.0f;
        targetPenY = 5.0f + qCos(writeSpeed * 2.0f) * 2.0f;
        targetBookY = -3.0f;
        
        if (m_isWriting && m_writeTimer > 90) {
            m_isWriting = false;
        }
    }
    
    // 3. 物理平滑
    float easing = 0.1f;
    m_penAngle += (targetPenAngle - m_penAngle) * easing;
    m_penX += (targetPenX - m_penX) * easing;
    m_penY += (targetPenY - m_penY) * easing;
    m_bookY += (targetBookY - m_bookY) * easing;

    updateParticles();
    update();
}

void FloatingBall::updateParticles() {
    if ((m_isWriting || m_isHovering) && m_particles.size() < 15) {
        if (QRandomGenerator::global()->generateDouble() < 0.3) {
            float rad = qDegreesToRadians(m_penAngle);
            float tipLen = 35.0f;
            Particle p;
            p.pos = QPointF(width()/2.0f + m_penX - qSin(rad)*tipLen, height()/2.0f + m_penY + qCos(rad)*tipLen);
            p.velocity = QPointF(QRandomGenerator::global()->generateDouble() - 0.5, QRandomGenerator::global()->generateDouble() + 0.5);
            p.life = 1.0;
            p.size = 1.0f + QRandomGenerator::global()->generateDouble() * 2.0f;
            p.color = QColor::fromHsv(QRandomGenerator::global()->bounded(360), 150, 255);
            m_particles.append(p);
        }
    }
    for (int i = 0; i < m_particles.size(); ++i) {
        m_particles[i].pos += m_particles[i].velocity;
        m_particles[i].life -= 0.03;
        m_particles[i].size *= 0.96f;
        if (m_particles[i].life <= 0) {
            m_particles.removeAt(i);
            --i;
        }
    }
}

void FloatingBall::savePosition() {
    QSettings settings("RapidNotes", "FloatingBall");
    settings.setValue("pos", pos());
    settings.setValue("visible", isVisible());
}

void FloatingBall::restorePosition() {
    QSettings settings("RapidNotes", "FloatingBall");
    if (settings.value("visible", true).toBool()) {
        show();
    } else {
        hide();
    }

    if (settings.contains("pos")) {
        QPoint savedPos = settings.value("pos").toPoint();
        QScreen* screen = QGuiApplication::screenAt(savedPos);
        if (!screen) screen = QGuiApplication::primaryScreen();
        
        if (screen) {
            QRect ag = screen->availableGeometry();
            int x = qBound(ag.left(), savedPos.x(), ag.right() - width());
            int y = qBound(ag.top(), savedPos.y(), ag.bottom() - height());
            move(x, y);
        } else {
            move(savedPos);
        }
    } else {
        QScreen *screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect ag = screen->availableGeometry();
            move(ag.right() - 150, ag.top() + ag.height() / 2 - height() / 2);
        }
    }
}
```

## 文件: `src/ui/FloatingBall.h`

```cpp
#ifndef FLOATINGBALL_H
#define FLOATINGBALL_H

#include <QWidget>
#include <QPoint>
#include <QPropertyAnimation>
#include <QTimer>
#include <QPainter>
#include <QMouseEvent>
#include <QMenu>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QMimeData>
#include "WritingAnimation.h"

class FloatingBall : public QWidget {
    Q_OBJECT
    Q_PROPERTY(QPoint pos READ pos WRITE move)

public:
    explicit FloatingBall(QWidget* parent = nullptr);
    static QIcon generateBallIcon();
    void savePosition();

protected:
    void paintEvent(QPaintEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void mouseDoubleClickEvent(QMouseEvent* event) override;
    void enterEvent(QEnterEvent* event) override;
    void leaveEvent(QEvent* event) override;
    void contextMenuEvent(QContextMenuEvent* event) override;
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragLeaveEvent(QDragLeaveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
    static void renderBook(QPainter* p, const QString& skinName, float bookY);
    static void renderPen(QPainter* p, const QString& skinName, float penX, float penY, float penAngle);

private:
    void switchSkin(const QString& name);
    // drawBook 和 drawPen 已改为静态 renderBook/renderPen
    void burstParticles();
    void updatePhysics();
    void updateParticles();
    void restorePosition();

    QPoint m_pressPos;
    QPoint m_offset;
    bool m_isDragging = false;
    bool m_isHovering = false;
    bool m_isWriting = false;
    int m_writeTimer = 0;

    QTimer* m_timer;
    float m_timeStep = 0.0f;
    float m_penX = 0.0f;
    float m_penY = 0.0f;
    float m_penAngle = -45.0f;
    float m_bookY = 0.0f;

    struct Particle {
        QPointF pos;
        QPointF velocity;
        double life;
        float size;
        QColor color;
    };
    QList<Particle> m_particles;

    QString m_skinName = "mocha";

signals:
    void doubleClicked();
    void requestMainWindow();
    void requestQuickWindow();
    void requestToolbox();
    void requestNewIdea();
};

#endif // FLOATINGBALL_H
```

## 文件: `src/ui/FlowLayout.cpp`

```cpp
#include <QtWidgets>
#include "FlowLayout.h"

FlowLayout::FlowLayout(QWidget *parent, int margin, int hSpacing, int vSpacing)
    : QLayout(parent), m_hSpace(hSpacing), m_vSpace(vSpacing)
{
    setContentsMargins(margin, margin, margin, margin);
}

FlowLayout::FlowLayout(int margin, int hSpacing, int vSpacing)
    : m_hSpace(hSpacing), m_vSpace(vSpacing)
{
    setContentsMargins(margin, margin, margin, margin);
}

FlowLayout::~FlowLayout()
{
    QLayoutItem *item;
    while ((item = takeAt(0)))
        delete item;
}

void FlowLayout::addItem(QLayoutItem *item)
{
    itemList.append(item);
}

int FlowLayout::horizontalSpacing() const
{
    if (m_hSpace >= 0) {
        return m_hSpace;
    } else {
        return smartSpacing(QStyle::PM_LayoutHorizontalSpacing);
    }
}

int FlowLayout::verticalSpacing() const
{
    if (m_vSpace >= 0) {
        return m_vSpace;
    } else {
        return smartSpacing(QStyle::PM_LayoutVerticalSpacing);
    }
}

int FlowLayout::count() const
{
    return itemList.size();
}

QLayoutItem *FlowLayout::itemAt(int index) const
{
    return itemList.value(index);
}

QLayoutItem *FlowLayout::takeAt(int index)
{
    if (index >= 0 && index < itemList.size())
        return itemList.takeAt(index);
    else
        return 0;
}

Qt::Orientations FlowLayout::expandingDirections() const
{
    return { };
}

bool FlowLayout::hasHeightForWidth() const
{
    return true;
}

int FlowLayout::heightForWidth(int width) const
{
    int height = doLayout(QRect(0, 0, width, 0), true);
    return height;
}

void FlowLayout::setGeometry(const QRect &rect)
{
    QLayout::setGeometry(rect);
    doLayout(rect, false);
}

QSize FlowLayout::sizeHint() const
{
    return minimumSize();
}

QSize FlowLayout::minimumSize() const
{
    QSize size;
    QLayoutItem *item;
    foreach (item, itemList)
        size = size.expandedTo(item->minimumSize());

    size += QSize(2*contentsMargins().top(), 2*contentsMargins().top());
    return size;
}

int FlowLayout::doLayout(const QRect &rect, bool testOnly) const
{
    int left, top, right, bottom;
    getContentsMargins(&left, &top, &right, &bottom);
    QRect effectiveRect = rect.adjusted(+left, +top, -right, -bottom);
    int x = effectiveRect.x();
    int y = effectiveRect.y();
    int lineHeight = 0;

    QLayoutItem *item;
    foreach (item, itemList) {
        QWidget *wid = item->widget();
        int spaceX = horizontalSpacing();
        if (spaceX == -1)
            spaceX = wid->style()->layoutSpacing(
                QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal);
        int spaceY = verticalSpacing();
        if (spaceY == -1)
            spaceY = wid->style()->layoutSpacing(
                QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Vertical);
        int nextX = x + item->sizeHint().width() + spaceX;
        if (nextX - spaceX > effectiveRect.right() && lineHeight > 0) {
            x = effectiveRect.x();
            y = y + lineHeight + spaceY;
            nextX = x + item->sizeHint().width() + spaceX;
            lineHeight = 0;
        }

        if (!testOnly)
            item->setGeometry(QRect(QPoint(x, y), item->sizeHint()));

        x = nextX;
        lineHeight = qMax(lineHeight, item->sizeHint().height());
    }
    return y + lineHeight - rect.y() + bottom;
}

int FlowLayout::smartSpacing(QStyle::PixelMetric pm) const
{
    QObject *parent = this->parent();
    if (!parent) {
        return -1;
    } else if (parent->isWidgetType()) {
        QWidget *pw = static_cast<QWidget *>(parent);
        return pw->style()->pixelMetric(pm, 0, pw);
    } else {
        return static_cast<QLayout *>(parent)->spacing();
    }
}

```

## 文件: `src/ui/FlowLayout.h`

```cpp
#ifndef FLOWLAYOUT_H
#define FLOWLAYOUT_H

#include <QLayout>
#include <QRect>
#include <QStyle>

class FlowLayout : public QLayout {
    Q_OBJECT
public:
    explicit FlowLayout(QWidget *parent, int margin = -1, int hSpacing = -1, int vSpacing = -1);
    explicit FlowLayout(int margin = -1, int hSpacing = -1, int vSpacing = -1);
    ~FlowLayout();

    void addItem(QLayoutItem *item) override;
    int horizontalSpacing() const;
    int verticalSpacing() const;
    Qt::Orientations expandingDirections() const override;
    bool hasHeightForWidth() const override;
    int heightForWidth(int) const override;
    int count() const override;
    QLayoutItem *itemAt(int index) const override;
    QSize minimumSize() const override;
    void setGeometry(const QRect &rect) override;
    QSize sizeHint() const override;
    QLayoutItem *takeAt(int index) override;

private:
    int doLayout(const QRect &rect, bool testOnly) const;
    int smartSpacing(QStyle::PixelMetric pm) const;

    QList<QLayoutItem *> itemList;
    int m_hSpace;
    int m_vSpace;
};

#endif // FLOWLAYOUT_H
```

## 文件: `src/ui/FramelessDialog.cpp`

```cpp
#include "FramelessDialog.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include <QGraphicsDropShadowEffect>
#include <QSettings>
#include <QMouseEvent>
#include <QKeyEvent>
#include <QTimer>
#include <QPainter>
#include <QPen>

#ifdef Q_OS_WIN
#include <windows.h>
#endif

#include <QMenu>
#include <QCursor>
#include "AdvancedTagSelector.h"
#include "../core/DatabaseManager.h"
#include "StringUtils.h"

// ============================================================================
// FramelessDialog 基类实现
// ============================================================================
FramelessDialog::FramelessDialog(const QString& title, QWidget* parent) 
    : QDialog(parent, Qt::FramelessWindowHint | Qt::Window) 
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_AlwaysShowToolTips);
    setMinimumWidth(40);
    setWindowTitle(title);

    auto* outerLayout = new QVBoxLayout(this);
    outerLayout->setContentsMargins(20, 20, 20, 20);

    auto* container = new QWidget(this);
    container->setObjectName("DialogContainer");
    container->setAttribute(Qt::WA_StyledBackground);
    container->setStyleSheet(
        "#DialogContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-radius: 12px;"
        "} "
    );
    outerLayout->addWidget(container);

    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(20);
    shadow->setXOffset(0);
    shadow->setYOffset(4);
    shadow->setColor(QColor(0, 0, 0, 120));
    container->setGraphicsEffect(shadow);

    m_mainLayout = new QVBoxLayout(container);
    m_mainLayout->setContentsMargins(0, 0, 0, 10);
    m_mainLayout->setSpacing(0);

    // --- 标题栏 ---
    auto* titleBar = new QWidget();
    titleBar->setObjectName("TitleBar");
    titleBar->setMinimumHeight(38);
    titleBar->setStyleSheet("background-color: transparent; border-bottom: 1px solid #2D2D2D;");
    auto* titleLayout = new QHBoxLayout(titleBar);
    titleLayout->setContentsMargins(12, 0, 5, 0);
    titleLayout->setSpacing(4);

    m_titleLabel = new QLabel(title);
    m_titleLabel->setStyleSheet("color: #888; font-size: 12px; font-weight: bold; border: none;");
    titleLayout->addWidget(m_titleLabel);
    titleLayout->addStretch();

    m_btnPin = new QPushButton();
    m_btnPin->setObjectName("btnPin");
    m_btnPin->setFixedSize(28, 28);
    m_btnPin->setIconSize(QSize(18, 18));
    m_btnPin->setAutoDefault(false);
    m_btnPin->setCheckable(true);
    m_btnPin->setIcon(IconHelper::getIcon("pin_tilted", "#aaaaaa"));
    
    // 初始化同步 UI 状态
    m_btnPin->blockSignals(true);
    m_btnPin->setChecked(m_isStayOnTop); 
    if (m_isStayOnTop) {
        m_btnPin->setIcon(IconHelper::getIcon("pin_vertical", "#ffffff"));
    }
    m_btnPin->blockSignals(false);
    m_btnPin->setStyleSheet("QPushButton { border: none; background: transparent; border-radius: 4px; } "
                          "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); } "
                          "QPushButton:pressed { background-color: rgba(255, 255, 255, 0.2); } "
                          "QPushButton:checked { background-color: rgba(58, 144, 255, 0.3); }");
    m_btnPin->setToolTip("置顶");
    connect(m_btnPin, &QPushButton::toggled, this, &FramelessDialog::toggleStayOnTop);
    titleLayout->addWidget(m_btnPin);

    m_minBtn = new QPushButton();
    m_minBtn->setObjectName("minBtn");
    m_minBtn->setFixedSize(28, 28);
    m_minBtn->setIconSize(QSize(18, 18));
    m_minBtn->setIcon(IconHelper::getIcon("minimize", "#888888"));
    m_minBtn->setAutoDefault(false);
    m_minBtn->setToolTip("最小化");
    m_minBtn->setCursor(Qt::PointingHandCursor);
    m_minBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } "
        "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }"
    );
    connect(m_minBtn, &QPushButton::clicked, this, &QDialog::showMinimized);
    titleLayout->addWidget(m_minBtn);

    m_closeBtn = new QPushButton();
    m_closeBtn->setObjectName("closeBtn");
    m_closeBtn->setFixedSize(28, 28);
    m_closeBtn->setIconSize(QSize(18, 18));
    m_closeBtn->setIcon(IconHelper::getIcon("close", "#888888"));
    m_closeBtn->setAutoDefault(false);
    m_closeBtn->setToolTip("关闭");
    m_closeBtn->setCursor(Qt::PointingHandCursor);
    m_closeBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } "
        "QPushButton:hover { background-color: #E81123; }"
    );
    connect(m_closeBtn, &QPushButton::clicked, this, &QDialog::reject);
    titleLayout->addWidget(m_closeBtn);

    m_mainLayout->addWidget(titleBar);

    m_contentArea = new QWidget();
    m_contentArea->setObjectName("DialogContentArea");
    m_contentArea->setAttribute(Qt::WA_StyledBackground);
    m_contentArea->setStyleSheet("QWidget#DialogContentArea { background: transparent; border: none; }");
    m_mainLayout->addWidget(m_contentArea, 1);
}

void FramelessDialog::setStayOnTop(bool stay) {
    if (m_btnPin) m_btnPin->setChecked(stay);
}

void FramelessDialog::toggleStayOnTop(bool checked) {
    m_isStayOnTop = checked;
    saveWindowSettings();

    if (isVisible()) {
#ifdef Q_OS_WIN
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, checked ? HWND_TOPMOST : HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
        Qt::WindowFlags f = windowFlags();
        if (checked) f |= Qt::WindowStaysOnTopHint;
        else f &= ~Qt::WindowStaysOnTopHint;
        setWindowFlags(f);
        show();
#endif
    }

    if (m_btnPin) {
        m_btnPin->setIcon(IconHelper::getIcon(checked ? "pin_vertical" : "pin_tilted", checked ? "#ffffff" : "#aaaaaa"));
    }
}

void FramelessDialog::showEvent(QShowEvent* event) {
    QDialog::showEvent(event);
#ifdef Q_OS_WIN
    if (m_isStayOnTop) {
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }
#endif
}

void FramelessDialog::loadWindowSettings() {
    if (objectName().isEmpty()) return;
    QSettings settings("RapidNotes", "WindowStates");
    bool stay = settings.value(objectName() + "/StayOnTop", false).toBool();
    m_isStayOnTop = stay;
    if (m_isStayOnTop) setWindowFlag(Qt::WindowStaysOnTopHint, true);
    
    if (m_btnPin) {
        m_btnPin->blockSignals(true);
        m_btnPin->setChecked(stay);
        m_btnPin->setIcon(IconHelper::getIcon(stay ? "pin_vertical" : "pin_tilted", stay ? "#ffffff" : "#aaaaaa"));
        m_btnPin->blockSignals(false);
    }
}

void FramelessDialog::saveWindowSettings() {
    if (objectName().isEmpty()) return;
    QSettings settings("RapidNotes", "WindowStates");
    settings.setValue(objectName() + "/StayOnTop", m_isStayOnTop);
}

void FramelessDialog::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_dragPos = event->globalPosition().toPoint() - frameGeometry().topLeft();
        event->accept();
    }
}

void FramelessDialog::mouseMoveEvent(QMouseEvent* event) {
    if (event->buttons() & Qt::LeftButton) {
        move(event->globalPosition().toPoint() - m_dragPos);
        event->accept();
    }
}

void FramelessDialog::paintEvent(QPaintEvent* event) {
    Q_UNUSED(event);
}

void FramelessDialog::keyPressEvent(QKeyEvent* event) {
    if (event->modifiers() == Qt::ControlModifier && event->key() == Qt::Key_W) {
        reject();
    } else {
        QDialog::keyPressEvent(event);
    }
}

// ============================================================================
// FramelessInputDialog 实现
// ============================================================================
FramelessInputDialog::FramelessInputDialog(const QString& title, const QString& label, 
                                           const QString& initial, QWidget* parent)
    : FramelessDialog(title, parent) 
{
    // 保持高度，确保有足够空间让按钮沉底
    resize(500, 260);
    setMinimumSize(400, 240);
    
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(20, 15, 20, 20);
    
    // 【关键修改】将全局间距设置为 7px，确保“标签”文字和输入框紧凑
    layout->setSpacing(7);

    auto* lbl = new QLabel(label);
    lbl->setStyleSheet("color: #eee; font-size: 13px;");
    layout->addWidget(lbl);

    m_edit = new QLineEdit(initial);
    // 设置最小高度，防止截断
    m_edit->setMinimumHeight(38);
    m_edit->setStyleSheet(
        "QLineEdit {"
        "  background-color: #2D2D2D; border: 1px solid #444; border-radius: 4px;"
        "  padding: 0px 10px; color: white; selection-background-color: #4a90e2;"
        "  font-size: 14px;"
        "}"
        "QLineEdit:focus { border: 1px solid #4a90e2; }"
    );
    layout->addWidget(m_edit);

    // 使用 PlaceholderText 显示提示
    if (title.contains("标签") || label.contains("标签")) {
        m_edit->setPlaceholderText("双击调出历史标签"); 
        m_edit->installEventFilter(this);
    }

    connect(m_edit, &QLineEdit::returnPressed, this, &QDialog::accept);

    // 【关键】增加 Stretch，强制将下方的按钮布局挤到底部
    // 这样输入框和上面的文字间距是 7px，而输入框和按钮的间距会自动拉大
    layout->addStretch();

    auto* btnLayout = new QHBoxLayout();
    btnLayout->addStretch();
    
    auto* btnOk = new QPushButton("确定");
    btnOk->setAutoDefault(false);
    btnOk->setCursor(Qt::PointingHandCursor);
    btnOk->setStyleSheet("QPushButton { background-color: #4a90e2; color: white; border: none; border-radius: 4px; padding: 6px 20px; font-weight: bold; } QPushButton:hover { background-color: #357abd; }");
    connect(btnOk, &QPushButton::clicked, this, &QDialog::accept);
    btnLayout->addWidget(btnOk);

    layout->addLayout(btnLayout);

    m_edit->setFocus();
    m_edit->selectAll();
}

bool FramelessInputDialog::eventFilter(QObject* watched, QEvent* event) {
    if (watched == m_edit && event->type() == QEvent::MouseButtonDblClick) {
        auto* selector = new AdvancedTagSelector(this);
        
        auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
        QStringList allTags = DatabaseManager::instance().getAllTags();
        QStringList selected = m_edit->text().split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
        for(QString& s : selected) s = s.trimmed();

        selector->setup(recentTags, allTags, selected);
        
        connect(selector, &AdvancedTagSelector::tagsConfirmed, [this](const QStringList& tags){
            if (!tags.isEmpty()) {
                m_edit->setText(tags.join(", "));
                m_edit->setFocus();
            }
        });

        selector->showAtCursor();
        return true;
    }
    return FramelessDialog::eventFilter(watched, event);
}

void FramelessInputDialog::showEvent(QShowEvent* event) {
    FramelessDialog::showEvent(event);
    QTimer::singleShot(100, m_edit, qOverload<>(&QWidget::setFocus));
}

// ============================================================================
// FramelessMessageBox 实现
// ============================================================================
FramelessMessageBox::FramelessMessageBox(const QString& title, const QString& text, QWidget* parent)
    : FramelessDialog(title, parent)
{
    resize(500, 220);
    setMinimumSize(400, 200);

    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(25, 20, 25, 25);
    layout->setSpacing(20);

    auto* lbl = new QLabel(text);
    lbl->setWordWrap(true);
    lbl->setStyleSheet("color: #eee; font-size: 14px; line-height: 150%;");
    layout->addWidget(lbl);

    auto* btnLayout = new QHBoxLayout();
    btnLayout->addStretch();

    auto* btnCancel = new QPushButton("取消");
    btnCancel->setAutoDefault(false);
    btnCancel->setCursor(Qt::PointingHandCursor);
    btnCancel->setStyleSheet("QPushButton { background-color: transparent; color: #888; border: 1px solid #555; border-radius: 4px; padding: 6px 15px; } QPushButton:hover { color: #eee; border-color: #888; }");
    connect(btnCancel, &QPushButton::clicked, this, [this](){ emit cancelled(); reject(); });
    btnLayout->addWidget(btnCancel);

    auto* btnOk = new QPushButton("确定");
    btnOk->setAutoDefault(false);
    btnOk->setCursor(Qt::PointingHandCursor);
    btnOk->setStyleSheet("QPushButton { background-color: #e74c3c; color: white; border: none; border-radius: 4px; padding: 6px 20px; font-weight: bold; } QPushButton:hover { background-color: #c0392b; }");
    connect(btnOk, &QPushButton::clicked, this, [this](){ emit confirmed(); accept(); });
    btnLayout->addWidget(btnOk);

    layout->addLayout(btnLayout);
}
```

## 文件: `src/ui/FramelessDialog.h`

```cpp
#ifndef FRAMELESSDIALOG_H
#define FRAMELESSDIALOG_H

#include <QDialog>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QLabel>
#include <QLineEdit>
#include <QFrame>

/**
 * @brief 无边框对话框基类，自带标题栏、关闭按钮、阴影、置顶
 */
class FramelessDialog : public QDialog {
    Q_OBJECT
public:
    explicit FramelessDialog(const QString& title, QWidget* parent = nullptr);
    virtual ~FramelessDialog() = default;

    void setStayOnTop(bool stay);

private slots:
    void toggleStayOnTop(bool checked);

protected:
    void showEvent(QShowEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void paintEvent(QPaintEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

    QWidget* m_contentArea;
    QVBoxLayout* m_mainLayout;
    QLabel* m_titleLabel;
    QPushButton* m_btnPin;
    QPushButton* m_minBtn;
    QPushButton* m_closeBtn;

    virtual void loadWindowSettings();
    virtual void saveWindowSettings();

private:
    QPoint m_dragPos;
    bool m_isStayOnTop = false; // 默认改为 false，支持记忆功能
    bool m_firstShow = true;
};

/**
 * @brief 无边框文本输入对话框
 */
class FramelessInputDialog : public FramelessDialog {
    Q_OBJECT
public:
    explicit FramelessInputDialog(const QString& title, const QString& label, 
                                  const QString& initial = "", QWidget* parent = nullptr);
    QString text() const { return m_edit->text().trimmed(); }
    void setEchoMode(QLineEdit::EchoMode mode) { m_edit->setEchoMode(mode); }

protected:
    void showEvent(QShowEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

private:
    QLineEdit* m_edit;
};

/**
 * @brief 无边框确认提示框
 */
class FramelessMessageBox : public FramelessDialog {
    Q_OBJECT
public:
    explicit FramelessMessageBox(const QString& title, const QString& text, QWidget* parent = nullptr);

signals:
    void confirmed();
    void cancelled();
};

#endif // FRAMELESSDIALOG_H
```

## 文件: `src/ui/HeaderBar.cpp`

```cpp
#include "HeaderBar.h"
#include "StringUtils.h"

#include "IconHelper.h"
#include <QHBoxLayout>
#include <QSettings>
#include <QMouseEvent>
#include <QApplication>
#include <QWindow>
#include <QIntValidator>

HeaderBar::HeaderBar(QWidget* parent) : QWidget(parent) {
    setFixedHeight(41); // 40 + 1px 线
    setStyleSheet("background-color: #252526; border: none;");

    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    // 顶部内容区
    auto* topContent = new QWidget();
    auto* layout = new QHBoxLayout(topContent);
    layout->setContentsMargins(10, 0, 10, 0);
    layout->setSpacing(0);
    
    // 1. Logo & Title
    QLabel* appLogo = new QLabel();
    appLogo->setFixedSize(18, 18);
    appLogo->setPixmap(IconHelper::getIcon("zap", "#4a90e2", 18).pixmap(18, 18));
    layout->addWidget(appLogo);
    layout->addSpacing(6);

    QLabel* titleLabel = new QLabel("快速笔记");
    titleLabel->setStyleSheet("font-size: 13px; font-weight: bold; color: #4a90e2; border: none; background: transparent;");
    layout->addWidget(titleLabel);
    layout->addSpacing(15);

    // 2. Search Box
    m_searchEdit = new SearchLineEdit();
    m_searchEdit->setPlaceholderText("搜索灵感 (双击查看历史)");
    m_searchEdit->setFixedWidth(280);
    m_searchEdit->setFixedHeight(28);
    m_searchEdit->setStyleSheet(
        "SearchLineEdit { "
        "  background-color: #1e1e1e; "
        "  border: 1px solid #444; "
        "  border-radius: 14px; "
        "  padding: 5px 15px; "
        "  color: white; "
        "  font-size: 13px; "
        "} "
        "SearchLineEdit:focus { border: 1px solid #4a90e2; background-color: #181818; }"
    );
    connect(m_searchEdit, &QLineEdit::textChanged, this, &HeaderBar::searchChanged);
    connect(m_searchEdit, &QLineEdit::returnPressed, [this](){
        m_searchEdit->addHistoryEntry(m_searchEdit->text().trimmed());
    });
    layout->addWidget(m_searchEdit);
    layout->addSpacing(15);

    // 3. Pagination Controls (保持原有逻辑)
    QString pageBtnStyle = 
        "QPushButton {"
        "    background-color: transparent;"
        "    border: 1px solid #555;"
        "    border-radius: 12px;"
        "    min-width: 24px;"
        "    max-width: 24px;"
        "    min-height: 24px;"
        "    max-height: 24px;"
        "    padding: 0px;"
        "}"
        "QPushButton:hover { background-color: #333; border-color: #777; }"
        "QPushButton:disabled { border-color: #333; }";

    auto createPageBtn = [&](const QString& icon, const QString& tip) {
        QPushButton* btn = new QPushButton();
        btn->setIcon(IconHelper::getIcon(icon, "#aaaaaa", 16));
        btn->setToolTip(tip);
        btn->setStyleSheet(pageBtnStyle);
        return btn;
    };

    QPushButton* btnFirst = createPageBtn("nav_first", "第一页");
    connect(btnFirst, &QPushButton::clicked, [this](){ emit pageChanged(1); });
    layout->addWidget(btnFirst);
    layout->addSpacing(6);

    QPushButton* btnPrev = createPageBtn("nav_prev", "上一页");
    connect(btnPrev, &QPushButton::clicked, [this](){ if(m_currentPage > 1) emit pageChanged(m_currentPage - 1); });
    layout->addWidget(btnPrev);
    layout->addSpacing(8);

    m_pageInput = new QLineEdit("1");
    m_pageInput->setFixedWidth(40);
    m_pageInput->setFixedHeight(24);
    m_pageInput->setAlignment(Qt::AlignCenter);
    m_pageInput->setValidator(new QIntValidator(1, 9999, this));
    m_pageInput->setStyleSheet(
        "QLineEdit {"
        "    background-color: #2D2D2D;"
        "    border: 1px solid #555;"
        "    border-radius: 12px;"
        "    color: #eee;"
        "    font-size: 11px;"
        "    padding: 0px;"
        "}"
        "QLineEdit:focus { border: 1px solid #4a90e2; }"
    );
    connect(m_pageInput, &QLineEdit::returnPressed, [this](){
        emit pageChanged(m_pageInput->text().toInt());
    });
    layout->addWidget(m_pageInput);
    layout->addSpacing(6);

    m_totalPageLabel = new QLabel("/ 1");
    m_totalPageLabel->setStyleSheet("color: #888; font-size: 12px; margin-left: 2px; margin-right: 5px; border: none; background: transparent;");
    layout->addWidget(m_totalPageLabel);
    layout->addSpacing(10);

    QPushButton* btnNext = createPageBtn("nav_next", "下一页");
    connect(btnNext, &QPushButton::clicked, [this](){ if(m_currentPage < m_totalPages) emit pageChanged(m_currentPage + 1); });
    layout->addWidget(btnNext);
    layout->addSpacing(6);

    QPushButton* btnLast = createPageBtn("nav_last", "最后一页");
    connect(btnLast, &QPushButton::clicked, [this](){ emit pageChanged(m_totalPages); });
    layout->addWidget(btnLast);
    layout->addSpacing(10);

    QPushButton* btnRefresh = createPageBtn("refresh", "刷新 (F5)");
    connect(btnRefresh, &QPushButton::clicked, this, &HeaderBar::refreshRequested);
    layout->addWidget(btnRefresh);
    layout->addSpacing(10);

    // 标准功能按钮样式 (32x32, 无边框)
    QString funcBtnStyle = 
        "QPushButton {"
        "    background-color: transparent;"
        "    border: none;"
        "    outline: none;"
        "    border-radius: 5px;"
        "    width: 32px;"
        "    height: 32px;"
        "    padding: 0px;"
        "}"
        "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }"
        "QPushButton:pressed { background-color: rgba(255, 255, 255, 0.2); }";

    // 迁移：新建笔记 (+) 和 工具箱 按钮移至中间组，保留其原有 32x32 风格
    QPushButton* btnAddCenter = new QPushButton();
    btnAddCenter->setIcon(IconHelper::getIcon("add", "#ffffff", 20));
    btnAddCenter->setIconSize(QSize(20, 20));
    btnAddCenter->setToolTip("新建笔记 (Ctrl+N)");
    btnAddCenter->setStyleSheet(funcBtnStyle);
    connect(btnAddCenter, &QPushButton::clicked, this, &HeaderBar::newNoteRequested);
    layout->addWidget(btnAddCenter);
    layout->addSpacing(4);

    QPushButton* btnTool = new QPushButton();
    btnTool->setIcon(IconHelper::getIcon("toolbox", "#aaaaaa", 20));
    btnTool->setIconSize(QSize(20, 20));
    btnTool->setToolTip("工具箱 (右键快捷设置)");
    btnTool->setStyleSheet(funcBtnStyle);
    btnTool->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(btnTool, &QPushButton::clicked, this, &HeaderBar::toolboxRequested);
    connect(btnTool, &QPushButton::customContextMenuRequested, this, [this, btnTool](const QPoint& pos){
        emit toolboxContextMenuRequested(btnTool->mapToGlobal(pos));
    });
    layout->addWidget(btnTool);
    layout->addSpacing(4);

    QPushButton* btnLock = new QPushButton();
    btnLock->setIcon(IconHelper::getIcon("lock", "#aaaaaa", 20));
    btnLock->setIconSize(QSize(20, 20));
    btnLock->setToolTip("全局锁定");
    btnLock->setStyleSheet(funcBtnStyle);
    connect(btnLock, &QPushButton::clicked, this, &HeaderBar::globalLockRequested);
    layout->addWidget(btnLock);

    layout->addStretch();

    // 4. Functional Buttons
    m_btnStayOnTop = new QPushButton();
    m_btnStayOnTop->setObjectName("btnStayOnTop");
    m_btnStayOnTop->setIcon(IconHelper::getIcon("pin_tilted", "#aaaaaa", 20));
    m_btnStayOnTop->setIconSize(QSize(20, 20));
    m_btnStayOnTop->setToolTip("始终最前 (自动置顶)");
    m_btnStayOnTop->setCheckable(true);
    m_btnStayOnTop->setStyleSheet(funcBtnStyle + " QPushButton:checked { background-color: #3A90FF; }");
    connect(m_btnStayOnTop, &QPushButton::toggled, this, [this](bool checked){
        m_btnStayOnTop->setIcon(IconHelper::getIcon(checked ? "pin_vertical" : "pin_tilted", checked ? "#ffffff" : "#aaaaaa", 20));
        emit stayOnTopRequested(checked);
    });
    layout->addWidget(m_btnStayOnTop);
    layout->addSpacing(4);

    m_btnMeta = new QPushButton();
    m_btnMeta->setIcon(IconHelper::getIcon("sidebar_right", "#aaaaaa", 20));
    m_btnMeta->setIconSize(QSize(20, 20));
    m_btnMeta->setToolTip("元数据面板 (Ctrl+I)");
    m_btnMeta->setCheckable(true);
    m_btnMeta->setStyleSheet(funcBtnStyle + " QPushButton:checked { background-color: #4a90e2; }");
    connect(m_btnMeta, &QPushButton::toggled, this, &HeaderBar::metadataToggled);
    layout->addWidget(m_btnMeta);
    layout->addSpacing(4);

    m_btnFilter = new QPushButton();
    m_btnFilter->setIcon(IconHelper::getIcon("filter", "#ffffff", 20));
    m_btnFilter->setIconSize(QSize(20, 20));
    m_btnFilter->setToolTip("高级筛选 (Ctrl+G)");
    m_btnFilter->setStyleSheet(funcBtnStyle + " QPushButton:checked { background-color: #4a90e2; }");
    m_btnFilter->setCheckable(true);
    connect(m_btnFilter, &QPushButton::clicked, this, &HeaderBar::filterRequested);
    layout->addWidget(m_btnFilter);

    // 5. Window Controls
    QWidget* winCtrlWidget = new QWidget();
    winCtrlWidget->setStyleSheet("background: transparent;");
    QHBoxLayout* winCtrlLayout = new QHBoxLayout(winCtrlWidget);
    winCtrlLayout->setContentsMargins(0, 0, 0, 0);
    winCtrlLayout->setSpacing(0);

    auto addWinBtn = [&](const QString& icon, const QString& hoverColor, auto signal) {
        QPushButton* btn = new QPushButton();
        btn->setIcon(IconHelper::getIcon(icon, "#aaaaaa", 20));
        btn->setIconSize(QSize(20, 20));
        btn->setFixedSize(32, 32);
        btn->setStyleSheet(QString("QPushButton { background: transparent; border: none; border-radius: 5px; } QPushButton:hover { background: %1; }").arg(hoverColor));
        connect(btn, &QPushButton::clicked, this, signal);
        winCtrlLayout->addWidget(btn);
    };

    addWinBtn("minimize", "rgba(255,255,255,0.1)", &HeaderBar::windowMinimize);
    addWinBtn("maximize", "rgba(255,255,255,0.1)", &HeaderBar::windowMaximize);
    addWinBtn("close", "#e81123", &HeaderBar::windowClose);
    layout->addWidget(winCtrlWidget);

    mainLayout->addWidget(topContent);

    // 【关键修复】实体的 1px 全宽分割线
    auto* bottomLine = new QFrame();
    bottomLine->setFrameShape(QFrame::HLine);
    bottomLine->setFixedHeight(1);
    bottomLine->setStyleSheet("background-color: #333333; border: none; margin: 0px;");
    mainLayout->addWidget(bottomLine);
}

void HeaderBar::updatePagination(int current, int total) {
    m_currentPage = current;
    m_totalPages = total;
    m_pageInput->setText(QString::number(current));
    m_totalPageLabel->setText(QString("/ %1").arg(total));
}

void HeaderBar::setFilterActive(bool active) {
    m_btnFilter->setChecked(active);
}

void HeaderBar::setMetadataActive(bool active) {
    m_btnMeta->setChecked(active);
}

void HeaderBar::focusSearch() {
    m_searchEdit->setFocus();
    m_searchEdit->selectAll();
}

void HeaderBar::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        if (auto* win = window()) {
            if (auto* handle = win->windowHandle()) {
                handle->startSystemMove();
            }
        }
        event->accept();
    }
}

void HeaderBar::mouseMoveEvent(QMouseEvent* event) {
    QWidget::mouseMoveEvent(event);
}

void HeaderBar::mouseDoubleClickEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        emit windowMaximize();
        event->accept();
    }
}
```

## 文件: `src/ui/HeaderBar.h`

```cpp
#ifndef HEADERBAR_H
#define HEADERBAR_H

#include <QWidget>
#include <QPushButton>
#include <QLabel>
#include <QMenu>
#include "SearchLineEdit.h"

class HeaderBar : public QWidget {
    Q_OBJECT
public:
    explicit HeaderBar(QWidget* parent = nullptr);

signals:
    void searchChanged(const QString& text);
    void newNoteRequested();
    void toggleSidebar();
    void pageChanged(int page);
    void toolboxRequested();
    void globalLockRequested();
    void toolboxContextMenuRequested(const QPoint& pos);
    void metadataToggled(bool checked);
    void refreshRequested();
    void filterRequested();
    void stayOnTopRequested(bool checked);
    void windowClose();
    void windowMinimize();
    void windowMaximize();

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseDoubleClickEvent(QMouseEvent* event) override;

public:
    void updatePagination(int current, int total);
    void setFilterActive(bool active);
    void setMetadataActive(bool active);
    void focusSearch();

private:
    SearchLineEdit* m_searchEdit;
    QLineEdit* m_pageInput;
    QLabel* m_totalPageLabel;
    QPushButton* m_btnFilter;
    QPushButton* m_btnMeta;
    QPushButton* m_btnStayOnTop;

    int m_currentPage = 1;
    int m_totalPages = 1;
    QPoint m_dragPos;
};

#endif // HEADERBAR_H
```

## 文件: `src/ui/HelpWindow.cpp`

```cpp
#include "HelpWindow.h"
#include "StringUtils.h"
#include <QVBoxLayout>
#include <QScrollArea>

HelpWindow::HelpWindow(QWidget* parent) : FramelessDialog("使用说明", parent) {
    setObjectName("HelpWindow");
    loadWindowSettings();
    setFixedSize(500, 600);
    initUI();
}

void HelpWindow::initUI() {
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(15, 5, 15, 15);
    layout->setSpacing(0);

    QScrollArea* scroll = new QScrollArea();
    scroll->setWidgetResizable(true);
    scroll->setFrameShape(QFrame::NoFrame);
    scroll->setStyleSheet("QScrollArea { background: transparent; } "
                          "QScrollBar:vertical { width: 8px; background: transparent; } "
                          "QScrollBar::handle:vertical { background: #555; border-radius: 4px; } "
                          "QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }");

    QLabel* contentLabel = new QLabel();
    contentLabel->setWordWrap(true);
    contentLabel->setTextFormat(Qt::RichText);
    contentLabel->setText(getHelpHtml());
    contentLabel->setStyleSheet("color: #DDD; line-height: 1.6; font-size: 13px;");
    contentLabel->setAlignment(Qt::AlignTop | Qt::AlignLeft);

    scroll->setWidget(contentLabel);
    layout->addWidget(scroll);
}

QString HelpWindow::getHelpHtml() {
    return R"html(
<style>
    h2 { color: #4FACFE; margin-top: 25px; border-bottom: 1px solid #333; padding-bottom: 8px; font-size: 18px; }
    b { color: #F1C40F; font-weight: bold; }
    .key { background: #444; padding: 2px 8px; border-radius: 4px; font-family: 'Consolas', monospace; color: #FFF; font-weight: bold; font-size: 12px; border: 1px solid #555; }
    .section { margin-bottom: 30px; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 8px; }
    ul { margin-left: -15px; list-style-type: none; }
    li { margin-bottom: 12px; line-height: 1.6; }
    .sub-title { color: #1abc9c; font-weight: bold; margin-top: 15px; display: block; font-size: 14px; border-left: 3px solid #1abc9c; padding-left: 8px; }
    .desc { color: #BBB; font-size: 13px; display: block; margin-top: 4px; }
    .cmd { color: #3498db; font-family: monospace; font-weight: bold; }
</style>

<div class="section">
    <h2>一、全局系统热键</h2>
    <ul>
        <li><span class="key">Alt + Space</span> : <b>呼出/隐藏极速窗口</b> <br/> <span class="desc">默认快捷键，可在设置中自定义。实现即用即走的极速交互体验。</span></li>
        <li><span class="key">Ctrl + Shift + S</span> : <b>浏览器智能采集</b> <br/> <span class="desc">仅限浏览器环境，自动提取所选文字的【标题】与【正文】并智能入库。</span></li>
        <li><span class="key">Ctrl + Alt + A</span> : <b>全能截屏/OCR</b> <br/> <span class="desc">支持识图取字、画笔标注、马赛克及【屏幕贴图】功能。</span></li>
        <li><span class="key">Ctrl + Shift + E</span> : <b>一键收藏最后捕获</b> <br/> <span class="desc">将剪贴板最后一条自动生成的灵感快速加入收藏夹。</span></li>
        <li><span class="key">快捷键 5 (需设置)</span> : <b>全局应用锁定</b> <br/> <span class="desc">一键进入 Eagle 风格的启动锁界面，保护数据隐私。</span></li>
    </ul>
</div>

<div class="section">
    <h2>二、极速窗口交互指南</h2>
    <span class="sub-title">搜索与内容处理</span>
    <ul>
        <li><b>智能搜索</b>：输入即过滤。无结果时按 <span class="key">Enter</span> 存入历史。双击搜索框查看历史。</li>
        <li><b>自动上屏</b>：选中项按 <span class="key">Enter</span> 或 <b>左键双击</b>，自动粘贴内容至目标软件。</li>
        <li><b>格式清洗</b>：按 <span class="key">Ctrl + T</span> 提取选中项的纯文本内容至剪贴板。</li>
        <li><b>快速预览</b>：按 <span class="key">Space</span> 呼出/关闭浮动预览大窗。</li>
    </ul>
    
    <span class="sub-title">高效管理快捷键</span>
    <ul>
        <li><b>分级标记</b>：<span class="key">Ctrl + 1~5</span> 设置评分；<span class="key">Ctrl + E</span> 收藏；<span class="key">Ctrl + P</span> 置顶。</li>
        <li><b>隐私控制</b>：<span class="key">Ctrl + S</span> 锁定单条记录；<span class="key">Ctrl + Shift + L</span> 立即锁定当前分类。</li>
        <li><b>标签系统</b>：底部框 <b>左键双击</b> 打开高级标签选择器。支持 <span class="key">Ctrl + Shift + C/V</span> 批量同步标签。</li>
        <li><b>翻页导航</b>：<span class="key">Alt + S</span> 上一页；<span class="key">Alt + X</span> 下一页。</li>
    </ul>

    <span class="sub-title">窗口与布局手势</span>
    <ul>
        <li><b>切换主界面</b>：按 <span class="key">Alt + W</span> 快速切换至主管理模式。</li>
        <li><b>侧边栏联动</b>：按 <span class="key">Ctrl + Q</span> 开关分类导航。支持 <b>拖拽列表项</b> 至侧边栏进行分类移动。</li>
        <li><b>置顶切换</b>：按 <span class="key">Alt + D</span> 切换窗口【始终最前】状态。</li>
    </ul>
</div>

<div class="section">
    <h2>三、主界面 (深度管理模式)</h2>
    <ul>
        <li><b>高级筛选面板</b> (<span class="key">Ctrl + G</span>)：支持类型（图片/链接/本地文件）、日期及评分的多维复合筛选。</li>
        <li><b>元数据/批量面板</b> (<span class="key">Ctrl + I</span>)：支持多选笔记后，一键批量修改标签。</li>
        <li><b>面板自由重组</b>：在各面板标题栏 <b>右键单击</b>，可选择【向左/向右移动】自定义布局顺序。</li>
        <li><b>分类管理</b>：侧边栏支持 <span class="key">Ctrl + Up/Down</span> 进行排序；<span class="key">Ctrl + Shift + Up/Down</span> 置顶/置底。</li>
    </ul>
</div>

<div class="section">
    <h2>四、编辑器与高级特性</h2>
    <ul>
        <li><b>扩展编辑</b>：在详情页 <b>左键双击标题栏</b>，可呼出无边框长标题编辑器。</li>
        <li><b>快捷保存</b>：编辑模式下 <span class="key">Ctrl + S</span> 立即保存修改；<span class="key">Ctrl + F</span> 开启内容内查找。</li>
        <li><b>自动化设置</b>：工具箱菜单中可开启【剪贴板自动归档】，捕获内容将自动归类至当前活跃分区。</li>
        <li><b>动态特效</b>：系统实时监听剪贴板，检测到新内容时将在鼠标位置触发【烟花动效】反馈。</li>
    </ul>
</div>

<div class="section">
    <h2>💡 进阶贴士</h2>
    <ul>
        <li><b>回收站保护</b>：<span class="key">Del</span> 进入回收站（可还原）；<span class="key">Ctrl + Shift + Del</span> 彻底销毁。</li>
        <li><b>多选模式</b>：列表支持标准的 <span class="key">Ctrl/Shift + 点击</span> 批量操作。</li>
    </ul>
</div>
<br/>
)html";
}
```

## 文件: `src/ui/HelpWindow.h`

```cpp
#ifndef HELPWINDOW_H
#define HELPWINDOW_H

#include "FramelessDialog.h"
#include <QScrollArea>
#include <QLabel>

class HelpWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit HelpWindow(QWidget* parent = nullptr);

private:
    void initUI();
    QString getHelpHtml();
};

#endif // HELPWINDOW_H
```

## 文件: `src/core/HotkeyManager.cpp`

```cpp
#include "HotkeyManager.h"
#include <QCoreApplication>
#include <QDebug>
#include <QSettings>

HotkeyManager& HotkeyManager::instance() {
    static HotkeyManager inst;
    return inst;
}

HotkeyManager::HotkeyManager(QObject* parent) : QObject(parent) {
    qApp->installNativeEventFilter(this);
}

HotkeyManager::~HotkeyManager() {
    // 退出时取消所有注册
}

bool HotkeyManager::registerHotkey(int id, uint modifiers, uint vk) {
#ifdef Q_OS_WIN
    if (RegisterHotKey(nullptr, id, modifiers, vk)) {
        return true;
    }
    
    QString keyDesc = QString("ID=%1").arg(id);
    if (id == 1) keyDesc = "Alt+Space (快速窗口)";
    else if (id == 2) keyDesc = "Ctrl+Shift+E (全局收藏)";
    else if (id == 3) keyDesc = "Ctrl+Alt+A (全局截屏)";
    else if (id == 4) keyDesc = "Ctrl+Shift+S (全局采集)";
    else if (id == 5) keyDesc = "Ctrl+Shift+L (全局锁定)";
    else if (id == 6) keyDesc = "Ctrl+Alt+Q (截图取文)";

    qWarning().noquote() << QString("[HotkeyManager] 注册热键失败: %1 (错误代码: %2). 该快捷键可能已被系统或其他软件占用。")
                            .arg(keyDesc).arg(GetLastError());
#endif
    return false;
}

void HotkeyManager::unregisterHotkey(int id) {
#ifdef Q_OS_WIN
    UnregisterHotKey(nullptr, id);
#endif
}

void HotkeyManager::reapplyHotkeys() {
    QSettings hotkeys("RapidNotes", "Hotkeys");
    
    // 注销旧热键
    unregisterHotkey(1);
    unregisterHotkey(2);
    unregisterHotkey(3);
    unregisterHotkey(4);
    unregisterHotkey(5);
    unregisterHotkey(6);
    
    // 注册新热键（带默认值）
    uint q_mods = hotkeys.value("quickWin_mods", 0x0001).toUInt();  // Alt
    uint q_vk   = hotkeys.value("quickWin_vk", 0x20).toUInt();     // Space
    registerHotkey(1, q_mods, q_vk);
    
    uint f_mods = hotkeys.value("favorite_mods", 0x0002 | 0x0004).toUInt(); // Ctrl+Shift
    uint f_vk   = hotkeys.value("favorite_vk", 0x45).toUInt();              // E
    registerHotkey(2, f_mods, f_vk);
    
    uint s_mods = hotkeys.value("screenshot_mods", 0x0002 | 0x0001).toUInt(); // Ctrl+Alt
    uint s_vk   = hotkeys.value("screenshot_vk", 0x41).toUInt();               // A
    registerHotkey(3, s_mods, s_vk);

    uint a_mods = hotkeys.value("acquire_mods", 0x0002 | 0x0004).toUInt();  // Ctrl+Shift
    uint a_vk   = hotkeys.value("acquire_vk", 0x53).toUInt();               // S
    registerHotkey(4, a_mods, a_vk);

    uint l_mods = hotkeys.value("lock_mods", 0x0002 | 0x0004).toUInt();     // Ctrl+Shift
    uint l_vk   = hotkeys.value("lock_vk", 0x4C).toUInt();                  // L
    registerHotkey(5, l_mods, l_vk);

    uint ocr_mods = hotkeys.value("ocr_mods", 0x0002 | 0x0001).toUInt();    // Ctrl+Alt
    uint ocr_vk   = hotkeys.value("ocr_vk", 0x51).toUInt();                 // Q
    registerHotkey(6, ocr_mods, ocr_vk);
    
    qDebug() << "[HotkeyManager] 热键配置已更新。";
}

bool HotkeyManager::nativeEventFilter(const QByteArray &eventType, void *message, qintptr *result) {
#ifdef Q_OS_WIN
    if (eventType == "windows_generic_MSG") {
        MSG* msg = static_cast<MSG*>(message);
        if (msg->message == WM_HOTKEY) {
            emit hotkeyPressed(static_cast<int>(msg->wParam));
            return true;
        }
    }
#endif
    return false;
}
```

## 文件: `src/core/HotkeyManager.h`

```cpp
#ifndef HOTKEYMANAGER_H
#define HOTKEYMANAGER_H

#include <QObject>
#include <QAbstractNativeEventFilter>

#ifdef Q_OS_WIN
#include <windows.h>
#endif

class HotkeyManager : public QObject, public QAbstractNativeEventFilter {
    Q_OBJECT
public:
    static HotkeyManager& instance();
    
    bool registerHotkey(int id, uint modifiers, uint vk);
    void unregisterHotkey(int id);
    void reapplyHotkeys();

    bool nativeEventFilter(const QByteArray &eventType, void *message, qintptr *result) override;

signals:
    void hotkeyPressed(int id);

private:
    HotkeyManager(QObject* parent = nullptr);
    ~HotkeyManager();
};

#endif // HOTKEYMANAGER_H
```

## 文件: `src/ui/IconHelper.h`

```cpp
#ifndef ICONHELPER_H
#define ICONHELPER_H

#include <QIcon>
#include <QMenu>
#include <QSvgRenderer>
#include <QPainter>
#include <QPixmap>
#include "SvgIcons.h"

class IconHelper {
public:
    static QIcon getIcon(const QString& name, const QString& color = "#cccccc", int size = 64) {
        if (!SvgIcons::icons.contains(name)) return QIcon();

        QString svgData = SvgIcons::icons[name];
        svgData.replace("currentColor", color);
        // 如果 svg 中没有 currentColor，强制替换所有可能的 stroke/fill 颜色（简易实现）
        // 这里假设 SVG 字符串格式标准，仅替换 stroke="currentColor" 或 fill="currentColor"
        // 实际上 Python 版是直接全量 replace "currentColor"

        QByteArray bytes = svgData.toUtf8();
        QSvgRenderer renderer(bytes);
        
        QPixmap pixmap(size, size);
        pixmap.fill(Qt::transparent);
        QPainter painter(&pixmap);
        renderer.render(&painter);
        
        QIcon icon;
        icon.addPixmap(pixmap, QIcon::Normal, QIcon::On);
        icon.addPixmap(pixmap, QIcon::Normal, QIcon::Off);
        icon.addPixmap(pixmap, QIcon::Active, QIcon::On);
        icon.addPixmap(pixmap, QIcon::Active, QIcon::Off);
        icon.addPixmap(pixmap, QIcon::Selected, QIcon::On);
        icon.addPixmap(pixmap, QIcon::Selected, QIcon::Off);
        return icon;
    }

    // 统一设置 QMenu 样式,移除系统原生直角阴影
    static void setupMenu(QMenu* menu) {
        if (!menu) return;
        // 移除系统原生阴影,使用自定义圆角
        menu->setAttribute(Qt::WA_TranslucentBackground);
        menu->setWindowFlags(menu->windowFlags() | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint);
    }
};

#endif // ICONHELPER_H
```

## 文件: `src/core/IPlatformSystem.h`

```cpp
#ifndef IPLATFORMSYSTEM_H
#define IPLATFORMSYSTEM_H

#include <QString>
#include <QImage>

class IPlatformSystem {
public:
    virtual ~IPlatformSystem() = default;

    // 进程与窗口
    virtual bool isBrowserActive() = 0;
    virtual QString getForegroundAppPath() = 0;

    // 输入模拟
    virtual void simulateCopy() = 0;
    virtual void simulateSelectAll() = 0;
    virtual void simulateKeyStroke(int vk, bool alt = false, bool ctrl = false, bool shift = false) = 0;

    // 系统热键与钩子底层支持 (可选，如果想彻底隔离 HotkeyManager)
    virtual bool registerGlobalHotkey(int id, uint modifiers, uint vk) = 0;
    virtual bool unregisterGlobalHotkey(int id) = 0;
};

#endif // IPLATFORMSYSTEM_H
```

## 文件: `src/core/KeyboardHook.cpp`

```cpp
#include "KeyboardHook.h"
#include <QDebug>

#ifdef Q_OS_WIN
HHOOK g_hHook = nullptr;
#endif

KeyboardHook& KeyboardHook::instance() {
    static KeyboardHook inst;
    return inst;
}

KeyboardHook::KeyboardHook() {}

KeyboardHook::~KeyboardHook() {
    stop();
}

void KeyboardHook::start() {
#ifdef Q_OS_WIN
    if (g_hHook) return;
    g_hHook = SetWindowsHookEx(WH_KEYBOARD_LL, HookProc, GetModuleHandle(NULL), 0);
    if (g_hHook) {
        m_active = true;
        qDebug() << "Keyboard hook started";
    }
#endif
}

void KeyboardHook::stop() {
#ifdef Q_OS_WIN
    if (g_hHook) {
        UnhookWindowsHookEx(g_hHook);
        g_hHook = nullptr;
        m_active = false;
        qDebug() << "Keyboard hook stopped";
    }
#endif
}

#ifdef Q_OS_WIN
LRESULT CALLBACK KeyboardHook::HookProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode == HC_ACTION) {
        KBDLLHOOKSTRUCT* pKey = (KBDLLHOOKSTRUCT*)lParam;
        
        // 忽略所有模拟按键，防止无限循环
        if (pKey->flags & LLKHF_INJECTED) {
            return CallNextHookEx(g_hHook, nCode, wParam, lParam);
        }

        bool isKeyDown = (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN);

        // 监听回车键/Ctrl+回车键 (仅限非本应用窗口)
        if (isKeyDown && pKey->vkCode == VK_RETURN) {
            HWND foreground = GetForegroundWindow();
            DWORD pid;
            GetWindowThreadProcessId(foreground, &pid);
            if (pid != GetCurrentProcessId()) {
                bool ctrl = (GetKeyState(VK_CONTROL) & 0x8000);
                bool shift = (GetKeyState(VK_SHIFT) & 0x8000);
                bool alt = (GetKeyState(VK_MENU) & 0x8000);
                emit KeyboardHook::instance().enterPressedInOtherApp(ctrl, shift, alt);
                return 1; // 拦截回车，交给处理器稍后重新模拟
            }
        }

        // 工具箱数字拦截 (仅在使能时触发)
        if (KeyboardHook::instance().m_digitInterceptEnabled) {
            if (pKey->vkCode >= 0x30 && pKey->vkCode <= 0x39) {
                if (isKeyDown) {
                    int digit = pKey->vkCode - 0x30;
                    qDebug() << "Digit pressed:" << digit;
                    emit KeyboardHook::instance().digitPressed(digit);
                }
                // 按下和弹起都拦截
                return 1;
            }
        }
    }
    return CallNextHookEx(g_hHook, nCode, wParam, lParam);
}
#endif
```

## 文件: `src/core/KeyboardHook.h`

```cpp
#ifndef KEYBOARDHOOK_H
#define KEYBOARDHOOK_H

#include <QObject>
#ifdef Q_OS_WIN
#include <windows.h>
#endif

class KeyboardHook : public QObject {
    Q_OBJECT
public:
    static KeyboardHook& instance();
    void start();
    void stop();
    bool isActive() const { return m_active; }

    void setDigitInterceptEnabled(bool enabled) { m_digitInterceptEnabled = enabled; }

signals:
    void digitPressed(int digit);
    void f4PressedInExplorer();
    void enterPressedInOtherApp(bool ctrl, bool shift, bool alt);

private:
    bool m_digitInterceptEnabled = false;
    KeyboardHook();
    ~KeyboardHook();
    bool m_active = false;

#ifdef Q_OS_WIN
    static LRESULT CALLBACK HookProc(int nCode, WPARAM wParam, LPARAM lParam);
#endif
};

#endif // KEYBOARDHOOK_H
```

## 文件: `src/ui/KeywordSearchWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "KeywordSearchWindow.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include "../core/ShortcutManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QFileDialog>
#include <QDirIterator>
#include <utility>
#include <QTextStream>
#include <QRegularExpression>
#include <QDateTime>
#include <QProcess>
#include <QDesktopServices>
#include <QUrl>
#include <QtConcurrent>
#include <QScrollBar>
#include <QToolTip>
#include <QSettings>
#include <QMenu>
#include <QSet>
#include <QMap>
#include <QFileInfo>
#include <QGraphicsDropShadowEffect>
#include <QPropertyAnimation>
#include <QScrollArea>
#include <QCheckBox>
#include <QProgressBar>
#include <QTextBrowser>
#include <QToolButton>
#include <QApplication>
#include <QClipboard>

#include <QMimeData>
#include <QDragEnterEvent>
#include <QDropEvent>

// ----------------------------------------------------------------------------
// 合并逻辑相关常量与辅助函数 (复刻自 FileSearchWindow)
// ----------------------------------------------------------------------------
static const QSet<QString> SUPPORTED_EXTENSIONS = {
    ".py", ".pyw", ".cpp", ".cc", ".cxx", ".c", ".h", ".hpp", ".hxx",
    ".java", ".js", ".jsx", ".ts", ".tsx", ".cs", ".go", ".rs", ".swift",
    ".kt", ".kts", ".php", ".rb", ".lua", ".r", ".m", ".scala", ".sh",
    ".bash", ".zsh", ".ps1", ".bat", ".cmd", ".html", ".htm", ".css",
    ".scss", ".sass", ".less", ".xml", ".svg", ".vue", ".json", ".yaml",
    ".yml", ".toml", ".ini", ".cfg", ".conf", ".env", ".properties",
    ".cmake", ".gradle", ".make", ".mk", ".dockerfile", ".md", ".markdown",
    ".txt", ".rst", ".qml", ".qrc", ".qss", ".ui", ".sql", ".graphql",
    ".gql", ".proto", ".asm", ".s", ".v", ".vh", ".vhdl", ".vhd"
};

static const QSet<QString> SPECIAL_FILENAMES = {
    "Makefile", "makefile", "Dockerfile", "dockerfile", "CMakeLists.txt",
    "Rakefile", "Gemfile", ".gitignore", ".dockerignore", ".editorconfig",
    ".eslintrc", ".prettierrc"
};

static QString getFileLanguage(const QString& filePath) {
    QFileInfo fi(filePath);
    QString basename = fi.fileName();
    QString ext = "." + fi.suffix().toLower();
    
    static const QMap<QString, QString> specialMap = {
        {"Makefile", "makefile"}, {"makefile", "makefile"},
        {"Dockerfile", "dockerfile"}, {"dockerfile", "dockerfile"},
        {"CMakeLists.txt", "cmake"}
    };
    if (specialMap.contains(basename)) return specialMap[basename];

    static const QMap<QString, QString> extMap = {
        {".py", "python"}, {".pyw", "python"}, {".cpp", "cpp"}, {".cc", "cpp"},
        {".cxx", "cpp"}, {".c", "c"}, {".h", "cpp"}, {".hpp", "cpp"},
        {".hxx", "cpp"}, {".java", "java"}, {".js", "javascript"},
        {".jsx", "jsx"}, {".ts", "typescript"}, {".tsx", "tsx"},
        {".cs", "csharp"}, {".go", "go"}, {".rs", "rust"}, {".swift", "swift"},
        {".kt", "kotlin"}, {".kts", "kotlin"}, {".php", "php"}, {".rb", "ruby"},
        {".lua", "lua"}, {".r", "r"}, {".m", "objectivec"}, {".scala", "scala"},
        {".sh", "bash"}, {".bash", "bash"}, {".zsh", "zsh"}, {".ps1", "powershell"},
        {".bat", "batch"}, {".cmd", "batch"}, {".html", "html"}, {".htm", "html"},
        {".css", "css"}, {".scss", "scss"}, {".sass", "sass"}, {".less", "less"},
        {".xml", "xml"}, {".svg", "svg"}, {".vue", "vue"}, {".json", "json"},
        {".yaml", "yaml"}, {".yml", "yaml"}, {".toml", "toml"}, {".ini", "ini"},
        {".cfg", "ini"}, {".conf", "conf"}, {".env", "bash"},
        {".properties", "properties"}, {".cmake", "cmake"}, {".gradle", "gradle"},
        {".make", "makefile"}, {".mk", "makefile"}, {".dockerfile", "dockerfile"},
        {".md", "markdown"}, {".markdown", "markdown"}, {".txt", "text"},
        {".rst", "restructuredtext"}, {".qml", "qml"}, {".qrc", "xml"},
        {".qss", "css"}, {".ui", "xml"}, {".sql", "sql"}, {".graphql", "graphql"},
        {".gql", "graphql"}, {".proto", "protobuf"}, {".asm", "asm"},
        {".s", "asm"}, {".v", "verilog"}, {".vh", "verilog"}, {".vhdl", "vhdl"},
        {".vhd", "vhdl"}
    };
    return extMap.value(ext, ext.mid(1).isEmpty() ? "text" : ext.mid(1));
}

static bool isSupportedFile(const QString& filePath) {
    QFileInfo fi(filePath);
    if (SPECIAL_FILENAMES.contains(fi.fileName())) return true;
    return SUPPORTED_EXTENSIONS.contains("." + fi.suffix().toLower());
}

// ----------------------------------------------------------------------------
// Sidebar ListWidget subclass for Drag & Drop
// ----------------------------------------------------------------------------
class KeywordSidebarListWidget : public QListWidget {
    Q_OBJECT
public:
    explicit KeywordSidebarListWidget(QWidget* parent = nullptr) : QListWidget(parent) {
        setAcceptDrops(true);
    }
signals:
    void folderDropped(const QString& path);
protected:
    void dragEnterEvent(QDragEnterEvent* event) override {
        if (event->mimeData()->hasUrls() || event->mimeData()->hasText()) {
            event->acceptProposedAction();
        }
    }
    void dragMoveEvent(QDragMoveEvent* event) override {
        event->acceptProposedAction();
    }
    void dropEvent(QDropEvent* event) override {
        QString path;
        if (event->mimeData()->hasUrls()) {
            path = event->mimeData()->urls().at(0).toLocalFile();
        } else if (event->mimeData()->hasText()) {
            path = event->mimeData()->text();
        }
        
        if (!path.isEmpty() && QDir(path).exists()) {
            emit folderDropped(path);
            event->acceptProposedAction();
        }
    }
};

// ----------------------------------------------------------------------------
// KeywordSearchHistory 相关辅助类 (复刻 FileSearchHistoryPopup 逻辑)
// ----------------------------------------------------------------------------
class KeywordChip : public QFrame {
    Q_OBJECT
public:
    KeywordChip(const QString& text, QWidget* parent = nullptr) : QFrame(parent), m_text(text) {
        setAttribute(Qt::WA_StyledBackground);
        setCursor(Qt::PointingHandCursor);
        setObjectName("KeywordChip");
        
        auto* layout = new QHBoxLayout(this);
        layout->setContentsMargins(10, 6, 10, 6);
        layout->setSpacing(10);
        
        auto* lbl = new QLabel(text);
        lbl->setStyleSheet("border: none; background: transparent; color: #DDD; font-size: 13px;");
        layout->addWidget(lbl);
        layout->addStretch();
        
        auto* btnDel = new QPushButton();
        btnDel->setIcon(IconHelper::getIcon("close", "#666", 16));
        btnDel->setIconSize(QSize(10, 10));
        btnDel->setFixedSize(16, 16);
        btnDel->setCursor(Qt::PointingHandCursor);
        btnDel->setStyleSheet(
            "QPushButton { background-color: transparent; border-radius: 4px; padding: 0px; }"
            "QPushButton:hover { background-color: #E74C3C; }"
        );
        
        connect(btnDel, &QPushButton::clicked, this, [this](){ emit deleted(m_text); });
        layout->addWidget(btnDel);

        setStyleSheet(
            "#KeywordChip { background-color: transparent; border: none; border-radius: 4px; }"
            "#KeywordChip:hover { background-color: #3E3E42; }"
        );
    }
    
    void mousePressEvent(QMouseEvent* e) override { 
        if(e->button() == Qt::LeftButton) emit clicked(m_text); 
        QFrame::mousePressEvent(e);
    }

signals:
    void clicked(const QString& text);
    void deleted(const QString& text);
private:
    QString m_text;
};

class KeywordSearchHistoryPopup : public QWidget {
    Q_OBJECT
public:
    enum Type { Path, Keyword, Replace };

    explicit KeywordSearchHistoryPopup(KeywordSearchWidget* widget, QLineEdit* edit, Type type) 
        : QWidget(widget->window(), Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint) 
    {
        m_widget = widget;
        m_edit = edit;
        m_type = type;
        setAttribute(Qt::WA_TranslucentBackground);
        
        auto* rootLayout = new QVBoxLayout(this);
        rootLayout->setContentsMargins(12, 12, 12, 12);
        
        auto* container = new QFrame();
        container->setObjectName("PopupContainer");
        container->setStyleSheet(
            "#PopupContainer { background-color: #252526; border: 1px solid #444; border-radius: 10px; }"
        );
        rootLayout->addWidget(container);

        auto* shadow = new QGraphicsDropShadowEffect(container);
        shadow->setBlurRadius(20); shadow->setXOffset(0); shadow->setYOffset(5);
        shadow->setColor(QColor(0, 0, 0, 120));
        container->setGraphicsEffect(shadow);

        auto* layout = new QVBoxLayout(container);
        layout->setContentsMargins(12, 12, 12, 12);
        layout->setSpacing(10);

        auto* top = new QHBoxLayout();
        auto* icon = new QLabel();
        icon->setPixmap(IconHelper::getIcon("clock", "#888").pixmap(14, 14));
        icon->setStyleSheet("border: none; background: transparent;");
        top->addWidget(icon);

        QString titleStr = "最近记录";
        if (m_type == Path) titleStr = "最近扫描路径";
        else if (m_type == Keyword) titleStr = "最近查找内容";
        else if (m_type == Replace) titleStr = "最近替换内容";

        auto* title = new QLabel(titleStr);
        title->setStyleSheet("color: #888; font-weight: bold; font-size: 11px; background: transparent; border: none;");
        top->addWidget(title);
        top->addStretch();
        auto* clearBtn = new QPushButton("清空");
        clearBtn->setCursor(Qt::PointingHandCursor);
        clearBtn->setStyleSheet("QPushButton { background: transparent; color: #666; border: none; font-size: 11px; } QPushButton:hover { color: #E74C3C; }");
        connect(clearBtn, &QPushButton::clicked, [this](){
            clearAllHistory();
            refreshUI();
        });
        top->addWidget(clearBtn);
        layout->addLayout(top);

        auto* scroll = new QScrollArea();
        scroll->setWidgetResizable(true);
        scroll->setStyleSheet(
            "QScrollArea { background-color: transparent; border: none; }"
            "QScrollArea > QWidget > QWidget { background-color: transparent; }"
        );
        scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

        m_chipsWidget = new QWidget();
        m_chipsWidget->setStyleSheet("background-color: transparent;");
        m_vLayout = new QVBoxLayout(m_chipsWidget);
        m_vLayout->setContentsMargins(0, 0, 0, 0);
        m_vLayout->setSpacing(2);
        m_vLayout->addStretch();
        scroll->setWidget(m_chipsWidget);
        layout->addWidget(scroll);

        m_opacityAnim = new QPropertyAnimation(this, "windowOpacity");
        m_opacityAnim->setDuration(200);
    }

    void clearAllHistory() {
        QString key = "keywordList";
        if (m_type == Path) key = "pathList";
        else if (m_type == Replace) key = "replaceList";

        QSettings settings("RapidNotes", "KeywordSearchHistory");
        settings.setValue(key, QStringList());
    }

    void removeEntry(const QString& text) {
        QString key = "keywordList";
        if (m_type == Path) key = "pathList";
        else if (m_type == Replace) key = "replaceList";

        QSettings settings("RapidNotes", "KeywordSearchHistory");
        QStringList history = settings.value(key).toStringList();
        history.removeAll(text);
        settings.setValue(key, history);
    }

    QStringList getHistory() const {
        QString key = "keywordList";
        if (m_type == Path) key = "pathList";
        else if (m_type == Replace) key = "replaceList";

        QSettings settings("RapidNotes", "KeywordSearchHistory");
        return settings.value(key).toStringList();
    }

    void refreshUI() {
        QLayoutItem* item;
        while ((item = m_vLayout->takeAt(0))) {
            if(item->widget()) item->widget()->deleteLater();
            delete item;
        }
        m_vLayout->addStretch();
        
        QStringList history = getHistory();
        if(history.isEmpty()) {
            auto* lbl = new QLabel("暂无历史记录");
            lbl->setAlignment(Qt::AlignCenter);
            lbl->setStyleSheet("color: #555; font-style: italic; margin: 20px; border: none;");
            m_vLayout->insertWidget(0, lbl);
        } else {
            for(const QString& val : history) {
                auto* chip = new KeywordChip(val);
                chip->setFixedHeight(32);
                connect(chip, &KeywordChip::clicked, this, [this](const QString& v){ 
                    m_edit->setText(v);
                    close(); 
                });
                connect(chip, &KeywordChip::deleted, this, [this](const QString& v){ 
                    removeEntry(v);
                    refreshUI(); 
                });
                m_vLayout->insertWidget(m_vLayout->count() - 1, chip);
            }
        }
        
        int targetWidth = m_edit->width();
        int contentHeight = qMin(410, (int)history.size() * 34 + 60);
        resize(targetWidth + 24, contentHeight);
    }

    void showAnimated() {
        refreshUI();
        QPoint pos = m_edit->mapToGlobal(QPoint(0, m_edit->height()));
        move(pos.x() - 12, pos.y() - 7);
        setWindowOpacity(0);
        show();
        m_opacityAnim->setStartValue(0);
        m_opacityAnim->setEndValue(1);
        m_opacityAnim->start();
    }

private:
    KeywordSearchWidget* m_widget;
    QLineEdit* m_edit;
    Type m_type;
    QWidget* m_chipsWidget;
    QVBoxLayout* m_vLayout;
    QPropertyAnimation* m_opacityAnim;
};

// ----------------------------------------------------------------------------
// KeywordCollectionListWidget 实现 (复刻自 FileSearchWindow)
// ----------------------------------------------------------------------------
KeywordCollectionListWidget::KeywordCollectionListWidget(QWidget* parent) : QListWidget(parent) {
    setAcceptDrops(true);
    setSelectionMode(QAbstractItemView::ExtendedSelection);
}

void KeywordCollectionListWidget::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls() || event->mimeData()->hasText()) {
        event->acceptProposedAction();
    }
}

void KeywordCollectionListWidget::dragMoveEvent(QDragMoveEvent* event) {
    event->acceptProposedAction();
}

void KeywordCollectionListWidget::dropEvent(QDropEvent* event) {
    QStringList paths;
    if (event->mimeData()->hasUrls()) {
        for (const QUrl& url : event->mimeData()->urls()) {
            QString p = url.toLocalFile();
            if (!p.isEmpty() && QFileInfo(p).isFile()) paths << p;
        }
    } else if (event->mimeData()->hasText()) {
        QStringList texts = event->mimeData()->text().split("\n", Qt::SkipEmptyParts);
        for (const QString& t : texts) {
            QString p = t.trimmed();
            if (!p.isEmpty() && QFileInfo(p).isFile()) paths << p;
        }
    }
    
    if (!paths.isEmpty()) {
        emit filesDropped(paths);
        event->acceptProposedAction();
    } else if (event->source() && event->source() != this) {
        QListWidget* sourceList = qobject_cast<QListWidget*>(event->source());
        if (sourceList) {
            QStringList sourcePaths;
            for (auto* item : sourceList->selectedItems()) {
                QString p = item->data(Qt::UserRole).toString();
                if (!p.isEmpty()) sourcePaths << p;
            }
            if (!sourcePaths.isEmpty()) {
                emit filesDropped(sourcePaths);
                event->acceptProposedAction();
            }
        }
    }
}

// ----------------------------------------------------------------------------
// KeywordResultItem: 用于在列表中左右对齐显示结果
// ----------------------------------------------------------------------------
class KeywordResultItem : public QWidget {
    Q_OBJECT
public:
    KeywordResultItem(const QString& name, const QString& badge, const QColor& badgeColor, QWidget* parent = nullptr) 
        : QWidget(parent) 
    {
        auto* layout = new QHBoxLayout(this);
        layout->setContentsMargins(10, 0, 10, 0);
        layout->setSpacing(10);

        auto* nameLabel = new QLabel(name);
        nameLabel->setStyleSheet("color: #CCCCCC; font-size: 13px; border: none; background: transparent;");
        layout->addWidget(nameLabel);

        layout->addStretch();

        auto* badgeLabel = new QLabel(badge);
        badgeLabel->setFixedWidth(120); // 扩大感应范围，鼠标进入此区域即显示提示
        badgeLabel->setAlignment(Qt::AlignRight | Qt::AlignVCenter);
        badgeLabel->setStyleSheet(QString("color: %1; font-size: 12px; font-weight: bold; border: none; background: transparent;").arg(badgeColor.name()));
        
        // 为右侧数字或状态添加悬浮提示
        if (badge == "已修改") {
            badgeLabel->setToolTip("文件已修改");
        } else if (badge == "已恢复") {
            badgeLabel->setToolTip("文件已恢复");
        } else {
            badgeLabel->setToolTip("匹配次数");
        }

        layout->addWidget(badgeLabel);
    }
protected:
    // 忽略鼠标事件以便让底层的 QListWidget 处理选中和点击
    void mousePressEvent(QMouseEvent* event) override { event->ignore(); }
    void mouseReleaseEvent(QMouseEvent* event) override { event->ignore(); }
    void mouseDoubleClickEvent(QMouseEvent* event) override { event->ignore(); }
};

// ----------------------------------------------------------------------------
// KeywordSearchWidget 实现
// ----------------------------------------------------------------------------
KeywordSearchWidget::KeywordSearchWidget(QWidget* parent) : QWidget(parent) {
    m_ignoreDirs = {".git", ".svn", ".idea", ".vscode", "__pycache__", "node_modules", "dist", "build", "venv"};
    setupStyles();
    initUI();
    loadFavorites();
    loadCollection();
}

KeywordSearchWidget::~KeywordSearchWidget() {
}

void KeywordSearchWidget::setupStyles() {
    setStyleSheet(R"(
        QWidget {
            font-family: "Microsoft YaHei", "Segoe UI", sans-serif;
            font-size: 14px;
            color: #E0E0E0;
            outline: none;
        }
        QSplitter::handle {
            background-color: #333;
        }
        QListWidget {
            background-color: #252526; 
            border: 1px solid #333333;
            border-radius: 6px;
            padding: 4px;
        }
        QListWidget::item {
            min-height: 20px;
            max-height: 20px;
            padding-left: 8px;
            border-radius: 4px;
            color: #CCCCCC;
        }
        QListWidget::item:selected {
            background-color: #37373D;
            border-left: 3px solid #007ACC;
            color: #FFFFFF;
        }
        #SidebarList::item:selected {
            background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #007ACC, stop:0.015 #007ACC, stop:0.016 #37373D, stop:1 #37373D);
            color: #FFFFFF;
            border-radius: 4px;
        }
        QListWidget::item:hover {
            background-color: #2A2D2E;
        }
        QLineEdit {
            background-color: #333333;
            border: 1px solid #444444;
            color: #FFFFFF;
            border-radius: 6px;
            padding: 8px;
            selection-background-color: #264F78;
        }
        QLineEdit:focus {
            border: 1px solid #007ACC;
            background-color: #2D2D2D;
        }
        QScrollBar:vertical {
            background: transparent;
            width: 8px;
            margin: 0px;
        }
        QScrollBar::handle:vertical {
            background: #555555;
            min-height: 20px;
            border-radius: 4px;
        }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
            height: 0px;
        }
    )");
}

void KeywordSearchWidget::initUI() {
    auto* mainLayout = new QHBoxLayout(this);
    mainLayout->setContentsMargins(10, 10, 10, 10);
    mainLayout->setSpacing(0);

    auto* splitter = new QSplitter(Qt::Horizontal);
    mainLayout->addWidget(splitter);

    // --- 左侧边栏 ---
    auto* sidebarWidget = new QWidget();
    auto* sidebarLayout = new QVBoxLayout(sidebarWidget);
    sidebarLayout->setContentsMargins(0, 0, 10, 0);
    sidebarLayout->setSpacing(10);

    auto* headerLayout = new QHBoxLayout();
    headerLayout->setSpacing(5);
    auto* sidebarIcon = new QLabel();
    sidebarIcon->setPixmap(IconHelper::getIcon("folder", "#888").pixmap(14, 14));
    sidebarIcon->setStyleSheet("border: none; background: transparent;");
    headerLayout->addWidget(sidebarIcon);

    auto* sidebarHeader = new QLabel("收藏夹 (可拖入)");
    sidebarHeader->setStyleSheet("color: #888; font-weight: bold; font-size: 12px; border: none; background: transparent;");
    headerLayout->addWidget(sidebarHeader);
    headerLayout->addStretch();
    sidebarLayout->addLayout(headerLayout);

    m_sidebar = new KeywordSidebarListWidget();
    m_sidebar->setObjectName("SidebarList");
    m_sidebar->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_sidebar->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_sidebar->setMinimumWidth(200);
    m_sidebar->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(static_cast<KeywordSidebarListWidget*>(m_sidebar), &KeywordSidebarListWidget::folderDropped, this, &KeywordSearchWidget::addFavorite);
    connect(m_sidebar, &QListWidget::itemClicked, this, &KeywordSearchWidget::onSidebarItemClicked);
    connect(m_sidebar, &QListWidget::customContextMenuRequested, this, &KeywordSearchWidget::showSidebarContextMenu);
    sidebarLayout->addWidget(m_sidebar);

    auto* btnAddFav = new QPushButton("收藏当前路径");
    btnAddFav->setFixedHeight(32);
    btnAddFav->setCursor(Qt::PointingHandCursor);
    btnAddFav->setStyleSheet(
        "QPushButton { background-color: #2D2D30; border: 1px solid #444; color: #AAA; border-radius: 4px; font-size: 12px; }"
        "QPushButton:hover { background-color: #3E3E42; color: #FFF; border-color: #666; }"
    );
    connect(btnAddFav, &QPushButton::clicked, this, [this](){
        QString p = m_pathEdit->text().trimmed();
        if (QDir(p).exists()) addFavorite(p);
    });
    sidebarLayout->addWidget(btnAddFav);

    splitter->addWidget(sidebarWidget);

    // --- 中间内容区域 ---
    auto* midWidget = new QWidget();
    auto* midLayout = new QVBoxLayout(midWidget);
    midLayout->setContentsMargins(10, 0, 10, 0);
    midLayout->setSpacing(15);

    // --- 配置区域 ---
    auto* configGroup = new QWidget();
    auto* configLayout = new QGridLayout(configGroup);
    configLayout->setContentsMargins(0, 0, 0, 0);
    configLayout->setHorizontalSpacing(10); 
    configLayout->setVerticalSpacing(10);
    configLayout->setColumnStretch(1, 1);
    configLayout->setColumnStretch(0, 0);
    configLayout->setColumnStretch(2, 0);

    auto createLabel = [](const QString& text) {
        auto* lbl = new QLabel(text);
        lbl->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);
        lbl->setStyleSheet("color: #AAA; font-weight: bold; border: none; background: transparent;");
        return lbl;
    };

    auto setEditStyle = [](QLineEdit* edit) {
        edit->setClearButtonEnabled(true);
        edit->setStyleSheet(
            "QLineEdit { background: #252526; border: 1px solid #333; border-radius: 4px; padding: 6px; color: #EEE; }"
            "QLineEdit:focus { border-color: #007ACC; }"
        );
    };

    // 1. 搜索目录
    configLayout->addWidget(createLabel("搜索目录:"), 0, 0);
    m_pathEdit = new ClickableLineEdit();
    m_pathEdit->setPlaceholderText("选择搜索根目录 (双击查看历史)...");
    setEditStyle(m_pathEdit);
    connect(m_pathEdit, &QLineEdit::returnPressed, this, &KeywordSearchWidget::onSearch);
    connect(m_pathEdit, &ClickableLineEdit::doubleClicked, this, &KeywordSearchWidget::onShowHistory);
    configLayout->addWidget(m_pathEdit, 0, 1);

    auto* browseBtn = new QPushButton();
    browseBtn->setFixedSize(38, 32);
    browseBtn->setIcon(IconHelper::getIcon("folder", "#EEE", 18));
    browseBtn->setToolTip("浏览文件夹");
    browseBtn->setAutoDefault(false);
    browseBtn->setCursor(Qt::PointingHandCursor);
    browseBtn->setStyleSheet("QPushButton { background: #3E3E42; border: none; border-radius: 4px; } QPushButton:hover { background: #4E4E52; }");
    connect(browseBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onBrowseFolder);
    configLayout->addWidget(browseBtn, 0, 2);

    // 2. 文件过滤
    configLayout->addWidget(createLabel("文件过滤:"), 1, 0);
    m_filterEdit = new QLineEdit();
    m_filterEdit->setPlaceholderText("例如: *.py, *.txt (留空则扫描所有文本文件)");
    setEditStyle(m_filterEdit);
    connect(m_filterEdit, &QLineEdit::returnPressed, this, &KeywordSearchWidget::onSearch);
    configLayout->addWidget(m_filterEdit, 1, 1, 1, 2);

    // 3. 查找内容
    configLayout->addWidget(createLabel("查找内容:"), 2, 0);
    m_searchEdit = new ClickableLineEdit();
    m_searchEdit->setPlaceholderText("输入要查找的内容 (双击查看历史)...");
    setEditStyle(m_searchEdit);
    connect(m_searchEdit, &QLineEdit::returnPressed, this, &KeywordSearchWidget::onSearch);
    connect(m_searchEdit, &ClickableLineEdit::doubleClicked, this, &KeywordSearchWidget::onShowHistory);
    configLayout->addWidget(m_searchEdit, 2, 1);

    // 4. 替换内容
    configLayout->addWidget(createLabel("替换内容:"), 3, 0);
    m_replaceEdit = new ClickableLineEdit();
    m_replaceEdit->setPlaceholderText("替换为 (双击查看历史)...");
    setEditStyle(m_replaceEdit);
    connect(m_replaceEdit, &QLineEdit::returnPressed, this, &KeywordSearchWidget::onSearch);
    connect(m_replaceEdit, &ClickableLineEdit::doubleClicked, this, &KeywordSearchWidget::onShowHistory);
    configLayout->addWidget(m_replaceEdit, 3, 1);

    // 交换按钮 (跨越查找和替换行)
    auto* swapBtn = new QPushButton();
    swapBtn->setFixedSize(32, 74); 
    swapBtn->setCursor(Qt::PointingHandCursor);
    swapBtn->setToolTip("交换查找与替换内容");
    swapBtn->setIcon(IconHelper::getIcon("swap", "#AAA", 20));
    swapBtn->setAutoDefault(false);
    swapBtn->setStyleSheet("QPushButton { background: #3E3E42; border: none; border-radius: 4px; } QPushButton:hover { background: #4E4E52; }");
    connect(swapBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onSwapSearchReplace);
    configLayout->addWidget(swapBtn, 2, 2, 2, 1);

    // 选项
    m_caseCheck = new QCheckBox("区分大小写");
    m_caseCheck->setStyleSheet("QCheckBox { color: #AAA; }");
    configLayout->addWidget(m_caseCheck, 4, 1, 1, 2);

    midLayout->addWidget(configGroup);

    // --- 按钮区域 ---
    auto* btnLayout = new QHBoxLayout();
    auto* searchBtn = new QPushButton(" 智能搜索");
    searchBtn->setAutoDefault(false);
    searchBtn->setIcon(IconHelper::getIcon("find_keyword", "#FFF", 16));
    searchBtn->setStyleSheet("QPushButton { background: #007ACC; border: none; border-radius: 4px; padding: 8px 20px; color: #FFF; font-weight: bold; } QPushButton:hover { background: #0098FF; }");
    connect(searchBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onSearch);

    auto* replaceBtn = new QPushButton(" 执行替换");
    replaceBtn->setAutoDefault(false);
    replaceBtn->setIcon(IconHelper::getIcon("edit", "#FFF", 16));
    replaceBtn->setStyleSheet("QPushButton { background: #D32F2F; border: none; border-radius: 4px; padding: 8px 20px; color: #FFF; font-weight: bold; } QPushButton:hover { background: #F44336; }");
    connect(replaceBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onReplace);

    auto* undoBtn = new QPushButton(" 撤销替换");
    undoBtn->setAutoDefault(false);
    undoBtn->setIcon(IconHelper::getIcon("undo", "#EEE", 16));
    undoBtn->setStyleSheet("QPushButton { background: #3E3E42; border: none; border-radius: 4px; padding: 8px 20px; color: #EEE; } QPushButton:hover { background: #4E4E52; }");
    connect(undoBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onUndo);

    auto* clearBtn = new QPushButton(" 清空日志");
    clearBtn->setAutoDefault(false);
    clearBtn->setIcon(IconHelper::getIcon("trash", "#EEE", 16));
    clearBtn->setStyleSheet("QPushButton { background: #3E3E42; border: none; border-radius: 4px; padding: 8px 20px; color: #EEE; } QPushButton:hover { background: #4E4E52; }");
    connect(clearBtn, &QPushButton::clicked, this, &KeywordSearchWidget::onClearLog);

    btnLayout->addWidget(searchBtn);
    btnLayout->addWidget(replaceBtn);
    btnLayout->addWidget(undoBtn);
    btnLayout->addWidget(clearBtn);
    btnLayout->addStretch();
    midLayout->addLayout(btnLayout);

    // --- 结果列表展示区域 ---
    auto* listHeaderLayout = new QHBoxLayout();
    auto* listTitle = new QLabel("搜索结果");
    listTitle->setStyleSheet("color: #888; font-size: 11px; font-weight: bold; border: none; background: transparent;");
    listHeaderLayout->addWidget(listTitle);
    listHeaderLayout->addStretch();
    
    auto* btnCopyAll = new QToolButton();
    btnCopyAll->setIcon(IconHelper::getIcon("copy", "#1abc9c", 14));
    btnCopyAll->setToolTip("复制所有结果的路径");
    btnCopyAll->setFixedSize(20, 20);
    btnCopyAll->setCursor(Qt::PointingHandCursor);
    btnCopyAll->setStyleSheet("QToolButton { border: none; background: transparent; padding: 2px; }"
                               "QToolButton:hover { background-color: #3E3E42; border-radius: 4px; }");
    connect(btnCopyAll, &QToolButton::clicked, this, &KeywordSearchWidget::copySelectedPaths);
    listHeaderLayout->addWidget(btnCopyAll);
    midLayout->addLayout(listHeaderLayout);

    m_resultList = new QListWidget();
    m_resultList->setObjectName("FileList");
    m_resultList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_resultList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_resultList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    m_resultList->setContextMenuPolicy(Qt::CustomContextMenu);
    m_resultList->setDragEnabled(true);
    m_resultList->setDragDropMode(QAbstractItemView::DragOnly);
    connect(m_resultList, &QListWidget::customContextMenuRequested, this, &KeywordSearchWidget::showResultContextMenu);
    midLayout->addWidget(m_resultList, 1);

    // --- 状态栏 ---
    auto* statusLayout = new QVBoxLayout();
    m_progressBar = new QProgressBar();
    m_progressBar->setFixedHeight(4);
    m_progressBar->setTextVisible(false);
    m_progressBar->setStyleSheet("QProgressBar { background: #252526; border: none; } QProgressBar::chunk { background: #007ACC; }");
    m_progressBar->hide();
    
    m_statusLabel = new QLabel("就绪");
    m_statusLabel->setStyleSheet("color: #888; font-size: 11px;");
    
    statusLayout->addWidget(m_progressBar);
    statusLayout->addWidget(m_statusLabel);
    midLayout->addLayout(statusLayout);

    splitter->addWidget(midWidget);

    // --- 右侧边栏 (文件收藏) ---
    auto* collectionWidget = new QWidget();
    auto* collectionLayout = new QVBoxLayout(collectionWidget);
    collectionLayout->setContentsMargins(10, 0, 0, 0);
    collectionLayout->setSpacing(10);

    auto* collHeaderLayout = new QHBoxLayout();
    collHeaderLayout->setSpacing(5);
    auto* collIcon = new QLabel();
    collIcon->setPixmap(IconHelper::getIcon("file", "#888").pixmap(14, 14));
    collIcon->setStyleSheet("border: none; background: transparent;");
    collHeaderLayout->addWidget(collIcon);

    auto* collHeader = new QLabel("文件收藏 (可多选/拖入)");
    collHeader->setStyleSheet("color: #888; font-weight: bold; font-size: 12px; border: none; background: transparent;");
    collHeaderLayout->addWidget(collHeader);
    collHeaderLayout->addStretch();
    collectionLayout->addLayout(collHeaderLayout);

    m_collectionSidebar = new KeywordCollectionListWidget();
    m_collectionSidebar->setObjectName("SidebarList");
    m_collectionSidebar->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_collectionSidebar->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_collectionSidebar->setMinimumWidth(200);
    m_collectionSidebar->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_collectionSidebar, &KeywordCollectionListWidget::filesDropped, this, [this](const QStringList& paths){
        for(const QString& p : paths) addCollectionItem(p);
    });
    connect(m_collectionSidebar, &QListWidget::itemClicked, this, &KeywordSearchWidget::onCollectionItemClicked);
    connect(m_collectionSidebar, &QListWidget::customContextMenuRequested, this, &KeywordSearchWidget::showCollectionContextMenu);
    collectionLayout->addWidget(m_collectionSidebar);

    auto* btnMergeColl = new QPushButton("合并收藏内容");
    btnMergeColl->setFixedHeight(32);
    btnMergeColl->setCursor(Qt::PointingHandCursor);
    btnMergeColl->setStyleSheet(
        "QPushButton { background-color: #2D2D30; border: 1px solid #444; color: #AAA; border-radius: 4px; font-size: 12px; }"
        "QPushButton:hover { background-color: #3E3E42; color: #FFF; border-color: #666; }"
    );
    connect(btnMergeColl, &QPushButton::clicked, this, &KeywordSearchWidget::onMergeCollectionFiles);
    collectionLayout->addWidget(btnMergeColl);

    splitter->addWidget(collectionWidget);

    splitter->setStretchFactor(0, 0);
    splitter->setStretchFactor(1, 1);
    splitter->setStretchFactor(2, 0);

    // 快捷键支持
    m_actionSearch = new QAction(this);
    connect(m_actionSearch, &QAction::triggered, this, &KeywordSearchWidget::onSearch);
    addAction(m_actionSearch);

    m_actionReplace = new QAction(this);
    connect(m_actionReplace, &QAction::triggered, this, &KeywordSearchWidget::onReplace);
    addAction(m_actionReplace);

    m_actionUndo = new QAction(this);
    connect(m_actionUndo, &QAction::triggered, this, &KeywordSearchWidget::onUndo);
    addAction(m_actionUndo);

    m_actionSwap = new QAction(this);
    connect(m_actionSwap, &QAction::triggered, this, &KeywordSearchWidget::onSwapSearchReplace);
    addAction(m_actionSwap);

    m_actionSelectAll = new QAction(this);
    connect(m_actionSelectAll, &QAction::triggered, [this](){ m_resultList->selectAll(); });
    m_resultList->addAction(m_actionSelectAll);

    m_actionCopyPaths = new QAction(this);
    connect(m_actionCopyPaths, &QAction::triggered, this, &KeywordSearchWidget::copySelectedPaths);
    m_resultList->addAction(m_actionCopyPaths);

    m_actionCopyFiles = new QAction(this);
    connect(m_actionCopyFiles, &QAction::triggered, this, &KeywordSearchWidget::copySelectedFiles);
    m_resultList->addAction(m_actionCopyFiles);

    updateShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &KeywordSearchWidget::updateShortcuts);
}

void KeywordSearchWidget::updateShortcuts() {
    auto& sm = ShortcutManager::instance();
    if (m_actionSearch) m_actionSearch->setShortcut(sm.getShortcut("ks_search"));
    if (m_actionReplace) m_actionReplace->setShortcut(sm.getShortcut("ks_replace"));
    if (m_actionUndo) m_actionUndo->setShortcut(sm.getShortcut("ks_undo"));
    if (m_actionSwap) m_actionSwap->setShortcut(sm.getShortcut("ks_swap"));
    if (m_actionSelectAll) m_actionSelectAll->setShortcut(sm.getShortcut("fs_select_all"));
    if (m_actionCopyPaths) m_actionCopyPaths->setShortcut(sm.getShortcut("fs_copy"));
}

void KeywordSearchWidget::onSidebarItemClicked(QListWidgetItem* item) {
    if (!item) return;
    QString path = item->data(Qt::UserRole).toString();
    m_pathEdit->setText(path);
}

void KeywordSearchWidget::showSidebarContextMenu(const QPoint& pos) {
    QListWidgetItem* item = m_sidebar->itemAt(pos);
    if (!item) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #252526; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #37373D; }");
    
    QAction* pinAct = menu.addAction(IconHelper::getIcon("pin", "#F1C40F"), "置顶文件夹");
    QAction* removeAct = menu.addAction(IconHelper::getIcon("close", "#E74C3C"), "取消收藏");
    
    QAction* selected = menu.exec(m_sidebar->mapToGlobal(pos));
    if (selected == pinAct) {
        int row = m_sidebar->row(item);
        if (row > 0) {
            QListWidgetItem* taken = m_sidebar->takeItem(row);
            m_sidebar->insertItem(0, taken);
            m_sidebar->setCurrentItem(taken);
            saveFavorites();
        }
    } else if (selected == removeAct) {
        delete m_sidebar->takeItem(m_sidebar->row(item));
        saveFavorites();
    }
}

void KeywordSearchWidget::addFavorite(const QString& path) {
    // 检查是否已存在
    for (int i = 0; i < m_sidebar->count(); ++i) {
        if (m_sidebar->item(i)->data(Qt::UserRole).toString() == path) return;
    }

    QFileInfo fi(path);
    auto* item = new QListWidgetItem(IconHelper::getIcon("folder", "#F1C40F"), fi.fileName());
    item->setData(Qt::UserRole, path);
    item->setToolTip(path);
    m_sidebar->addItem(item);
    saveFavorites();
}

void KeywordSearchWidget::loadFavorites() {
    QSettings settings("RapidNotes", "KeywordSearchFavorites");
    QStringList favs = settings.value("list").toStringList();
    for (const QString& path : std::as_const(favs)) {
        if (QDir(path).exists()) {
            QFileInfo fi(path);
            auto* item = new QListWidgetItem(IconHelper::getIcon("folder", "#F1C40F"), fi.fileName());
            item->setData(Qt::UserRole, path);
            item->setToolTip(path);
            m_sidebar->addItem(item);
        }
    }
}

void KeywordSearchWidget::saveFavorites() {
    QStringList favs;
    for (int i = 0; i < m_sidebar->count(); ++i) {
        favs << m_sidebar->item(i)->data(Qt::UserRole).toString();
    }
    QSettings settings("RapidNotes", "KeywordSearchFavorites");
    settings.setValue("list", favs);
}

void KeywordSearchWidget::onBrowseFolder() {
    QString folder = QFileDialog::getExistingDirectory(this, "选择搜索目录");
    if (!folder.isEmpty()) {
        m_pathEdit->setText(folder);
    }
}

bool KeywordSearchWidget::isTextFile(const QString& filePath) {
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) return false;
    
    QByteArray chunk = file.read(1024);
    file.close();

    if (chunk.isEmpty()) return true;
    if (chunk.contains('\0')) return false;

    return true;
}

void KeywordSearchWidget::onSearch() {
    QString rootDir = m_pathEdit->text().trimmed();
    QString keyword = m_searchEdit->text().trimmed();
    QString replaceText = m_replaceEdit->text().trimmed();
    if (rootDir.isEmpty() || keyword.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 目录和查找内容不能为空!</b>");
        return;
    }

    // 保存历史记录
    addHistoryEntry(Path, rootDir);
    addHistoryEntry(Keyword, keyword);
    if (!replaceText.isEmpty()) {
        addHistoryEntry(Replace, replaceText);
    }

    m_resultList->clear();
    m_resultsData.clear();
    m_progressBar->show();
    m_progressBar->setRange(0, 0);
    m_statusLabel->setText("正在搜索...");

    QString filter = m_filterEdit->text();
    bool caseSensitive = m_caseCheck->isChecked();

    (void)QtConcurrent::run([this, rootDir, keyword, filter, caseSensitive]() {
        int scannedFiles = 0;
        struct TmpMatch { QString path; int count; };
        QList<TmpMatch> matches;

        QStringList filters;
        if (!filter.isEmpty()) {
            filters = filter.split(QRegularExpression("[,\\s;]+"), Qt::SkipEmptyParts);
        }

        QDirIterator it(rootDir, QDir::Files, QDirIterator::Subdirectories);
        while (it.hasNext()) {
            QString filePath = it.next();
            
            // 过滤目录
            bool skip = false;
            for (const QString& ignore : m_ignoreDirs) {
                if (filePath.contains("/" + ignore + "/") || filePath.contains("\\" + ignore + "\\")) {
                    skip = true;
                    break;
                }
            }
            if (skip) continue;

            // 过滤文件名
            if (!filters.isEmpty()) {
                bool matchFilter = false;
                QString fileName = QFileInfo(filePath).fileName();
                for (const QString& f : filters) {
                    QRegularExpression re(QRegularExpression::wildcardToRegularExpression(f));
                    if (re.match(fileName).hasMatch()) {
                        matchFilter = true;
                        break;
                    }
                }
                if (!matchFilter) continue;
            }

            if (!isTextFile(filePath)) continue;

            scannedFiles++;
            QFile file(filePath);
            if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
                QTextStream in(&file);
                QString content = in.readAll();
                file.close();

                Qt::CaseSensitivity cs = caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive;
                if (content.contains(keyword, cs)) {
                    int count = content.count(keyword, cs);
                    matches.append({filePath, count});
                }
            }
        }

        QMetaObject::invokeMethod(this, [this, scannedFiles, matches, keyword]() {
            for(const auto& m : matches) {
                m_resultsData.append({m.path, m.count});
                QString fileName = QFileInfo(m.path).fileName();
                auto* item = new QListWidgetItem("");
                item->setData(Qt::UserRole, m.path);
                item->setToolTip(m.path);
                m_resultList->addItem(item);

                auto* widget = new KeywordResultItem(fileName, QString::number(m.count), QColor("#007ACC"));
                m_resultList->setItemWidget(item, widget);
            }

            m_statusLabel->setText(QString("扫描 %1 个文件，找到 %2 个匹配").arg(scannedFiles).arg(matches.size()));
            m_progressBar->hide();
        });
    });
}

void KeywordSearchWidget::onReplace() {
    QString rootDir = m_pathEdit->text().trimmed();
    QString keyword = m_searchEdit->text().trimmed();
    QString replaceText = m_replaceEdit->text().trimmed();
    if (rootDir.isEmpty() || keyword.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 目录和查找内容不能为空!</b>");
        return;
    }

    // 保存历史记录
    addHistoryEntry(Path, rootDir);
    addHistoryEntry(Keyword, keyword);
    if (!replaceText.isEmpty()) {
        addHistoryEntry(Replace, replaceText);
    }

    m_resultList->clear();
    m_resultsData.clear();
    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #007acc;'>ℹ 正在开始批量替换...</b>");

    m_progressBar->show();
    m_progressBar->setRange(0, 0);
    m_statusLabel->setText("正在替换...");

    QString filter = m_filterEdit->text();
    bool caseSensitive = m_caseCheck->isChecked();

    (void)QtConcurrent::run([this, rootDir, keyword, replaceText, filter, caseSensitive]() {
        int modifiedFiles = 0;
        QString timestamp = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
        QString backupDirName = "_backup_" + timestamp;
        QDir root(rootDir);
        root.mkdir(backupDirName);
        m_lastBackupPath = root.absoluteFilePath(backupDirName);

        QStringList filters;
        if (!filter.isEmpty()) {
            filters = filter.split(QRegularExpression("[,\\s;]+"), Qt::SkipEmptyParts);
        }

        QDirIterator it(rootDir, QDir::Files, QDirIterator::Subdirectories);
        while (it.hasNext()) {
            QString filePath = it.next();
            if (filePath.contains(backupDirName)) continue;

            // 过滤目录和文件名（逻辑同搜索）
            bool skip = false;
            for (const QString& ignore : m_ignoreDirs) {
                if (filePath.contains("/" + ignore + "/") || filePath.contains("\\" + ignore + "\\")) {
                    skip = true;
                    break;
                }
            }
            if (skip) continue;

            if (!filters.isEmpty()) {
                bool matchFilter = false;
                QString fileName = QFileInfo(filePath).fileName();
                for (const QString& f : filters) {
                    QRegularExpression re(QRegularExpression::wildcardToRegularExpression(f));
                    if (re.match(fileName).hasMatch()) {
                        matchFilter = true;
                        break;
                    }
                }
                if (!matchFilter) continue;
            }

            if (!isTextFile(filePath)) continue;

            QFile file(filePath);
            if (file.open(QIODevice::ReadWrite | QIODevice::Text)) {
                QTextStream in(&file);
                QString content = in.readAll();
                
                Qt::CaseSensitivity cs = caseSensitive ? Qt::CaseSensitive : Qt::CaseInsensitive;
                if (content.contains(keyword, cs)) {
                    // 备份
                    QString fileName = QFileInfo(filePath).fileName();
                    QFile::copy(filePath, m_lastBackupPath + "/" + fileName + ".bak");

                    // 替换
                    QString newContent;
                    if (caseSensitive) {
                        newContent = content.replace(keyword, replaceText);
                    } else {
                        newContent = content.replace(QRegularExpression(QRegularExpression::escape(keyword), QRegularExpression::CaseInsensitiveOption), replaceText);
                    }

                    file.resize(0);
                    in << newContent;
                    modifiedFiles++;
                    
                    QMetaObject::invokeMethod(this, [this, filePath]() {
                        QString fileName = QFileInfo(filePath).fileName();
                        auto* item = new QListWidgetItem("");
                        item->setData(Qt::UserRole, filePath);
                        item->setToolTip(filePath);
                        m_resultList->addItem(item);

                        auto* widget = new KeywordResultItem(fileName, "已修改", QColor("#6A9955"));
                        m_resultList->setItemWidget(item, widget);
                    });
                }
                file.close();
            }
        }

        QMetaObject::invokeMethod(this, [this, modifiedFiles]() {
            m_statusLabel->setText(QString("替换完成: 修改了 %1 个文件").arg(modifiedFiles));
            m_progressBar->hide();
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已修改 %1 个文件 (备份于 %2)").arg(modifiedFiles).arg(m_lastBackupPath));
        });
    });
}

void KeywordSearchWidget::onUndo() {
    if (m_lastBackupPath.isEmpty() || !QDir(m_lastBackupPath).exists()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 未找到有效的备份目录！</b>");
        return;
    }

    int restored = 0;
    QDir backupDir(m_lastBackupPath);
    QStringList baks = backupDir.entryList({"*.bak"});
    
    QString rootDir = m_pathEdit->text();

    m_resultList->clear();
    for (const QString& bak : baks) {
        QString origName = bak.left(bak.length() - 4);
        
        // 在根目录下寻找原始文件（简化策略：找同名文件）
        QDirIterator it(rootDir, {origName}, QDir::Files, QDirIterator::Subdirectories);
        if (it.hasNext()) {
            QString targetPath = it.next();
            if (QFile::remove(targetPath)) {
                if (QFile::copy(backupDir.absoluteFilePath(bak), targetPath)) {
                    restored++;
                    auto* item = new QListWidgetItem("");
                    item->setData(Qt::UserRole, targetPath);
                    item->setToolTip(targetPath);
                    m_resultList->addItem(item);

                    auto* widget = new KeywordResultItem(origName, "已恢复", QColor("#007ACC"));
                    m_resultList->setItemWidget(item, widget);
                }
            }
        }
    }

    m_statusLabel->setText(QString("撤销完成，已恢复 %1 个文件").arg(restored));
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已恢复 %1 个文件").arg(restored));
}

void KeywordSearchWidget::onClearLog() {
    m_resultList->clear();
    m_resultsData.clear();
    m_statusLabel->setText("就绪");
}

void KeywordSearchWidget::showResultContextMenu(const QPoint& pos) {
    auto selectedItems = m_resultList->selectedItems();
    if (selectedItems.isEmpty()) {
        auto* item = m_resultList->itemAt(pos);
        if (item) {
            item->setSelected(true);
            selectedItems << item;
        }
    }

    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) paths << p;
    }

    if (paths.isEmpty()) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D30; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #3E3E42; }");
    
    if (selectedItems.size() == 1) {
        QString filePath = paths.first();
        menu.addAction(IconHelper::getIcon("folder", "#F1C40F"), "定位文件夹", [filePath](){
            QDesktopServices::openUrl(QUrl::fromLocalFile(QFileInfo(filePath).absolutePath()));
        });
        menu.addAction(IconHelper::getIcon("search", "#4A90E2"), "定位文件", [filePath](){
#ifdef Q_OS_WIN
            QStringList args;
            args << "/select," << QDir::toNativeSeparators(filePath);
            QProcess::startDetached("explorer.exe", args);
#endif
        });
        menu.addAction(IconHelper::getIcon("edit", "#3498DB"), "编辑", [this](){ onEditFile(); });
        menu.addSeparator();
    }

    QString copyPathText = selectedItems.size() > 1 ? "复制选中路径" : "复制完整路径";
    menu.addAction(IconHelper::getIcon("copy", "#2ECC71"), copyPathText, [this](){ copySelectedPaths(); });

    if (selectedItems.size() == 1) {
        QString fileName = QFileInfo(paths.first()).fileName();
        menu.addAction(IconHelper::getIcon("copy", "#F39C12"), "复制文件名", [fileName](){
            QApplication::clipboard()->setText(fileName);
            ToolTipOverlay::instance()->showText(QCursor::pos(), "✔ 已复制文件名");
        });
    }

    QString copyFileText = selectedItems.size() > 1 ? "复制选中文件" : "复制文件";
    menu.addAction(IconHelper::getIcon("file", "#4A90E2"), copyFileText, [this](){ copySelectedFiles(); });

    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并选中内容", [this](){ onMergeSelectedFiles(); });

    menu.addSeparator();

    menu.addAction(IconHelper::getIcon("star", "#F1C40F"), "加入收藏", [this](){
        auto selectedItems = m_resultList->selectedItems();
        for (auto* item : selectedItems) {
            QString p = item->data(Qt::UserRole).toString();
            if (!p.isEmpty()) addCollectionItem(p);
        }
    });

    menu.exec(m_resultList->mapToGlobal(pos));
}

void KeywordSearchWidget::onEditFile() {
    auto selectedItems = m_resultList->selectedItems();
    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) paths << p;
    }
    if (paths.isEmpty()) return;

    QSettings settings("RapidNotes", "ExternalEditor");
    QString editorPath = settings.value("EditorPath").toString();

    if (editorPath.isEmpty() || !QFile::exists(editorPath)) {
        QStringList commonPaths = {
            "C:/Program Files/Notepad++/notepad++.exe",
            "C:/Program Files (x86)/Notepad++/notepad++.exe"
        };
        for (const QString& p : commonPaths) {
            if (QFile::exists(p)) {
                editorPath = p;
                break;
            }
        }
    }

    if (editorPath.isEmpty() || !QFile::exists(editorPath)) {
        editorPath = QFileDialog::getOpenFileName(this, "选择编辑器 (推荐 Notepad++)", "C:/Program Files", "Executable (*.exe)");
        if (editorPath.isEmpty()) return;
        settings.setValue("EditorPath", editorPath);
    }

    for (const QString& filePath : paths) {
        QProcess::startDetached(editorPath, { QDir::toNativeSeparators(filePath) });
    }
}

void KeywordSearchWidget::copySelectedPaths() {
    auto selectedItems = m_resultList->selectedItems();
    QStringList paths;
    if (selectedItems.isEmpty()) {
        for (int i = 0; i < m_resultList->count(); ++i) {
            paths << m_resultList->item(i)->data(Qt::UserRole).toString();
        }
    } else {
        for (auto* item : selectedItems) {
            paths << item->data(Qt::UserRole).toString();
        }
    }

    if (paths.isEmpty()) return;
    QApplication::clipboard()->setText(paths.join("\n"));
    ToolTipOverlay::instance()->showText(QCursor::pos(), "✔ 已复制路径到剪贴板");
}

void KeywordSearchWidget::copySelectedFiles() {
    auto selectedItems = m_resultList->selectedItems();
    if (selectedItems.isEmpty()) return;

    QList<QUrl> urls;
    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty()) {
            urls << QUrl::fromLocalFile(p);
            paths << p;
        }
    }
    if (urls.isEmpty()) return;

    QMimeData* mimeData = new QMimeData();
    mimeData->setUrls(urls);
    mimeData->setText(paths.join("\n"));
    QApplication::clipboard()->setMimeData(mimeData);

    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已复制 %1 个文件").arg(urls.size()));
}

void KeywordSearchWidget::onMergeFiles(const QStringList& filePaths, const QString& rootPath, bool useCombineDir) {
    if (filePaths.isEmpty()) return;

    QString targetDir = rootPath;
    if (useCombineDir) {
        targetDir = QCoreApplication::applicationDirPath() + "/Combine";
        QDir dir(targetDir);
        if (!dir.exists()) dir.mkpath(".");
    }

    QString ts = QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
    QString outName = QString("%1_keyword_export.md").arg(ts);
    QString outPath = QDir(targetDir).filePath(outName);

    QFile outFile(outPath);
    if (!outFile.open(QIODevice::WriteOnly | QIODevice::Text)) return;

    QTextStream out(&outFile);
    out.setEncoding(QStringConverter::Utf8);

    out << "# 关键字搜索导出结果 - " << ts << "\n\n";
    out << "**项目路径**: `" << rootPath << "`\n\n";
    out << "**文件总数**: " << filePaths.size() << "\n\n";

    for (const QString& fp : filePaths) {
        QString relPath = rootPath.isEmpty() ? fp : QDir(rootPath).relativeFilePath(fp);
        QString lang = getFileLanguage(fp);

        out << "## 文件: `" << relPath << "`\n\n";
        out << "```" << lang << "\n";

        QFile inFile(fp);
        if (inFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
            out << inFile.readAll();
        }
        out << "\n```\n\n";
    }

    outFile.close();
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已保存: %1").arg(outName));
}

void KeywordSearchWidget::onMergeSelectedFiles() {
    auto selectedItems = m_resultList->selectedItems();
    if (selectedItems.isEmpty()) return;

    QStringList paths;
    for (auto* item : std::as_const(selectedItems)) {
        QString p = item->data(Qt::UserRole).toString();
        if (!p.isEmpty() && isSupportedFile(p)) paths << p;
    }
    
    if (paths.isEmpty()) return;
    onMergeFiles(paths, m_pathEdit->text().trimmed());
}

void KeywordSearchWidget::onMergeCollectionFiles() {
    QStringList paths;
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        paths << m_collectionSidebar->item(i)->data(Qt::UserRole).toString();
    }
    if (paths.isEmpty()) return;
    onMergeFiles(paths, "", true);
}

void KeywordSearchWidget::onCollectionItemClicked(QListWidgetItem* item) {
}

void KeywordSearchWidget::showCollectionContextMenu(const QPoint& pos) {
    auto selectedItems = m_collectionSidebar->selectedItems();
    if (selectedItems.isEmpty()) return;

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #252526; border: 1px solid #444; color: #EEE; } QMenu::item:selected { background-color: #37373D; }");
    
    menu.addAction(IconHelper::getIcon("merge", "#3498DB"), "合并选中内容", [this](){
        QStringList paths;
        for (auto* item : m_collectionSidebar->selectedItems()) {
            paths << item->data(Qt::UserRole).toString();
        }
        onMergeFiles(paths, "", true);
    });

    menu.addAction(IconHelper::getIcon("close", "#E74C3C"), "取消收藏", [this](){
        for (auto* item : m_collectionSidebar->selectedItems()) {
            delete item;
        }
        saveCollection();
    });
    
    menu.exec(m_collectionSidebar->mapToGlobal(pos));
}

void KeywordSearchWidget::addCollectionItem(const QString& path) {
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        if (m_collectionSidebar->item(i)->data(Qt::UserRole).toString() == path) return;
    }

    QFileInfo fi(path);
    auto* item = new QListWidgetItem(IconHelper::getIcon("file", "#2ECC71"), fi.fileName());
    item->setData(Qt::UserRole, path);
    item->setToolTip(path);
    m_collectionSidebar->addItem(item);
    saveCollection();
}

void KeywordSearchWidget::loadCollection() {
    QSettings settings("RapidNotes", "KeywordSearchCollection");
    QStringList coll = settings.value("list").toStringList();
    for (const QString& path : std::as_const(coll)) {
        if (QFile::exists(path)) {
            QFileInfo fi(path);
            auto* item = new QListWidgetItem(IconHelper::getIcon("file", "#2ECC71"), fi.fileName());
            item->setData(Qt::UserRole, path);
            item->setToolTip(path);
            m_collectionSidebar->addItem(item);
        }
    }
}

void KeywordSearchWidget::saveCollection() {
    QStringList coll;
    for (int i = 0; i < m_collectionSidebar->count(); ++i) {
        coll << m_collectionSidebar->item(i)->data(Qt::UserRole).toString();
    }
    QSettings settings("RapidNotes", "KeywordSearchCollection");
    settings.setValue("list", coll);
}

void KeywordSearchWidget::onSwapSearchReplace() {
    QString searchTxt = m_searchEdit->text();
    QString replaceTxt = m_replaceEdit->text();
    m_searchEdit->setText(replaceTxt);
    m_replaceEdit->setText(searchTxt);
}

void KeywordSearchWidget::addHistoryEntry(HistoryType type, const QString& text) {
    if (text.isEmpty()) return;
    QString key = "keywordList";
    if (type == Path) key = "pathList";
    else if (type == Replace) key = "replaceList";

    QSettings settings("RapidNotes", "KeywordSearchHistory");
    QStringList history = settings.value(key).toStringList();
    history.removeAll(text);
    history.prepend(text);
    while (history.size() > 10) history.removeLast();
    settings.setValue(key, history);
}

void KeywordSearchWidget::onShowHistory() {
    auto* edit = qobject_cast<ClickableLineEdit*>(sender());
    if (!edit) return;

    KeywordSearchHistoryPopup::Type type = KeywordSearchHistoryPopup::Keyword;
    if (edit == m_pathEdit) type = KeywordSearchHistoryPopup::Path;
    else if (edit == m_replaceEdit) type = KeywordSearchHistoryPopup::Replace;
    
    auto* popup = new KeywordSearchHistoryPopup(this, edit, type);
    popup->setAttribute(Qt::WA_DeleteOnClose);
    popup->showAnimated();
}

// ----------------------------------------------------------------------------
// KeywordSearchWindow 实现
// ----------------------------------------------------------------------------
KeywordSearchWindow::KeywordSearchWindow(QWidget* parent) : FramelessDialog("查找关键字", parent) {
    setObjectName("KeywordSearchWindow");
    loadWindowSettings();
    resize(1200, 700);
    m_searchWidget = new KeywordSearchWidget(m_contentArea);
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->addWidget(m_searchWidget);
    m_resizeHandle = new ResizeHandle(this, this);
    m_resizeHandle->raise();
}

KeywordSearchWindow::~KeywordSearchWindow() {
}

void KeywordSearchWindow::hideEvent(QHideEvent* event) {
    FramelessDialog::hideEvent(event);
}

void KeywordSearchWindow::resizeEvent(QResizeEvent* event) {
    FramelessDialog::resizeEvent(event);
    if (m_resizeHandle) {
        m_resizeHandle->move(width() - 20, height() - 20);
    }
}

#include "KeywordSearchWindow.moc"
```

## 文件: `src/ui/KeywordSearchWindow.h`

```cpp
#ifndef KEYWORDSEARCHWINDOW_H
#define KEYWORDSEARCHWINDOW_H

#include "FramelessDialog.h"
#include "ClickableLineEdit.h"
#include "ResizeHandle.h"
#include <QLineEdit>
#include <QPushButton>
#include <QCheckBox>
#include <QTextBrowser>
#include <QProgressBar>
#include <QLabel>
#include <QListWidget>
#include <QSplitter>

class KeywordSidebarListWidget;

/**
 * @brief 收藏侧边栏列表 (支持拖拽和多选) - 复刻自 FileSearchWindow
 */
class KeywordCollectionListWidget : public QListWidget {
    Q_OBJECT
public:
    explicit KeywordCollectionListWidget(QWidget* parent = nullptr);
signals:
    void filesDropped(const QStringList& paths);
protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
};

/**
 * @brief 关键字搜索核心组件
 */
class KeywordSearchWidget : public QWidget {
    Q_OBJECT
public:
    explicit KeywordSearchWidget(QWidget* parent = nullptr);
    ~KeywordSearchWidget();

private slots:
    void onBrowseFolder();
    void onSidebarItemClicked(QListWidgetItem* item);
    void showSidebarContextMenu(const QPoint& pos);
    void addFavorite(const QString& path);
    void onSearch();
    void onReplace();
    void onUndo();
    void onClearLog();
    void onShowHistory();
    void onSwapSearchReplace();
    void updateShortcuts();

    // 结果列表相关 slots
    void showResultContextMenu(const QPoint& pos);
    void onEditFile();
    void onMergeSelectedFiles();
    void onMergeCollectionFiles();
    void copySelectedPaths();
    void copySelectedFiles();

    // 收藏相关
    void onCollectionItemClicked(QListWidgetItem* item);
    void showCollectionContextMenu(const QPoint& pos);
    void addCollectionItem(const QString& path);

private:
    void initUI();
    void setupStyles();
    void loadFavorites();
    void saveFavorites();
    void loadCollection();
    void saveCollection();
    void onMergeFiles(const QStringList& filePaths, const QString& rootPath, bool useCombineDir = false);
    
    // 历史记录管理
    enum HistoryType { Path, Keyword, Replace };
    void addHistoryEntry(HistoryType type, const QString& text);
    bool isTextFile(const QString& filePath);

    QListWidget* m_sidebar;
    KeywordCollectionListWidget* m_collectionSidebar;
    QAction* m_actionSearch = nullptr;
    QAction* m_actionReplace = nullptr;
    QAction* m_actionUndo = nullptr;
    QAction* m_actionSwap = nullptr;
    QAction* m_actionCopyPaths = nullptr;
    QAction* m_actionCopyFiles = nullptr;
    QAction* m_actionSelectAll = nullptr;

    ClickableLineEdit* m_pathEdit;
    QLineEdit* m_filterEdit;
    ClickableLineEdit* m_searchEdit;
    ClickableLineEdit* m_replaceEdit;
    QCheckBox* m_caseCheck;
    QListWidget* m_resultList;
    QProgressBar* m_progressBar;
    QLabel* m_statusLabel;

    QString m_lastBackupPath;
    QStringList m_ignoreDirs;

    struct MatchData {
        QString path;
        int count;
    };
    QList<MatchData> m_resultsData;
};

/**
 * @brief 关键字搜索窗口：封装了 KeywordSearchWidget
 */
class KeywordSearchWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit KeywordSearchWindow(QWidget* parent = nullptr);
    ~KeywordSearchWindow();

protected:
    void hideEvent(QHideEvent* event) override;
    void resizeEvent(QResizeEvent* event) override;

private:
    KeywordSearchWidget* m_searchWidget;
    ResizeHandle* m_resizeHandle;
};

#endif // KEYWORDSEARCHWINDOW_H
```

## 文件: `src/main.cpp`

```cpp
#include <QSettings>
#include <QApplication>
#include <QThread>
#include <QFile>
#include <QToolTip>
#include <QCursor>
#include <QMessageBox>
#include <QCoreApplication>
#include <QDir>
#include <QDebug>
#include <QDateTime>
#include <QFileInfo>
#include <QBuffer>
#include <QUrl>
#include <QTimer>
#include <QLocalServer>
#include <QLocalSocket>
#include <QPointer>
#include <QRegularExpression>
#include <QKeyEvent>
#include <QLineEdit>
#include <QTextEdit>
#include <QPlainTextEdit>
#include <QTextCursor>
#include <QTextDocument>
#include <functional>
#include <utility>
#include "core/DatabaseManager.h"
#include "core/HotkeyManager.h"
#include "core/ClipboardMonitor.h"
#include "core/OCRManager.h"
#include "ui/MainWindow.h"
#include "ui/FloatingBall.h"
#include "ui/QuickWindow.h"
#include "ui/SystemTray.h"
#include "ui/Toolbox.h"

#include <QAbstractItemView>
#include <QHelpEvent>
#include <QModelIndex>

/**
 * @brief 全局 ToolTip 拦截器
 * [IMPORTANT] 本项目杜绝采用原生 QToolTip。
 * 拦截所有 QEvent::ToolTip 事件，并将其转发至自定义的 ToolTipOverlay。
 * 支持普通 Widget 的 toolTip() 属性，以及 QAbstractItemView 的 Item-level (ToolTipRole) 提示。
 */
/**
 * @brief 全局输入框按键拦截器
 * [CRITICAL] 核心交互增强：
 * 1. 单行输入框 (QLineEdit)：重定义上下键为“直接跳到开头/结尾”。
 * 2. 多行编辑器 (QTextEdit/QPlainTextEdit)：采用“边缘触发”逻辑。
 *    - 如果在第一行按“上”，跳至全文开头；如果在最后一行按“下”，跳至全文末尾。
 *    - 其它情况保持原生行间移动行为，不干扰正常编辑。
 */
class GlobalInputKeyFilter : public QObject {
public:
    explicit GlobalInputKeyFilter(QObject* parent = nullptr) : QObject(parent) {}
protected:
    bool eventFilter(QObject* watched, QEvent* event) override {
        if (event->type() == QEvent::KeyPress) {
            QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
            int key = keyEvent->key();

            // 1. 处理单行输入框 (QLineEdit)
            if (QLineEdit* lineEdit = qobject_cast<QLineEdit*>(watched)) {
                if (key == Qt::Key_Up) {
                    lineEdit->home(false);
                    return true;
                } else if (key == Qt::Key_Down) {
                    lineEdit->end(false);
                    return true;
                }
            }
            
            // 2. 处理多行编辑器 (QTextEdit)
            if (QTextEdit* textEdit = qobject_cast<QTextEdit*>(watched)) {
                if (key == Qt::Key_Up) {
                    // 如果当前已经在第一段，则触发“跳到开头”
                    if (textEdit->textCursor().blockNumber() == 0) {
                        textEdit->moveCursor(QTextCursor::Start);
                        return true;
                    }
                } else if (key == Qt::Key_Down) {
                    // 如果当前已经在最后一段，则触发“跳到结尾”
                    if (textEdit->textCursor().blockNumber() == textEdit->document()->blockCount() - 1) {
                        textEdit->moveCursor(QTextCursor::End);
                        return true;
                    }
                }
            }

            // 3. 处理多行编辑器 (QPlainTextEdit)
            if (QPlainTextEdit* plainTextEdit = qobject_cast<QPlainTextEdit*>(watched)) {
                if (key == Qt::Key_Up) {
                    if (plainTextEdit->textCursor().blockNumber() == 0) {
                        plainTextEdit->moveCursor(QTextCursor::Start);
                        return true;
                    }
                } else if (key == Qt::Key_Down) {
                    if (plainTextEdit->textCursor().blockNumber() == plainTextEdit->document()->blockCount() - 1) {
                        plainTextEdit->moveCursor(QTextCursor::End);
                        return true;
                    }
                }
            }
        }
        return QObject::eventFilter(watched, event);
    }
};

class GlobalToolTipFilter : public QObject {
public:
    explicit GlobalToolTipFilter(QObject* parent = nullptr) : QObject(parent) {}
protected:
    bool eventFilter(QObject* watched, QEvent* event) override {
        if (event->type() == QEvent::ToolTip) {
            QHelpEvent* helpEvent = static_cast<QHelpEvent*>(event);
            QWidget* widget = qobject_cast<QWidget*>(watched);
            if (widget) {
                QString tip = widget->toolTip();
                
                // [CRITICAL] 针对列表/树形视图的深度拦截逻辑
                // QAbstractItemView 的 ToolTip 事件通常发送给其 viewport() 部件。
                QAbstractItemView* view = qobject_cast<QAbstractItemView*>(widget);
                if (!view && widget->parentWidget()) {
                    view = qobject_cast<QAbstractItemView*>(widget->parentWidget());
                }

                if (view) {
                    QModelIndex index = view->indexAt(view->mapFromGlobal(helpEvent->globalPos()));
                    if (index.isValid()) {
                        tip = index.data(Qt::ToolTipRole).toString();
                    }
                }

                if (!tip.isEmpty()) {
                    ToolTipOverlay::instance()->showText(helpEvent->globalPos(), tip, 0);
                    return true; // 拦截默认 ToolTip
                }
            }
        } else if (event->type() == QEvent::Leave || event->type() == QEvent::MouseButtonPress || 
                   event->type() == QEvent::WindowDeactivate || event->type() == QEvent::FocusOut) {
            ToolTipOverlay::hideTip();
        }
        return QObject::eventFilter(watched, event);
    }
};

#include "ui/TimePasteWindow.h"
#include "ui/PasswordGeneratorWindow.h"
#include "ui/OCRWindow.h"
#include "ui/OCRResultWindow.h"
#include "ui/KeywordSearchWindow.h"
#include "ui/FileStorageWindow.h"
#include "ui/TagManagerWindow.h"
#include "ui/FileSearchWindow.h"
#include "ui/ColorPickerWindow.h"
#include "ui/PixelRulerOverlay.h"
#include "ui/HelpWindow.h"
#include "ui/FireworksOverlay.h"
#include "ui/ScreenshotTool.h"
#include "ui/SettingsWindow.h"
#include "ui/StringUtils.h"
#include "core/KeyboardHook.h"
#include "core/MessageCaptureHandler.h"
#include "core/FileCryptoHelper.h"

#ifdef Q_OS_WIN
#include <windows.h>
#include <psapi.h>
#endif

#ifdef Q_OS_WIN
/**
 * @brief 判定当前活跃窗口是否为浏览器
 */
static bool isBrowserActive() {
    HWND hwnd = GetForegroundWindow();
    if (!hwnd) return false;

    DWORD pid;
    GetWindowThreadProcessId(hwnd, &pid);
    
    HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if (!process) return false;

    wchar_t buffer[MAX_PATH];
    // 使用 GetModuleFileNameExW 获取完整路径
    if (GetModuleFileNameExW(process, NULL, buffer, MAX_PATH)) {
        QString exePath = QString::fromWCharArray(buffer).toLower();
        QString exeName = QFileInfo(exePath).fileName();
        qDebug() << "[Acquire] 当前活跃窗口进程:" << exeName;

        static const QStringList browserExes = {
            "chrome.exe", "msedge.exe", "firefox.exe", "brave.exe", 
            "opera.exe", "iexplore.exe", "vivaldi.exe", "safari.exe"
        };
        
        CloseHandle(process);
        return browserExes.contains(exeName);
    }

    CloseHandle(process);
    return false;
}
#endif

int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    // [CRITICAL] 安装全局过滤器
    a.installEventFilter(new GlobalToolTipFilter(&a));
    a.installEventFilter(new GlobalInputKeyFilter(&a));
    
    a.setApplicationName("RapidNotes");
    a.setOrganizationName("RapidDev");
    a.setQuitOnLastWindowClosed(false);

    // 单实例运行保护
    QString serverName = "RapidNotes_SingleInstance_Server";
    QLocalSocket socket;
    socket.connectToServer(serverName);
    if (socket.waitForConnected(500)) {
        // 如果已经运行，发送 SHOW 信号并退出当前进程
        socket.write("SHOW");
        socket.waitForBytesWritten(1000);
        return 0;
    }
    QLocalServer::removeServer(serverName);
    QLocalServer server;
    if (!server.listen(serverName)) {
        qWarning() << "无法启动单实例服务器";
    }

    // 加载全局样式表
    QFile styleFile(":/qss/dark_style.qss");
    if (styleFile.open(QFile::ReadOnly)) {
        a.setStyleSheet(styleFile.readAll());
    }

    // 1. 初始化数据库 (外壳文件名改为 inspiration.db)
    QString dbPath = QCoreApplication::applicationDirPath() + "/inspiration.db";
    qDebug() << "[Main] 数据库外壳路径:" << dbPath;

    if (!DatabaseManager::instance().init(dbPath)) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            "<b style='color: #e74c3c;'>❌ 启动失败</b><br>无法初始化数据库！请检查写入权限或 SQLite 驱动。", 5000, QColor("#e74c3c"));
        QThread::msleep(3000); // 留出时间显示提示
        return -1;
    }


    // 1.1 试用期与使用次数检查
    QVariantMap trialStatus = DatabaseManager::instance().getTrialStatus();
    if (trialStatus["expired"].toBool() || trialStatus["usage_limit_reached"].toBool()) {
        QString reason = trialStatus["expired"].toBool() ? "您的 30 天试用期已结束。" : "您的 100 次使用额度已用完。";
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            QString("<b style='color: #f39c12;'>⚠️ 试用结束</b><br>%1<br>感谢您体验 RapidNotes！如需继续使用，请联系开发者。").arg(reason), 6000, QColor("#f39c12"));
        
        QThread::msleep(4000);
        DatabaseManager::instance().closeAndPack();
        return 0;
    }

    // 2. 初始化核心 UI 组件 (极速窗口与悬浮球)
    QuickWindow* quickWin = new QuickWindow();
    quickWin->setObjectName("QuickWindow");
    quickWin->showAuto();

    // 3. 初始化特效层与悬浮球
    FireworksOverlay::instance(); 
    FloatingBall* ball = new FloatingBall();
    ball->setObjectName("FloatingBall");

    a.setWindowIcon(FloatingBall::generateBallIcon());

    // 4. 子窗口延迟加载策略
    MainWindow* mainWin = nullptr;
    Toolbox* toolbox = nullptr;
    TimePasteWindow* timePasteWin = nullptr;
    PasswordGeneratorWindow* passwordGenWin = nullptr;
    OCRWindow* ocrWin = nullptr;
    KeywordSearchWindow* keywordSearchWin = nullptr;
    TagManagerWindow* tagMgrWin = nullptr;
    FileStorageWindow* fileStorageWin = nullptr;
    FileSearchWindow* fileSearchWin = nullptr;
    ColorPickerWindow* colorPickerWin = nullptr;
    HelpWindow* helpWin = nullptr;

    auto toggleWindow = [](QWidget* win, QWidget* parentWin = nullptr) {
        if (!win) return;
        
        // [CRITICAL] 修复首次点击无法激活窗口的 Bug。
        // 原因：如果窗口在构造函数中因应用置顶设置而触发了内部 show()，
        // 那么在此处 isVisible() 会返回 true，导致第一次点击反而执行了 hide()。
        // 我们通过 hasBeenToggled 属性确保第一次点击总是执行“显示”逻辑。
        bool hasBeenToggled = win->property("hasBeenToggled").toBool();
        
        if (win->isVisible() && hasBeenToggled) {
            win->hide();
        } else {
            if (parentWin && win->objectName() != "ToolboxLauncher") {
                if (parentWin->objectName() == "QuickWindow") {
                    win->move(parentWin->x() - win->width() - 10, parentWin->y());
                } else {
                    win->move(parentWin->geometry().center() - win->rect().center());
                }
            }
            win->show();
            win->raise();
            win->activateWindow();
            win->setProperty("hasBeenToggled", true);
        }
    };

    auto checkLockAndExecute = [&](std::function<void()> func) {
        if (quickWin->isLocked()) {
            quickWin->showAuto();
            return;
        }
        func();
    };

    std::function<void()> showMainWindow;
    std::function<void()> startScreenshot;
    std::function<void()> startImmediateOCR;

    auto getToolbox = [&]() -> Toolbox* {
        if (!toolbox) {
            toolbox = new Toolbox();
            toolbox->setObjectName("ToolboxLauncher");
            
            QObject::connect(toolbox, &Toolbox::showTimePasteRequested, [=, &timePasteWin](){
                if (!timePasteWin) {
                    timePasteWin = new TimePasteWindow();
                    timePasteWin->setObjectName("TimePasteWindow");
                }
                toggleWindow(timePasteWin);
            });
            QObject::connect(toolbox, &Toolbox::showPasswordGeneratorRequested, [=, &passwordGenWin](){
                if (!passwordGenWin) {
                    passwordGenWin = new PasswordGeneratorWindow();
                    passwordGenWin->setObjectName("PasswordGeneratorWindow");
                }
                toggleWindow(passwordGenWin);
            });
            QObject::connect(toolbox, &Toolbox::showOCRRequested, [=, &ocrWin](){
                if (!ocrWin) {
                    ocrWin = new OCRWindow();
                    ocrWin->setObjectName("OCRWindow");
                }
                toggleWindow(ocrWin);
            });
            QObject::connect(toolbox, &Toolbox::showKeywordSearchRequested, [=, &keywordSearchWin](){
                if (!keywordSearchWin) {
                    keywordSearchWin = new KeywordSearchWindow();
                    keywordSearchWin->setObjectName("KeywordSearchWindow");
                }
                toggleWindow(keywordSearchWin);
            });
            QObject::connect(toolbox, &Toolbox::showTagManagerRequested, [=, &tagMgrWin](){
                if (!tagMgrWin) {
                    tagMgrWin = new TagManagerWindow();
                    tagMgrWin->setObjectName("TagManagerWindow");
                }
                tagMgrWin->refreshData();
                toggleWindow(tagMgrWin);
            });
            QObject::connect(toolbox, &Toolbox::showFileStorageRequested, [=, &fileStorageWin, &mainWin, &quickWin](){
                if (!fileStorageWin) {
                    fileStorageWin = new FileStorageWindow();
                    fileStorageWin->setObjectName("FileStorageWindow");
                }
                int catId = -1;
                if (quickWin->isVisible()) catId = quickWin->getCurrentCategoryId();
                else if (mainWin && mainWin->isVisible()) catId = mainWin->getCurrentCategoryId();
                fileStorageWin->setCurrentCategory(catId);
                toggleWindow(fileStorageWin);
            });
            QObject::connect(toolbox, &Toolbox::showFileSearchRequested, [=, &fileSearchWin](){
                if (!fileSearchWin) {
                    fileSearchWin = new FileSearchWindow();
                    fileSearchWin->setObjectName("FileSearchWindow");
                }
                toggleWindow(fileSearchWin);
            });
            QObject::connect(toolbox, &Toolbox::showColorPickerRequested, [=, &colorPickerWin](){
                if (!colorPickerWin) {
                    colorPickerWin = new ColorPickerWindow();
                    colorPickerWin->setObjectName("ColorPickerWindow");
                }
                toggleWindow(colorPickerWin);
            });
            QObject::connect(toolbox, &Toolbox::startColorPickerRequested, [=, &colorPickerWin](){
                if (!colorPickerWin) {
                    colorPickerWin = new ColorPickerWindow();
                    colorPickerWin->setObjectName("ColorPickerWindow");
                }
                colorPickerWin->startScreenPicker();
            });
            QObject::connect(toolbox, &Toolbox::showPixelRulerRequested, [](){
                auto* ruler = new PixelRulerOverlay(nullptr);
                ruler->setAttribute(Qt::WA_DeleteOnClose);
                ruler->show();
            });
            QObject::connect(toolbox, &Toolbox::showHelpRequested, [=, &helpWin](){
                if (!helpWin) {
                    helpWin = new HelpWindow();
                    helpWin->setObjectName("HelpWindow");
                }
                toggleWindow(helpWin);
            });

            QObject::connect(toolbox, &Toolbox::showMainWindowRequested, [=](){ showMainWindow(); });
            QObject::connect(toolbox, &Toolbox::showQuickWindowRequested, [=](){ quickWin->showAuto(); });
            QObject::connect(toolbox, &Toolbox::screenshotRequested, [=](){ startScreenshot(); });
            QObject::connect(toolbox, &Toolbox::startOCRRequested, [=](){ startImmediateOCR(); });
        }
        return toolbox;
    };

    showMainWindow = [=, &mainWin, &checkLockAndExecute, &getToolbox, &fileStorageWin, &quickWin]() {
        checkLockAndExecute([=, &mainWin, &getToolbox, &fileStorageWin, &quickWin](){
            if (!mainWin) {
                mainWin = new MainWindow();
                QObject::connect(mainWin, &MainWindow::toolboxRequested, [=](){ toggleWindow(getToolbox(), mainWin); });
                QObject::connect(mainWin, &MainWindow::fileStorageRequested, [=, &mainWin, &fileStorageWin](){
                    if (!fileStorageWin) {
                        fileStorageWin = new FileStorageWindow();
                        fileStorageWin->setObjectName("FileStorageWindow");
                    }
                    fileStorageWin->setCurrentCategory(mainWin->getCurrentCategoryId());
                    toggleWindow(fileStorageWin, mainWin);
                });
            }
            mainWin->showNormal();
            mainWin->activateWindow();
            mainWin->raise();
        });
    };

    startImmediateOCR = [=, &checkLockAndExecute]() {
        static bool isScreenshotActive = false;
        if (isScreenshotActive) return;

        checkLockAndExecute([&](){
            isScreenshotActive = true;
            auto* tool = new ScreenshotTool();
            tool->setAttribute(Qt::WA_DeleteOnClose);
            tool->setImmediateOCRMode(true);
            
            QObject::connect(tool, &ScreenshotTool::destroyed, [=](){
                isScreenshotActive = false;
            });
            
            QObject::connect(tool, &ScreenshotTool::screenshotCaptured, [=](const QImage& img, bool isOcrRequest){
                QSettings settings("RapidNotes", "OCR");
                bool autoCopy = settings.value("autoCopy", false).toBool();
                
                // 1. 先存入数据库，确保产生历史记录
                QByteArray ba;
                QBuffer buffer(&ba);
                buffer.open(QIODevice::WriteOnly);
                img.save(&buffer, "PNG");
                QString title = "[截图取文] " + QDateTime::currentDateTime().toString("MMdd_HHmm");
                // [CRITICAL] 明确指定类型为 ocr_text，以便在 QuickWindow 列表中显示专用蓝色扫描图标
                int noteId = DatabaseManager::instance().addNote(title, "[正在识别文本...]", QStringList() << "截屏" << "截图取文", "", -1, "ocr_text", ba);

                // 2. 使用 noteId 进行识别，这样全局监听器会自动更新数据库内容
                auto* resWin = new OCRResultWindow(img, noteId);
                QObject::connect(&OCRManager::instance(), &OCRManager::recognitionFinished, 
                                 resWin, &OCRResultWindow::setRecognizedText);
                
                if (autoCopy) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "⏳ 正在识别文字...");
                } else {
                    resWin->show();
                }
                OCRManager::instance().recognizeAsync(img, noteId);
            });
            tool->show();
        });
    };

    startScreenshot = [=, &checkLockAndExecute]() {
        static bool isNormalScreenshotActive = false;
        if (isNormalScreenshotActive) return;

        checkLockAndExecute([&](){
            isNormalScreenshotActive = true;
            auto* tool = new ScreenshotTool();
            tool->setAttribute(Qt::WA_DeleteOnClose);
            QObject::connect(tool, &ScreenshotTool::destroyed, [=](){ isNormalScreenshotActive = false; });
            QObject::connect(tool, &ScreenshotTool::screenshotCaptured, [=](const QImage& img, bool isOcrRequest){
                if (!isOcrRequest) QApplication::clipboard()->setImage(img);
                
                QByteArray ba;
                QBuffer buffer(&ba);
                buffer.open(QIODevice::WriteOnly);
                img.save(&buffer, "PNG");
                
                QString title = (isOcrRequest ? "[截图取文] " : "[截屏] ") + QDateTime::currentDateTime().toString("MMdd_HHmm");
                QStringList tags = isOcrRequest ? (QStringList() << "截屏" << "截图取文") : (QStringList() << "截屏");
                int noteId = DatabaseManager::instance().addNote(title, "[正在进行文字识别...]", tags, "", -1, "image", ba);
                
                if (isOcrRequest) {
                    QSettings settings("RapidNotes", "OCR");
                    bool autoCopy = settings.value("autoCopy", false).toBool();
                    auto* resWin = new OCRResultWindow(img, noteId);
                    QObject::connect(&OCRManager::instance(), &OCRManager::recognitionFinished, 
                                     resWin, &OCRResultWindow::setRecognizedText);
                    
                    if (autoCopy) {
                        ToolTipOverlay::instance()->showText(QCursor::pos(), "⏳ 正在识别文字...");
                    } else {
                        resWin->show();
                    }
                }
                
                OCRManager::instance().recognizeAsync(img, noteId);
            });
            tool->show();
        });
    };

    QObject::connect(quickWin, &QuickWindow::toolboxRequested, [=, &getToolbox](){ toggleWindow(getToolbox(), quickWin); });
    QObject::connect(quickWin, &QuickWindow::toggleMainWindowRequested, [=, &showMainWindow](){ showMainWindow(); });

    // 5. 开启全局键盘钩子 (支持快捷键重映射)
    KeyboardHook::instance().start();
    MessageCaptureHandler::instance().init();

    // 6. 注册全局热键 (从配置加载)
    HotkeyManager::instance().reapplyHotkeys();
    
    QObject::connect(&HotkeyManager::instance(), &HotkeyManager::hotkeyPressed, [&](int id){
        if (id == 1) {
            if (quickWin->isVisible() && quickWin->isActiveWindow()) {
                quickWin->hide();
            } else {
                quickWin->showAuto();
            }
        } else if (id == 2) {
            checkLockAndExecute([&](){
                // 收藏最后一条灵感
                auto notes = DatabaseManager::instance().searchNotes("");
                if (!notes.isEmpty()) {
                    int lastId = notes.first()["id"].toInt();
                    DatabaseManager::instance().updateNoteState(lastId, "is_favorite", 1);
                    qDebug() << "[Main] 已收藏最新灵感 ID:" << lastId;
                }
            });
        } else if (id == 3) {
            startScreenshot();
        } else if (id == 4) {
            checkLockAndExecute([&](){
                // 全局采集：仅限浏览器 -> 清空剪贴板 -> 模拟 Ctrl+C -> 获取剪贴板 -> 智能拆分 -> 入库
#ifdef Q_OS_WIN
                if (!isBrowserActive()) {
                    qDebug() << "[Acquire] 当前非浏览器窗口，忽略采集指令。";
                    return;
                }

                // 1. 务必清空剪贴板，防止残留
                QApplication::clipboard()->clear();
                // 屏蔽监听器的下一次捕获，防止重复入库
                ClipboardMonitor::instance().skipNext();

                // 2. 模拟 Ctrl+C
                // 关键修复：由于热键是 Ctrl+Shift+S，此时物理 Shift 和 S 键很可能仍被按下。
                // 如果不显式释放 Shift，Ctrl+C 会变成 Ctrl+Shift+C (在浏览器中通常是打开开发者工具而非复制)。
                keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
                keybd_event('S', 0, KEYEVENTF_KEYUP, 0);

                keybd_event(VK_CONTROL, 0, 0, 0);
                keybd_event('C', 0, 0, 0);
                keybd_event('C', 0, KEYEVENTF_KEYUP, 0);
                // 这里不要立即抬起 Control，因为抬起太快可能导致目标窗口还没来得及接收到组合键
#endif
                // 增加延迟至 300ms，为浏览器处理复制请求提供更充裕的时间
                QTimer::singleShot(300, [=](){
                    // 此时再彻底释放 Ctrl (可选，防止干扰后续操作)
#ifdef Q_OS_WIN
                    keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
#endif
                    QString text = QApplication::clipboard()->text();
                    if (text.trimmed().isEmpty()) {
                        qWarning() << "[Acquire] 剪贴板为空，采集失败。";
                        ToolTipOverlay::instance()->showText(QCursor::pos(), "✖ 未能采集到内容，请确保已选中浏览器中的文本");
                        return;
                    }

                    auto pairs = StringUtils::smartSplitPairs(text);
                    if (pairs.isEmpty()) return;

                    int catId = -1;
                    if (quickWin && quickWin->isVisible()) {
                        catId = quickWin->getCurrentCategoryId();
                    }

                    for (const auto& pair : std::as_const(pairs)) {
                        DatabaseManager::instance().addNoteAsync(pair.first, pair.second, {"采集"}, "", catId, "text");
                    }
                    
                    // 成功反馈 (ToolTip)
                    QString feedback = pairs.size() > 1 
                        ? QString("✔ 已批量采集 %1 条灵感").arg(pairs.size())
                        : "✔ 已采集灵感: " + (pairs[0].first.length() > 20 ? pairs[0].first.left(17) + "..." : pairs[0].first);

                    ToolTipOverlay::instance()->showText(QCursor::pos(), feedback);
                });
            });
        } else if (id == 5) {
            // 全局锁定
            quickWin->doGlobalLock();
        } else if (id == 6) {
            // 截图取文
            startImmediateOCR();
        }
    });

    // 监听 OCR 完成信号并更新笔记内容
    // 必须指定 context 对象 (&DatabaseManager::instance()) 确保回调在正确的线程执行
    QObject::connect(&OCRManager::instance(), &OCRManager::recognitionFinished, &DatabaseManager::instance(), [](const QString& text, int noteId){
        if (noteId > 0) {
            DatabaseManager::instance().updateNoteState(noteId, "content", text);
        }
    });

    // 7. 系统托盘
    QObject::connect(&server, &QLocalServer::newConnection, [&](){
        QLocalSocket* conn = server.nextPendingConnection();
        if (conn->waitForReadyRead(500)) {
            QByteArray data = conn->readAll();
            if (data == "SHOW") {
                quickWin->showAuto();
            }
            conn->disconnectFromServer();
        }
    });

    SystemTray* tray = new SystemTray(&a);
    QObject::connect(tray, &SystemTray::showMainWindow, showMainWindow);
    QObject::connect(tray, &SystemTray::showQuickWindow, quickWin, &QuickWindow::showAuto);
    
    // 初始化托盘菜单中悬浮球的状态
    tray->updateBallAction(ball->isVisible());
    QObject::connect(tray, &SystemTray::toggleFloatingBall, [=](bool visible){
        if (visible) ball->show();
        else ball->hide();
        ball->savePosition(); // 立即记忆状态
        tray->updateBallAction(visible);
    });

    QObject::connect(tray, &SystemTray::showHelpRequested, [=, &helpWin](){
        checkLockAndExecute([=, &helpWin](){
            if (!helpWin) {
                helpWin = new HelpWindow();
                helpWin->setObjectName("HelpWindow");
            }
            toggleWindow(helpWin);
        });
    });
    QObject::connect(tray, &SystemTray::showSettings, [=](){
        checkLockAndExecute([=](){
            static QPointer<SettingsWindow> settingsWin;
            if (settingsWin) {
                settingsWin->showNormal();
                settingsWin->raise();
                settingsWin->activateWindow();
                return;
            }

            settingsWin = new SettingsWindow();
            settingsWin->setObjectName("SettingsWindow");
            settingsWin->setAttribute(Qt::WA_DeleteOnClose);
            
            // 核心修复：先计算位置并移动，确保窗口 show() 的那一刻就在正确的位置，杜绝闪烁
            QScreen *screen = QGuiApplication::primaryScreen();
            if (screen) {
                QRect screenGeom = screen->geometry();
                settingsWin->move(screenGeom.center() - settingsWin->rect().center());
            }
            
            settingsWin->show();
            settingsWin->raise();
            settingsWin->activateWindow();
        });
    });
    QObject::connect(tray, &SystemTray::quitApp, &a, &QApplication::quit);
    tray->show();

    QObject::connect(ball, &FloatingBall::doubleClicked, [&](){
        quickWin->showAuto();
    });
    QObject::connect(ball, &FloatingBall::requestMainWindow, showMainWindow);
    QObject::connect(ball, &FloatingBall::requestQuickWindow, quickWin, &QuickWindow::showAuto);
    QObject::connect(ball, &FloatingBall::requestToolbox, [=, &getToolbox](){
        checkLockAndExecute([=, &getToolbox](){ toggleWindow(getToolbox()); });
    });
    QObject::connect(ball, &FloatingBall::requestNewIdea, [=](){
        checkLockAndExecute([=](){
            NoteEditWindow* win = new NoteEditWindow();
            QObject::connect(win, &NoteEditWindow::noteSaved, quickWin, &QuickWindow::refreshData);
            win->show();
        });
    });

    // 8. 监听剪贴板 (智能标题与自动分类)
    QObject::connect(&ClipboardMonitor::instance(), &ClipboardMonitor::clipboardChanged, [=](){
        // 触发烟花爆炸特效
        FireworksOverlay::instance()->explode(QCursor::pos());
    });

    QObject::connect(&ClipboardMonitor::instance(), &ClipboardMonitor::newContentDetected, 
        [=](const QString& content, const QString& type, const QByteArray& data,
            const QString& sourceApp, const QString& sourceTitle){
        qDebug() << "[Main] 接收到剪贴板信号:" << type << "来自:" << sourceApp;
        
        QString title;
        QString finalContent = content;
        QString finalType = type;

        if (type == "image") {
            title = "[图片] " + QDateTime::currentDateTime().toString("MMdd_HHmm");
        } else if (type == "file") {
            QStringList files = content.split(";", Qt::SkipEmptyParts);
            if (!files.isEmpty()) {
                QFileInfo info(files.first());
                title = info.fileName();
                if (files.size() > 1) title += QString(" 等 %1 个文件").arg(files.size());
            } else {
                title = "[未知文件]";
            }
        } else {
            // 文本：取第一行
            QString firstLine = content.section('\n', 0, 0).trimmed();
            if (firstLine.isEmpty()) title = "无标题灵感";
            else {
                title = firstLine.left(40);
                if (firstLine.length() > 40) title += "...";
            }
        }

        // 自动归档逻辑
        int catId = -1;
        if (quickWin && quickWin->isAutoCategorizeEnabled()) {
            catId = quickWin->getCurrentCategoryId();
        }

        // 自动生成类型标签与类型修正 (解耦逻辑)
        QStringList tags;
        
        if (type == "text") {
            QString trimmed = content.trimmed();

            // 颜色码识别逻辑
            static QRegularExpression hexRegex("^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$");
            static QRegularExpression rgbRegex(R"(^(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})$)");

            QRegularExpressionMatch hexMatch = hexRegex.match(trimmed);
            bool isColor = false;
            if (hexMatch.hasMatch()) {
                if (!tags.contains("HEX")) tags << "HEX";
                isColor = true;
            } else {
                QRegularExpressionMatch rgbMatch = rgbRegex.match(trimmed);
                if (rgbMatch.hasMatch()) {
                    int r = rgbMatch.captured(1).toInt();
                    int g = rgbMatch.captured(2).toInt();
                    int b = rgbMatch.captured(3).toInt();
                    if (r <= 255 && g <= 255 && b <= 255) {
                        if (!tags.contains("RGB")) tags << "RGB";
                        isColor = true;
                    }
                }
            }

            if (isColor) {
                for (const QString& t : {"色码", "色值", "颜值", "颜色码"}) {
                    if (!tags.contains(t)) tags << t;
                }
            }

            // 恢复后的网址识别与域名提取逻辑
            if (trimmed.startsWith("http://") || trimmed.startsWith("https://") || trimmed.startsWith("www.")) {
                finalType = "link";
                tags << "链接" << "网址";

                // 提取二级域名作为标题和标签 (例如: https://www.google.com -> Google)
                QUrl url(trimmed.startsWith("www.") ? "http://" + trimmed : trimmed);
                QString host = url.host();
                if (host.startsWith("www.")) host = host.mid(4);
                QStringList hostParts = host.split('.');
                if (hostParts.size() >= 2) {
                    QString sld = hostParts[hostParts.size() - 2];
                    if (!sld.isEmpty()) {
                        sld[0] = sld[0].toUpper();
                        title = sld;
                        if (!tags.contains(sld)) tags << sld;
                    }
                }
            }
        }
        
        DatabaseManager::instance().addNoteAsync(title, finalContent, tags, "", catId, finalType, data, sourceApp, sourceTitle);
    });

    int result = a.exec();
    
    // 退出前合壳并加密数据库
    DatabaseManager::instance().closeAndPack();
    
    return result;
}
```

## 文件: `src/viewmodels/MainNoteViewModel.cpp`

```cpp
#include "MainNoteViewModel.h"
#include "../core/ServiceLocator.h"

#include "../core/DatabaseManager.h"
#include <algorithm>

MainNoteViewModel::MainNoteViewModel(QObject* parent) : QObject(parent) {}

void MainNoteViewModel::refreshData(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page, int pageSize, const QVariantMap& criteria) {
    m_currentFilterType = filterType;
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;

    auto notes = db->searchNotes(keyword, filterType, filterValue, page, pageSize, criteria);
    int totalCount = db->getNotesCount(keyword, filterType, filterValue, criteria);
    int totalPages = (totalCount + pageSize - 1) / pageSize;
    if (totalPages < 1) totalPages = 1;

    emit dataRefreshed(notes, totalCount, totalPages);
}

void MainNoteViewModel::deleteNotes(const QList<int>& ids, bool physical) {
    if (ids.isEmpty()) return;
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;

    if (physical || m_currentFilterType == "trash") {
        db->deleteNotesBatch(ids);
        emit statusMessageRequested(QString("✔ 已永久删除 %1 条数据").arg(ids.count()));
    } else {
        db->softDeleteNotes(ids);
        emit statusMessageRequested(QString("✔ 已移至回收站 %1 条数据").arg(ids.count()));
    }
}

void MainNoteViewModel::toggleFavorite(const QList<int>& ids) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->toggleNoteState(id, "is_favorite");
    }
}

void MainNoteViewModel::togglePin(const QList<int>& ids) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->toggleNoteState(id, "is_pinned");
    }
}

void MainNoteViewModel::setRating(const QList<int>& ids, int rating) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->updateNoteState(id, "rating", rating);
    }
}

void MainNoteViewModel::moveToCategory(const QList<int>& ids, int catId) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    db->moveNotesToCategory(ids, catId);
}
```

## 文件: `src/viewmodels/MainNoteViewModel.h`

```cpp
#ifndef MAINNOTEVIEWMODEL_H
#define MAINNOTEVIEWMODEL_H

#include <QObject>
#include <QVariantMap>
#include <QList>
#include <QString>
#include <QVariant>

class MainNoteViewModel : public QObject {
    Q_OBJECT
public:
    explicit MainNoteViewModel(QObject* parent = nullptr);

    void refreshData(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page, int pageSize, const QVariantMap& criteria);
    void deleteNotes(const QList<int>& ids, bool physical);
    void toggleFavorite(const QList<int>& ids);
    void togglePin(const QList<int>& ids);
    void setRating(const QList<int>& ids, int rating);
    void moveToCategory(const QList<int>& ids, int catId);

signals:
    void dataRefreshed(const QList<QVariantMap>& notes, int totalCount, int totalPages);
    void statusMessageRequested(const QString& message);

private:
    QString m_currentFilterType;
};

#endif // MAINNOTEVIEWMODEL_H
```

## 文件: `src/ui/MainWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "MainWindow.h"
#include "StringUtils.h"
#include "../core/DatabaseManager.h"
#include "../core/ClipboardMonitor.h"
#include "NoteDelegate.h"
#include "CategoryDelegate.h"
#include "IconHelper.h"
#include <QHBoxLayout>
#include <utility>
#include <QVBoxLayout>
#include <QHeaderView>
#include <QLabel>
#include <QSplitter>
#include <QMenu>
#include <QAction>
#include <QElapsedTimer>
#include <QToolTip>
#include <QCursor>
#include <QKeyEvent>
#include <QMouseEvent>
#include <QCloseEvent>
#include <QShortcut>
#include <QItemSelection>
#include <QActionGroup>
#include <QInputDialog>
#include <QColorDialog>
#include <QSet>
#include <QSettings>
#include <QRandomGenerator>
#include <QLineEdit>
#include <QTextEdit>
#include <QToolTip>
#include <QDateTime>
#include <QRegularExpression>
#include <QTimer>
#include <QGraphicsDropShadowEffect>
#include <QDesktopServices>
#include <QUrl>
#include <QApplication>
#include <QFile>
#include <QCoreApplication>
#include <QClipboard>
#include <QMimeData>
#include <QPlainTextEdit>
#include "CleanListView.h"
#include "NoteEditWindow.h"
#include "StringUtils.h"
#include "FramelessDialog.h"
#include "CategoryPasswordDialog.h"
#include "SettingsWindow.h"
#include "OCRResultWindow.h"
#include "../core/ShortcutManager.h"
#include "../core/OCRManager.h"
#include <functional>
#include <QVariant>
#include <QtGlobal>

#ifdef Q_OS_WIN
#include <windows.h>
#include <windowsx.h>
#define RESIZE_MARGIN 10
#endif

MainWindow::MainWindow(QWidget* parent) : QMainWindow(parent, Qt::FramelessWindowHint) {
    setWindowTitle("RapidNotes");
    resize(1200, 800);
    setMouseTracking(true);
    setAttribute(Qt::WA_Hover);
    initUI();

    m_searchTimer = new QTimer(this);
    m_searchTimer->setSingleShot(true);
    connect(m_searchTimer, &QTimer::timeout, this, &MainWindow::refreshData);

    m_refreshTimer = new QTimer(this);
    m_refreshTimer->setSingleShot(true);
    m_refreshTimer->setInterval(300);
    connect(m_refreshTimer, &QTimer::timeout, this, &MainWindow::refreshData);

    refreshData();

    // 【关键修改】区分两种信号
    // 1. 增量更新：添加新笔记时不刷新全表
    connect(&DatabaseManager::instance(), &DatabaseManager::noteAdded, this, &MainWindow::onNoteAdded);
    
    // 2. 全量刷新：修改、删除、分类变化（锁定状态）时才刷新全表 (通过 scheduleRefresh 节流)
    connect(&DatabaseManager::instance(), &DatabaseManager::noteUpdated, this, &MainWindow::scheduleRefresh);
    connect(&DatabaseManager::instance(), &DatabaseManager::categoriesChanged, this, &MainWindow::scheduleRefresh, Qt::QueuedConnection);

    restoreLayout(); // 恢复布局
    setupShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &MainWindow::updateShortcuts);
}

void MainWindow::initUI() {
    auto* centralWidget = new QWidget(this);
    centralWidget->setObjectName("CentralWidget");
    centralWidget->setMouseTracking(true);
    centralWidget->setAttribute(Qt::WA_StyledBackground, true);
    centralWidget->setStyleSheet("#CentralWidget { background-color: #1E1E1E; }");
    setCentralWidget(centralWidget);
    auto* mainLayout = new QVBoxLayout(centralWidget);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    // 1. HeaderBar
    m_header = new HeaderBar(this);
    connect(m_header, &HeaderBar::searchChanged, this, [this](const QString& text){
        m_currentKeyword = text;
        m_currentPage = 1;
        m_searchTimer->start(300);
    });
    connect(m_header, &HeaderBar::pageChanged, this, [this](int page){
        m_currentPage = page;
        refreshData();
    });
    connect(m_header, &HeaderBar::refreshRequested, this, &MainWindow::refreshData);
    connect(m_header, &HeaderBar::stayOnTopRequested, this, [this](bool checked){
        if (auto* win = window()) {
            if (win->isVisible()) {
#ifdef Q_OS_WIN
                HWND hwnd = (HWND)win->winId();
                SetWindowPos(hwnd, checked ? HWND_TOPMOST : HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
                Qt::WindowFlags f = win->windowFlags();
                if (checked) f |= Qt::WindowStaysOnTopHint;
                else f &= ~Qt::WindowStaysOnTopHint;
                win->setWindowFlags(f);
                win->show();
#endif
            }
        }
    });
    connect(m_header, &HeaderBar::filterRequested, this, [this](){
        bool visible = !m_filterWrapper->isVisible();
        m_filterWrapper->setVisible(visible);
        m_header->setFilterActive(visible);
        if (visible) {
            m_filterPanel->updateStats(m_currentKeyword, m_currentFilterType, m_currentFilterValue);
        }
    });
    connect(m_header, &HeaderBar::newNoteRequested, this, [this](){
        NoteEditWindow* win = new NoteEditWindow();
        connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
        win->show();
    });
    connect(m_header, &HeaderBar::toggleSidebar, this, [this](){
        m_sidebarContainer->setVisible(!m_sidebarContainer->isVisible());
    });
    connect(m_header, &HeaderBar::toolboxRequested, this, &MainWindow::toolboxRequested);
    connect(m_header, &HeaderBar::toolboxContextMenuRequested, this, &MainWindow::showToolboxMenu);
    connect(m_header, &HeaderBar::metadataToggled, this, [this](bool checked){
        m_metaPanel->setVisible(checked);
    });
    connect(m_header, &HeaderBar::windowClose, this, &MainWindow::close);
    connect(m_header, &HeaderBar::windowMinimize, this, &MainWindow::showMinimized);
    connect(m_header, &HeaderBar::windowMaximize, this, [this](){
        if (isMaximized()) showNormal();
        else showMaximized();
    });
    mainLayout->addWidget(m_header);

    // 核心内容容器：管理 5px 全局边距
    auto* contentWidget = new QWidget(centralWidget);
    contentWidget->setAttribute(Qt::WA_StyledBackground, true);
    contentWidget->setStyleSheet("background: transparent; border: none;");
    auto* contentLayout = new QVBoxLayout(contentWidget);
    contentLayout->setContentsMargins(5, 5, 5, 5); // 确保顶栏下方及窗口四周均有 5px 留白
    contentLayout->setSpacing(0);

    auto* splitter = new QSplitter(Qt::Horizontal);
    splitter->setHandleWidth(5); // 统一横向板块间的物理缝隙为 5px
    splitter->setChildrenCollapsible(false);
    splitter->setAttribute(Qt::WA_StyledBackground, true);
    splitter->setStyleSheet("QSplitter { background: transparent; border: none; } QSplitter::handle { background: transparent; }");

    // 1. 左侧侧边栏包装容器 (固定 230px)
    auto* sidebarWrapper = new QWidget();
    sidebarWrapper->setMinimumWidth(230);
    auto* sidebarWrapperLayout = new QVBoxLayout(sidebarWrapper);
    sidebarWrapperLayout->setContentsMargins(0, 0, 0, 0); // 彻底消除偏移边距，由全局 Layout 和 Splitter 控制

    m_sidebarContainer = new QFrame();
    m_sidebarContainer->setMinimumWidth(230);
    m_sidebarContainer->setObjectName("SidebarContainer");
    m_sidebarContainer->setAttribute(Qt::WA_StyledBackground, true);
    m_sidebarContainer->setStyleSheet(
        "#SidebarContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );

    auto* sidebarShadow = new QGraphicsDropShadowEffect(m_sidebarContainer);
    sidebarShadow->setBlurRadius(10);
    sidebarShadow->setXOffset(0);
    sidebarShadow->setYOffset(4);
    sidebarShadow->setColor(QColor(0, 0, 0, 150));
    m_sidebarContainer->setGraphicsEffect(sidebarShadow);

    auto* sidebarContainerLayout = new QVBoxLayout(m_sidebarContainer);
    sidebarContainerLayout->setContentsMargins(0, 0, 0, 0); 
    sidebarContainerLayout->setSpacing(0);

    // 侧边栏标题栏 (全宽下划线方案)
    auto* sidebarHeader = new QWidget();
    sidebarHeader->setFixedHeight(32);
    sidebarHeader->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #333;"
    );
    auto* sidebarHeaderLayout = new QHBoxLayout(sidebarHeader);
    sidebarHeaderLayout->setContentsMargins(15, 0, 15, 0);
    auto* sbIcon = new QLabel();
    sbIcon->setPixmap(IconHelper::getIcon("category", "#3498db").pixmap(18, 18));
    sidebarHeaderLayout->addWidget(sbIcon);
    auto* sbTitle = new QLabel("数据分类");
    sbTitle->setStyleSheet("color: #3498db; font-size: 13px; font-weight: bold; background: transparent; border: none;");
    sidebarHeaderLayout->addWidget(sbTitle);
    sidebarHeaderLayout->addStretch();
    
    sidebarHeader->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(sidebarHeader, &QWidget::customContextMenuRequested, this, [this, splitter, sidebarHeader](const QPoint& pos){
        QMenu menu;
        IconHelper::setupMenu(&menu);
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #3E3E42; }");
        menu.addAction(IconHelper::getIcon("nav_prev", "#aaaaaa", 18), "向左移动", [this, splitter](){
            int index = splitter->indexOf(m_sidebarContainer);
            if (index > 0) splitter->insertWidget(index - 1, m_sidebarContainer);
        });
        menu.addAction("向右移动", [this, splitter](){
            int index = splitter->indexOf(m_sidebarContainer);
            if (index < splitter->count() - 1) splitter->insertWidget(index + 1, m_sidebarContainer);
        });
        menu.exec(sidebarHeader->mapToGlobal(pos));
    });
    
    sidebarContainerLayout->addWidget(sidebarHeader);

    // 内容容器
    auto* sbContent = new QWidget();
    sbContent->setAttribute(Qt::WA_StyledBackground, true);
    sbContent->setStyleSheet("background: transparent; border: none;");
    auto* sbContentLayout = new QVBoxLayout(sbContent);
    sbContentLayout->setContentsMargins(8, 8, 8, 8);
    sbContentLayout->setSpacing(0);

    QString treeStyle = R"(
        QTreeView { background-color: transparent; border: none; color: #CCC; outline: none; }
        QTreeView::branch { image: none; border: none; width: 0px; }
        QTreeView::item { height: 22px; padding-left: 10px; }
    )";

    m_systemTree = new DropTreeView();
    m_systemTree->setStyleSheet(treeStyle);
    m_systemTree->setItemDelegate(new CategoryDelegate(this));
    m_systemModel = new CategoryModel(CategoryModel::System, this);
    m_systemTree->setModel(m_systemModel);
    m_systemTree->setHeaderHidden(true);
    m_systemTree->setRootIsDecorated(false);
    m_systemTree->setIndentation(12);
    m_systemTree->setFixedHeight(176); // 8 items * 22px = 176px
    m_systemTree->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_systemTree->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_systemTree->setContextMenuPolicy(Qt::CustomContextMenu);

    m_partitionTree = new DropTreeView();
    m_partitionTree->setStyleSheet(treeStyle);
    m_partitionTree->setItemDelegate(new CategoryDelegate(this));
    m_partitionModel = new CategoryModel(CategoryModel::User, this);
    m_partitionTree->setModel(m_partitionModel);
    m_partitionTree->setHeaderHidden(true);
    m_partitionTree->setRootIsDecorated(false);
    m_partitionTree->setIndentation(12);
    m_partitionTree->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_partitionTree->setDragEnabled(true);
    m_partitionTree->setAcceptDrops(true);
    m_partitionTree->setDropIndicatorShown(true);
    m_partitionTree->setDragDropMode(QAbstractItemView::InternalMove);
    m_partitionTree->setDefaultDropAction(Qt::MoveAction);
    m_partitionTree->expandAll();
    m_partitionTree->setContextMenuPolicy(Qt::CustomContextMenu);
    
    sbContentLayout->addWidget(m_systemTree);
    sbContentLayout->addWidget(m_partitionTree);
    sidebarContainerLayout->addWidget(sbContent);

    // 直接放入 Splitter (移除 Wrapper)
    splitter->addWidget(m_sidebarContainer);

    auto onSidebarMenu = [this](const QPoint& pos){
        auto* tree = qobject_cast<QTreeView*>(sender());
        if (!tree) return;
        QModelIndex index = tree->indexAt(pos);
        QMenu menu(this);
        IconHelper::setupMenu(&menu);
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #4a90e2; color: white; }");

        if (!index.isValid() || index.data().toString() == "我的分区") {
            menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建分组", [this]() {
                auto* dlg = new FramelessInputDialog("新建分组", "组名称:", "", this);
                connect(dlg, &FramelessInputDialog::accepted, [this, dlg](){
                    QString text = dlg->text();
                    if (!text.isEmpty()) {
                        DatabaseManager::instance().addCategory(text);
                        refreshData();
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.exec(tree->mapToGlobal(pos));
            return;
        }

        QString type = index.data(CategoryModel::TypeRole).toString();
        if (type == "category") {
            int catId = index.data(CategoryModel::IdRole).toInt();
            QString currentName = index.data(CategoryModel::NameRole).toString();

            menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建数据", [this, catId]() {
                auto* win = new NoteEditWindow();
                win->setDefaultCategory(catId);
                connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
                win->show();
            });
            menu.addSeparator();
            menu.addAction(IconHelper::getIcon("palette", "#e67e22", 18), "设置颜色", [this, catId]() {
                auto* dlg = new QColorDialog(Qt::gray, this);
                dlg->setWindowTitle("选择分类颜色");
                dlg->setWindowFlags(dlg->windowFlags() | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);
                connect(dlg, &QColorDialog::colorSelected, [this, catId](const QColor& color){
                    if (color.isValid()) {
                        DatabaseManager::instance().setCategoryColor(catId, color.name());
                        refreshData();
                    }
                });
                connect(dlg, &QColorDialog::finished, dlg, &QObject::deleteLater);
                dlg->show();
            });
            menu.addAction(IconHelper::getIcon("random_color", "#FF6B9D", 18), "随机颜色", [this, catId]() {
                static const QStringList palette = {
                    "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEEAD",
                    "#D4A5A5", "#9B59B6", "#3498DB", "#E67E22", "#2ECC71",
                    "#E74C3C", "#F1C40F", "#1ABC9C", "#34495E", "#95A5A6"
                };
                QString chosenColor = palette.at(QRandomGenerator::global()->bounded(palette.size()));
                DatabaseManager::instance().setCategoryColor(catId, chosenColor);
                refreshData();
            });
            menu.addAction(IconHelper::getIcon("tag", "#FFAB91", 18), "设置预设标签", [this, catId]() {
                QString currentTags = DatabaseManager::instance().getCategoryPresetTags(catId);
                auto* dlg = new FramelessInputDialog("设置预设标签", "标签 (逗号分隔):", currentTags, this);
                connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                    DatabaseManager::instance().setCategoryPresetTags(catId, dlg->text());
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.addSeparator();
            menu.addAction(IconHelper::getIcon("add", "#aaaaaa", 18), "新建分组", [this]() {
                auto* dlg = new FramelessInputDialog("新建分组", "组名称:", "", this);
                connect(dlg, &FramelessInputDialog::accepted, [this, dlg](){
                    QString text = dlg->text();
                    if (!text.isEmpty()) {
                        DatabaseManager::instance().addCategory(text);
                        refreshData();
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建子分区", [this, catId]() {
                auto* dlg = new FramelessInputDialog("新建子分区", "区名称:", "", this);
                connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                    QString text = dlg->text();
                    if (!text.isEmpty()) {
                        DatabaseManager::instance().addCategory(text, catId);
                        refreshData();
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.addSeparator();

            menu.addAction(IconHelper::getIcon("edit", "#aaaaaa", 18), "重命名分类", [this, catId, currentName]() {
                auto* dlg = new FramelessInputDialog("重命名分类", "新名称:", currentName, this);
                connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                    QString text = dlg->text();
                    if (!text.isEmpty()) {
                        DatabaseManager::instance().renameCategory(catId, text);
                        refreshData();
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
            menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "删除分类", [this, catId]() {
                auto* dlg = new FramelessMessageBox("确认删除", "确定要删除此分类吗？内容将移至未分类。", this);
                connect(dlg, &FramelessMessageBox::confirmed, [this, catId](){
                    DatabaseManager::instance().deleteCategory(catId);
                    refreshData();
                });
                dlg->show();
            });

            menu.addSeparator();
            auto* sortMenu = menu.addMenu(IconHelper::getIcon("list_ol", "#aaaaaa", 18), "排列");
            sortMenu->setStyleSheet(menu.styleSheet());

            int parentId = -1;
            QModelIndex parentIdx = index.parent();
            if (parentIdx.isValid() && parentIdx.data(CategoryModel::TypeRole).toString() == "category") {
                parentId = parentIdx.data(CategoryModel::IdRole).toInt();
            }

            sortMenu->addAction("标题(当前层级) (A→Z)", [this, parentId]() {
                if (DatabaseManager::instance().reorderCategories(parentId, true))
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 排列已完成</b>");
            });
            sortMenu->addAction("标题(当前层级) (Z→A)", [this, parentId]() {
                if (DatabaseManager::instance().reorderCategories(parentId, false))
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 排列已完成</b>");
            });
            sortMenu->addAction("标题(全部) (A→Z)", [this]() {
                if (DatabaseManager::instance().reorderAllCategories(true))
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 全部排列已完成</b>");
            });
            sortMenu->addAction("标题(全部) (Z→A)", [this]() {
                if (DatabaseManager::instance().reorderAllCategories(false))
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 全部排列已完成</b>");
            });

            menu.addSeparator();
            auto* pwdMenu = menu.addMenu(IconHelper::getIcon("lock", "#aaaaaa", 18), "密码保护");
            pwdMenu->setStyleSheet(menu.styleSheet());
            
            pwdMenu->addAction("设置", [this, catId]() {
                QTimer::singleShot(0, [this, catId]() {
                    auto* dlg = new CategoryPasswordDialog("设置密码", this);
                    connect(dlg, &QDialog::accepted, [this, catId, dlg]() {
                        DatabaseManager::instance().setCategoryPassword(catId, dlg->password(), dlg->passwordHint());
                        refreshData();
                    });
                    dlg->show();
                    dlg->activateWindow();
                    dlg->raise();
                });
            });
            pwdMenu->addAction("修改", [this, catId]() {
                QTimer::singleShot(0, [this, catId]() {
                    auto* verifyDlg = new FramelessInputDialog("验证旧密码", "请输入当前密码:", "", this);
                    verifyDlg->setEchoMode(QLineEdit::Password);
                    connect(verifyDlg, &FramelessInputDialog::accepted, [this, catId, verifyDlg]() {
                        if (DatabaseManager::instance().verifyCategoryPassword(catId, verifyDlg->text())) {
                            auto* dlg = new CategoryPasswordDialog("修改密码", this);
                            QString currentHint;
                            auto cats = DatabaseManager::instance().getAllCategories();
                            for(const auto& c : std::as_const(cats)) if(c.value("id").toInt() == catId) currentHint = c.value("password_hint").toString();
                            dlg->setInitialData(currentHint);
                            connect(dlg, &QDialog::accepted, [this, catId, dlg]() {
                                DatabaseManager::instance().setCategoryPassword(catId, dlg->password(), dlg->passwordHint());
                                refreshData();
                            });
                            dlg->show();
                            dlg->activateWindow();
                            dlg->raise();
                        } else {
                            ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 旧密码验证失败</b>");
                        }
                    });
                    verifyDlg->show();
                    verifyDlg->activateWindow();
                    verifyDlg->raise();
                });
            });
            pwdMenu->addAction("移除", [this, catId]() {
                QTimer::singleShot(0, [this, catId]() {
                    auto* dlg = new FramelessInputDialog("验证密码", "请输入当前密码以移除保护:", "", this);
                    dlg->setEchoMode(QLineEdit::Password);
                    connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg]() {
                        if (DatabaseManager::instance().verifyCategoryPassword(catId, dlg->text())) {
                            DatabaseManager::instance().removeCategoryPassword(catId);
                            refreshData();
                        } else {
                            ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 密码错误</b>");
                        }
                    });
                    dlg->show();
                    dlg->activateWindow();
                    dlg->raise();
                });
            });
            pwdMenu->addAction("立即锁定", [this, catId]() {
                DatabaseManager::instance().lockCategory(catId);
                refreshData();
            })->setShortcut(QKeySequence("Ctrl+Shift+L"));
        } else if (type == "trash") {
            menu.addAction(IconHelper::getIcon("refresh", "#2ecc71", 18), "全部恢复 (到未分类)", [this](){
                DatabaseManager::instance().restoreAllFromTrash();
                refreshData();
            });
            menu.addSeparator();
            menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "清空回收站", [this]() {
                auto* dlg = new FramelessMessageBox("确认清空", "确定要永久删除回收站中的所有内容吗？\n(此操作不可逆)", this);
                connect(dlg, &FramelessMessageBox::confirmed, [this](){
                    DatabaseManager::instance().emptyTrash();
                    refreshData();
                });
                dlg->show();
            });
        }
        menu.exec(tree->mapToGlobal(pos));
    };

    connect(m_systemTree, &QTreeView::customContextMenuRequested, this, onSidebarMenu);
    connect(m_partitionTree, &QTreeView::customContextMenuRequested, this, onSidebarMenu);

    auto onSelection = [this](QTreeView* tree, const QModelIndex& index) {
        if (!index.isValid()) return;
        if (tree == m_systemTree) {
            m_partitionTree->selectionModel()->clearSelection();
            m_partitionTree->setCurrentIndex(QModelIndex());
        } else {
            m_systemTree->selectionModel()->clearSelection();
            m_systemTree->setCurrentIndex(QModelIndex());
        }
        onTagSelected(index);
    };

    connect(m_systemTree, &QTreeView::clicked, this, [this, onSelection](const QModelIndex& idx){ onSelection(m_systemTree, idx); });
    connect(m_partitionTree, &QTreeView::clicked, this, [this, onSelection](const QModelIndex& idx){ onSelection(m_partitionTree, idx); });
    
    // 连接拖拽信号 (使用 Model 定义的枚举)
    auto onNotesDropped = [this](const QList<int>& ids, const QModelIndex& targetIndex){
        if (!targetIndex.isValid()) return;
        QString type = targetIndex.data(CategoryModel::TypeRole).toString();
        for (int id : ids) {
            if (type == "category") {
                int catId = targetIndex.data(CategoryModel::IdRole).toInt();
                DatabaseManager::instance().updateNoteState(id, "category_id", catId);
            } else if (targetIndex.data().toString() == "收藏" || type == "bookmark") { 
                DatabaseManager::instance().updateNoteState(id, "is_favorite", 1);
            } else if (type == "trash") {
                DatabaseManager::instance().updateNoteState(id, "is_deleted", 1);
            } else if (type == "uncategorized") {
                DatabaseManager::instance().updateNoteState(id, "category_id", QVariant());
            }
        }
        refreshData();
    };

    connect(m_systemTree, &DropTreeView::notesDropped, this, onNotesDropped);
    connect(m_partitionTree, &DropTreeView::notesDropped, this, onNotesDropped);

    // 3. 中间列表卡片容器
    auto* listContainer = new QFrame();
    listContainer->setMinimumWidth(230); // 对齐 MetadataPanel
    listContainer->setObjectName("ListContainer");
    listContainer->setAttribute(Qt::WA_StyledBackground, true);
    listContainer->setStyleSheet(
        "#ListContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );

    auto* listShadow = new QGraphicsDropShadowEffect(listContainer);
    listShadow->setBlurRadius(10);
    listShadow->setXOffset(0);
    listShadow->setYOffset(4);
    listShadow->setColor(QColor(0, 0, 0, 150));
    listContainer->setGraphicsEffect(listShadow);

    auto* listContainerLayout = new QVBoxLayout(listContainer);
    listContainerLayout->setContentsMargins(0, 0, 0, 0); 
    listContainerLayout->setSpacing(0);

    // 列表标题栏 (锁定 32px, 统一配色与分割线)
    auto* listHeader = new QWidget();
    listHeader->setFixedHeight(32);
    listHeader->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #333;" 
    );
    auto* listHeaderLayout = new QHBoxLayout(listHeader);
    listHeaderLayout->setContentsMargins(15, 0, 15, 0); 
    auto* listIcon = new QLabel();
    listIcon->setPixmap(IconHelper::getIcon("list_ul", "#2ecc71").pixmap(18, 18));
    listHeaderLayout->addWidget(listIcon);
    auto* listHeaderTitle = new QLabel("笔记列表");
    listHeaderTitle->setStyleSheet("color: #2ecc71; font-size: 13px; font-weight: bold; background: transparent; border: none;");
    listHeaderLayout->addWidget(listHeaderTitle);
    listHeaderLayout->addStretch();
    
    listHeader->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(listHeader, &QWidget::customContextMenuRequested, this, [this, listContainer, splitter, listHeader](const QPoint& pos){
        QMenu menu;
        IconHelper::setupMenu(&menu);
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #3E3E42; }");
        menu.addAction("向左移动", [this, listContainer, splitter](){
            int index = splitter->indexOf(listContainer);
            if (index > 0) splitter->insertWidget(index - 1, listContainer);
        });
        menu.addAction("向右移动", [this, listContainer, splitter](){
            int index = splitter->indexOf(listContainer);
            if (index < splitter->count() - 1) splitter->insertWidget(index + 1, listContainer);
        });
        menu.exec(listHeader->mapToGlobal(pos));
    });
    
    listContainerLayout->addWidget(listHeader);

    // 内容容器
    auto* listContent = new QWidget();
    listContent->setAttribute(Qt::WA_StyledBackground, true);
    listContent->setStyleSheet("background: transparent; border: none;");
    auto* listContentLayout = new QVBoxLayout(listContent);
    // 恢复垂直边距为 8，保留水平边距 15 以对齐宽度
    listContentLayout->setContentsMargins(15, 8, 15, 8);
    
    m_noteList = new CleanListView();
    m_noteList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_noteList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_noteModel = new NoteModel(this);
    m_noteList->setModel(m_noteModel);
    m_noteList->setItemDelegate(new NoteDelegate(m_noteList));
    m_noteList->setContextMenuPolicy(Qt::CustomContextMenu);
    m_noteList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    connect(m_noteList, &QListView::customContextMenuRequested, this, &MainWindow::showContextMenu);
    
    // 恢复垂直间距为 5，垂直 Padding 为 5；仅水平 Padding 设为 0
    m_noteList->setSpacing(5); 
    m_noteList->setStyleSheet("QListView { background: transparent; border: none; padding-top: 5px; padding-bottom: 5px; padding-left: 0px; padding-right: 0px; }");
    
    // 基础拖拽使能 (其余复杂逻辑已由 CleanListView 实现)
    m_noteList->setDragEnabled(true);

    connect(m_noteList->selectionModel(), &QItemSelectionModel::selectionChanged, this, &MainWindow::onSelectionChanged);
    connect(m_noteList, &QListView::doubleClicked, this, [this](const QModelIndex& index){
        if (!index.isValid()) return;
        int id = index.data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        QString type = note.value("item_type").toString();
        
        if (type == "local_file" || type == "local_folder" || type == "local_batch") {
            QString relativePath = note.value("content").toString();
            QString fullPath = QCoreApplication::applicationDirPath() + "/" + relativePath;
            
            if (QFile::exists(fullPath)) {
                QDesktopServices::openUrl(QUrl::fromLocalFile(fullPath));
            } else {
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 文件已丢失：<br></b>" + fullPath);
            }
            return;
        }

        NoteEditWindow* win = new NoteEditWindow(id);
        connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
        win->show();
    });

    listContentLayout->addWidget(m_noteList);

    m_lockWidget = new CategoryLockWidget(this);
    m_lockWidget->setVisible(false);
    connect(m_lockWidget, &CategoryLockWidget::unlocked, this, [this](){
        refreshData();
    });
    listContentLayout->addWidget(m_lockWidget);

    listContainerLayout->addWidget(listContent);
    splitter->addWidget(listContainer);
    
    // 4. 编辑器容器 (Card) - 独立出来
    auto* editorContainer = new QFrame();
    editorContainer->setMinimumWidth(230);
    editorContainer->setObjectName("EditorContainer");
    editorContainer->setAttribute(Qt::WA_StyledBackground, true);
    editorContainer->setStyleSheet(
        "#EditorContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );

    auto* editorShadow = new QGraphicsDropShadowEffect(editorContainer);
    editorShadow->setBlurRadius(10);
    editorShadow->setXOffset(0);
    editorShadow->setYOffset(4);
    editorShadow->setColor(QColor(0, 0, 0, 150));
    editorContainer->setGraphicsEffect(editorShadow);

    auto* editorContainerLayout = new QVBoxLayout(editorContainer);
    editorContainerLayout->setContentsMargins(0, 0, 0, 0);
    editorContainerLayout->setSpacing(0);

    // 编辑器标题栏 (全宽贯穿线)
    auto* editorHeader = new QWidget();
    editorHeader->setFixedHeight(32);
    editorHeader->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #333;"
    );
    auto* editorHeaderLayout = new QHBoxLayout(editorHeader);
    editorHeaderLayout->setContentsMargins(15, 0, 15, 0);
    auto* edIcon = new QLabel();
    edIcon->setPixmap(IconHelper::getIcon("eye", "#e67e22").pixmap(18, 18));
    editorHeaderLayout->addWidget(edIcon);
    auto* edTitle = new QLabel("预览数据"); // 保护用户修改的标题内容
    edTitle->setStyleSheet("color: #e67e22; font-size: 13px; font-weight: bold; background: transparent; border: none;");
    editorHeaderLayout->addWidget(edTitle);
    editorHeaderLayout->addStretch();

    // 编辑锁定/解锁按钮
    m_editLockBtn = new QPushButton();
    m_editLockBtn->setFixedSize(24, 24);
    m_editLockBtn->setCursor(Qt::PointingHandCursor);
    m_editLockBtn->setCheckable(true);
    m_editLockBtn->setEnabled(false); // 初始禁用
    m_editLockBtn->setToolTip("请先选择一条笔记以启用编辑");
    m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#555555")); // 初始灰色
    m_editLockBtn->setStyleSheet(
        "QPushButton { background: transparent; border: none; border-radius: 4px; }"
        "QPushButton:hover:enabled { background-color: rgba(255, 255, 255, 0.1); }"
        "QPushButton:checked { background-color: rgba(74, 144, 226, 0.2); }"
        "QPushButton:disabled { opacity: 0.5; }"
    );
    editorHeaderLayout->addWidget(m_editLockBtn);
    
    editorHeader->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(editorHeader, &QWidget::customContextMenuRequested, this, [this, editorContainer, splitter, editorHeader](const QPoint& pos){
        QMenu menu;
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #3E3E42; }");
        menu.addAction("向左移动", [this, editorContainer, splitter](){
            int index = splitter->indexOf(editorContainer);
            if (index > 0) splitter->insertWidget(index - 1, editorContainer);
        });
        menu.addAction("向右移动", [this, editorContainer, splitter](){
            int index = splitter->indexOf(editorContainer);
            if (index < splitter->count() - 1) splitter->insertWidget(index + 1, editorContainer);
        });
        menu.exec(editorHeader->mapToGlobal(pos));
    });

    editorContainerLayout->addWidget(editorHeader);

    // --- 编辑器工具栏 (同步 NoteEditWindow) ---
    m_editorToolbar = new QWidget();
    m_editorToolbar->setVisible(false);
    m_editorToolbar->setStyleSheet("background-color: #252526; border-bottom: 1px solid #333;");
    auto* toolBarLayout = new QHBoxLayout(m_editorToolbar);
    toolBarLayout->setContentsMargins(10, 2, 10, 2);
    toolBarLayout->setSpacing(0);

    QString toolBtnStyle = "QPushButton { background: transparent; border: none; border-radius: 4px; padding: 4px; } "
                           "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); } "
                           "QPushButton:checked { background-color: rgba(74, 144, 226, 0.2); }";

    auto addTool = [&](const QString& iconName, const QString& tip, std::function<void()> callback) {
        QPushButton* btn = new QPushButton();
        btn->setIcon(IconHelper::getIcon(iconName, "#aaaaaa", 18));
        btn->setIconSize(QSize(18, 18));
        btn->setToolTip(tip);
        btn->setFixedSize(28, 28);
        btn->setCursor(Qt::PointingHandCursor);
        btn->setStyleSheet(toolBtnStyle);
        connect(btn, &QPushButton::clicked, callback);
        toolBarLayout->addWidget(btn);
        return btn;
    };

    addTool("undo", "撤销 (Ctrl+Z)", [this](){ m_editor->undo(); });
    addTool("redo", "重做 (Ctrl+Y)", [this](){ m_editor->redo(); });
    
    auto* sep1 = new QFrame();
    sep1->setFixedWidth(1); sep1->setFixedHeight(16); sep1->setStyleSheet("background-color: #444; margin: 0 4px;");
    toolBarLayout->addWidget(sep1);

    addTool("list_ul", "无序列表", [this](){ m_editor->toggleList(false); });
    addTool("list_ol", "有序列表", [this](){ m_editor->toggleList(true); });
    addTool("todo", "插入待办", [this](){ m_editor->insertTodo(); });
    
    auto* btnPre = addTool("eye", "Markdown 预览", nullptr);
    btnPre->setCheckable(true);
    connect(btnPre, &QPushButton::toggled, [this](bool checked){ m_editor->togglePreview(checked); });

    addTool("edit_clear", "清除格式", [this](){ m_editor->clearFormatting(); });

    auto* sep2 = new QFrame();
    sep2->setFixedWidth(1); sep2->setFixedHeight(16); sep2->setStyleSheet("background-color: #444; margin: 0 4px;");
    toolBarLayout->addWidget(sep2);

    // 高亮颜色
    QStringList hColors = {"#c0392b", "#f1c40f", "#27ae60", "#2980b9"};
    for (const auto& color : hColors) {
        QPushButton* hBtn = new QPushButton();
        hBtn->setFixedSize(18, 18);
        hBtn->setStyleSheet(QString("QPushButton { background-color: %1; border-radius: 4px; margin: 2px; } QPushButton:hover { border: 1px solid white; }").arg(color));
        connect(hBtn, &QPushButton::clicked, [this, color](){ m_editor->highlightSelection(QColor(color)); });
        toolBarLayout->addWidget(hBtn);
    }

    // 清除高亮按钮
    QPushButton* btnNoColor = new QPushButton();
    btnNoColor->setIcon(IconHelper::getIcon("no_color", "#aaaaaa", 14));
    btnNoColor->setIconSize(QSize(14, 14));
    btnNoColor->setFixedSize(22, 22);
    btnNoColor->setToolTip("清除高亮");
    btnNoColor->setStyleSheet("QPushButton { background: transparent; border: 1px solid #444; border-radius: 4px; margin-left: 4px; } "
                              "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); border-color: #888; }");
    btnNoColor->setCursor(Qt::PointingHandCursor);
    connect(btnNoColor, &QPushButton::clicked, [this](){ m_editor->highlightSelection(Qt::transparent); });
    toolBarLayout->addWidget(btnNoColor);

    toolBarLayout->addStretch();
    
    auto* btnSave = addTool("save", "保存修改 (Ctrl+S)", [this](){ saveCurrentNote(); });
    btnSave->setIcon(IconHelper::getIcon("save", "#2ecc71", 18));

    editorContainerLayout->addWidget(m_editorToolbar);

    // --- 编辑器搜索栏 ---
    m_editorSearchBar = new QWidget();
    m_editorSearchBar->setVisible(false);
    m_editorSearchBar->setStyleSheet("background-color: #2D2D30; border-bottom: 1px solid #333;");
    auto* esLayout = new QHBoxLayout(m_editorSearchBar);
    esLayout->setContentsMargins(15, 4, 15, 4);
    
    m_editorSearchEdit = new QLineEdit();
    m_editorSearchEdit->setPlaceholderText("在内容中查找...");
    m_editorSearchEdit->setStyleSheet("border: none; background: transparent; color: #fff; font-size: 12px;");
    connect(m_editorSearchEdit, &QLineEdit::returnPressed, [this](){ m_editor->findText(m_editorSearchEdit->text()); });
    
    auto* btnPrev = new QPushButton();
    btnPrev->setIcon(IconHelper::getIcon("nav_prev", "#ccc", 14));
    btnPrev->setFixedSize(24, 24);
    btnPrev->setStyleSheet("background: transparent; border: none;");
    connect(btnPrev, &QPushButton::clicked, [this](){ m_editor->findText(m_editorSearchEdit->text(), true); });
    
    auto* btnNext = new QPushButton();
    btnNext->setIcon(IconHelper::getIcon("nav_next", "#ccc", 14));
    btnNext->setFixedSize(24, 24);
    btnNext->setStyleSheet("background: transparent; border: none;");
    connect(btnNext, &QPushButton::clicked, [this](){ m_editor->findText(m_editorSearchEdit->text(), false); });

    auto* btnCloseSearch = new QPushButton();
    btnCloseSearch->setIcon(IconHelper::getIcon("close", "#888", 14));
    btnCloseSearch->setFixedSize(24, 24);
    btnCloseSearch->setStyleSheet("background: transparent; border: none;");
    connect(btnCloseSearch, &QPushButton::clicked, [this](){ m_editorSearchBar->hide(); });

    esLayout->addWidget(m_editorSearchEdit);
    esLayout->addWidget(btnPrev);
    esLayout->addWidget(btnNext);
    esLayout->addWidget(btnCloseSearch);
    editorContainerLayout->addWidget(m_editorSearchBar);

    // 内容容器
    auto* editorContent = new QWidget();
    editorContent->setAttribute(Qt::WA_StyledBackground, true);
    editorContent->setStyleSheet("background: transparent; border: none;");
    auto* editorContentLayout = new QVBoxLayout(editorContent);
    editorContentLayout->setContentsMargins(2, 2, 2, 2); // 编辑器保留微量对齐边距

    m_editor = new Editor();
    m_editor->togglePreview(false);
    m_editor->setReadOnly(true); // 默认不可编辑

    connect(m_editLockBtn, &QPushButton::toggled, this, [this](bool checked){
        m_editor->setReadOnly(!checked);
        m_editorToolbar->setVisible(checked);
        if (!checked) m_editorSearchBar->hide();

        // 核心修复：切换模式时重新同步内容，防止预览标题污染正文
        QModelIndex index = m_noteList->currentIndex();
        if (index.isValid()) {
            int id = index.data(NoteModel::IdRole).toInt();
            QVariantMap note = DatabaseManager::instance().getNoteById(id);
            // 模式切换：编辑模式不带标题(false)，预览模式带标题(true)
            m_editor->setNote(note, !checked);
        }

        if (checked) {
            m_editLockBtn->setIcon(IconHelper::getIcon("eye", "#4a90e2"));
            m_editLockBtn->setToolTip("当前：编辑模式 (点击切回预览)");
        } else {
            m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#aaaaaa"));
            m_editLockBtn->setToolTip("当前：锁定模式 (点击解锁编辑)");
        }
    });
    
    editorContentLayout->addWidget(m_editor);
    editorContainerLayout->addWidget(editorContent);
    
    // 直接放入 Splitter
    splitter->addWidget(editorContainer);

    // 5. 元数据面板 - 独立出来
    m_metaPanel = new MetadataPanel(this);
    m_metaPanel->setMinimumWidth(230);
    connect(m_metaPanel, &MetadataPanel::noteUpdated, this, &MainWindow::refreshData);
    connect(m_metaPanel, &MetadataPanel::closed, this, [this](){
        m_header->setMetadataActive(false);
    });
    connect(m_metaPanel, &MetadataPanel::tagAdded, this, [this](const QStringList& tags){
        QModelIndexList indices = m_noteList->selectionModel()->selectedIndexes();
        if (indices.isEmpty()) return;
        for (const auto& index : std::as_const(indices)) {
            int id = index.data(NoteModel::IdRole).toInt();
            DatabaseManager::instance().addTagsToNote(id, tags);
        }
        refreshData();
    });
    
    // 给元数据面板添加右键移动菜单
    auto* metaHeader = m_metaPanel->findChild<QWidget*>("MetadataHeader");
    if (metaHeader) {
        metaHeader->setContextMenuPolicy(Qt::CustomContextMenu);
        connect(metaHeader, &QWidget::customContextMenuRequested, this, [this, splitter, metaHeader](const QPoint& pos){
            QMenu menu;
            IconHelper::setupMenu(&menu);
            menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                               /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                               "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                               "QMenu::icon { margin-left: 6px; } "
                               "QMenu::item:selected { background-color: #3E3E42; }");
            menu.addAction("向左移动", [this, splitter](){
                int index = splitter->indexOf(m_metaPanel);
                if (index > 0) splitter->insertWidget(index - 1, m_metaPanel);
            });
            menu.addAction("向右移动", [this, splitter](){
                int index = splitter->indexOf(m_metaPanel);
                if (index < splitter->count() - 1) splitter->insertWidget(index + 1, m_metaPanel);
            });
            menu.exec(metaHeader->mapToGlobal(pos));
        });
    }

    splitter->addWidget(m_metaPanel);

    // 6. 高级筛选器卡片容器
    auto* filterContainer = new QFrame();
    filterContainer->setMinimumWidth(230);
    filterContainer->setObjectName("FilterContainer");
    filterContainer->setAttribute(Qt::WA_StyledBackground, true);
    filterContainer->setStyleSheet(
        "#FilterContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );

    auto* filterShadow = new QGraphicsDropShadowEffect(filterContainer);
    filterShadow->setBlurRadius(10);
    filterShadow->setXOffset(0);
    filterShadow->setYOffset(4);
    filterShadow->setColor(QColor(0, 0, 0, 150));
    filterContainer->setGraphicsEffect(filterShadow);

    auto* filterContainerLayout = new QVBoxLayout(filterContainer);
    filterContainerLayout->setContentsMargins(0, 0, 0, 0);
    filterContainerLayout->setSpacing(0);

    // 筛选器标题栏
    auto* filterHeader = new QWidget();
    filterHeader->setFixedHeight(32);
    filterHeader->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #333;"
    );
    auto* filterHeaderLayout = new QHBoxLayout(filterHeader);
    filterHeaderLayout->setContentsMargins(15, 0, 15, 0);
    auto* fiIcon = new QLabel();
    fiIcon->setPixmap(IconHelper::getIcon("filter", "#f1c40f").pixmap(18, 18));
    filterHeaderLayout->addWidget(fiIcon);
    auto* fiTitle = new QLabel("高级筛选");
    fiTitle->setStyleSheet("color: #f1c40f; font-size: 13px; font-weight: bold; background: transparent; border: none;");
    filterHeaderLayout->addWidget(fiTitle);
    filterHeaderLayout->addStretch();

    auto* filterCloseBtn = new QPushButton();
    filterCloseBtn->setIcon(IconHelper::getIcon("close", "#888888"));
    filterCloseBtn->setFixedSize(24, 24);
    filterCloseBtn->setCursor(Qt::PointingHandCursor);
    filterCloseBtn->setStyleSheet(
        "QPushButton { background-color: transparent; border: none; border-radius: 4px; }"
        "QPushButton:hover { background-color: #e74c3c; }"
    );
    connect(filterCloseBtn, &QPushButton::clicked, this, [this](){
        m_filterWrapper->hide();
        m_header->setFilterActive(false);
    });
    filterHeaderLayout->addWidget(filterCloseBtn);
    
    filterHeader->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(filterHeader, &QWidget::customContextMenuRequested, this, [this, filterContainer, splitter, filterHeader](const QPoint& pos){
        QMenu menu;
        menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                           /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                           "QMenu::icon { margin-left: 6px; } "
                           "QMenu::item:selected { background-color: #3E3E42; }");
        menu.addAction("向左移动", [this, filterContainer, splitter](){
            int index = splitter->indexOf(filterContainer);
            if (index > 0) splitter->insertWidget(index - 1, filterContainer);
        });
        menu.addAction("向右移动", [this, filterContainer, splitter](){
            int index = splitter->indexOf(filterContainer);
            if (index < splitter->count() - 1) splitter->insertWidget(index + 1, filterContainer);
        });
        menu.exec(filterHeader->mapToGlobal(pos));
    });
    
    filterContainerLayout->addWidget(filterHeader);

    // 内容容器
    auto* filterContent = new QWidget();
    filterContent->setAttribute(Qt::WA_StyledBackground, true);
    filterContent->setStyleSheet("background: transparent; border: none;");
    auto* filterContentLayout = new QVBoxLayout(filterContent);
    filterContentLayout->setContentsMargins(0, 0, 10, 10);

    m_filterPanel = new FilterPanel(this);
    m_filterPanel->setStyleSheet("background: transparent; border: none;");
    connect(m_filterPanel, &FilterPanel::filterChanged, this, &MainWindow::refreshData);
    filterContentLayout->addWidget(m_filterPanel);
    filterContainerLayout->addWidget(filterContent);

    m_filterWrapper = filterContainer;
    splitter->addWidget(m_filterWrapper);



    splitter->setStretchFactor(0, 1); 
    splitter->setStretchFactor(1, 2); 
    splitter->setStretchFactor(2, 8); 
    splitter->setStretchFactor(3, 1); 
    splitter->setStretchFactor(4, 1);
    
    // 显式设置初始大小比例
    splitter->setSizes({230, 230, 600, 230, 230});

    contentLayout->addWidget(splitter);
    mainLayout->addWidget(contentWidget);

    m_partitionTree->installEventFilter(this);

    m_quickPreview = new QuickPreview(this);
    connect(m_quickPreview, &QuickPreview::editRequested, this, [this](int id){
        NoteEditWindow* win = new NoteEditWindow(id);
        connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
        win->show();
    });
    connect(m_quickPreview, &QuickPreview::prevRequested, this, [this](){
        QModelIndex current = m_noteList->currentIndex();
        if (!current.isValid() || m_noteModel->rowCount() == 0) return;

        int catId = current.data(NoteModel::CategoryIdRole).toInt();
        int row = current.row();
        int count = m_noteModel->rowCount();
        
        // 循环向上查找相同分类
        for (int i = 1; i <= count; ++i) {
            int prevRow = (row - i + count) % count;
            QModelIndex idx = m_noteModel->index(prevRow, 0);
            if (idx.data(NoteModel::CategoryIdRole).toInt() == catId) {
                m_noteList->setCurrentIndex(idx);
                m_noteList->scrollTo(idx);
                updatePreviewContent();
                if (prevRow > row) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "已回环至列表末尾相同分类");
                }
                return;
            }
        }
    });
    connect(m_quickPreview, &QuickPreview::nextRequested, this, [this](){
        QModelIndex current = m_noteList->currentIndex();
        if (!current.isValid() || m_noteModel->rowCount() == 0) return;

        int catId = current.data(NoteModel::CategoryIdRole).toInt();
        int row = current.row();
        int count = m_noteModel->rowCount();

        // 循环向下查找相同分类
        for (int i = 1; i <= count; ++i) {
            int nextRow = (row + i) % count;
            QModelIndex idx = m_noteModel->index(nextRow, 0);
            if (idx.data(NoteModel::CategoryIdRole).toInt() == catId) {
                m_noteList->setCurrentIndex(idx);
                m_noteList->scrollTo(idx);
                updatePreviewContent();
                if (nextRow < row) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "已回环至列表起始相同分类");
                }
                return;
            }
        }
    });
    connect(m_quickPreview, &QuickPreview::historyNavigationRequested, this, [this](int id){
        // 在模型中查找此 ID 的行
        for (int i = 0; i < m_noteModel->rowCount(); ++i) {
            QModelIndex idx = m_noteModel->index(i, 0);
            if (idx.data(NoteModel::IdRole).toInt() == id) {
                m_noteList->setCurrentIndex(idx);
                m_noteList->scrollTo(idx);
                // 注意：setCurrentIndex 会触发 onSelectionChanged -> updatePreviewContent
                return;
            }
        }
        // 如果在当前列表中没找到（可能被过滤了），则直接更新预览内容而不切换列表选中项
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        if (!note.isEmpty()) {
            m_quickPreview->showPreview(
                id,
                note.value("title").toString(),
                note.value("content").toString(),
                note.value("item_type").toString(),
                note.value("data_blob").toByteArray(),
                m_quickPreview->pos(),
                "" // 分类名暂时留空或根据需要查询
            );
        }
    });

    m_noteList->installEventFilter(this);
}

void MainWindow::showEvent(QShowEvent* event) {
    QMainWindow::showEvent(event);
    // 从 HeaderBar 获取按钮状态
    if (m_header) {
        auto* btn = m_header->findChild<QPushButton*>("btnStayOnTop");
        if (btn && btn->isChecked()) {
#ifdef Q_OS_WIN
            HWND hwnd = (HWND)winId();
            SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
            Qt::WindowFlags f = windowFlags();
            f |= Qt::WindowStaysOnTopHint;
            setWindowFlags(f);
            show();
#endif
        }
    }
}

#ifdef Q_OS_WIN
bool MainWindow::nativeEvent(const QByteArray &eventType, void *message, qintptr *result) {
    MSG* msg = static_cast<MSG*>(message);
    if (msg->message == WM_NCHITTEST) {
        int x = GET_X_LPARAM(msg->lParam);
        int y = GET_Y_LPARAM(msg->lParam);
        
        QPoint pos = mapFromGlobal(QPoint(x, y));
        int margin = RESIZE_MARGIN;
        int w = width();
        int h = height();

        bool left = pos.x() < margin;
        bool right = pos.x() > w - margin;
        bool top = pos.y() < margin;
        bool bottom = pos.y() > h - margin;

        if (top && left) *result = HTTOPLEFT;
        else if (top && right) *result = HTTOPRIGHT;
        else if (bottom && left) *result = HTBOTTOMLEFT;
        else if (bottom && right) *result = HTBOTTOMRIGHT;
        else if (top) *result = HTTOP;
        else if (bottom) *result = HTBOTTOM;
        else if (left) *result = HTLEFT;
        else if (right) *result = HTRIGHT;
        else return QMainWindow::nativeEvent(eventType, message, result);

        return true;
    }
    return QMainWindow::nativeEvent(eventType, message, result);
}
#endif

void MainWindow::onNoteAdded(const QVariantMap& note) {
    m_noteModel->prependNote(note);
    m_noteList->scrollToTop();
}

void MainWindow::scheduleRefresh() {
    m_refreshTimer->start();
}

void MainWindow::refreshData() {
    // 保存当前选中项状态以供恢复
    QString selectedType;
    QVariant selectedValue;
    QModelIndex sysIdx = m_systemTree->currentIndex();
    QModelIndex partIdx = m_partitionTree->currentIndex();
    
    if (sysIdx.isValid()) {
        selectedType = sysIdx.data(CategoryModel::TypeRole).toString();
        selectedValue = sysIdx.data(CategoryModel::NameRole);
    } else if (partIdx.isValid()) {
        selectedType = partIdx.data(CategoryModel::TypeRole).toString();
        selectedValue = partIdx.data(CategoryModel::IdRole);
    }

    QSet<QString> expandedPaths;
    std::function<void(const QModelIndex&)> checkChildren = [&](const QModelIndex& parent) {
        for (int j = 0; j < m_partitionModel->rowCount(parent); ++j) {
            QModelIndex child = m_partitionModel->index(j, 0, parent);
            if (m_partitionTree->isExpanded(child)) {
                QString type = child.data(CategoryModel::TypeRole).toString();
                if (type == "category") {
                    expandedPaths.insert("cat_" + QString::number(child.data(CategoryModel::IdRole).toInt()));
                } else {
                    expandedPaths.insert(child.data(CategoryModel::NameRole).toString());
                }
            }
            if (m_partitionModel->rowCount(child) > 0) checkChildren(child);
        }
    };

    for (int i = 0; i < m_partitionModel->rowCount(); ++i) {
        QModelIndex index = m_partitionModel->index(i, 0);
        if (m_partitionTree->isExpanded(index)) {
            expandedPaths.insert(index.data(CategoryModel::NameRole).toString());
        }
        checkChildren(index);
    }

    QVariantMap criteria = m_filterPanel->getCheckedCriteria();
    auto notes = DatabaseManager::instance().searchNotes(m_currentKeyword, m_currentFilterType, m_currentFilterValue, m_currentPage, m_pageSize, criteria);
    int totalCount = DatabaseManager::instance().getNotesCount(m_currentKeyword, m_currentFilterType, m_currentFilterValue, criteria);

    // 检查当前分类是否锁定
    bool isLocked = false;
    if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
        int catId = m_currentFilterValue.toInt();
        if (DatabaseManager::instance().isCategoryLocked(catId)) {
            isLocked = true;
            QString hint;
            auto cats = DatabaseManager::instance().getAllCategories();
            for(const auto& c : std::as_const(cats)) if(c.value("id").toInt() == catId) hint = c.value("password_hint").toString();
            m_lockWidget->setCategory(catId, hint);
        }
    }

    m_noteList->setVisible(!isLocked);
    m_lockWidget->setVisible(isLocked);

    if (isLocked) {
        m_editor->setPlainText("");
        m_metaPanel->clearSelection();
    }

    m_noteModel->setNotes(isLocked ? QList<QVariantMap>() : notes);
    m_systemModel->refresh();
    m_partitionModel->refresh();

    int totalPages = (totalCount + m_pageSize - 1) / m_pageSize;
    if (totalPages < 1) totalPages = 1;
    m_header->updatePagination(m_currentPage, totalPages);

    // 恢复系统项选中
    if (!selectedType.isEmpty() && selectedType != "category") {
        for (int i = 0; i < m_systemModel->rowCount(); ++i) {
            QModelIndex idx = m_systemModel->index(i, 0);
            if (idx.data(CategoryModel::TypeRole).toString() == selectedType &&
                idx.data(CategoryModel::NameRole) == selectedValue) {
                m_systemTree->setCurrentIndex(idx);
                break;
            }
        }
    }

    // 恢复分区选中与展开
    for (int i = 0; i < m_partitionModel->rowCount(); ++i) {
        QModelIndex index = m_partitionModel->index(i, 0);
        QString name = index.data(CategoryModel::NameRole).toString();

        if (name == "我的分区" || expandedPaths.contains(name)) {
            m_partitionTree->setExpanded(index, true);
        }
        
        std::function<void(const QModelIndex&)> restoreChildren = [&](const QModelIndex& parent) {
            for (int j = 0; j < m_partitionModel->rowCount(parent); ++j) {
                QModelIndex child = m_partitionModel->index(j, 0, parent);
                QString cType = child.data(CategoryModel::TypeRole).toString();
                QString cName = child.data(CategoryModel::NameRole).toString();
                
                // 恢复选中
                if (!selectedType.isEmpty() && cType == "category" && child.data(CategoryModel::IdRole) == selectedValue) {
                    m_partitionTree->setCurrentIndex(child);
                }

                QString identifier = (cType == "category") ? 
                    ("cat_" + QString::number(child.data(CategoryModel::IdRole).toInt())) : cName;

                if (expandedPaths.contains(identifier) || (parent.data(CategoryModel::NameRole).toString() == "我的分区")) {
                    m_partitionTree->setExpanded(child, true);
                }
                if (m_partitionModel->rowCount(child) > 0) restoreChildren(child);
            }
        };
        restoreChildren(index);
    }

    if (!m_filterWrapper->isHidden()) {
        m_filterPanel->updateStats(m_currentKeyword, m_currentFilterType, m_currentFilterValue);
    }
}

void MainWindow::onNoteSelected(const QModelIndex& index) {
}

void MainWindow::onSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected) {
    QModelIndexList indices = m_noteList->selectionModel()->selectedIndexes();
    if (indices.isEmpty()) {
        m_metaPanel->clearSelection();
        m_editor->setPlainText("");
        m_editLockBtn->setEnabled(false);
        m_editLockBtn->setChecked(false);
        m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#555555"));
        m_editLockBtn->setToolTip("请先选择一条笔记以启用编辑");
    } else if (indices.size() == 1) {
        int id = indices.first().data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        
        // 记录访问
        DatabaseManager::instance().recordAccess(id);

        m_editor->setNote(note, true);
        m_metaPanel->setNote(note);
        m_editLockBtn->setEnabled(true);
        // 切换笔记时自动退出编辑模式，防止误操作或内容丢失
        m_editLockBtn->setChecked(false);
        m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#aaaaaa"));
        m_editLockBtn->setToolTip("点击进入编辑模式");

        // 联动更新预览窗口
        if (m_quickPreview->isVisible()) {
            updatePreviewContent();
        }
    } else {
        m_metaPanel->setMultipleNotes(indices.size());
        m_editor->setPlainText(QString("已选中 %1 条笔记").arg(indices.size()));
        m_editLockBtn->setEnabled(false);
        m_editLockBtn->setChecked(false);
        m_editLockBtn->setIcon(IconHelper::getIcon("edit", "#555555"));
        m_editLockBtn->setToolTip("多选状态下不可直接编辑");
    }
}

void MainWindow::setupShortcuts() {
    auto add = [&](const QString& id, std::function<void()> func) {
        auto* sc = new QShortcut(ShortcutManager::instance().getShortcut(id), this, func);
        sc->setProperty("id", id);
    };

    add("mw_filter", [this](){ emit m_header->filterRequested(); });
    // [CRITICAL] 使用 ApplicationShortcut 确保在子窗口（如预览窗）获得焦点时也能触发
    auto* previewSc = new QShortcut(ShortcutManager::instance().getShortcut("mw_preview"), this, [this](){ doPreview(); }, Qt::ApplicationShortcut);
    previewSc->setProperty("id", "mw_preview");
    add("mw_meta", [this](){ 
        bool current = m_metaPanel->isVisible();
        emit m_header->metadataToggled(!current); 
    });
    add("mw_refresh", [this](){ refreshData(); });
    add("mw_search", [this](){ m_header->focusSearch(); });
    add("mw_new", [this](){ doNewIdea(); });
    add("mw_save", [this](){ if(m_editLockBtn->isChecked()) saveCurrentNote(); });
    add("mw_edit", [this](){ doEditSelected(); });
    add("mw_extract", [this](){ doExtractContent(); });
    add("mw_lock_cat", [this](){
        if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
            DatabaseManager::instance().lockCategory(m_currentFilterValue.toInt());
            refreshData();
        }
    });
    add("mw_delete_soft", [this](){ doDeleteSelected(false); });
    add("mw_delete_hard", [this](){ doDeleteSelected(true); });
    add("mw_copy_tags", [this](){ doCopyTags(); });
    add("mw_paste_tags", [this](){ doPasteTags(); });
    add("mw_close", [this](){ close(); });

    for (int i = 0; i <= 5; ++i) {
        add(QString("mw_rating_%1").arg(i), [this, i](){ doSetRating(i); });
    }
}

void MainWindow::updateShortcuts() {
    // Note: m_shortcutActions was partially used in old version, but we should use QShortcut list
    // Let's fix the member variable usage to match NoteEditWindow/QuickWindow style
    auto shortcuts = findChildren<QShortcut*>();
    for (auto* sc : shortcuts) {
        QString id = sc->property("id").toString();
        if (!id.isEmpty()) {
            sc->setKey(ShortcutManager::instance().getShortcut(id));
        }
    }
}

void MainWindow::keyPressEvent(QKeyEvent* event) {
    QMainWindow::keyPressEvent(event);
}

bool MainWindow::eventFilter(QObject* watched, QEvent* event) {
    if (watched == m_partitionTree && event->type() == QEvent::KeyPress) {
        QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
        int key = keyEvent->key();
        auto modifiers = keyEvent->modifiers();

        if ((key == Qt::Key_Up || key == Qt::Key_Down) && (modifiers & Qt::ControlModifier)) {
            QModelIndex current = m_partitionTree->currentIndex();
            if (current.isValid() && current.data(CategoryModel::TypeRole).toString() == "category") {
                int catId = current.data(CategoryModel::IdRole).toInt();
                DatabaseManager::MoveDirection dir;
                
                if (key == Qt::Key_Up) {
                    dir = (modifiers & Qt::ShiftModifier) ? DatabaseManager::Top : DatabaseManager::Up;
                } else {
                    dir = (modifiers & Qt::ShiftModifier) ? DatabaseManager::Bottom : DatabaseManager::Down;
                }

                if (DatabaseManager::instance().moveCategory(catId, dir)) {
                    refreshData();
                    // 重新选中该分类 (refreshData 会刷新整个模型)
                    // 注意：refreshData 内部有恢复选中的逻辑，但它是基于 NameRole 的。
                    // 既然 sort_order 变了，我们需要确保它还在选中状态。
                    return true;
                }
            }
        }
    }

    return QMainWindow::eventFilter(watched, event);
}

void MainWindow::onTagSelected(const QModelIndex& index) {
    m_currentFilterType = index.data(CategoryModel::TypeRole).toString();
    if (m_currentFilterType == "category") {
        m_currentFilterValue = index.data(CategoryModel::IdRole).toInt();
        StringUtils::recordRecentCategory(m_currentFilterValue.toInt());
    } else {
        m_currentFilterValue = -1;
    }
    m_currentPage = 1;
    refreshData();
}

void MainWindow::showContextMenu(const QPoint& pos) {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) {
        QModelIndex index = m_noteList->indexAt(pos);
        if (index.isValid()) {
            m_noteList->setCurrentIndex(index);
            selected << index;
        } else {
            return;
        }
    }

    int selCount = selected.size();
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    if (selCount == 1) {
        menu.addAction(IconHelper::getIcon("eye", "#1abc9c", 18), "预览 (Space)", this, &MainWindow::doPreview);
        
        QString type = selected.first().data(NoteModel::TypeRole).toString();
        if (type == "image") {
            menu.addAction(IconHelper::getIcon("screenshot_ocr", "#3498db", 18), "从图提取文字", this, &MainWindow::doOCR);
        }
    }
    
    menu.addAction(IconHelper::getIcon("copy", "#1abc9c", 18), QString("复制内容 (%1)").arg(selCount), this, &MainWindow::doExtractContent);
    menu.addSeparator();

    if (selCount == 1) {
        menu.addAction(IconHelper::getIcon("edit", "#4a90e2", 18), "编辑 (Ctrl+B)", this, &MainWindow::doEditSelected);
        menu.addSeparator();
    }

    auto* ratingMenu = menu.addMenu(IconHelper::getIcon("star", "#f39c12", 18), QString("设置星级 (%1)").arg(selCount));
    ratingMenu->setStyleSheet(menu.styleSheet());
    auto* starGroup = new QActionGroup(this);
    int currentRating = (selCount == 1) ? selected.first().data(NoteModel::RatingRole).toInt() : -1;
    
    for (int i = 1; i <= 5; ++i) {
        QString stars = QString("★").repeated(i);
        QAction* action = ratingMenu->addAction(stars, [this, i]() { doSetRating(i); });
        action->setCheckable(true);
        if (i == currentRating) action->setChecked(true);
        starGroup->addAction(action);
    }
    ratingMenu->addSeparator();
    ratingMenu->addAction("清除评级", [this]() { doSetRating(0); });

    bool isFavorite = (selCount == 1) && selected.first().data(NoteModel::FavoriteRole).toBool();
    menu.addAction(IconHelper::getIcon(isFavorite ? "bookmark_filled" : "bookmark", "#ff6b81", 18), 
                   isFavorite ? "取消书签" : "添加书签 (Ctrl+E)", this, &MainWindow::doToggleFavorite);

    bool isPinned = (selCount == 1) && selected.first().data(NoteModel::PinnedRole).toBool();
    menu.addAction(IconHelper::getIcon(isPinned ? "pin_vertical" : "pin_tilted", isPinned ? "#3A90FF" : "#aaaaaa", 18), 
                   isPinned ? "取消置顶" : "置顶选中项 (Ctrl+P)", this, &MainWindow::doTogglePin);
    
    bool isLocked = (selCount == 1) && selected.first().data(NoteModel::LockedRole).toBool();
    menu.addAction(IconHelper::getIcon("lock", isLocked ? "#aaaaaa" : "#888888", 18), 
                   isLocked ? "解锁选中项" : "锁定选中项 (Ctrl+S)", this, &MainWindow::doLockSelected);
    
    menu.addSeparator();

    auto* catMenu = menu.addMenu(IconHelper::getIcon("branch", "#cccccc", 18), QString("移动选中项到分类 (%1)").arg(selCount));
    catMenu->setStyleSheet(menu.styleSheet());
    catMenu->addAction(IconHelper::getIcon("uncategorized", "#e67e22", 18), "未分类", [this]() { doMoveToCategory(-1); });
    
    QVariantList recentCats = StringUtils::getRecentCategories();
    auto allCategories = DatabaseManager::instance().getAllCategories();
    QMap<int, QVariantMap> catMap;
    for (const auto& cat : std::as_const(allCategories)) catMap[cat.value("id").toInt()] = cat;

    int count = 0;
    for (const auto& v : std::as_const(recentCats)) {
        if (count >= 10) break;
        int cid = v.toInt();
        if (catMap.contains(cid)) {
            const auto& cat = catMap.value(cid);
            catMenu->addAction(IconHelper::getIcon("branch", cat.value("color").toString(), 18), cat.value("name").toString(), [this, cid]() {
                doMoveToCategory(cid);
            });
            count++;
        }
    }

    menu.addSeparator();
    if (m_currentFilterType == "trash") {
        menu.addAction(IconHelper::getIcon("refresh", "#2ecc71", 18), "恢复 (还原到未分类)", [this, selected](){
            QList<int> ids;
            for (const auto& index : selected) ids << index.data(NoteModel::IdRole).toInt();
            DatabaseManager::instance().moveNotesToCategory(ids, -1);
            refreshData();
        });
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "彻底删除 (不可逆)", [this](){ doDeleteSelected(true); });
    } else {
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "移至回收站 (Delete)", [this](){ doDeleteSelected(false); });
    }

    menu.exec(QCursor::pos());
}

void MainWindow::closeEvent(QCloseEvent* event) {
    saveLayout();
    QMainWindow::closeEvent(event);
}

void MainWindow::saveLayout() {
    QSettings settings("RapidNotes", "MainWindow");
    settings.setValue("geometry", saveGeometry());
    settings.setValue("windowState", saveState());

    if (m_header) {
        auto* btn = m_header->findChild<QPushButton*>("btnStayOnTop");
        if (btn) {
            settings.setValue("stayOnTop", btn->isChecked());
        }
    }
    
    QSplitter* splitter = findChild<QSplitter*>();
    if (splitter) {
        settings.setValue("splitterState", splitter->saveState());
    }

    // 保存面板可见性
    settings.setValue("showFilter", m_filterWrapper->isVisible());
    settings.setValue("showMetadata", m_metaPanel->isVisible());
}

void MainWindow::restoreLayout() {
    QSettings settings("RapidNotes", "MainWindow");
    if (settings.contains("geometry")) {
        restoreGeometry(settings.value("geometry").toByteArray());
    }
    if (settings.contains("windowState")) {
        restoreState(settings.value("windowState").toByteArray());
    }
    
    QSplitter* splitter = findChild<QSplitter*>();
    if (splitter && settings.contains("splitterState")) {
        splitter->restoreState(settings.value("splitterState").toByteArray());
    }

    // 恢复面板可见性
    bool showFilter = settings.value("showFilter", true).toBool();
    bool showMetadata = settings.value("showMetadata", true).toBool();
    
    m_filterWrapper->setVisible(showFilter);
    m_header->setFilterActive(showFilter);
    
    m_metaPanel->setVisible(showMetadata);
    m_header->setMetadataActive(showMetadata);

    bool stayOnTop = settings.value("stayOnTop", false).toBool();
    auto* btnStay = m_header->findChild<QPushButton*>("btnStayOnTop");
    if (btnStay) {
        btnStay->setChecked(stayOnTop);
        // 手动应用图标 (HeaderBar 不会自动切换图标，除非触发 toggled 信号)
        btnStay->setIcon(IconHelper::getIcon(stayOnTop ? "pin_vertical" : "pin_tilted", stayOnTop ? "#ffffff" : "#aaaaaa", 20));
        
        if (stayOnTop) {
            #ifdef Q_OS_WIN
            HWND hwnd = (HWND)winId();
            SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
            #else
            setWindowFlag(Qt::WindowStaysOnTopHint, true);
            #endif
        }
    }

    QSettings globalSettings("RapidNotes", "QuickWindow");
    m_autoCategorizeClipboard = globalSettings.value("autoCategorizeClipboard", false).toBool();
}

void MainWindow::showToolboxMenu(const QPoint& pos) {
    // 每次打开前刷新设置，确保与 QuickWindow 同步
    QSettings globalSettings("RapidNotes", "QuickWindow");
    m_autoCategorizeClipboard = globalSettings.value("autoCategorizeClipboard", false).toBool();

    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                           "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    QString iconName = m_autoCategorizeClipboard ? "switch_on" : "switch_off";
    QString iconColor = m_autoCategorizeClipboard ? "#00A650" : "#000000";
    QAction* autoCatAction = menu.addAction(IconHelper::getIcon(iconName, iconColor, 18), "剪贴板自动归档到当前分类");
    autoCatAction->setCheckable(true);
    autoCatAction->setChecked(m_autoCategorizeClipboard);
    connect(autoCatAction, &QAction::triggered, [this](bool checked){
        m_autoCategorizeClipboard = checked;
        QSettings settings("RapidNotes", "QuickWindow");
        settings.setValue("autoCategorizeClipboard", m_autoCategorizeClipboard);
        ToolTipOverlay::instance()->showText(QCursor::pos(), m_autoCategorizeClipboard ? "✅ 剪贴板自动归档已开启" : "❌ 剪贴板自动归档已关闭");
    });

    menu.addSeparator();
    
    menu.addAction(IconHelper::getIcon("save", "#aaaaaa", 18), "存储文件 (拖拽入库)", [this]() {
        emit fileStorageRequested();
    });

    menu.addAction(IconHelper::getIcon("settings", "#aaaaaa", 18), "更多设置...", [this]() {
        auto* dlg = new SettingsWindow(this);
        dlg->setAttribute(Qt::WA_DeleteOnClose);
        // 预定位：居中于主窗口
        dlg->move(this->geometry().center() - dlg->rect().center());
        dlg->exec();
    });

    menu.exec(pos);
}

void MainWindow::doPreview() {
    // 增加防抖保护，防止由于快捷键冲突（子窗口与主窗口同时响应）导致的“双重触发”现象
    // 这种现象表现为：按下空格后预览窗刚隐藏又被立即打开，看起来没反应
    static QElapsedTimer timer;
    if (timer.isValid() && timer.elapsed() < 200) {
        return;
    }
    timer.restart();

    QWidget* focusWidget = QApplication::focusWidget();
    // 保护：如果焦点在输入框，空格键应保留其原始打字功能
    // 但如果焦点在预览窗口内部（例如预览只读文本框），则不视为正在输入，允许切换预览
    if (focusWidget && (qobject_cast<QLineEdit*>(focusWidget) || 
                        qobject_cast<QTextEdit*>(focusWidget) ||
                        qobject_cast<QPlainTextEdit*>(focusWidget))) {
        if (focusWidget != m_quickPreview && !m_quickPreview->isAncestorOf(focusWidget)) {
            return;
        }
    }

    if (m_quickPreview->isVisible()) {
        m_quickPreview->hide();
        return;
    }
    
    updatePreviewContent();
    
    m_quickPreview->raise();
    m_quickPreview->activateWindow();
}

void MainWindow::updatePreviewContent() {
    QModelIndex index = m_noteList->currentIndex();
    if (!index.isValid()) return;
    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    
    QPoint pos;
    if (m_quickPreview->isVisible()) {
        pos = m_quickPreview->pos();
    } else {
        pos = m_noteList->mapToGlobal(m_noteList->rect().center()) - QPoint(250, 300);
    }

    m_quickPreview->showPreview(
        id,
        note.value("title").toString(), 
        note.value("content").toString(), 
        note.value("item_type").toString(),
        note.value("data_blob").toByteArray(),
        pos,
        index.data(NoteModel::CategoryNameRole).toString()
    );
}

void MainWindow::doDeleteSelected(bool physical) {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    bool inTrash = (m_currentFilterType == "trash");
    
    if (physical || inTrash) {
        QString title = inTrash ? "清空项目" : "彻底删除";
        QString text = QString("确定要永久删除选中的 %1 条数据吗？\n此操作不可逆，数据将无法找回。").arg(selected.count());
        
        auto* msg = new FramelessMessageBox(title, text, this);
        QList<int> idsToDelete;
        for (const auto& index : std::as_const(selected)) idsToDelete << index.data(NoteModel::IdRole).toInt();
        
        connect(msg, &FramelessMessageBox::confirmed, this, [this, idsToDelete]() {
            if (idsToDelete.isEmpty()) return;
            DatabaseManager::instance().deleteNotesBatch(idsToDelete);
            refreshData();
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已永久删除 %1 条数据").arg(idsToDelete.size()));
        });
        msg->show();
    } else {
        QList<int> ids;
        for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().softDeleteNotes(ids);
        refreshData();
    }
}

void MainWindow::doToggleFavorite() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().toggleNoteState(id, "is_favorite");
    }
    refreshData();
}

void MainWindow::doTogglePin() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().toggleNoteState(id, "is_pinned");
    }
    refreshData();
}

void MainWindow::doLockSelected() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    
    bool firstState = selected.first().data(NoteModel::LockedRole).toBool();
    bool targetState = !firstState;

    QList<int> ids;
    for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
    
    DatabaseManager::instance().updateNoteStateBatch(ids, "is_locked", targetState);
    refreshData();
}

void MainWindow::doNewIdea() {
    NoteEditWindow* win = new NoteEditWindow();
    connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
    win->show();
}

void MainWindow::doOCR() {
    QModelIndex index = m_noteList->currentIndex();
    if (!index.isValid()) return;

    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    if (note.value("item_type").toString() != "image") return;

    QByteArray data = note.value("data_blob").toByteArray();
    QImage img;
    img.loadFromData(data);
    if (img.isNull()) return;

    auto* resWin = new OCRResultWindow(img, id);
    connect(&OCRManager::instance(), &OCRManager::recognitionFinished, resWin, &OCRResultWindow::setRecognizedText);
    
    QSettings settings("RapidNotes", "OCR");
    if (settings.value("autoCopy", false).toBool()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "⏳ 正在识别文字...");
    } else {
        resWin->show();
    }
    
    OCRManager::instance().recognizeAsync(img, id);
}

void MainWindow::doExtractContent() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    QStringList texts;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        QString type = note.value("item_type").toString();
        if (type == "text" || type.isEmpty()) {
            QString content = note.value("content").toString();
            texts << StringUtils::htmlToPlainText(content);
        }
    }
    if (!texts.isEmpty()) {
        ClipboardMonitor::instance().skipNext();
        QApplication::clipboard()->setText(texts.join("\n---\n"));
    }
}

void MainWindow::doEditSelected() {
    QModelIndex index = m_noteList->currentIndex();
    if (!index.isValid()) return;
    int id = index.data(NoteModel::IdRole).toInt();
    NoteEditWindow* win = new NoteEditWindow(id);
    connect(win, &NoteEditWindow::noteSaved, this, &MainWindow::refreshData);
    win->show();
}

void MainWindow::doSetRating(int rating) {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().updateNoteState(id, "rating", rating);
    }
    refreshData();
}

void MainWindow::doMoveToCategory(int catId) {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QList<int> ids;
    for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
    
    DatabaseManager::instance().moveNotesToCategory(ids, catId);
    
    if (catId != -1) {
        StringUtils::recordRecentCategory(catId);
    }
    refreshData();
}

void MainWindow::saveCurrentNote() {
    QModelIndex index = m_noteList->currentIndex();
    if (!index.isValid()) return;
    int id = index.data(NoteModel::IdRole).toInt();
    
    QString content = m_editor->toHtml();
    
    // 保存前锁定剪贴板监控，防止自触发 (虽然 updateNoteState 不直接操作剪贴板，但为了严谨性)
    // 实际上 updateNoteState 会触发 noteUpdated，不会引起剪贴板变化。
    
    DatabaseManager::instance().updateNoteState(id, "content", content);
    DatabaseManager::instance().recordAccess(id);
    
    // 退出编辑模式
    m_editLockBtn->setChecked(false);
    refreshData();
    ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 内容已保存");
}

void MainWindow::toggleSearchBar() {
    m_editorSearchBar->setVisible(!m_editorSearchBar->isVisible());
    if (m_editorSearchBar->isVisible()) {
        m_editorSearchEdit->setFocus();
        m_editorSearchEdit->selectAll();
    }
}

void MainWindow::doCopyTags() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    // 获取选中的第一个项的标签
    int id = selected.first().data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    QString tagsStr = note.value("tags").toString();
    QStringList tags = tagsStr.split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
    for (QString& t : tags) t = t.trimmed();

    DatabaseManager::setTagClipboard(tags);
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✅ 已复制 %1 个标签").arg(tags.size()));
}

void MainWindow::doPasteTags() {
    auto selected = m_noteList->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QStringList tagsToPaste = DatabaseManager::getTagClipboard();
    if (tagsToPaste.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "❌ 标签剪贴板为空");
        return;
    }

    // 直接覆盖标签 (符合粘贴语义)
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().updateNoteState(id, "tags", tagsToPaste.join(", "));
    }

    // 刷新数据以显示新标签
    refreshData();
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✅ 已覆盖粘贴标签至 %1 条数据").arg(selected.size()));
}
```

## 文件: `src/ui/MainWindow.h`

```cpp
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QTreeView>
#include <QListView>
#include <QSplitter>
#include <QStandardItemModel>
#include <QTimer>
#include <QFileInfo>
#include "../models/NoteModel.h"
#include "../models/CategoryModel.h"
#include "Editor.h"
#include "NoteEditWindow.h"
#include "HeaderBar.h"
#include "MetadataPanel.h"
#include "QuickPreview.h"
#include "DropTreeView.h"
#include "FilterPanel.h"
#include "CategoryLockWidget.h"
#include "FileStorageWindow.h"

#ifdef Q_OS_WIN
#include <windows.h>
#include <windowsx.h>
#endif

class MainWindow : public QMainWindow {
    Q_OBJECT
public:
    explicit MainWindow(QWidget* parent = nullptr);
    int getCurrentCategoryId() const {
        if (m_currentFilterType == "category") return m_currentFilterValue.toInt();
        return -1;
    }

signals:
    void toolboxRequested();
    void fileStorageRequested();
    void globalLockRequested();

private slots:
    void onNoteSelected(const QModelIndex& index);
    void onSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected);
    void onTagSelected(const QModelIndex& index);
    void showContextMenu(const QPoint& pos);
    
    // Layout persistence
    void saveLayout();
    void restoreLayout();
    void updateShortcuts();

    // 【新增】处理单条笔记添加，不刷新全表
    void onNoteAdded(const QVariantMap& note);
    
    void refreshData();
    void scheduleRefresh();
    void doPreview();
    void updatePreviewContent();
    void showToolboxMenu(const QPoint& pos);

    // 快捷键处理与操作逻辑 (同步 QuickWindow)
    void doDeleteSelected(bool physical = false);
    void doToggleFavorite();
    void doTogglePin();
    void doLockSelected();
    void doNewIdea();
    void doExtractContent();
    void doOCR();
    void doEditSelected();
    void doSetRating(int rating);
    void doMoveToCategory(int catId);
    void saveCurrentNote();
    void toggleSearchBar();
    void doCopyTags();
    void doPasteTags();

protected:
#ifdef Q_OS_WIN
    bool nativeEvent(const QByteArray &eventType, void *message, qintptr *result) override;
#endif
    void showEvent(QShowEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void closeEvent(QCloseEvent* event) override;

private:
    void initUI();
    void setupShortcuts();
    
    DropTreeView* m_systemTree;
    CategoryModel* m_systemModel;
    DropTreeView* m_partitionTree;
    CategoryModel* m_partitionModel;
    QWidget* m_sidebarContainer;
    
    QListView* m_noteList;
    NoteModel* m_noteModel;

    HeaderBar* m_header;
    MetadataPanel* m_metaPanel;
    QuickPreview* m_quickPreview;
    FilterPanel* m_filterPanel;
    QWidget* m_filterWrapper;
    
    Editor* m_editor;
    CategoryLockWidget* m_lockWidget;
    QPushButton* m_editLockBtn;
    QWidget* m_editorToolbar;
    QWidget* m_editorSearchBar;
    QLineEdit* m_editorSearchEdit;

    QString m_currentKeyword;
    QString m_currentFilterType = "all";
    QVariant m_currentFilterValue = -1;
    int m_currentPage = 1;
    int m_pageSize = 50;
    bool m_autoCategorizeClipboard = false;
    QTimer* m_searchTimer;
    QTimer* m_refreshTimer;
};

#endif // MAINWINDOW_H
```

## 文件: `src/core/MessageCaptureHandler.cpp`

```cpp
#include "MessageCaptureHandler.h"
#include "KeyboardHook.h"
#include "DatabaseManager.h"
#include "ClipboardMonitor.h"
#include "Win32System.h"
#include <QClipboard>
#include <QApplication>
#include <QDebug>
#include <QDateTime>
#include <QTimer>
#include <QFileInfo>

#ifdef Q_OS_WIN
#include <windows.h>
#include <psapi.h>
#endif

MessageCaptureHandler& MessageCaptureHandler::instance() {
    static MessageCaptureHandler inst;
    return inst;
}

MessageCaptureHandler::MessageCaptureHandler(QObject* parent) : QObject(parent) {}

void MessageCaptureHandler::init() {
    connect(&KeyboardHook::instance(), &KeyboardHook::enterPressedInOtherApp, this, &MessageCaptureHandler::onEnterPressed);
    qDebug() << "[MessageCaptureHandler] 初始化完成，开始监听外部应用回车键";
}

void MessageCaptureHandler::onEnterPressed(bool ctrl, bool shift, bool alt) {
    // 简单的频率限制，防止长按回车或高频重复触发 (500ms 内仅一次)
    qint64 currentTime = QDateTime::currentMSecsSinceEpoch();
    if (currentTime - m_lastTriggerTime < 500) return;
    m_lastTriggerTime = currentTime;

    qDebug() << "[Capture] 触发捕获，C:" << ctrl << " S:" << shift << " A:" << alt;

    // 使用定时器序列，避免在 Hook 回调中执行过长的阻塞操作
    QTimer::singleShot(0, [this, ctrl, shift, alt]() {
        Win32System sys;
        
        // 告知剪贴板监控器跳过接下来的变更，由我们手动处理
        ClipboardMonitor::instance().skipNext();

        // 1. 模拟全选
        sys.simulateSelectAll();
        
        QTimer::singleShot(50, [this, ctrl, shift, alt]() {
            Win32System sys;
            // 2. 模拟复制
            sys.simulateCopy();
            
            QTimer::singleShot(150, [this, ctrl, shift, alt]() {
                QString text = QApplication::clipboard()->text().trimmed();
                
                Win32System sys;
                // 3. 模拟按下 END 键以取消全选状态，防止回车键删除选中的文字
                sys.simulateKeyStroke(VK_END);

                // 4. 补发原始回车键（带上原来的修饰键状态）
                sys.simulateKeyStroke(VK_RETURN, alt, ctrl, shift);

                if (text.isEmpty()) {
                    qDebug() << "[Capture] 捕获文本为空，取消保存";
                    return;
                }

                // 4. 获取来源应用信息
                QString sourceApp = "未知应用";
                QString sourceTitle = "未知窗口";
#ifdef Q_OS_WIN
                HWND hwnd = GetForegroundWindow();
                if (hwnd) {
                    wchar_t title[512];
                    if (GetWindowTextW(hwnd, title, 512)) {
                        sourceTitle = QString::fromWCharArray(title);
                    }
                    DWORD pid;
                    GetWindowThreadProcessId(hwnd, &pid);
                    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
                    if (hProcess) {
                        wchar_t exePath[MAX_PATH];
                        if (GetModuleFileNameExW(hProcess, NULL, exePath, MAX_PATH)) {
                            sourceApp = QFileInfo(QString::fromWCharArray(exePath)).baseName();
                        }
                        CloseHandle(hProcess);
                    }
                }
#endif

                // 5. 保存到数据库
                // 取第一行作为标题
                QString firstLine = text.section('\n', 0, 0).trimmed();
                QString title;
                if (firstLine.isEmpty()) {
                    title = "自动捕获消息";
                } else {
                    title = firstLine.left(40);
                    if (firstLine.length() > 40) title += "...";
                }
                
                // 使用特定的 item_type: captured_message
                DatabaseManager::instance().addNoteAsync(title, text, {"自动捕获"}, "", -1, "captured_message", QByteArray(), sourceApp, sourceTitle);
                qDebug() << "[Capture] 已保存捕获的消息:" << title;
            });
        });
    });
}
```

## 文件: `src/core/MessageCaptureHandler.h`

```cpp
#ifndef MESSAGECAPTUREHANDLER_H
#define MESSAGECAPTUREHANDLER_H

#include <QObject>

class MessageCaptureHandler : public QObject {
    Q_OBJECT
public:
    static MessageCaptureHandler& instance();
    void init();

private slots:
    void onEnterPressed(bool ctrl, bool shift, bool alt);

private:
    MessageCaptureHandler(QObject* parent = nullptr);
    qint64 m_lastTriggerTime = 0;
};

#endif // MESSAGECAPTUREHANDLER_H
```

## 文件: `src/ui/MetadataPanel.cpp`

```cpp
#include "MetadataPanel.h"
#include "AdvancedTagSelector.h"
#include "TitleEditorDialog.h"
#include "../core/DatabaseManager.h"
#include "IconHelper.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QFrame>
#include <QGraphicsDropShadowEffect>
#include <QApplication>
#include <QTextEdit>
#include <QDialog>
#include <QCursor>


// ==========================================
// MetadataPanel
// ==========================================
MetadataPanel::MetadataPanel(QWidget* parent) : QWidget(parent) {
    setMinimumWidth(230); // 最小宽度 230px，可拉伸
    setAttribute(Qt::WA_StyledBackground, true);
    setStyleSheet("background: transparent; border: none; outline: none;");
    initUI();
}

void MetadataPanel::initUI() {
    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0); // 移除外部边距，由 MainWindow 的 Splitter 统一控制

    // 内部卡片容器
    auto* container = new QFrame(this);
    container->setObjectName("MetadataContainer");
    container->setStyleSheet(
        "#MetadataContainer {"
        "  background-color: #1e1e1e;"
        "  border: 1px solid #333333;"
        "  border-top-left-radius: 12px;"
        "  border-top-right-radius: 12px;"
        "  border-bottom-left-radius: 0px;"
        "  border-bottom-right-radius: 0px;"
        "}"
    );
    container->setAttribute(Qt::WA_StyledBackground, true);

    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(10);
    shadow->setXOffset(0);
    shadow->setYOffset(4);
    shadow->setColor(QColor(0, 0, 0, 150));
    container->setGraphicsEffect(shadow);

    auto* containerLayout = new QVBoxLayout(container);
    containerLayout->setContentsMargins(0, 0, 0, 0); // 设为 0 以允许标题栏拉伸到边缘
    containerLayout->setSpacing(0);

    // 1. 顶部标题栏 (锁定 32px，标准配色)
    auto* titleBar = new QWidget();
    titleBar->setObjectName("MetadataHeader");
    titleBar->setFixedHeight(32);
    titleBar->setStyleSheet(
        "background-color: #252526; "
        "border-top-left-radius: 12px; "
        "border-top-right-radius: 12px; "
        "border-bottom: 1px solid #333;" // 统一通过 border 实现分割线
    );
    auto* titleLayout = new QHBoxLayout(titleBar);
    titleLayout->setContentsMargins(15, 0, 10, 0);
    titleLayout->setSpacing(8);

    auto* icon = new QLabel();
    icon->setPixmap(IconHelper::getIcon("all_data", "#4a90e2", 18).pixmap(18, 18));
    auto* lbl = new QLabel("元数据");
    lbl->setStyleSheet("font-size: 13px; font-weight: bold; color: #4a90e2; background: transparent; border: none;");
    titleLayout->addWidget(icon);
    titleLayout->addWidget(lbl);
    titleLayout->addStretch();

    auto* closeBtn = new QPushButton();
    closeBtn->setIcon(IconHelper::getIcon("close", "#888888"));
    closeBtn->setFixedSize(24, 24);
    closeBtn->setCursor(Qt::PointingHandCursor);
    closeBtn->setStyleSheet(
        "QPushButton { background-color: transparent; border: none; border-radius: 4px; }"
        "QPushButton:hover { background-color: #e74c3c; }"
    );
    connect(closeBtn, &QPushButton::clicked, this, [this](){
        hide();
        emit closed();
    });
    titleLayout->addWidget(closeBtn);
    containerLayout->addWidget(titleBar);

    // 3. 内容包裹容器 (带边距)
    auto* contentWidget = new QWidget();
    contentWidget->setStyleSheet(
        "QWidget { "
        "  background-color: transparent; "
        "  border: none; "
        "  border-bottom-left-radius: 0px; "
        "  border-bottom-right-radius: 0px; "
        "}"
    );
    auto* innerLayout = new QVBoxLayout(contentWidget);
    innerLayout->setContentsMargins(15, 10, 15, 15);
    innerLayout->setSpacing(10);

    m_stack = new QStackedWidget(this);
    m_stack->setStyleSheet("background-color: transparent;");
    
    m_stack->addWidget(createInfoWidget("select", "未选择项目", "请选择一个项目以查看其元数据"));
    m_stack->addWidget(createInfoWidget("all_data", "已选择多个项目", "请仅选择一项以查看其元数据"));
    
    m_metadataDisplayWidget = createMetadataDisplay();
    m_stack->addWidget(m_metadataDisplayWidget);
    
    innerLayout->addWidget(m_stack);

    // 标题输入框 (仅单选显示)
    m_titleEdit = new ClickableLineEdit();
    m_titleEdit->setPlaceholderText("标题");
    m_titleEdit->setStyleSheet(
        "background-color: rgba(255, 255, 255, 0.05); "
        "border: 1px solid rgba(255, 255, 255, 0.1); "
        "border-radius: 10px; "
        "color: #EEE; "
        "font-size: 13px; "
        "font-weight: bold; "
        "padding: 8px 12px; "
        "margin-top: 10px;"
    );
    connect(m_titleEdit, &QLineEdit::editingFinished, [this](){
        if(m_currentNoteId != -1) {
            DatabaseManager::instance().updateNoteState(m_currentNoteId, "title", m_titleEdit->text());
            emit noteUpdated();
        }
    });
    connect(m_titleEdit, &QLineEdit::returnPressed, m_titleEdit, &QWidget::clearFocus);
    connect(m_titleEdit, &ClickableLineEdit::doubleClicked, this, &MetadataPanel::openExpandedTitleEditor);
    innerLayout->addWidget(m_titleEdit);

    innerLayout->addStretch(1);

    m_separatorLine = new QFrame();
    m_separatorLine->setFrameShape(QFrame::HLine);
    m_separatorLine->setFrameShadow(QFrame::Plain);
    m_separatorLine->setStyleSheet("background-color: #505050; border: none; max-height: 1px; margin-bottom: 5px;");
    innerLayout->addWidget(m_separatorLine);

    // 标签输入框 (双击更多)
    m_tagEdit = new ClickableLineEdit();
    m_tagEdit->setPlaceholderText("输入标签添加... (双击更多)");
    m_tagEdit->setStyleSheet(
        "QLineEdit { background-color: rgba(255, 255, 255, 0.05); "
        "border: 1px solid rgba(255, 255, 255, 0.1); "
        "border-radius: 10px; "
        "padding: 8px 12px; "
        "font-size: 12px; "
        "color: #EEE; } "
        "QLineEdit:focus { border-color: #4a90e2; background-color: rgba(255, 255, 255, 0.08); } "
        "QLineEdit:disabled { background-color: transparent; border: 1px solid #333; color: #666; }"
    );
    connect(m_tagEdit, &QLineEdit::returnPressed, this, &MetadataPanel::handleTagInput);
    connect(m_tagEdit, &ClickableLineEdit::doubleClicked, this, &MetadataPanel::openTagSelector);
    innerLayout->addWidget(m_tagEdit);

    containerLayout->addWidget(contentWidget);
    mainLayout->addWidget(container);

    // 初始状态
    clearSelection();
}

QWidget* MetadataPanel::createInfoWidget(const QString& icon, const QString& title, const QString& subtitle) {
    auto* w = new QWidget();
    auto* layout = new QVBoxLayout(w);
    layout->setContentsMargins(20, 40, 20, 20);
    layout->setSpacing(15);
    layout->setAlignment(Qt::AlignCenter);

    auto* iconLabel = new QLabel();
    iconLabel->setPixmap(IconHelper::getIcon(icon, "#555", 64).pixmap(64, 64));
    iconLabel->setAlignment(Qt::AlignCenter);
    layout->addWidget(iconLabel);

    auto* titleLabel = new QLabel(title);
    titleLabel->setAlignment(Qt::AlignCenter);
    titleLabel->setStyleSheet("font-size: 14px; font-weight: bold; color: #e0e0e0;");
    layout->addWidget(titleLabel);

    auto* subLabel = new QLabel(subtitle);
    subLabel->setAlignment(Qt::AlignCenter);
    subLabel->setStyleSheet("font-size: 12px; color: #888;");
    subLabel->setWordWrap(true);
    layout->addWidget(subLabel);

    layout->addStretch();
    return w;
}

QWidget* MetadataPanel::createMetadataDisplay() {
    auto* w = new QWidget();
    auto* layout = new QVBoxLayout(w);
    layout->setContentsMargins(0, 5, 0, 5);
    layout->setSpacing(8);
    layout->setAlignment(Qt::AlignTop);

    layout->addWidget(createCapsule("创建于", "created"));
    layout->addWidget(createCapsule("更新于", "updated"));
    layout->addWidget(createCapsule("分类", "category"));
    layout->addWidget(createCapsule("状态", "status"));
    layout->addWidget(createCapsule("星级", "rating"));
    layout->addWidget(createCapsule("标签", "tags"));

    return w;
}

QWidget* MetadataPanel::createCapsule(const QString& label, const QString& key) {
    auto* row = new QWidget();
    row->setAttribute(Qt::WA_StyledBackground, true);
    auto* layout = new QHBoxLayout(row);
    layout->setContentsMargins(12, 8, 12, 8);
    layout->setSpacing(10);
    
    row->setStyleSheet(
        "QWidget { background-color: rgba(255, 255, 255, 0.05); "
        "border: 1px solid rgba(255, 255, 255, 0.1); "
        "border-radius: 10px; }"
    );
    
    auto* lbl = new QLabel(label);
    lbl->setStyleSheet("font-size: 11px; color: #AAA; border: none; min-width: 45px; background: transparent;");
    
    auto* val = new QLabel("-");
    val->setWordWrap(true);
    val->setStyleSheet("font-size: 12px; color: #FFF; border: none; font-weight: bold; background: transparent;");
    val->setAlignment(Qt::AlignLeft | Qt::AlignVCenter);
    
    layout->addWidget(lbl);
    layout->addWidget(val);
    
    m_capsules[key] = val;
    return row;
}

void MetadataPanel::setNote(const QVariantMap& note) {
    if(note.isEmpty()) {
        clearSelection();
        return;
    }
    m_currentNoteId = note.value("id").toInt();
    m_stack->setCurrentIndex(2); // 详情页
    
    m_titleEdit->show();
    m_titleEdit->setText(note.value("title").toString());
    m_titleEdit->setCursorPosition(0);
    
    m_tagEdit->setEnabled(true);
    m_tagEdit->setPlaceholderText("输入标签添加... (双击更多)");
    m_separatorLine->show();

    m_capsules["created"]->setText(note.value("created_at").toString().left(16).replace("T", " "));
    m_capsules["updated"]->setText(note.value("updated_at").toString().left(16).replace("T", " "));
    
    int rating = note.value("rating").toInt();
    QString stars = QString("★").repeated(rating) + QString("☆").repeated(5 - rating);
    m_capsules["rating"]->setText(stars);
    
    QStringList status;
    if (note.value("is_pinned").toInt() > 0) status << "置顶";
    if (note.value("is_favorite").toInt() > 0) status << "书签";
    if (note.value("is_locked").toInt() > 0) status << "锁定";
    m_capsules["status"]->setText(status.isEmpty() ? "常规" : status.join(", "));

    // 分类
    int catId = note.value("category_id").toInt();
    if (catId > 0) {
        auto categories = DatabaseManager::instance().getAllCategories();
        for (const auto& cat : categories) {
            if (cat.value("id").toInt() == catId) {
                m_capsules["category"]->setText(cat.value("name").toString());
                break;
            }
        }
    } else {
        m_capsules["category"]->setText("未分类");
    }

    // 标签显示
    m_capsules["tags"]->setText(note.value("tags").toString().isEmpty() ? "无" : note.value("tags").toString());
}

void MetadataPanel::setMultipleNotes(int count) {
    m_currentNoteId = -1;
    m_stack->setCurrentIndex(1); // 多选页
    m_titleEdit->hide();
    m_tagEdit->setEnabled(true);
    m_tagEdit->setPlaceholderText("输入标签批量添加...");
    m_separatorLine->show();
}

void MetadataPanel::clearSelection() {
    m_currentNoteId = -1;
    m_stack->setCurrentIndex(0); // 无选择页
    m_titleEdit->hide();
    m_tagEdit->setEnabled(false);
    m_tagEdit->setPlaceholderText("请先选择一个项目");
    m_separatorLine->hide();
}

void MetadataPanel::openExpandedTitleEditor() {
    if (m_currentNoteId == -1) return;
    
    TitleEditorDialog dialog(m_titleEdit->text(), this);
    if (dialog.exec() == QDialog::Accepted) {
        QString newTitle = dialog.getText();
        if (!newTitle.isEmpty() && newTitle != m_titleEdit->text()) {
            m_titleEdit->setText(newTitle);
            DatabaseManager::instance().updateNoteState(m_currentNoteId, "title", newTitle);
            emit noteUpdated();
        }
    }
}

void MetadataPanel::handleTagInput() {
    QString text = m_tagEdit->text().trimmed();
    if (text.isEmpty()) return;
    
    QStringList tags = { text };
    emit tagAdded(tags);
    m_tagEdit->clear();
}

void MetadataPanel::openTagSelector() {
    if (m_currentNoteId == -1) return;
    
    QStringList currentTags = m_capsules["tags"]->text().split(",", Qt::SkipEmptyParts);
    for (QString& t : currentTags) t = t.trimmed();
    if (m_capsules["tags"]->text() == "无") currentTags.clear();

    auto* selector = new AdvancedTagSelector(this);
    // 获取最近使用的标签 (20个) 和全量标签
    auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
    auto allTags = DatabaseManager::instance().getAllTags();
    selector->setup(recentTags, allTags, currentTags);
    connect(selector, &AdvancedTagSelector::tagsConfirmed, [this](const QStringList& tags){
        if (m_currentNoteId != -1) {
            DatabaseManager::instance().updateNoteState(m_currentNoteId, "tags", tags.join(", "));
            emit noteUpdated();
            // 刷新本地显示
            m_capsules["tags"]->setText(tags.join(", "));
        }
    });
    selector->showAtCursor();
}
```

## 文件: `src/ui/MetadataPanel.h`

```cpp
#ifndef METADATAPANEL_H
#define METADATAPANEL_H

#include <QWidget>
#include <QLabel>
#include <QLineEdit>
#include <QVariant>
#include <QStringList>
#include <QMap>
#include <QStackedWidget>
#include <QFrame>
#include "ClickableLineEdit.h"

class MetadataPanel : public QWidget {
    Q_OBJECT
public:
    explicit MetadataPanel(QWidget* parent = nullptr);
    void setNote(const QVariantMap& note);
    void setMultipleNotes(int count);
    void clearSelection();

signals:
    void noteUpdated();
    void tagAdded(const QStringList& tags);
    void closed();

private:
    void initUI();
    QWidget* createInfoWidget(const QString& icon, const QString& title, const QString& subtitle);
    QWidget* createMetadataDisplay();
    QWidget* createCapsule(const QString& label, const QString& key);
    void openExpandedTitleEditor();
    void handleTagInput();
    void openTagSelector();

    QStackedWidget* m_stack;
    QWidget* m_metadataDisplayWidget;
    
    // Metadata Display widgets
    ClickableLineEdit* m_titleEdit;
    ClickableLineEdit* m_tagEdit;
    QFrame* m_separatorLine;
    QMap<QString, QLabel*> m_capsules;

    int m_currentNoteId = -1;
};

#endif // METADATAPANEL_H
```

## 文件: `src/ui/NoteDelegate.h`

```cpp
#ifndef NOTEDELEGATE_H
#define NOTEDELEGATE_H

#include <QStyledItemDelegate>
#include <QPainter>
#include <QPainterPath>
#include <QDateTime>
#include <QRegularExpression>
#include "../models/NoteModel.h"
#include "IconHelper.h"
#include "StringUtils.h"

class NoteDelegate : public QStyledItemDelegate {
    Q_OBJECT
public:
    explicit NoteDelegate(QObject* parent = nullptr) : QStyledItemDelegate(parent) {}

    // 定义卡片高度
    QSize sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        Q_UNUSED(index);
        return QSize(option.rect.width(), 110); // 每个卡片高度 110px
    }

    void paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        if (!index.isValid()) return;

        painter->save();
        painter->setRenderHint(QPainter::Antialiasing);

        // 1. 获取数据
        QString title = index.data(NoteModel::TitleRole).toString();
        QString content = index.data(NoteModel::ContentRole).toString();
        QString timeStr = index.data(NoteModel::TimeRole).toDateTime().toString("yyyy-MM-dd HH:mm:ss");
        bool isPinned = index.data(NoteModel::PinnedRole).toBool();
        
        // 2. 处理选中状态和背景 (更精致的配色与阴影感)
        bool isSelected = (option.state & QStyle::State_Selected);
        
        // 【关键修复】使用 QRectF 并根据笔宽调整，确保 2px 边框完全在 option.rect 内部绘制，消除选中残留伪影
        qreal penWidth = isSelected ? 2.0 : 1.0;
        QRectF rect = QRectF(option.rect).adjusted(penWidth/2.0, penWidth/2.0, -penWidth/2.0, -4.0 - penWidth/2.0);
        
        // 获取笔记自身的颜色标记作为背景
        QString colorHex = index.data(NoteModel::ColorRole).toString();
        QColor noteColor = colorHex.isEmpty() ? QColor("#1a1a1b") : QColor(colorHex);
        
        QColor bgColor = isSelected ? noteColor.lighter(115) : noteColor; 
        QColor borderColor = isSelected ? QColor("#ffffff") : QColor("#333333");
        
        // 绘制卡片背景
        QPainterPath path;
        path.addRoundedRect(rect, 8, 8);
        
        // 模拟阴影
        if (!isSelected) {
            painter->setPen(Qt::NoPen);
            painter->setBrush(QColor(0, 0, 0, 40));
            painter->drawRoundedRect(rect.translated(0, 2), 8, 8);
        }

        painter->setPen(QPen(borderColor, penWidth));
        painter->setBrush(bgColor);
        painter->drawPath(path);

        // 3. 绘制标题 (加粗，主文本色: 统一设为白色以应对多样背景卡片)
        painter->setPen(Qt::white);
        QFont titleFont("Microsoft YaHei", 10, QFont::Bold);
        painter->setFont(titleFont);
        QRectF titleRect = rect.adjusted(12, 10, -35, -70);
        painter->drawText(titleRect, Qt::AlignLeft | Qt::AlignTop, painter->fontMetrics().elidedText(title, Qt::ElideRight, titleRect.width()));

        // 4. 绘制置顶/星级标识
        if (isPinned) {
            QPixmap pin = IconHelper::getIcon("pin", "#f1c40f", 14).pixmap(14, 14);
            painter->drawPixmap(rect.right() - 25, rect.top() + 12, pin);
        }

        // 5. 绘制内容预览 (强制纯白：确保在任何背景下都有最高清晰度)
        painter->setPen(Qt::white);
        painter->setFont(QFont("Microsoft YaHei", 9));
        QRectF contentRect = rect.adjusted(12, 34, -12, -32);
        
        // 【统一优化】调用 StringUtils 剥离 HTML 标签，确保预览纯净
        QString cleanContent = StringUtils::htmlToPlainText(content).simplified();
        QString elidedContent = painter->fontMetrics().elidedText(cleanContent, Qt::ElideRight, contentRect.width() * 2);
        painter->drawText(contentRect, Qt::AlignLeft | Qt::AlignTop | Qt::TextWordWrap, elidedContent);

        // 6. 绘制底部元数据栏 (时间图标 + 时间 + 类型标签)
        QRectF bottomRect = rect.adjusted(12, 78, -12, -8);
        
        // 时间 (强制纯白)
        painter->setPen(Qt::white);
        painter->setFont(QFont("Segoe UI", 8));
        QPixmap clock = IconHelper::getIcon("clock", "#ffffff", 12).pixmap(12, 12);
        painter->drawPixmap(bottomRect.left(), bottomRect.top() + (bottomRect.height() - 12) / 2, clock);
        painter->drawText(bottomRect.adjusted(16, 0, 0, 0), Qt::AlignLeft | Qt::AlignVCenter, timeStr);

        // 处理类型标签显示 (对齐智能标签逻辑)
        QString itemType = index.data(NoteModel::TypeRole).toString();
        if (itemType == "text") itemType = "文本";
        else if (itemType == "image") itemType = "图片";
        else if (itemType == "file" || itemType == "local_file") itemType = "文件";
        else if (itemType == "folder" || itemType == "local_folder") itemType = "文件夹";
        else if (itemType == "local_batch") itemType = "批量";
        else if (itemType.isEmpty()) itemType = "笔记";
        
        QString tagText = itemType;
        int tagWidth = painter->fontMetrics().horizontalAdvance(tagText) + 16;
        QRectF tagRect(bottomRect.right() - tagWidth, bottomRect.top() + 2, tagWidth, 18);
        
        painter->setBrush(QColor("#1e1e1e"));
        painter->setPen(QPen(QColor("#444"), 1));
        painter->drawRoundedRect(tagRect, 4, 4);
        
        painter->setPen(Qt::white); // 类型标签文字也改为纯白
        painter->setFont(QFont("Microsoft YaHei", 7, QFont::Bold));
        painter->drawText(tagRect, Qt::AlignCenter, tagText);

        painter->restore();
    }
};

#endif // NOTEDELEGATE_H
```

## 文件: `src/ui/NoteEditWindow.cpp`

```cpp
#include "NoteEditWindow.h"
#include "StringUtils.h"
#include "../core/ShortcutManager.h"
#include "AdvancedTagSelector.h"
#include "TitleEditorDialog.h"

#ifdef Q_OS_WIN
#include <windows.h>
#endif
#include "../core/DatabaseManager.h"
#include "IconHelper.h"
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QPushButton>
#include <QTextEdit>
#include <QLabel>
#include <QGridLayout>
#include <QPainter>
#include <QGraphicsDropShadowEffect>
#include <QWindow>
#include <QMouseEvent>
#include <QShortcut>
#include <QKeySequence>
#include <QApplication>
#include <QScreen>
#include <QTextListFormat>
#include <QCompleter>
#include <QStringListModel>
#include <QDialog>


NoteEditWindow::NoteEditWindow(int noteId, QWidget* parent) 
    : QWidget(parent, Qt::Window | Qt::FramelessWindowHint), m_noteId(noteId) 
{
    setObjectName("NoteEditWindow");
    setWindowTitle(m_noteId > 0 ? "编辑笔记" : "记录灵感");
    setAttribute(Qt::WA_TranslucentBackground); 
    // 增加窗口物理尺寸以容纳外围阴影，防止 UpdateLayeredWindowIndirect 参数错误
    resize(980, 680); 
    initUI();
    setupShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &NoteEditWindow::updateShortcuts);
    
    if (m_noteId > 0) {
        loadNoteData(m_noteId);
    }
}

void NoteEditWindow::setDefaultCategory(int catId) {
    m_catId = catId;
}

void NoteEditWindow::showEvent(QShowEvent* event) {
    QWidget::showEvent(event);
#ifdef Q_OS_WIN
    if (m_isStayOnTop) {
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }
#else
    Qt::WindowFlags f = windowFlags();
    if (m_isStayOnTop) f |= Qt::WindowStaysOnTopHint;
    else f &= ~Qt::WindowStaysOnTopHint;
    if (windowFlags() != f) {
        setWindowFlags(f);
        show();
    }
#endif
}

void NoteEditWindow::paintEvent(QPaintEvent* event) {
    // 由于使用了 mainContainer 承载背景和圆角，窗口本身只需保持透明
    Q_UNUSED(event);
}

void NoteEditWindow::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        if (event->pos().y() < 40) {
            m_dragPos = event->globalPosition().toPoint() - frameGeometry().topLeft();
            event->accept();
        }
    }
}

void NoteEditWindow::mouseMoveEvent(QMouseEvent* event) {
    if (event->buttons() & Qt::LeftButton) {
        if (!m_dragPos.isNull()) {
            move(event->globalPosition().toPoint() - m_dragPos);
            event->accept();
        }
    }
}

void NoteEditWindow::mouseReleaseEvent(QMouseEvent* event) {
    m_dragPos = QPoint();
}

bool NoteEditWindow::eventFilter(QObject* watched, QEvent* event) {
    if (watched->property("isCloseBtn").toBool()) {
        QPushButton* btn = qobject_cast<QPushButton*>(watched);
        if (btn) {
            if (event->type() == QEvent::Enter) {
                btn->setIcon(IconHelper::getIcon("close", "#ffffff", 20));
            } else if (event->type() == QEvent::Leave) {
                btn->setIcon(IconHelper::getIcon("close", "#aaaaaa", 20));
            }
        }
    }
    return QWidget::eventFilter(watched, event);
}

void NoteEditWindow::mouseDoubleClickEvent(QMouseEvent* event) {
    if (event->pos().y() < 40) {
        toggleMaximize();
    }
}

void NoteEditWindow::initUI() {
    auto* windowLayout = new QVBoxLayout(this);
    windowLayout->setObjectName("WindowLayout");
    windowLayout->setContentsMargins(15, 15, 15, 15); // 留出阴影空间
    windowLayout->setSpacing(0);

    // 主容器：承载圆角、背景和阴影
    auto* mainContainer = new QWidget();
    mainContainer->setObjectName("MainContainer");
    mainContainer->setStyleSheet("QWidget#MainContainer { background-color: #1E1E1E; border-radius: 12px; }");
    windowLayout->addWidget(mainContainer);

    auto* outerLayout = new QVBoxLayout(mainContainer);
    outerLayout->setContentsMargins(0, 0, 0, 0);
    outerLayout->setSpacing(0);

    // 自定义标题栏
    m_titleBar = new QWidget();
    m_titleBar->setFixedHeight(32); 
    m_titleBar->setStyleSheet("background-color: #252526; border-top-left-radius: 12px; border-top-right-radius: 12px; border-bottom: 1px solid #333;");
    auto* tbLayout = new QHBoxLayout(m_titleBar);
    tbLayout->setContentsMargins(12, 0, 0, 0); // 右边距设为 0
    tbLayout->setSpacing(0); // 按钮间距设为 0

    QLabel* titleIcon = new QLabel();
    titleIcon->setPixmap(IconHelper::getIcon("edit", "#4FACFE", 18).pixmap(18, 18));
    tbLayout->addWidget(titleIcon);

    m_winTitleLabel = new QLabel(m_noteId > 0 ? "编辑笔记" : "记录灵感");
    m_winTitleLabel->setStyleSheet("font-weight: bold; color: #ddd; font-size: 13px; margin-left: 5px;");
    tbLayout->addWidget(m_winTitleLabel);
    tbLayout->addStretch();

    // 统一控制按钮样式：32x32px（对齐主窗口），图标 20px，锁定比例以消除离谱内边距
    QString ctrlBtnStyle = "QPushButton { background: transparent; border: none; border-radius: 5px; padding: 0px; } "
                           "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }";
    
    QPushButton* btnMin = new QPushButton();
    btnMin->setIcon(IconHelper::getIcon("minimize", "#aaaaaa", 20));
    btnMin->setIconSize(QSize(20, 20));
    btnMin->setFixedSize(32, 32);
    btnMin->setStyleSheet(ctrlBtnStyle);
    connect(btnMin, &QPushButton::clicked, this, &QWidget::showMinimized);
    
    m_maxBtn = new QPushButton();
    m_maxBtn->setIcon(IconHelper::getIcon("maximize", "#aaaaaa", 20));
    m_maxBtn->setIconSize(QSize(20, 20));
    m_maxBtn->setFixedSize(32, 32);
    m_maxBtn->setStyleSheet(ctrlBtnStyle);
    connect(m_maxBtn, &QPushButton::clicked, this, &NoteEditWindow::toggleMaximize);

    m_btnStayOnTop = new QPushButton();
    m_btnStayOnTop->setIcon(IconHelper::getIcon("pin_tilted", "#aaaaaa", 20));
    m_btnStayOnTop->setIconSize(QSize(20, 20));
    m_btnStayOnTop->setFixedSize(32, 32);
    m_btnStayOnTop->setCheckable(true);
    m_btnStayOnTop->setStyleSheet(ctrlBtnStyle + " QPushButton:checked { background-color: #3A90FF; }");

    // 加载记忆状态
    QSettings settings("RapidNotes", "WindowStates");
    m_isStayOnTop = settings.value("NoteEditWindow/StayOnTop", false).toBool();
    if (m_isStayOnTop) {
        m_btnStayOnTop->setChecked(true);
        m_btnStayOnTop->setIcon(IconHelper::getIcon("pin_vertical", "#ffffff", 20));
    }

    connect(m_btnStayOnTop, &QPushButton::toggled, this, &NoteEditWindow::toggleStayOnTop);
    
    QPushButton* btnClose = new QPushButton();
    btnClose->setIcon(IconHelper::getIcon("close", "#aaaaaa", 20));
    btnClose->setIconSize(QSize(20, 20));
    btnClose->setFixedSize(32, 32);
    btnClose->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 5px; padding: 0px; } QPushButton:hover { background-color: #E81123; }");
    connect(btnClose, &QPushButton::clicked, this, &QWidget::close);

    // 为关闭按钮实现 Hover 图标变白逻辑
    btnClose->installEventFilter(this);
    btnClose->setProperty("isCloseBtn", true);

    tbLayout->addWidget(m_btnStayOnTop);
    tbLayout->addWidget(btnMin);
    tbLayout->addWidget(m_maxBtn);
    tbLayout->addWidget(btnClose);
    outerLayout->addWidget(m_titleBar);

    // 主内容区使用 Splitter
    m_splitter = new QSplitter(Qt::Horizontal);
    m_splitter->setStyleSheet("QSplitter::handle { background-color: #252526; width: 2px; } QSplitter::handle:hover { background-color: #4FACFE; }");

    // 左侧面板
    QWidget* leftContainer = new QWidget();
    auto* leftLayout = new QVBoxLayout(leftContainer);
    leftLayout->setContentsMargins(15, 15, 15, 15);
    setupLeftPanel(leftLayout);

    // 右侧面板
    QWidget* rightContainer = new QWidget();
    auto* rightLayout = new QVBoxLayout(rightContainer);
    rightLayout->setContentsMargins(10, 15, 15, 15);
    setupRightPanel(rightLayout);

    m_splitter->addWidget(leftContainer);
    m_splitter->addWidget(rightContainer);
    m_splitter->setStretchFactor(0, 0);
    m_splitter->setStretchFactor(1, 1);
    m_splitter->setSizes({300, 650});

    outerLayout->addWidget(m_splitter);

    // 阴影应用在内部容器上，确保不超出窗口边界
    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(15);
    shadow->setColor(QColor(0, 0, 0, 180));
    shadow->setOffset(0, 2);
    mainContainer->setGraphicsEffect(shadow);
}

void NoteEditWindow::setupLeftPanel(QVBoxLayout* layout) {
    QString labelStyle = "color: #888; font-size: 12px; font-weight: bold; margin-bottom: 4px;";
    QString inputStyle = "QLineEdit, QComboBox { background: #252526; border: 1px solid #333; border-radius: 4px; padding: 8px; color: #eee; font-size: 13px; } QLineEdit:focus, QComboBox:focus { border: 1px solid #4FACFE; }";

    QLabel* lblTitle = new QLabel("标题");
    lblTitle->setStyleSheet(labelStyle);
    m_titleEdit = new ClickableLineEdit();
    m_titleEdit->setPlaceholderText("请输入灵感标题...");
    m_titleEdit->setStyleSheet(inputStyle);
    m_titleEdit->setAlignment(Qt::AlignLeft);
    connect(m_titleEdit, &ClickableLineEdit::doubleClicked, this, &NoteEditWindow::openExpandedTitleEditor);
    layout->addWidget(lblTitle);
    layout->addWidget(m_titleEdit);

    QLabel* lblTags = new QLabel("标签");
    lblTags->setStyleSheet(labelStyle);
    m_tagEdit = new ClickableLineEdit();
    m_tagEdit->setPlaceholderText("使用逗号分隔，如: 工作, 待办 (双击显示历史)");
    m_tagEdit->setStyleSheet(inputStyle);
    connect(m_tagEdit, &ClickableLineEdit::doubleClicked, this, &NoteEditWindow::openTagSelector);
    
    // 智能补全标签
    QStringList allTags = DatabaseManager::instance().getAllTags();
    QCompleter* completer = new QCompleter(allTags, this);
    completer->setCaseSensitivity(Qt::CaseInsensitive);
    completer->setFilterMode(Qt::MatchContains);
    m_tagEdit->setCompleter(completer);

    layout->addWidget(lblTags);
    layout->addWidget(m_tagEdit);

    QLabel* lblColor = new QLabel("标记颜色");
    lblColor->setStyleSheet(labelStyle);
    layout->addWidget(lblColor);

    QWidget* colorGrid = new QWidget();
    QGridLayout* grid = new QGridLayout(colorGrid);
    grid->setContentsMargins(0, 10, 0, 10);
    
    m_colorGroup = new QButtonGroup(this);
    QStringList colors = {"#FF9800", "#444444", "#2196F3", "#4CAF50", "#F44336", "#9C27B0"};
    for(int i=0; i<colors.size(); ++i) {
        QPushButton* btn = createColorBtn(colors[i], i);
        grid->addWidget(btn, i/3, i%3);
        m_colorGroup->addButton(btn, i);
    }
    if(m_colorGroup->button(0)) m_colorGroup->button(0)->setChecked(true);
    
    layout->addWidget(colorGrid);
    
    m_defaultColorCheck = new QCheckBox("设为默认颜色");
    m_defaultColorCheck->setStyleSheet("QCheckBox { color: #858585; font-size: 12px; margin-top: 5px; }");
    layout->addWidget(m_defaultColorCheck);

    layout->addStretch(); 

    QPushButton* saveBtn = new QPushButton();
    saveBtn->setIcon(IconHelper::getIcon("save", "#ffffff"));
    saveBtn->setText("  保存 (Ctrl+S)");
    saveBtn->setCursor(Qt::PointingHandCursor);
    saveBtn->setFixedHeight(50);
    saveBtn->setStyleSheet("QPushButton { background-color: #4FACFE; color: white; border: none; border-radius: 6px; font-weight: bold; font-size: 13px; } QPushButton:hover { background-color: #357abd; }");
    connect(saveBtn, &QPushButton::clicked, this, &NoteEditWindow::saveNote);
    layout->addWidget(saveBtn);
}

QPushButton* NoteEditWindow::createColorBtn(const QString& color, int id) {
    QPushButton* btn = new QPushButton();
    btn->setCheckable(true);
    btn->setFixedSize(30, 30);
    btn->setProperty("color", color);
    btn->setStyleSheet(QString(
        "QPushButton { background-color: %1; border-radius: 15px; border: 2px solid transparent; }"
        "QPushButton:checked { border: 2px solid white; }"
    ).arg(color));
    return btn;
}

void NoteEditWindow::setupRightPanel(QVBoxLayout* layout) {
    QHBoxLayout* headerLayout = new QHBoxLayout();
    headerLayout->setContentsMargins(0, 0, 0, 0);
    headerLayout->setSpacing(1);

    QLabel* titleLabel = new QLabel("详细内容");
    titleLabel->setStyleSheet("color: #888; font-size: 11px; font-weight: bold;");
    headerLayout->addWidget(titleLabel);
    headerLayout->addStretch();

    QHBoxLayout* toolBar = new QHBoxLayout();
    toolBar->setContentsMargins(0, 0, 0, 0);
    toolBar->setSpacing(0); // 彻底消除按钮间距，实现紧凑布局

    // 标准化工具栏样式：对齐 HeaderBar 参数
    QString btnStyle = "QPushButton { background: transparent; border: none; border-radius: 5px; padding: 0px; } "
                       "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); } "
                       "QPushButton:checked { background-color: rgba(255, 255, 255, 0.2); }";
    
    auto addTool = [&](const QString& iconName, const QString& tip, std::function<void()> callback) {
        QPushButton* btn = new QPushButton();
        btn->setIcon(IconHelper::getIcon(iconName, "#aaaaaa", 20)); // 图标增大到 20px
        btn->setIconSize(QSize(20, 20));
        btn->setToolTip(tip);
        btn->setFixedSize(32, 32); // 尺寸标准化为 32x32
        btn->setCursor(Qt::PointingHandCursor);
        btn->setStyleSheet(btnStyle);
        connect(btn, &QPushButton::clicked, callback);
        toolBar->addWidget(btn);
        return btn;
    };

    addTool("undo", "撤销 (Ctrl+Z)", [this](){ m_contentEdit->undo(); });
    addTool("redo", "重做 (Ctrl+Y)", [this](){ m_contentEdit->redo(); });
    
    QFrame* sep1 = new QFrame();
    sep1->setFixedWidth(1);
    sep1->setFixedHeight(16);
    sep1->setStyleSheet("background-color: #333; margin-left: 2px; margin-right: 2px;");
    toolBar->addWidget(sep1);

    addTool("list_ul", "无序列表", [this](){ m_contentEdit->toggleList(false); });
    addTool("list_ol", "有序列表", [this](){ m_contentEdit->toggleList(true); });
    
    QPushButton* btnTodo = new QPushButton();
    btnTodo->setIcon(IconHelper::getIcon("todo", "#aaaaaa", 20));
    btnTodo->setIconSize(QSize(20, 20));
    btnTodo->setFixedSize(32, 32); 
    btnTodo->setToolTip("插入待办事项");
    btnTodo->setStyleSheet(btnStyle);
    btnTodo->setCursor(Qt::PointingHandCursor);
    connect(btnTodo, &QPushButton::clicked, [this](){ m_contentEdit->insertTodo(); });
    toolBar->addWidget(btnTodo);

    QPushButton* btnPre = new QPushButton();
    btnPre->setIcon(IconHelper::getIcon("eye", "#aaaaaa", 20));
    btnPre->setIconSize(QSize(20, 20));
    btnPre->setFixedSize(32, 32);
    btnPre->setToolTip("切换 Markdown 预览/编辑");
    btnPre->setStyleSheet(btnStyle);
    btnPre->setCursor(Qt::PointingHandCursor);
    btnPre->setCheckable(true);
    connect(btnPre, &QPushButton::toggled, [this](bool checked){ m_contentEdit->togglePreview(checked); });
    toolBar->addWidget(btnPre);

    addTool("edit_clear", "清除格式", [this](){ m_contentEdit->clearFormatting(); });
    
    QFrame* sep2 = new QFrame();
    sep2->setFixedWidth(1);
    sep2->setFixedHeight(16);
    sep2->setStyleSheet("background-color: #333; margin-left: 2px; margin-right: 2px;");
    toolBar->addWidget(sep2);

    // 高亮颜色
    QStringList hColors = {"#c0392b", "#f1c40f", "#27ae60", "#2980b9"};
    for (const auto& color : hColors) {
        QPushButton* hBtn = new QPushButton();
        hBtn->setFixedSize(20, 20);
        hBtn->setStyleSheet(QString("QPushButton { background-color: %1; border: 1px solid rgba(0,0,0,0.2); border-radius: 4px; } "
                                    "QPushButton:hover { border-color: white; }").arg(color));
        hBtn->setCursor(Qt::PointingHandCursor);
        connect(hBtn, &QPushButton::clicked, [this, color](){ m_contentEdit->highlightSelection(QColor(color)); });
        toolBar->addWidget(hBtn);
    }

    // 清除高亮按钮
    QPushButton* btnNoColor = new QPushButton();
    btnNoColor->setIcon(IconHelper::getIcon("no_color", "#aaaaaa", 14));
    btnNoColor->setFixedSize(24, 24);
    btnNoColor->setToolTip("清除高亮");
    btnNoColor->setStyleSheet("QPushButton { background: transparent; border: 1px solid #444; border-radius: 4px; margin-left: 4px; } "
                              "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); border-color: #888; }");
    btnNoColor->setCursor(Qt::PointingHandCursor);
    connect(btnNoColor, &QPushButton::clicked, [this](){ m_contentEdit->highlightSelection(Qt::transparent); });
    toolBar->addWidget(btnNoColor);
    
    headerLayout->addLayout(toolBar);
    layout->addLayout(headerLayout);

    // 搜索栏 (默认隐藏)
    m_searchBar = new QWidget();
    m_searchBar->setVisible(false);
    m_searchBar->setStyleSheet("background-color: #252526; border-radius: 6px; padding: 2px;");
    auto* sbLayout = new QHBoxLayout(m_searchBar);
    sbLayout->setContentsMargins(5, 2, 5, 2);
    m_searchEdit = new QLineEdit();
    m_searchEdit->setPlaceholderText("查找内容...");
    m_searchEdit->setStyleSheet("border: none; background: transparent; color: #fff;");
    connect(m_searchEdit, &QLineEdit::returnPressed, [this](){ m_contentEdit->findText(m_searchEdit->text()); });
    
    QPushButton* btnPrev = new QPushButton();
    btnPrev->setIcon(IconHelper::getIcon("nav_prev", "#ccc"));
    btnPrev->setFixedSize(24, 24);
    btnPrev->setStyleSheet("background: transparent; border: none;");
    connect(btnPrev, &QPushButton::clicked, [this](){ m_contentEdit->findText(m_searchEdit->text(), true); });
    
    QPushButton* btnNext = new QPushButton();
    btnNext->setIcon(IconHelper::getIcon("nav_next", "#ccc"));
    btnNext->setFixedSize(24, 24);
    btnNext->setStyleSheet("background: transparent; border: none;");
    connect(btnNext, &QPushButton::clicked, [this](){ m_contentEdit->findText(m_searchEdit->text(), false); });
    
    QPushButton* btnCls = new QPushButton();
    btnCls->setIcon(IconHelper::getIcon("close", "#ccc"));
    btnCls->setFixedSize(24, 24);
    btnCls->setStyleSheet("background: transparent; border: none;");
    connect(btnCls, &QPushButton::clicked, [this](){ m_searchBar->hide(); });

    sbLayout->addWidget(m_searchEdit);
    sbLayout->addWidget(btnPrev);
    sbLayout->addWidget(btnNext);
    sbLayout->addWidget(btnCls);
    layout->addWidget(m_searchBar);

    layout->addSpacing(5);
    m_contentEdit = new Editor(); 
    m_contentEdit->setPlaceholderText("在这里记录详细内容（支持 Markdown 和粘贴图片）...");
    layout->addWidget(m_contentEdit);
}

void NoteEditWindow::setupShortcuts() {
    auto add = [&](const QString& id, std::function<void()> func) {
        auto* sc = new QShortcut(ShortcutManager::instance().getShortcut(id), this, func);
        sc->setProperty("id", id);
        m_shortcutObjs.append(sc);
    };

    add("ed_save", [this](){ saveNote(); });
    add("ed_close", [this](){ close(); });
    add("ed_search", [this](){ toggleSearchBar(); });

    new QShortcut(QKeySequence("Escape"), this, SLOT(close()));
}

void NoteEditWindow::updateShortcuts() {
    for (auto* sc : m_shortcutObjs) {
        QString id = sc->property("id").toString();
        sc->setKey(ShortcutManager::instance().getShortcut(id));
    }
}

void NoteEditWindow::toggleStayOnTop() {
    m_isStayOnTop = m_btnStayOnTop->isChecked();
    m_btnStayOnTop->setIcon(IconHelper::getIcon(m_isStayOnTop ? "pin_vertical" : "pin_tilted", m_isStayOnTop ? "#ffffff" : "#aaaaaa", 20));

    QSettings settings("RapidNotes", "WindowStates");
    settings.setValue("NoteEditWindow/StayOnTop", m_isStayOnTop);

    if (isVisible()) {
#ifdef Q_OS_WIN
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, m_isStayOnTop ? HWND_TOPMOST : HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
        Qt::WindowFlags f = windowFlags();
        if (m_isStayOnTop) f |= Qt::WindowStaysOnTopHint;
        else f &= ~Qt::WindowStaysOnTopHint;
        setWindowFlags(f);
        show();
#endif
    }
}

void NoteEditWindow::toggleMaximize() {
    auto* windowLayout = findChild<QVBoxLayout*>("WindowLayout");
    auto* mainContainer = findChild<QWidget*>("MainContainer");

    if (m_isMaximized) {
        showNormal();
        if (windowLayout) windowLayout->setContentsMargins(15, 15, 15, 15);
        if (mainContainer) mainContainer->setStyleSheet("QWidget#MainContainer { background-color: #1E1E1E; border-radius: 12px; }");
        m_maxBtn->setIcon(IconHelper::getIcon("maximize", "#aaaaaa", 20));
        m_titleBar->setStyleSheet("background-color: #252526; border-top-left-radius: 12px; border-top-right-radius: 12px; border-bottom: 1px solid #333;");
    } else {
        m_normalGeometry = geometry();
        showMaximized();
        if (windowLayout) windowLayout->setContentsMargins(0, 0, 0, 0);
        if (mainContainer) mainContainer->setStyleSheet("QWidget#MainContainer { background-color: #1E1E1E; border-radius: 0px; }");
        m_maxBtn->setIcon(IconHelper::getIcon("restore", "#aaaaaa", 20));
        m_titleBar->setStyleSheet("background-color: #252526; border-radius: 0px; border-bottom: 1px solid #333;");
    }
    m_isMaximized = !m_isMaximized;
    update();
}

void NoteEditWindow::saveNote() {
    QString title = m_titleEdit->text();
    if(title.isEmpty()) title = "未命名灵感";
    QString content = m_contentEdit->toHtml();
    QString tags = m_tagEdit->text();
    int catId = m_catId;
    QString color = m_colorGroup->checkedButton() ? m_colorGroup->checkedButton()->property("color").toString() : "";
    
    if (m_noteId == 0) {
        DatabaseManager::instance().addNoteAsync(title, content, tags.split(","), color, catId);
    } else {
        DatabaseManager::instance().updateNote(m_noteId, title, content, tags.split(","), color, catId);
        DatabaseManager::instance().recordAccess(m_noteId);
    }
    emit noteSaved();
    close();
}

void NoteEditWindow::toggleSearchBar() {
    m_searchBar->setVisible(!m_searchBar->isVisible());
    if (m_searchBar->isVisible()) {
        m_searchEdit->setFocus();
        m_searchEdit->selectAll();
    }
}

void NoteEditWindow::openTagSelector() {
    QStringList currentTags = m_tagEdit->text().split(",", Qt::SkipEmptyParts);
    for (QString& t : currentTags) t = t.trimmed();

    auto* selector = new AdvancedTagSelector(this);
    auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
    auto allTags = DatabaseManager::instance().getAllTags();
    selector->setup(recentTags, allTags, currentTags);

    connect(selector, &AdvancedTagSelector::tagsConfirmed, [this](const QStringList& tags){
        m_tagEdit->setText(tags.join(", "));
    });

    selector->showAtCursor();
}

void NoteEditWindow::openExpandedTitleEditor() {
    TitleEditorDialog dialog(m_titleEdit->text(), this);
    // 设置初始位置在鼠标附近
    QPoint pos = QCursor::pos();
    dialog.move(pos.x() - 160, pos.y() - 40);
    
    if (dialog.exec() == QDialog::Accepted) {
        QString newTitle = dialog.getText();
        if (!newTitle.isEmpty() && newTitle != m_titleEdit->text()) {
            m_titleEdit->setText(newTitle);
        }
    }
}

void NoteEditWindow::loadNoteData(int id) {
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    if (!note.isEmpty()) {
        m_titleEdit->setText(note.value("title").toString());
        m_contentEdit->setNote(note, false); // 编辑模式不注入预览标题
        m_tagEdit->setText(note.value("tags").toString());
        
        m_catId = note["category_id"].toInt();
        
        QString color = note["color"].toString();
        for (int i = 0; i < m_colorGroup->buttons().size(); ++i) {
            if (m_colorGroup->button(i)->property("color").toString() == color) {
                m_colorGroup->button(i)->setChecked(true);
                break;
            }
        }
    }
}
```

## 文件: `src/ui/NoteEditWindow.h`

```cpp
#ifndef NOTEEDITWINDOW_H
#define NOTEEDITWINDOW_H

#include <QWidget>
#include <QLineEdit>
#include "ClickableLineEdit.h"
#include <QComboBox>
#include <QTextEdit>
#include <QCheckBox>
#include <QPushButton>
#include <QButtonGroup>
#include <QVBoxLayout>
#include <QSplitter>
#include <QLabel>
#include "Editor.h" 

class QShortcut;

class NoteEditWindow : public QWidget {
    Q_OBJECT
public:
    explicit NoteEditWindow(int noteId = 0, QWidget* parent = nullptr);
    void setDefaultCategory(int catId);

signals:
    void noteSaved();

protected:
    bool eventFilter(QObject* watched, QEvent* event) override;
    void showEvent(QShowEvent* event) override;
    void paintEvent(QPaintEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void mouseDoubleClickEvent(QMouseEvent* event) override;

private:
    void initUI();
    void setupShortcuts();
    void updateShortcuts();
    void loadNoteData(int id);
    void setupLeftPanel(QVBoxLayout* layout);
    void setupRightPanel(QVBoxLayout* layout);
    QPushButton* createColorBtn(const QString& color, int id);
    
private slots:
    void toggleMaximize();
    void toggleStayOnTop();
    void saveNote();
    void toggleSearchBar();
    void openTagSelector();
    void openExpandedTitleEditor();

private:
    int m_noteId;
    int m_catId = -1;
    
    // 窗口控制
    bool m_isMaximized = false;
    bool m_isStayOnTop = false;
    QRect m_normalGeometry;
    QPoint m_dragPos;
    
    // UI 控件引用
    QWidget* m_titleBar;
    QLabel* m_winTitleLabel;
    QPushButton* m_maxBtn;
    QPushButton* m_btnStayOnTop;
    QSplitter* m_splitter;
    ClickableLineEdit* m_titleEdit;
    ClickableLineEdit* m_tagEdit;
    QList<QShortcut*> m_shortcutObjs;
    QButtonGroup* m_colorGroup;
    QCheckBox* m_defaultColorCheck;
    Editor* m_contentEdit;

    // 搜索栏
    QWidget* m_searchBar;
    QLineEdit* m_searchEdit;
};

#endif // NOTEEDITWINDOW_H
```

## 文件: `src/models/NoteModel.cpp`

```cpp
#include "NoteModel.h"
#include <QDateTime>
#include <QIcon>
#include "../ui/IconHelper.h"
#include "../ui/StringUtils.h"
#include "../core/DatabaseManager.h"
#include <QFileInfo>
#include <QBuffer>
#include <QPixmap>
#include <QByteArray>
#include <QUrl>

static QString getIconHtml(const QString& name, const QString& color) {
    QIcon icon = IconHelper::getIcon(name, color, 16);
    QPixmap pixmap = icon.pixmap(16, 16);
    QByteArray ba;
    QBuffer buffer(&ba);
    buffer.open(QIODevice::WriteOnly);
    pixmap.save(&buffer, "PNG");
    return QString("<img src='data:image/png;base64,%1' width='16' height='16' style='vertical-align:middle;'>")
           .arg(QString(ba.toBase64()));
}

NoteModel::NoteModel(QObject* parent) : QAbstractListModel(parent) {
    updateCategoryMap();
}

int NoteModel::rowCount(const QModelIndex& parent) const {
    if (parent.isValid()) return 0;
    return m_notes.count();
}

QVariant NoteModel::data(const QModelIndex& index, int role) const {
    if (!index.isValid() || index.row() >= m_notes.count()) return QVariant();

    const QVariantMap& note = m_notes.at(index.row());
    switch (role) {
        case Qt::BackgroundRole:
            return QVariant(); // 强制不返回任何背景色，由 Delegate 控制
        case Qt::DecorationRole: {
            QString type = note.value("item_type").toString();
            QString content = note.value("content").toString().trimmed();
            QString iconName = "text"; // Default
            QString iconColor = "#95a5a6";

            if (type == "image") {
                int id = note.value("id").toInt();
                if (m_thumbnailCache.contains(id)) return m_thumbnailCache[id];
                
                QImage img;
                img.loadFromData(note.value("data_blob").toByteArray());
                if (!img.isNull()) {
                    QIcon thumb(QPixmap::fromImage(img.scaled(32, 32, Qt::KeepAspectRatio, Qt::SmoothTransformation)));
                    m_thumbnailCache[id] = thumb;
                    return thumb;
                }
                iconName = "image";
                iconColor = "#9b59b6";
            } else if (type == "file" || type == "files") {
                iconName = "file";
                iconColor = "#f1c40f";
            } else if (type == "ocr_text") {
                // [CRITICAL] 识别提取的文字专用图标
                iconName = "screenshot_ocr";
                iconColor = "#007ACC";
            } else if (type == "captured_message") {
                // 自动捕获的消息
                iconName = "message";
                iconColor = "#4a90e2";
            } else if (type == "local_file" || type == "local_batch") {
                iconName = "file_managed";
                iconColor = "#f1c40f";
            } else if (type == "folder") {
                iconName = "folder";
                iconColor = "#e67e22";
            } else if (type == "local_folder") {
                iconName = "folder_managed";
                iconColor = "#e67e22";
            } else if (type == "color") {
                iconName = "palette";
                iconColor = content;
            } else if (type == "pixel_ruler") {
                iconName = "pixel_ruler";
                iconColor = "#ff5722";
            } else {
                // 【核心修复】智能检测文本内容，对齐 Python 版逻辑
                QString stripped = content.trimmed();
                QString cleanPath = stripped;
                if ((cleanPath.startsWith("\"") && cleanPath.endsWith("\"")) || 
                    (cleanPath.startsWith("'") && cleanPath.endsWith("'"))) {
                    cleanPath = cleanPath.mid(1, cleanPath.length() - 2);
                }

                if (stripped.startsWith("http://") || stripped.startsWith("https://") || stripped.startsWith("www.")) {
                    iconName = "link";
                    iconColor = "#3498db";
                } else if (QRegularExpression("^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$").match(stripped).hasMatch()) {
                    // 优先识别 HEX 色码，防止被识别为代码
                    iconName = "palette";
                    iconColor = stripped;
                } else if (stripped.startsWith("#") || stripped.startsWith("import ") || stripped.startsWith("class ") || 
                           stripped.startsWith("def ") || stripped.startsWith("<") || stripped.startsWith("{") ||
                           stripped.startsWith("function") || stripped.startsWith("var ") || stripped.startsWith("const ")) {
                    iconName = "code";
                    iconColor = "#2ecc71";
                } else if (cleanPath.length() < 260 && (
                           (cleanPath.length() > 2 && cleanPath[1] == ':') || 
                           cleanPath.startsWith("\\\\") || cleanPath.startsWith("/") || 
                           cleanPath.startsWith("./") || cleanPath.startsWith("../"))) {
                    QFileInfo info(cleanPath);
                    if (info.exists()) {
                        if (info.isDir()) {
                            iconName = "folder";
                            iconColor = "#e67e22";
                        } else {
                            iconName = "file";
                            iconColor = "#f1c40f";
                        }
                    }
                }
            }
            return IconHelper::getIcon(iconName, iconColor, 32);
        }
        case Qt::ToolTipRole: {
            int id = note.value("id").toInt();
            if (m_tooltipCache.contains(id)) return m_tooltipCache[id];

            QString title = note.value("title").toString();
            QString content = note.value("content").toString();
            int catId = note.value("category_id").toInt();
            QString tags = note.value("tags").toString();
            bool pinned = note.value("is_pinned").toBool();
            bool locked = note.value("is_locked").toBool();
            bool favorite = note.value("is_favorite").toBool();
            int rating = note.value("rating").toInt();
            QString sourceApp = note.value("source_app").toString();

            QString catName = m_categoryMap.value(catId, "未分类");
            if (tags.isEmpty()) tags = "无";

            QString statusStr;
            if (pinned) statusStr += getIconHtml("pin_vertical", "#e74c3c") + " 置顶 ";
            if (locked) statusStr += getIconHtml("lock", "#aaaaaa") + " 锁定 ";
            if (favorite) statusStr += getIconHtml("bookmark_filled", "#ff6b81") + " 书签 ";
            if (statusStr.isEmpty()) statusStr = "无";

            if (sourceApp.isEmpty()) sourceApp = "未知应用";

            QString ratingStr;
            for(int i=0; i<rating; ++i) ratingStr += getIconHtml("star_filled", "#f39c12") + " ";
            if (ratingStr.isEmpty()) ratingStr = "无";

            QString preview;
            if (note.value("item_type").toString() == "image") {
                QByteArray ba = note.value("data_blob").toByteArray();
                preview = QString("<img src='data:image/png;base64,%1' width='300'>").arg(QString(ba.toBase64()));
            } else {
                // 【核心修复】剥离 HTML 标签以显示纯文本预览 (防止样式代码进入 ToolTip)
                QString plainText = StringUtils::htmlToPlainText(content);
                preview = plainText.left(400).toHtmlEscaped().replace("\n", "<br>").trimmed();
                if (plainText.length() > 400) preview += "...";
            }
            if (preview.isEmpty()) preview = title.toHtmlEscaped();

            QString html = QString("<html><body style='color: #ddd;'>"
                           "<table border='0' cellpadding='2' cellspacing='0'>"
                           "<tr><td width='22'>%1</td><td><b>分区:</b> %2</td></tr>"
                           "<tr><td width='22'>%3</td><td><b>标签:</b> %4</td></tr>"
                           "<tr><td width='22'>%5</td><td><b>评级:</b> %6</td></tr>"
                           "<tr><td width='22'>%7</td><td><b>状态:</b> %8</td></tr>"
                           "<tr><td width='22'>%9</td><td><b>来源:</b> %10</td></tr>"
                           "</table>"
                           "<hr style='border: 0; border-top: 1px solid #555; margin: 5px 0;'>"
                           "<div style='color: #ccc; font-size: 12px; line-height: 1.4;'>%11</div>"
                           "</body></html>")
                .arg(getIconHtml("branch", "#4a90e2"), catName,
                     getIconHtml("tag", "#FFAB91"), tags,
                     getIconHtml("star", "#f39c12"), ratingStr,
                     getIconHtml("pin_tilted", "#aaa"), statusStr,
                     getIconHtml("monitor", "#aaaaaa"))
                .arg(sourceApp, preview);
            
            m_tooltipCache[id] = html;
            return html;
        }
        case Qt::DisplayRole: {
            QString type = note.value("item_type").toString();
            QString title = note.value("title").toString();
            QString content = note.value("content").toString();
            if (type == "text" || type.isEmpty()) {
                QString plain = StringUtils::htmlToPlainText(content);
                QString display = plain.replace('\n', ' ').replace('\r', ' ').trimmed().left(150);
                return display.isEmpty() ? title : display;
            }
            return title;
        }
        case TitleRole:
            return note.value("title");
        case ContentRole:
            return note.value("content");
        case IdRole:
            return note.value("id");
        case TagsRole:
            return note.value("tags");
        case TimeRole:
            return note.value("updated_at");
        case PinnedRole:
            return note.value("is_pinned");
        case LockedRole:
            return note.value("is_locked");
        case FavoriteRole:
            return note.value("is_favorite");
        case TypeRole:
            return note.value("item_type");
        case RatingRole:
            return note.value("rating");
        case CategoryIdRole:
            return note.value("category_id");
        case CategoryNameRole:
            return m_categoryMap.value(note.value("category_id").toInt(), "未分类");
        case ColorRole:
            return note.value("color");
        case SourceAppRole:
            return note.value("source_app");
        case SourceTitleRole:
            return note.value("source_title");
        default:
            return QVariant();
    }
}

Qt::ItemFlags NoteModel::flags(const QModelIndex& index) const {
    if (!index.isValid()) return Qt::ItemIsEnabled;
    return QAbstractListModel::flags(index) | Qt::ItemIsDragEnabled;
}

QStringList NoteModel::mimeTypes() const {
    // 【核心修复】优先级调整：text/plain 必须放在第一位，确保浏览器等外部应用优先识别
    return {"text/plain", "text/html", "text/uri-list", "application/x-note-ids"};
}

QMimeData* NoteModel::mimeData(const QModelIndexList& indexes) const {
    QMimeData* mimeData = new QMimeData();
    QStringList ids;
    QStringList plainTexts;
    QStringList htmlTexts;
    QList<QUrl> urls;

    for (const QModelIndex& index : indexes) {
        if (index.isValid()) {
            ids << QString::number(data(index, IdRole).toInt());
            
            QString content = data(index, ContentRole).toString();
            QString type = data(index, TypeRole).toString();
            
            if (type == "text" || type.isEmpty()) {
                if (StringUtils::isHtml(content)) {
                    plainTexts << StringUtils::htmlToPlainText(content);
                    htmlTexts << content;
                } else {
                    plainTexts << content;
                    htmlTexts << content.toHtmlEscaped().replace("\n", "<br>");
                }
            } else if (type == "file" || type == "folder" || type == "files") {
                QStringList rawPaths = content.split(';', Qt::SkipEmptyParts);
                for (const QString& p : rawPaths) {
                    QString path = p.trimmed().remove('\"');
                    if (QFileInfo::exists(path)) {
                        urls << QUrl::fromLocalFile(path);
                    }
                }
                plainTexts << content;
                htmlTexts << content.toHtmlEscaped().replace("\n", "<br>");
            }
        }
    }
    
    mimeData->setData("application/x-note-ids", ids.join(",").toUtf8());
    
    if (!plainTexts.isEmpty()) {
        // 1. 设置纯文本格式 (使用 \r\n 换行)
        QString combinedPlain = plainTexts.join("\n---\n").replace("\n", "\r\n");
        mimeData->setText(combinedPlain);
        
        // 2. 仅在确实包含 HTML 内容时提供 HTML 分支，防止纯文本拖拽时出现 HTML 源码泄漏
        bool hasActualHtml = false;
        for (const QModelIndex& index : indexes) {
            if (StringUtils::isHtml(data(index, ContentRole).toString())) {
                hasActualHtml = true;
                break;
            }
        }

        if (hasActualHtml) {
            if (indexes.size() == 1) {
                mimeData->setHtml(data(indexes.first(), ContentRole).toString());
            } else {
                QString combinedHtml = htmlTexts.join("<br><hr><br>");
                mimeData->setHtml(QString(
                    "<html>"
                    "<head><meta charset='utf-8'></head>"
                    "<body>%1</body>"
                    "</html>"
                ).arg(combinedHtml));
            }
        }
    }
    
    if (!urls.isEmpty()) {
        mimeData->setUrls(urls);
    }
    
    return mimeData;
}

void NoteModel::setNotes(const QList<QVariantMap>& notes) {
    updateCategoryMap();
    m_thumbnailCache.clear();
    m_tooltipCache.clear();
    beginResetModel();
    m_notes = notes;
    endResetModel();
}

void NoteModel::updateCategoryMap() {
    auto categories = DatabaseManager::instance().getAllCategories();
    m_categoryMap.clear();
    for (const auto& cat : categories) {
        m_categoryMap[cat["id"].toInt()] = cat["name"].toString();
    }
}

// 【新增】函数的具体实现
void NoteModel::prependNote(const QVariantMap& note) {
    // 通知视图：我要在第0行插入1条数据
    beginInsertRows(QModelIndex(), 0, 0);
    m_notes.prepend(note);
    endInsertRows();
}
```

## 文件: `src/models/NoteModel.h`

```cpp
#ifndef NOTEMODEL_H
#define NOTEMODEL_H

#include <QAbstractListModel>
#include <QVariantMap>
#include <QList>
#include <QMimeData>

class NoteModel : public QAbstractListModel {
    Q_OBJECT
public:
    enum NoteRoles {
        IdRole = Qt::UserRole + 1,
        TitleRole,
        ContentRole,
        TagsRole,
        TimeRole,
        PinnedRole,
        LockedRole,
        FavoriteRole,
        TypeRole,
        RatingRole,
        CategoryIdRole,
        CategoryNameRole,
        ColorRole,
        SourceAppRole,
        SourceTitleRole
    };

    explicit NoteModel(QObject* parent = nullptr);

    int rowCount(const QModelIndex& parent = QModelIndex()) const override;
    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
    
    Qt::ItemFlags flags(const QModelIndex& index) const override;
    QStringList mimeTypes() const override;
    QMimeData* mimeData(const QModelIndexList& indexes) const override;

    // 全量重置
    void setNotes(const QList<QVariantMap>& notes);
    
    // 【新增】增量插入 (这就是报错缺失的函数！)
    void prependNote(const QVariantMap& note);
    void updateCategoryMap();

private:
    QList<QVariantMap> m_notes;
    QMap<int, QString> m_categoryMap;
    mutable QMap<int, QIcon> m_thumbnailCache;
    mutable QMap<int, QString> m_tooltipCache;
};

#endif // NOTEMODEL_H
```

## 文件: `src/core/OCRManager.cpp`

```cpp
#include "OCRManager.h"
#include <QtConcurrent>
#include <QThreadPool>
#include <QStringList>
#include <QTemporaryFile>
#include <QProcess>
#include <QDir>
#include <QDebug>
#include <QLocale>
#include <QCoreApplication>
#include <utility>

OCRManager& OCRManager::instance() {
    static OCRManager inst;
    return inst;
}

OCRManager::OCRManager(QObject* parent) : QObject(parent) {}

void OCRManager::setLanguage(const QString& lang) {
    m_language = lang;
}

QString OCRManager::getLanguage() const {
    return m_language;
}

void OCRManager::recognizeAsync(const QImage& image, int contextId) {
    qDebug() << "[OCRManager] recognizeAsync: 接收任务 ID:" << contextId 
             << "图片大小:" << image.width() << "x" << image.height() 
             << "主线程:" << QThread::currentThread();
    (void)QtConcurrent::run(QThreadPool::globalInstance(), [this, image, contextId]() {
        qDebug() << "[OCRManager] 工作线程开始执行 ID:" << contextId 
                 << "线程:" << QThread::currentThread();
        this->recognizeSync(image, contextId);
        qDebug() << "[OCRManager] 工作线程完成 ID:" << contextId;
    });
}

// 图像预处理函数：提高 OCR 识别准确度
QImage OCRManager::preprocessImage(const QImage& original) {
    if (original.isNull()) {
        return original;
    }
    
    // 1. 转换为灰度图 (保留 8 位深度的灰度细节，这对 Tesseract 4+ 至关重要)
    QImage processed = original.convertToFormat(QImage::Format_Grayscale8);
    
    // 2. 动态缩放策略
    // 目标：使文字像素高度达到 Tesseract 偏好的 30-35 像素。
    // 如果原图已经很大（宽度 > 2000），则不需要放大 3 倍，否则会导致内存占用过高且识别变慢
    int scale = 3;
    if (processed.width() > 2000 || processed.height() > 2000) {
        scale = 1;
    } else if (processed.width() > 1000 || processed.height() > 1000) {
        scale = 2;
    }
    
    if (scale > 1) {
        processed = processed.scaled(
            processed.width() * scale, 
            processed.height() * scale, 
            Qt::KeepAspectRatio, 
            Qt::SmoothTransformation
        );
    }
    
    // 3. 自动反色处理：Tesseract 在白底黑字下表现最好
    // 简单判断：如果四个角的像素平均值较暗，则认为可能是深色背景
    int cornerSum = 0;
    cornerSum += qGray(processed.pixel(0, 0));
    cornerSum += qGray(processed.pixel(processed.width()-1, 0));
    cornerSum += qGray(processed.pixel(0, processed.height()-1));
    cornerSum += qGray(processed.pixel(processed.width()-1, processed.height()-1));
    if (cornerSum / 4 < 128) {
        processed.invertPixels();
    }

    // 4. 增强对比度（线性拉伸）
    // 泰语等细笔画文字对二值化和过度的对比度拉伸很敏感，因此我们收窄忽略范围（从 1% 降至 0.5%）
    int histogram[256] = {0};
    for (int y = 0; y < processed.height(); ++y) {
        const uchar* line = processed.constScanLine(y);
        for (int x = 0; x < processed.width(); ++x) {
            histogram[line[x]]++;
        }
    }
    
    int totalPixels = processed.width() * processed.height();
    int minGray = 0, maxGray = 255;
    int count = 0;
    
    for (int i = 0; i < 256; ++i) {
        count += histogram[i];
        if (count > totalPixels * 0.005) {
            minGray = i;
            break;
        }
    }
    
    count = 0;
    for (int i = 255; i >= 0; --i) {
        count += histogram[i];
        if (count > totalPixels * 0.005) {
            maxGray = i;
            break;
        }
    }
    
    if (maxGray > minGray) {
        for (int y = 0; y < processed.height(); ++y) {
            uchar* line = processed.scanLine(y);
            for (int x = 0; x < processed.width(); ++x) {
                int val = line[x];
                val = (val - minGray) * 255 / (maxGray - minGray);
                val = qBound(0, val, 255);
                line[x] = static_cast<uchar>(val);
            }
        }
    }

    // 5. 简单锐化处理 (卷积)
    // 增加文字边缘对比度，有助于 Tesseract 识别彩色变灰度后的细微笔画
    QImage sharpened = processed;
    int kernel[3][3] = {
        {0, -1, 0},
        {-1, 5, -1},
        {0, -1, 0}
    };
    for (int y = 1; y < processed.height() - 1; ++y) {
        const uchar* prevLine = processed.constScanLine(y - 1);
        const uchar* currLine = processed.constScanLine(y);
        const uchar* nextLine = processed.constScanLine(y + 1);
        uchar* destLine = sharpened.scanLine(y);
        for (int x = 1; x < processed.width() - 1; ++x) {
            int sum = currLine[x] * kernel[1][1]
                    + prevLine[x] * kernel[0][1] + nextLine[x] * kernel[2][1]
                    + currLine[x-1] * kernel[1][0] + currLine[x+1] * kernel[1][2];
            destLine[x] = static_cast<uchar>(qBound(0, sum, 255));
        }
    }
    processed = sharpened;
    
    // 注意：不再手动调用 Otsu 二值化。
    // Tesseract 4.0+ 内部的二值化器（基于 Leptonica）在处理具有抗锯齿边缘的灰度图像时表现更好。
    
    return processed;
}

void OCRManager::recognizeSync(const QImage& image, int contextId) {
    qDebug() << "[OCRManager] recognizeSync: 开始识别 ID:" << contextId 
             << "线程:" << QThread::currentThread();
    QString result;

#ifdef Q_OS_WIN
    // 预处理图像以提高识别准确度
    QImage processedImage = preprocessImage(image);
    
    if (processedImage.isNull()) {
        result = "图像无效";
        emit recognitionFinished(result, contextId);
        return;
    }
    
    // 使用 BMP 格式存储临时文件，因为其写入速度最快且不涉及复杂的压缩计算，能缩短毫秒级开销
    QTemporaryFile tempFile(QDir::tempPath() + "/ocr_XXXXXX.bmp");
    tempFile.setAutoRemove(true);
    
    if (!tempFile.open()) {
        result = "无法创建临时图像文件";
        emit recognitionFinished(result, contextId);
        return;
    }
    
    QString filePath = QDir::toNativeSeparators(tempFile.fileName());
    
    // 保存预处理后的灰度图
    if (!processedImage.save(filePath, "BMP")) {
        result = "无法保存临时图像文件";
        emit recognitionFinished(result, contextId);
        return;
    }
    
    tempFile.close();

    // 路径探测逻辑：增强鲁棒性，支持从 bin 或 build 目录运行
    QString appPath = QCoreApplication::applicationDirPath();
    QString tessDataPath;
    QString tesseractPath;

    // 尝试在多个层级寻找 resources 目录
    QStringList basePaths;
    basePaths << appPath;
    basePaths << QDir(appPath).absolutePath() + "/..";
    basePaths << QDir(appPath).absolutePath() + "/../..";

    for (const QString& base : std::as_const(basePaths)) {
        // 搜索数据目录 (支持资源目录、根目录及标准安装路径)
        if (tessDataPath.isEmpty()) {
            QStringList dataPotentials;
            dataPotentials << base + "/resources/Tesseract-OCR/tessdata"
                           << base + "/Tesseract-OCR/tessdata"
                           << base + "/tessdata"
                           << "C:/Program Files/Tesseract-OCR/tessdata";
            for (const QString& p : std::as_const(dataPotentials)) {
                if (QDir(p).exists()) {
                    tessDataPath = QDir(p).absolutePath();
                    break;
                }
            }
        }
        
        // 搜索执行文件
        if (tesseractPath.isEmpty()) {
            QStringList exePotentials;
            exePotentials << base + "/resources/Tesseract-OCR/tesseract.exe"
                           << base + "/Tesseract-OCR/tesseract.exe"
                           << base + "/resources/tesseract.exe"
                           << base + "/tesseract.exe"
                           << "C:/Program Files/Tesseract-OCR/tesseract.exe";
            for (const QString& p : std::as_const(exePotentials)) {
                if (QFile::exists(p)) {
                    tesseractPath = QDir::toNativeSeparators(p);
                    break;
                }
            }
        }
        
        if (!tessDataPath.isEmpty() && !tesseractPath.isEmpty()) break;
    }

    // 系统 PATH 兜底
    if (tesseractPath.isEmpty()) tesseractPath = "tesseract";

    if (!tesseractPath.isEmpty()) {
        QProcess tesseract;
        
        // 设置 TESSDATA_PREFIX 环境变量（Tesseract 主程序所在的父目录或 tessdata 所在目录）
        QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
        if (!tessDataPath.isEmpty() && QDir(tessDataPath).exists()) {
            // TESSDATA_PREFIX 通常应该是包含 tessdata 文件夹的目录
            QDir prefixDir(tessDataPath);
            prefixDir.cdUp();
            env.insert("TESSDATA_PREFIX", QDir::toNativeSeparators(prefixDir.absolutePath()));
        }
        tesseract.setProcessEnvironment(env);
        
        // 智能语言探测：自动扫描 tessdata 目录下所有可用的训练数据
        QStringList foundLangs;
        if (!tessDataPath.isEmpty()) {
            QDir dir(tessDataPath);
            if (dir.exists()) {
            QStringList filters; filters << "*.traineddata";
            QStringList files = dir.entryList(filters, QDir::Files);
            
            // 定义优先级：优先加载中文简体和泰语，防止误识别为英文字符 (如 星号 -> BE)
            QStringList priority;
            QString systemName = QLocale::system().name();
            // 严谨判断简繁：只有明确匹配到港澳台地区或传统脚本时才视为繁体
            bool isTraditional = (systemName.contains("zh_TW") || systemName.contains("zh_HK") || 
                                 systemName.contains("zh_MO") || 
                                 QLocale::system().script() == QLocale::TraditionalChineseScript);
            
            if (isTraditional) {
                priority = {"chi_tra", "tha", "eng", "chi_sim", "jpn", "kor"};
            } else {
                priority = {"chi_sim", "tha", "eng", "chi_tra", "jpn", "kor"};
            }

            for (const QString& pLang : std::as_const(priority)) {
                if (files.contains(pLang + ".traineddata")) {
                    foundLangs << pLang;
                    files.removeAll(pLang + ".traineddata");
                }
            }
            // 其余语言按字母顺序追加，但限制总数。
            // 速度优化的关键：加载的语言模型（LSTM）越多，Tesseract 初始化越慢。
            // 将上限从 10 降至 3，可使初始化速度提升数倍。
            for (const QString& file : std::as_const(files)) {
                if (foundLangs.size() >= 3) break;
                QString name = file.left(file.lastIndexOf('.'));
                if (name != "osd" && !foundLangs.contains(name)) foundLangs << name;
            }
            }
        }

        QString currentLang = foundLangs.isEmpty() ? m_language : foundLangs.join('+');
        qDebug() << "OCR: Used tessdata path:" << tessDataPath;
        qDebug() << "OCR: Detected languages:" << foundLangs.size() << ":" << currentLang;

        QStringList args;
        // 明确指定数据目录
        if (QFile::exists(tessDataPath)) {
            args << "--tessdata-dir" << QDir::toNativeSeparators(tessDataPath);
        }
        
        args << filePath << "stdout" << "-l" << currentLang << "--oem" << "1" << "--psm" << "3";
        tesseract.start(tesseractPath, args);
        
        if (!tesseract.waitForStarted()) {
            result = "无法启动 Tesseract 引擎。路径: " + tesseractPath;
        } else if (tesseract.waitForFinished(20000)) {
            QByteArray output = tesseract.readAllStandardOutput();
            QByteArray errorOutput = tesseract.readAllStandardError();
            result = QString::fromUtf8(output).trimmed();
            
            if (!result.isEmpty()) {
                qDebug() << "Tesseract OCR succeeded using:" << tesseractPath << "with lang:" << currentLang;
                emit recognitionFinished(result, contextId);
                return;
            }
            
            if (!errorOutput.isEmpty()) {
                result = "Tesseract 错误: " + QString::fromUtf8(errorOutput).left(100);
            } else {
                result = "未识别到任何内容。请检查数据包及语言。";
            }
        } else {
            tesseract.kill();
            result = "OCR 识别超时 (20s)。语言包过量或图片过大。";
        }
    } else {
        result = "未找到 Tesseract 引擎组件。搜索路径包括 resources/Tesseract-OCR。";
    }
#else
    result = "当前平台不支持 OCR 功能";
#endif

    if (result.isEmpty()) {
        result = "未能从图片中识别出任何文字";
    }
    
    qDebug() << "[OCRManager] recognizeSync: 识别完成 ID:" << contextId 
             << "结果长度:" << result.length() << "线程:" << QThread::currentThread();
    qDebug() << "[OCRManager] 准备发送 recognitionFinished 信号 ID:" << contextId;
    
    try {
        emit recognitionFinished(result, contextId);
        qDebug() << "[OCRManager] recognitionFinished 信号已发送 ID:" << contextId;
    } catch (const std::exception& e) {
        qDebug() << "[OCRManager] 异常: 发送信号时出错 ID:" << contextId << "错误:" << e.what();
    } catch (...) {
        qDebug() << "[OCRManager] 异常: 发送信号时出现未知错误 ID:" << contextId;
    }
}
```

## 文件: `src/core/OCRManager.h`

```cpp
#ifndef OCRMANAGER_H
#define OCRMANAGER_H
#include <QObject>
#include <QImage>
#include <QString>

class OCRManager : public QObject {
    Q_OBJECT
public:
    static OCRManager& instance();
    void recognizeAsync(const QImage& image, int contextId = -1);
    
    // 设置 OCR 识别语言（默认: "chi_sim+eng"）
    // 可用语言见 traineddata 文件，多语言用 + 连接
    // 例如: "chi_sim+eng", "jpn+eng", "fra+deu"
    void setLanguage(const QString& lang);
    QString getLanguage() const;

private:
    void recognizeSync(const QImage& image, int contextId);
    QImage preprocessImage(const QImage& original);

signals:
    void recognitionFinished(const QString& text, int contextId);

private:
    OCRManager(QObject* parent = nullptr);
    QString m_language = "chi_sim+eng"; // 默认中文简体+英文
};

#endif // OCRMANAGER_H
```

## 文件: `src/ui/OCRResultWindow.cpp`

```cpp
#include "OCRResultWindow.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include "ToolTipOverlay.h"
#include "../core/ClipboardMonitor.h"
#include <QApplication>
#include <QClipboard>
#include <QToolTip>
#include <QCursor>
#include <QSettings>
#include <QDebug>
#include <QRegularExpression>

OCRResultWindow::OCRResultWindow(const QImage& image, int contextId, QWidget* parent)
    : FramelessDialog("识别文本", parent), m_image(image), m_contextId(contextId)
{
    setObjectName("OCRResultWindow");
    loadWindowSettings();
    setAttribute(Qt::WA_DeleteOnClose);
    setFixedSize(600, 450);
    
    // 强制更新标题栏样式
    m_titleLabel->clear();
    auto* titleLayout = qobject_cast<QHBoxLayout*>(m_titleLabel->parentWidget()->layout());
    if (titleLayout) {
        // 尝试在标题文字前插个图标
        QLabel* iconLabel = new QLabel;
        iconLabel->setPixmap(IconHelper::getIcon("screenshot_ocr", "#007ACC", 20).pixmap(20, 20));
        titleLayout->insertWidget(0, iconLabel);
        
        m_titleLabel->setText("识别文本");
        m_titleLabel->setStyleSheet("font-weight: bold; color: #eee;");
    }
    
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(15, 10, 15, 15);
    layout->setSpacing(12);

    m_textEdit = new QPlainTextEdit();
    m_textEdit->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_textEdit->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_textEdit->setPlaceholderText("正在识别中...");
    m_textEdit->setStyleSheet(R"(
        QPlainTextEdit {
            background-color: #1E1E1E;
            color: #D4D4D4;
            border: 1px solid #333333;
            border-radius: 4px;
            padding: 8px;
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 14px;
        }
        QScrollBar:vertical {
            border: none;
            background: #1E1E1E;
            width: 10px;
            margin: 0px;
        }
        QScrollBar::handle:vertical {
            background: #333;
            min-height: 20px;
            border-radius: 5px;
        }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
            height: 0px;
        }
    )");
    layout->addWidget(m_textEdit);

    auto* bottomLayout = new QHBoxLayout();
    bottomLayout->setSpacing(10);
    
    m_autoCopyCheck = new QCheckBox("下次自动复制");
    m_autoCopyCheck->setStyleSheet("QCheckBox { color: #999; font-size: 12px; } QCheckBox::indicator { width: 16px; height: 16px; }");
    
    QSettings settings("RapidNotes", "OCR");
    m_autoCopyCheck->setChecked(settings.value("autoCopy", false).toBool());
    
    // 立即保存设置，确保用户勾选后即刻生效
    connect(m_autoCopyCheck, &QCheckBox::toggled, [](bool checked){
        QSettings settings("RapidNotes", "OCR");
        settings.setValue("autoCopy", checked);
    });
    
    bottomLayout->addWidget(m_autoCopyCheck);

    bottomLayout->addStretch(1);

    QPushButton* toSimplifiedBtn = new QPushButton("转简体");
    toSimplifiedBtn->setFlat(true);
    toSimplifiedBtn->setStyleSheet("QPushButton { color: #1abc9c; border: none; font-size: 13px; } QPushButton:hover { color: #2ecc71; }");
    toSimplifiedBtn->setCursor(Qt::PointingHandCursor);
    connect(toSimplifiedBtn, &QPushButton::clicked, [this]{
        m_textEdit->setPlainText(StringUtils::convertChineseVariant(m_textEdit->toPlainText(), true));
    });
    bottomLayout->addWidget(toSimplifiedBtn);

    QPushButton* toTraditionalBtn = new QPushButton("转繁体");
    toTraditionalBtn->setFlat(true);
    toTraditionalBtn->setStyleSheet("QPushButton { color: #f39c12; border: none; font-size: 13px; } QPushButton:hover { color: #e67e22; }");
    toTraditionalBtn->setCursor(Qt::PointingHandCursor);
    connect(toTraditionalBtn, &QPushButton::clicked, [this]{
        m_textEdit->setPlainText(StringUtils::convertChineseVariant(m_textEdit->toPlainText(), false));
    });
    bottomLayout->addWidget(toTraditionalBtn);

    QPushButton* typesettingBtn = new QPushButton("排版");
    typesettingBtn->setFlat(true);
    typesettingBtn->setStyleSheet("QPushButton { color: #4a90e2; border: none; font-size: 13px; } QPushButton:hover { color: #6ab0ff; }");
    typesettingBtn->setCursor(Qt::PointingHandCursor);
    connect(typesettingBtn, &QPushButton::clicked, this, &OCRResultWindow::onTypesettingClicked);
    bottomLayout->addWidget(typesettingBtn);

    QPushButton* copyBtn = new QPushButton("复制");
    copyBtn->setFixedSize(80, 32);
    copyBtn->setStyleSheet(R"(
        QPushButton {
            background-color: #007ACC;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            font-size: 13px;
        }
        QPushButton:hover {
            background-color: #008be5;
        }
        QPushButton:pressed {
            background-color: #005a9e;
        }
    )");
    connect(copyBtn, &QPushButton::clicked, this, &OCRResultWindow::onCopyClicked);
    bottomLayout->addWidget(copyBtn);

    layout->addLayout(bottomLayout);
}

void OCRResultWindow::setRecognizedText(const QString& text, int contextId) {
    if (m_contextId != -1 && contextId != m_contextId) return;
    
    m_textEdit->setPlainText(text);
    
    if (m_autoCopyCheck->isChecked()) {
        if (!isVisible()) {
            // 静默模式反馈
            if (text.trimmed().isEmpty() || text.contains("未识别到") || text.contains("错误")) {
                this->show();
                return;
            }
            ToolTipOverlay::instance()->showText(QCursor::pos(), "✔ 识别完成并已复制到剪贴板");
        }
        onCopyClicked();
    }
}

void OCRResultWindow::onCopyClicked() {
    QString text = m_textEdit->toPlainText();
    if (!text.isEmpty()) {
        // [CRITICAL] 明确标记为 ocr_text 类型，确保通过识别提取的文字入库后显示扫描图标
        ClipboardMonitor::instance().forceNext("ocr_text");
        QApplication::clipboard()->setText(text);
    }
    QSettings settings("RapidNotes", "OCR");
    settings.setValue("autoCopy", m_autoCopyCheck->isChecked());
    
    // 明确关闭窗口。由于设置了 WA_DeleteOnClose，close() 会触发析构
    this->close();
}

void OCRResultWindow::onTypesettingClicked() {
    QString text = m_textEdit->toPlainText();
    if (text.isEmpty()) return;

    // 优化排版逻辑：合并被换行符切断的行，保留真正的段落（连续两个换行或空白行）
    // 处理逻辑：
    // 1. 统一换行符
    text.replace("\r\n", "\n");
    // 2. 识别段落：将两个以上的换行替换为特殊标记
    text.replace(QRegularExpression("\n{2,}"), "[[PARAGRAPH]]");
    // 3. 将剩余的单换行替换为空格（西文）或直接删除（中文）
    // 这里简单处理：删除所有单换行，去除行首尾空格
    QStringList lines = text.split('\n', Qt::SkipEmptyParts);
    QString merged;
    for (int i = 0; i < lines.size(); ++i) {
        merged += lines[i].trimmed();
    }
    // 4. 恢复段落
    merged.replace("[[PARAGRAPH]]", "\n\n");
    
    m_textEdit->setPlainText(merged);
}
```

## 文件: `src/ui/OCRResultWindow.h`

```cpp
#ifndef OCRRESULTWINDOW_H
#define OCRRESULTWINDOW_H

#include "FramelessDialog.h"
#include <QPlainTextEdit>
#include <QCheckBox>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>

class OCRResultWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit OCRResultWindow(const QImage& image, int contextId = -1, QWidget* parent = nullptr);
    void setRecognizedText(const QString& text, int contextId);

private slots:
    void onCopyClicked();
    void onTypesettingClicked();

private:
    QPlainTextEdit* m_textEdit;
    QCheckBox* m_autoCopyCheck;
    QImage m_image;
    int m_contextId;
};

#endif // OCRRESULTWINDOW_H
```

## 文件: `src/ui/OCRWindow.cpp`

```cpp
#include "OCRWindow.h"
#include "IconHelper.h"
#include "../core/OCRManager.h"
#include "../core/ClipboardMonitor.h"
#include <QApplication>
#include <QClipboard>
#include <QMimeData>
#include <QMouseEvent>
#include <QGraphicsDropShadowEffect>
#include <QFileDialog>
#include <QDropEvent>
#include <QFileInfo>
#include <QDateTime>
#include <QThread>

OCRWindow::OCRWindow(QWidget* parent) : FramelessDialog("截图取文", parent) {
    setObjectName("OCRWindow");
    setFixedSize(800, 500);
    setAcceptDrops(true);

    loadWindowSettings();
    initUI();
    onClearResults();
    
    qDebug() << "[OCR] OCRWindow 初始化完成，使用顺序处理模式";
    
    connect(&OCRManager::instance(), &OCRManager::recognitionFinished, 
            this, &OCRWindow::onRecognitionFinished, 
            static_cast<Qt::ConnectionType>(Qt::QueuedConnection | Qt::UniqueConnection));
}

OCRWindow::~OCRWindow() {
    m_processingQueue.clear();
    m_isProcessing = false;
}

void OCRWindow::initUI() {
    auto* mainHLayout = new QHBoxLayout(m_contentArea);
    mainHLayout->setContentsMargins(10, 10, 10, 10);
    mainHLayout->setSpacing(10);

    // --- 左侧：操作面板 ---
    auto* leftPanel = new QWidget();
    auto* leftLayout = new QVBoxLayout(leftPanel);
    leftLayout->setContentsMargins(0, 0, 0, 0);
    leftLayout->setSpacing(8);

    auto* btnBrowse = new QPushButton(" 本地浏览");
    btnBrowse->setIcon(IconHelper::getIcon("folder", "#ffffff"));
    btnBrowse->setFixedHeight(36);
    btnBrowse->setStyleSheet("QPushButton { background: #4a90e2; color: white; border-radius: 4px; padding: 0 10px; text-align: left; } QPushButton:hover { background: #357abd; }");
    connect(btnBrowse, &QPushButton::clicked, this, &OCRWindow::onBrowseAndRecognize);
    leftLayout->addWidget(btnBrowse);

    auto* btnPaste = new QPushButton(" 粘贴识别");
    btnPaste->setIcon(IconHelper::getIcon("copy", "#ffffff"));
    btnPaste->setFixedHeight(36);
    btnPaste->setStyleSheet("QPushButton { background: #2ecc71; color: white; border-radius: 4px; padding: 0 10px; text-align: left; } QPushButton:hover { background: #27ae60; }");
    connect(btnPaste, &QPushButton::clicked, this, &OCRWindow::onPasteAndRecognize);
    leftLayout->addWidget(btnPaste);

    leftLayout->addSpacing(10);

    auto* btnClear = new QPushButton(" 清空列表");
    btnClear->setIcon(IconHelper::getIcon("trash", "#ddbbbb"));
    btnClear->setFixedHeight(36);
    btnClear->setStyleSheet("QPushButton { background: #333; color: #ccc; border: 1px solid #444; border-radius: 4px; padding: 0 10px; text-align: left; } QPushButton:hover { background: #444; color: #fff; }");
    connect(btnClear, &QPushButton::clicked, this, &OCRWindow::onClearResults);
    leftLayout->addWidget(btnClear);

    leftLayout->addStretch();

    auto* btnCopy = new QPushButton(" 复制文字");
    btnCopy->setIcon(IconHelper::getIcon("copy", "#ffffff"));
    btnCopy->setFixedHeight(36);
    btnCopy->setStyleSheet("QPushButton { background: #3d3d3d; color: #eee; border: 1px solid #4a4a4a; border-radius: 4px; padding: 0 10px; text-align: left; } QPushButton:hover { background: #4d4d4d; }");
    connect(btnCopy, &QPushButton::clicked, this, &OCRWindow::onCopyResult);
    leftLayout->addWidget(btnCopy);

    leftPanel->setFixedWidth(120);
    mainHLayout->addWidget(leftPanel);

    // --- 中间：项目列表 ---
    auto* middlePanel = new QWidget();
    auto* middleLayout = new QVBoxLayout(middlePanel);
    middleLayout->setContentsMargins(0, 0, 0, 0);
    middleLayout->setSpacing(5);

    auto* listLabel = new QLabel("上传的项目");
    listLabel->setStyleSheet("color: #888; font-size: 11px; font-weight: bold;");
    middleLayout->addWidget(listLabel);

    m_itemList = new QListWidget();
    m_itemList->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_itemList->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_itemList->setStyleSheet(
        "QListWidget { background: #222; border: 1px solid #333; border-radius: 4px; color: #ddd; }"
        "QListWidget::item { height: 32px; padding-left: 5px; }"
        "QListWidget::item:selected { background: #357abd; color: white; border-radius: 2px; }"
    );
    connect(m_itemList, &QListWidget::itemSelectionChanged, this, &OCRWindow::onItemSelectionChanged);
    middleLayout->addWidget(m_itemList);

    middlePanel->setFixedWidth(180);
    mainHLayout->addWidget(middlePanel);

    // --- 右侧：结果展示 ---
    auto* rightPanel = new QWidget();
    auto* rightLayout = new QVBoxLayout(rightPanel);
    rightLayout->setContentsMargins(0, 0, 0, 0);
    rightLayout->setSpacing(5);

    auto* resultLabel = new QLabel("识别结果");
    resultLabel->setStyleSheet("color: #888; font-size: 11px; font-weight: bold;");
    rightLayout->addWidget(resultLabel);

    
    // 进度条
    m_progressBar = new QProgressBar();
    m_progressBar->setTextVisible(true);
    m_progressBar->setAlignment(Qt::AlignCenter);
    m_progressBar->setStyleSheet("QProgressBar { border: none; background: #333; border-radius: 4px; height: 6px; text-align: center; color: transparent; } QProgressBar::chunk { background-color: #4a90e2; border-radius: 4px; }");
    m_progressBar->hide();
    rightLayout->addWidget(m_progressBar);

    m_ocrResult = new QTextEdit();
    m_ocrResult->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_ocrResult->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_ocrResult->setReadOnly(true);
    m_ocrResult->setPlaceholderText("选择左侧项目查看识别结果...");
    m_ocrResult->setStyleSheet("QTextEdit { background: #1a1a1a; border: 1px solid #333; border-radius: 6px; color: #eee; font-size: 13px; padding: 10px; line-height: 1.4; }");
    rightLayout->addWidget(m_ocrResult);

    mainHLayout->addWidget(rightPanel);
}

void OCRWindow::onPasteAndRecognize() {
    qDebug() << "[OCR] 粘贴识别: 开始";
    
    // 自动清空之前的数据
    onClearResults();
    
    const QClipboard* clipboard = QApplication::clipboard();
    const QMimeData* mimeData = clipboard->mimeData();

    QList<QPair<QImage, QString>> imageData;

    if (!mimeData) return;

    if (mimeData->hasImage()) {
        QImage img = qvariant_cast<QImage>(mimeData->imageData());
        if (!img.isNull()) {
            imageData.append({img, "粘贴的图片"});
        }
    } else if (mimeData->hasUrls()) {
        for (const QUrl& url : mimeData->urls()) {
            QString path = url.toLocalFile();
            if (!path.isEmpty()) {
                QImage img(path);
                if (!img.isNull()) {
                    imageData.append({img, QFileInfo(path).fileName()});
                }
            }
        }
    }

    if (!imageData.isEmpty()) {
        // 限制最多 10 张图片
        if (imageData.size() > 10) {
            qDebug() << "[OCR] 粘贴识别: 图片数量超过限制，仅处理前 10 张";
            imageData = imageData.mid(0, 10);
        }
        
        qDebug() << "[OCR] 粘贴识别: 开始处理" << imageData.size() << "张图片";
        QList<QImage> imgs;
        for (auto& p : imageData) {
            OCRItem item;
            item.image = p.first;
            item.name = p.second;
            // 【核心修复】使用负数 ID 作为临时任务，避免与数据库中的 noteId 冲突导致误更新
            item.id = -(++m_lastUsedId);
            item.sessionVersion = m_sessionVersion;
            m_items.append(item);
            imgs << p.first;
            qDebug() << "[OCR] 添加任务 ID:" << item.id << "名称:" << item.name;

            auto* listItem = new QListWidgetItem(item.name, m_itemList);
            listItem->setData(Qt::UserRole, item.id);
            listItem->setIcon(IconHelper::getIcon("image", "#888"));
        }
        processImages(imgs);
        
        // 自动选中第一个新加入的项目
        m_itemList->setCurrentRow(m_itemList->count() - imageData.size());
    }
}

void OCRWindow::onBrowseAndRecognize() {
    QStringList files = QFileDialog::getOpenFileNames(this, "选择识别图片", "", "图片文件 (*.png *.jpg *.jpeg *.bmp *.gif)");
    if (files.isEmpty()) return;

    // 自动清空之前的数据
    onClearResults();

    qDebug() << "[OCR] 浏览识别: 选择了" << files.size() << "个文件";
    
    // 限制最多 10 张图片
    if (files.size() > 10) {
        qDebug() << "[OCR] 浏览识别: 文件数量超过限制，仅处理前 10 个";
        files = files.mid(0, 10);
    }
    
    QList<QImage> imgs;
    for (const QString& file : std::as_const(files)) {
        QImage img(file);
        if (!img.isNull()) {
            OCRItem item;
            item.image = img;
            item.name = QFileInfo(file).fileName();
            // 【核心修复】使用负数 ID
            item.id = -(++m_lastUsedId);
            item.sessionVersion = m_sessionVersion;
            m_items.append(item);
            imgs << img;
            qDebug() << "[OCR] 添加任务 ID:" << item.id << "文件:" << file;

            auto* listItem = new QListWidgetItem(item.name, m_itemList);
            listItem->setData(Qt::UserRole, item.id);
            listItem->setIcon(IconHelper::getIcon("image", "#888"));
        }
    }

    if (!imgs.isEmpty()) {
        processImages(imgs);
        m_itemList->setCurrentRow(m_itemList->count() - imgs.size());
    }
}

void OCRWindow::onClearResults() {
    qDebug() << "[OCR] 清空结果";
    
    m_isProcessing = false;
    m_processingQueue.clear();
    m_sessionVersion++; // 递增版本号，使旧的回调失效
    
    m_itemList->clear();
    m_items.clear();
    m_ocrResult->clear();
    
    // 重置进度条
    if (m_progressBar) {
        m_progressBar->hide();
        m_progressBar->setValue(0);
    }
    
    // 不重置 m_lastUsedId，防止异步回调 ID 冲突
    
    auto* summaryItem = new QListWidgetItem("--- 全部结果汇总 ---", m_itemList);
    summaryItem->setData(Qt::UserRole, 0); // 0 代表汇总
    summaryItem->setIcon(IconHelper::getIcon("file_managed", "#1abc9c"));
    m_itemList->setCurrentItem(summaryItem);
}

void OCRWindow::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasImage() || event->mimeData()->hasUrls()) {
        event->acceptProposedAction();
    }
}

void OCRWindow::dropEvent(QDropEvent* event) {
    qDebug() << "[OCR] 拖入识别: 开始";
    
    // 自动清空之前的数据
    onClearResults();
    
    const QMimeData* mime = event->mimeData();
    QList<QImage> imgsToProcess;

    // 限制最多 10 张图片
    int imageCount = 0;
    const int MAX_IMAGES = 10;

    if (mime->hasImage()) {
        QImage img = qvariant_cast<QImage>(mime->imageData());
        if (!img.isNull() && imageCount < MAX_IMAGES) {
            OCRItem item;
            item.image = img;
            item.name = "拖入的图片";
            // 【核心修复】使用负数 ID
            item.id = -(++m_lastUsedId);
            item.sessionVersion = m_sessionVersion;
            m_items.append(item);
            imgsToProcess << img;
            imageCount++;

            auto* listItem = new QListWidgetItem(item.name, m_itemList);
            listItem->setData(Qt::UserRole, item.id);
            listItem->setIcon(IconHelper::getIcon("image", "#888"));
        }
    }

    if (mime->hasUrls()) {
        for (const QUrl& url : mime->urls()) {
            if (imageCount >= MAX_IMAGES) {
                qDebug() << "[OCR] 拖入识别: 已达到最大图片数量限制 (10 张)";
                break;
            }
            
            QString path = url.toLocalFile();
            if (!path.isEmpty()) {
                QImage img(path);
                if (!img.isNull()) {
                    OCRItem item;
                    item.image = img;
                    item.name = QFileInfo(path).fileName();
                    // 【核心修复】使用负数 ID
                    item.id = -(++m_lastUsedId);
                    item.sessionVersion = m_sessionVersion;
                    m_items.append(item);
                    imgsToProcess << img;
                    imageCount++;

                    auto* listItem = new QListWidgetItem(item.name, m_itemList);
                    listItem->setData(Qt::UserRole, item.id);
                    listItem->setIcon(IconHelper::getIcon("image", "#888"));
                }
            }
        }
    }

    if (!imgsToProcess.isEmpty()) {
        processImages(imgsToProcess);
        m_itemList->setCurrentRow(m_itemList->count() - imgsToProcess.size());
        event->acceptProposedAction();
    }
}

void OCRWindow::processImages(const QList<QImage>& images) {
    qDebug() << "[OCR] processImages: 添加" << images.size() << "张图片到队列";
    
    m_processingQueue.clear(); // 清空旧队列
    
    // 将所有图片添加到队列
    int startIdx = m_items.size() - images.size();
    for (int i = 0; i < images.size(); ++i) {
        int taskId = m_items[startIdx + i].id;
        m_processingQueue.enqueue(taskId);
        qDebug() << "[OCR] 添加到队列 ID:" << taskId;
    }
    
    // 显示并初始化进度条
    if (m_progressBar && !images.isEmpty()) {
        m_progressBar->setMaximum(images.size()); // 仅当前批次
        m_progressBar->setValue(0);
        m_progressBar->show();
    }
    
    // 如果当前没有在处理，立即开始处理
    if (!m_isProcessing) {
        qDebug() << "[OCR] 开始顺序处理";
        processNextImage();
    }
}

void OCRWindow::processNextImage() {
    // 检查队列是否为空
    if (m_processingQueue.isEmpty()) {
        qDebug() << "[OCR] 所有任务处理完成";
        m_isProcessing = false;
        updateRightDisplay();
        return;
    }
    
    m_isProcessing = true;
    int taskId = m_processingQueue.dequeue();
    
    qDebug() << "[OCR] 开始处理 ID:" << taskId << "剩余:" << m_processingQueue.size();
    
    // 找到对应的图片
    OCRItem* item = nullptr;
    for (auto& it : m_items) {
        if (it.id == taskId) {
            item = &it;
            break;
        }
    }
    
    if (!item) {
        qDebug() << "[OCR] 错误: 未找到任务 ID:" << taskId;
        // 继续处理下一个
        QMetaObject::invokeMethod(this, &OCRWindow::processNextImage, Qt::QueuedConnection);
        return;
    }
    
    // 启动异步识别
    // 注意：这里我们使用 recognizeAsync，它会在后台线程运行
    // 识别完成后会发射 recognitionFinished 信号，我们在槽函数中触发下一个任务
    qDebug() << "[OCR] 调用 recognizeAsync ID:" << taskId;
    OCRManager::instance().recognizeAsync(item->image, taskId);
}


void OCRWindow::onItemSelectionChanged() {
    updateRightDisplay();
}

void OCRWindow::onRecognitionFinished(const QString& text, int contextId) {
    qDebug() << "[OCR] onRecognitionFinished: 收到识别结果 ID:" << contextId 
             << "线程:" << QThread::currentThread() << "文本长度:" << text.length();
    
    bool found = false;
    for (auto& item : m_items) {
        if (item.id == contextId) {
            // 检查会话版本号
            if (item.sessionVersion != m_sessionVersion) {
                qDebug() << "[OCR] 忽略过期回调 ID:" << contextId 
                         << "任务会话:" << item.sessionVersion 
                         << "当前会话:" << m_sessionVersion;
                // 注意：旧任务的回调不应该触发下一个新任务的处理
                // 因为新任务的处理循环是由新的 processImages 启动的
                return; 
            }
            
            item.result = text.trimmed();
            item.isFinished = true;
            found = true;
            qDebug() << "[OCR] 更新任务状态 ID:" << contextId << "名称:" << item.name;
            break;
        }
    }
    
    if (!found) {
        // 如果未找到任务（可能已被清空），也不要触发下一个
        qDebug() << "[OCR] 警告: 未找到对应的任务 ID:" << contextId;
        return;
    }
    
    // 统计完成进度
    int finished = 0;
    for (const auto& item : std::as_const(m_items)) {
        if (item.isFinished) finished++;
    }
    qDebug() << "[OCR] 识别进度:" << finished << "/" << m_items.size();
    
    // 更新进度条
    if (m_progressBar) {
        m_progressBar->setValue(finished);
        if (finished >= m_items.size()) {
            QTimer::singleShot(1000, m_progressBar, &QProgressBar::hide); // 完成1秒后隐藏
        }
    }
    
    // 延迟到主线程更新UI
    QMetaObject::invokeMethod(this, &OCRWindow::updateRightDisplay, Qt::QueuedConnection);
    
    // 延迟到下一个事件循环处理任务，避免栈溢出
    qDebug() << "[OCR] 当前任务完成，准备处理下一个";
    QMetaObject::invokeMethod(this, &OCRWindow::processNextImage, Qt::QueuedConnection);
}

void OCRWindow::updateRightDisplay() {
    // 确保在主线程执行
    if (QThread::currentThread() != this->thread()) {
        QMetaObject::invokeMethod(this, &OCRWindow::updateRightDisplay, Qt::QueuedConnection);
        return;
    }

    qDebug() << "[OCR] updateRightDisplay: 开始更新显示 线程:" << QThread::currentThread();
    
    if (!m_itemList) {
        qDebug() << "[OCR] updateRightDisplay: m_itemList 为空";
        return;
    }
    
    if (!m_ocrResult) {
        qDebug() << "[OCR] updateRightDisplay: m_ocrResult 为空";
        return;
    }
    
    auto* current = m_itemList->currentItem();
    if (!current) {
        qDebug() << "[OCR] updateRightDisplay: 没有选中项";
        return;
    }

    int id = current->data(Qt::UserRole).toInt();
    qDebug() << "[OCR] updateRightDisplay: 当前选中 ID:" << id << "m_items 大小:" << m_items.size();

    if (id == 0) {
        // 展示全部
        qDebug() << "[OCR] updateRightDisplay: 展示全部结果";
        QString allText;
        int itemCount = 0;
        for (const auto& item : std::as_const(m_items)) {
            itemCount++;
            if (!allText.isEmpty()) allText += "\n\n";
            allText += QString("【%1】\n").arg(item.name);
            allText += item.isFinished ? item.result : "正在识别管理中...";
            allText += "\n-----------------------------------";
        }
        qDebug() << "[OCR] updateRightDisplay: 处理了" << itemCount << "个项目，文本长度:" << allText.length();
        m_ocrResult->setPlainText(allText);
        qDebug() << "[OCR] updateRightDisplay: setPlainText 完成";
    } else {
        // 展示单个
        qDebug() << "[OCR] updateRightDisplay: 展示单个结果 ID:" << id;
        bool found = false;
        for (const auto& item : std::as_const(m_items)) {
            if (item.id == id) {
                found = true;
                QString text = item.isFinished ? item.result : "正在识别中，请稍候...";
                qDebug() << "[OCR] updateRightDisplay: 找到项目，文本长度:" << text.length();
                m_ocrResult->setPlainText(text);
                qDebug() << "[OCR] updateRightDisplay: setPlainText 完成";
                break;
            }
        }
        if (!found) {
            qDebug() << "[OCR] updateRightDisplay: 警告 - 未找到 ID:" << id;
        }
    }
    qDebug() << "[OCR] updateRightDisplay: 完成";
}

void OCRWindow::onCopyResult() {
    QString text = m_ocrResult->toPlainText();
    if (!text.isEmpty()) {
        // [CRITICAL] 明确标记为 ocr_text 类型，确保通过识别提取的文字入库后显示扫描图标
        ClipboardMonitor::instance().forceNext("ocr_text");
        QApplication::clipboard()->setText(text);
    }
}

```

## 文件: `src/ui/OCRWindow.h`

```cpp
#ifndef OCRWINDOW_H
#define OCRWINDOW_H

#include "FramelessDialog.h"
#include <QTextEdit>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QMap>
#include <QListWidget>
#include <QTimer>
#include <QQueue>
#include <QProgressBar>

class OCRWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit OCRWindow(QWidget* parent = nullptr);
    ~OCRWindow();

    void processImages(const QList<QImage>& images);

private slots:
    void onPasteAndRecognize();
    void onBrowseAndRecognize();
    void onClearResults();
    void onCopyResult();
    void onItemSelectionChanged();
    void processNextImage();  // 处理队列中的下一张图片
    void onRecognitionFinished(const QString& text, int contextId);

protected:
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dropEvent(QDropEvent* event) override;

private:
    void initUI();
    void updateRightDisplay();

    struct OCRItem {
        QImage image;
        QString name;
        QString result;
        bool isFinished = false;
        int id = -1;
        int sessionVersion = 0;
    };

    QListWidget* m_itemList = nullptr;
    QTextEdit* m_ocrResult = nullptr;
    QProgressBar* m_progressBar = nullptr;
    
    QList<OCRItem> m_items;
    int m_lastUsedId = 0;
    int m_sessionVersion = 0;
    
    // 顺序处理队列
    QQueue<int> m_processingQueue;  // 待处理的任务 ID 队列
    bool m_isProcessing = false;  // 是否正在处理
};

#endif // OCRWINDOW_H
```

## 文件: `src/ui/PasswordGeneratorWindow.cpp`

```cpp
#include "PasswordGeneratorWindow.h"
#include "IconHelper.h"
#include "ToolTipOverlay.h"
#include "../core/DatabaseManager.h"
#include "../core/ClipboardMonitor.h"
#include <QMouseEvent>
#include <QApplication>
#include <QClipboard>
#include <QRandomGenerator>
#include <QTimer>
#include <QToolTip>
#include <QGraphicsDropShadowEffect>
#include <QSettings>

PasswordGeneratorWindow::PasswordGeneratorWindow(QWidget* parent) : FramelessDialog("密码生成器", parent) {
    setObjectName("PasswordGeneratorWindow");
    setFixedSize(570, 400);

    loadWindowSettings();
    initUI();
}

PasswordGeneratorWindow::~PasswordGeneratorWindow() {
}

void PasswordGeneratorWindow::initUI() {
    auto* innerLayout = new QVBoxLayout(m_contentArea);
    innerLayout->setContentsMargins(20, 10, 20, 20);
    innerLayout->setSpacing(10);

    m_usageEntry = new QLineEdit();
    m_usageEntry->setPlaceholderText("Account / Usage (e.g. GitHub, Gmail...)");
    m_usageEntry->setFixedHeight(36);
    m_usageEntry->setStyleSheet("QLineEdit { background-color: #252525; border: 1px solid #333333; border-radius: 8px; color: #cccccc; font-size: 13px; padding-left: 10px; } QLineEdit:focus { border-color: #3b8ed0; }");
    innerLayout->addWidget(m_usageEntry);

    innerLayout->addWidget(createDisplayArea());
    innerLayout->addWidget(createControlsArea());

    auto* generateBtn = new QPushButton("Generate Password");
    generateBtn->setFixedHeight(40);
    generateBtn->setFixedWidth(200);
    generateBtn->setStyleSheet("QPushButton { background-color: #2cc985; color: white; border: none; border-radius: 20px; font-size: 13px; font-weight: bold; } QPushButton:hover { background-color: #229c67; }");
    connect(generateBtn, &QPushButton::clicked, this, &PasswordGeneratorWindow::generatePassword);
    innerLayout->addWidget(generateBtn, 0, Qt::AlignCenter);

    m_statusLabel = new QLabel("");
    m_statusLabel->setAlignment(Qt::AlignCenter);
    m_statusLabel->setStyleSheet("color: gray; font-size: 9px;");
    innerLayout->addWidget(m_statusLabel);

}

QWidget* PasswordGeneratorWindow::createDisplayArea() {
    auto* frame = new QWidget();
    auto* layout = new QVBoxLayout(frame);
    layout->setContentsMargins(0, 0, 0, 0);
    layout->setSpacing(4);

    m_passEntry = new QLineEdit();
    m_passEntry->setFixedHeight(44);
    m_passEntry->setAlignment(Qt::AlignCenter);
    m_passEntry->setReadOnly(true);
    m_passEntry->setStyleSheet("QLineEdit { background-color: #2b2b2b; border: none; border-radius: 10px; color: #e0e0e0; font-family: Consolas; font-size: 15px; }");

    m_strengthBar = new QProgressBar();
    m_strengthBar->setFixedHeight(3);
    m_strengthBar->setTextVisible(false);
    m_strengthBar->setStyleSheet("QProgressBar { border: none; background-color: #2b2b2b; border-radius: 1.5px; } QProgressBar::chunk { background-color: #4ade80; border-radius: 1.5px; }");
    m_strengthBar->setRange(0, 100);
    m_strengthBar->setValue(0);

    layout->addWidget(m_passEntry);
    layout->addWidget(m_strengthBar);
    return frame;
}

QWidget* PasswordGeneratorWindow::createControlsArea() {
    auto* frame = new QWidget();
    auto* layout = new QVBoxLayout(frame);
    layout->setContentsMargins(0, 5, 0, 5);
    layout->setSpacing(10);

    m_lengthLabel = new QLabel("Length: 16");
    m_lengthLabel->setStyleSheet("font-size: 12px; font-weight: bold; color: #cccccc;");

    m_lengthSlider = new QSlider(Qt::Horizontal);
    m_lengthSlider->setRange(8, 64);
    
    QSettings settings("RapidNotes", "PasswordGenerator");
    int savedLen = settings.value("length", 16).toInt();
    m_lengthSlider->setValue(savedLen);
    m_lengthLabel->setText(QString("Length: %1").arg(savedLen));

    connect(m_lengthSlider, &QSlider::valueChanged, [this](int v) {
        m_lengthLabel->setText(QString("Length: %1").arg(v));
        QSettings("RapidNotes", "PasswordGenerator").setValue("length", v);
    });
    m_lengthSlider->setStyleSheet("QSlider::groove:horizontal { border: 1px solid #444; height: 4px; background: #333; margin: 2px 0; border-radius: 2px; } "
                                  "QSlider::handle:horizontal { background-color: #3b8ed0; border: 5px solid #1e1e1e; width: 18px; height: 18px; margin: -7px 0; border-radius: 9px; } "
                                  "QSlider::sub-page:horizontal { background: #3b8ed0; border-radius: 2px; }");

    auto* checksFrame = new QWidget();
    auto* checksLayout = new QHBoxLayout(checksFrame);
    checksLayout->setContentsMargins(10, 0, 10, 0);

    QString cbStyle = "QCheckBox { spacing: 8px; font-size: 12px; font-weight: bold; color: #cccccc; } "
                      "QCheckBox::indicator { width: 18px; height: 18px; border: 2px solid #555; border-radius: 5px; background-color: transparent; } "
                      "QCheckBox::indicator:hover { border-color: #2cc985; } "
                      "QCheckBox::indicator:checked { background-color: #2cc985; border-color: #2cc985; }";

    m_checkUpper = new QCheckBox("A-Z"); m_checkUpper->setChecked(true); m_checkUpper->setStyleSheet(cbStyle);
    m_checkLower = new QCheckBox("a-z"); m_checkLower->setChecked(true); m_checkLower->setStyleSheet(cbStyle);
    m_checkDigits = new QCheckBox("0-9"); m_checkDigits->setChecked(true); m_checkDigits->setStyleSheet(cbStyle);
    m_checkSymbols = new QCheckBox("@#$"); m_checkSymbols->setChecked(true); m_checkSymbols->setStyleSheet(cbStyle);

    checksLayout->addStretch();
    checksLayout->addWidget(m_checkUpper);
    checksLayout->addStretch();
    checksLayout->addWidget(m_checkLower);
    checksLayout->addStretch();
    checksLayout->addWidget(m_checkDigits);
    checksLayout->addStretch();
    checksLayout->addWidget(m_checkSymbols);
    checksLayout->addStretch();

    m_excludeAmbiguous = new QCheckBox("排除相似字符 (0O1lI)");
    m_excludeAmbiguous->setChecked(settings.value("excludeAmbiguous", false).toBool());
    m_excludeAmbiguous->setStyleSheet("QCheckBox { spacing: 8px; font-size: 11px; color: #cccccc; } "
                                     "QCheckBox::indicator { width: 16px; height: 16px; border: 2px solid #555; border-radius: 4px; background-color: transparent; } "
                                     "QCheckBox::indicator:hover { border-color: #3b8ed0; } "
                                     "QCheckBox::indicator:checked { background-color: #3b8ed0; border-color: #3b8ed0; }");
    connect(m_excludeAmbiguous, &QCheckBox::toggled, [](bool checked){
        QSettings("RapidNotes", "PasswordGenerator").setValue("excludeAmbiguous", checked);
    });

    layout->addWidget(m_lengthLabel);
    layout->addWidget(m_lengthSlider);
    layout->addWidget(checksFrame);
    layout->addWidget(m_excludeAmbiguous);

    return frame;
}

void PasswordGeneratorWindow::generatePassword() {
    QString usageText = m_usageEntry->text().trimmed();
    if (usageText.isEmpty()) {
        m_usageEntry->setStyleSheet("QLineEdit { background-color: #252525; border: 1px solid #ef4444; border-radius: 8px; color: #cccccc; font-size: 13px; padding-left: 10px; }");
        ToolTipOverlay::instance()->showText(m_usageEntry->mapToGlobal(QPoint(0, m_usageEntry->height())), "请输入账号备注信息！");
        QTimer::singleShot(1500, [this]() {
            m_usageEntry->setStyleSheet("QLineEdit { background-color: #252525; border: 1px solid #333333; border-radius: 8px; color: #cccccc; font-size: 13px; padding-left: 10px; }");
        });
        return;
    }

    if (!m_checkUpper->isChecked() && !m_checkLower->isChecked() && !m_checkDigits->isChecked() && !m_checkSymbols->isChecked()) {
        ToolTipOverlay::instance()->showText(m_passEntry->mapToGlobal(QPoint(0, 0)), "至少选择一种字符类型！");
        return;
    }

    int length = m_lengthSlider->value();
    QString pwd = generateSecurePassword(length, m_checkUpper->isChecked(), m_checkLower->isChecked(), m_checkDigits->isChecked(), m_checkSymbols->isChecked(), m_excludeAmbiguous->isChecked());

    m_passEntry->setText(pwd);
    
    // 1. 手动存入数据库：备注为标题，密码为内容，绑定双标签
    DatabaseManager::instance().addNote(usageText, pwd, {"密码", "密码生成器"}, "", -1, "text");

    // 2. 复制到剪贴板前先屏蔽自动监听，防止重复入库。仅复制密码本体。
    ClipboardMonitor::instance().skipNext();
    QApplication::clipboard()->setText(pwd);

    m_statusLabel->setText(QString("✓ 已保存并复制密码！[%1]").arg(usageText));
    m_statusLabel->setStyleSheet("color: #4ade80; font-size: 9px;");

    // Update strength bar
    if (length < 10) {
        m_strengthBar->setStyleSheet("QProgressBar { border: none; background-color: #2b2b2b; border-radius: 1.5px; } QProgressBar::chunk { background-color: #ef4444; border-radius: 1.5px; }");
        m_strengthBar->setValue(30);
    } else if (length < 16) {
        m_strengthBar->setStyleSheet("QProgressBar { border: none; background-color: #2b2b2b; border-radius: 1.5px; } QProgressBar::chunk { background-color: #f59e0b; border-radius: 1.5px; }");
        m_strengthBar->setValue(60);
    } else {
        m_strengthBar->setStyleSheet("QProgressBar { border: none; background-color: #2b2b2b; border-radius: 1.5px; } QProgressBar::chunk { background-color: #2cc985; border-radius: 1.5px; }");
        m_strengthBar->setValue(100);
    }
}

QString PasswordGeneratorWindow::generateSecurePassword(int length, bool upper, bool lower, bool digits, bool symbols, bool excludeAmbiguous) {
    QString pool = "";
    QString required = "";
    QString symStr = "!@#$%^&*()-_=+[]{}|;:,.<>?/~`";
    QString ambig = "0O1lI";

    auto addFromSet = [&](bool use, const QString& set) {
        if (!use) return;
        QString filtered = set;
        if (excludeAmbiguous) {
            for (QChar c : ambig) filtered.remove(c);
        }
        if (!filtered.isEmpty()) {
            pool += filtered;
            required += filtered.at(QRandomGenerator::global()->bounded(filtered.length()));
        }
    };

    addFromSet(upper, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    addFromSet(lower, "abcdefghijklmnopqrstuvwxyz");
    addFromSet(digits, "0123456789");
    addFromSet(symbols, symStr);

    if (pool.isEmpty()) return "";

    QString pwd = required;
    while (pwd.length() < length) {
        pwd += pool.at(QRandomGenerator::global()->bounded(pool.length()));
    }

    // Shuffle
    for (int i = 0; i < pwd.length(); ++i) {
        int j = QRandomGenerator::global()->bounded(pwd.length());
        QChar temp = pwd[i];
        pwd[i] = pwd[j];
        pwd[j] = temp;
    }

    return pwd.left(length);
}

```

## 文件: `src/ui/PasswordGeneratorWindow.h`

```cpp
#ifndef PASSWORDGENERATORWINDOW_H
#define PASSWORDGENERATORWINDOW_H

#include "FramelessDialog.h"
#include <QLineEdit>
#include <QProgressBar>
#include <QSlider>
#include <QCheckBox>
#include <QLabel>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>

class PasswordGeneratorWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit PasswordGeneratorWindow(QWidget* parent = nullptr);
    ~PasswordGeneratorWindow();

private slots:
    void generatePassword();

private:
    void initUI();
    QWidget* createDisplayArea();
    QWidget* createControlsArea();
    QString generateSecurePassword(int length, bool upper, bool lower, bool digits, bool symbols, bool excludeAmbiguous);

    QLineEdit* m_usageEntry;
    QLineEdit* m_passEntry;
    QProgressBar* m_strengthBar;
    QLabel* m_lengthLabel;
    QSlider* m_lengthSlider;
    QCheckBox* m_checkUpper;
    QCheckBox* m_checkLower;
    QCheckBox* m_checkDigits;
    QCheckBox* m_checkSymbols;
    QCheckBox* m_excludeAmbiguous;
    QLabel* m_statusLabel;
    QPoint m_dragPos;
};

#endif // PASSWORDGENERATORWINDOW_H
```

## 文件: `src/ui/PixelRulerOverlay.cpp`

```cpp
#include "PixelRulerOverlay.h"
#include "ToolTipOverlay.h"
#include "IconHelper.h"
#include "../core/DatabaseManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QScreen>
#include <QGuiApplication>
#include <QMouseEvent>
#include <QKeyEvent>
#include <QPainter>
#include <QFontMetrics>
#include <cmath>

PixelRulerOverlay::PixelRulerOverlay(QWidget* parent) : QWidget(nullptr) {
    // [CRITICAL] 核心架构修复：作为顶级窗口，不使用 grabMouse 以允许与子部件 m_toolbar 交互
    setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool);
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_NoSystemBackground);
    setCursor(Qt::CrossCursor);
    setMouseTracking(true);
    
    QRect totalRect;
    const auto screens = QGuiApplication::screens();
    for (QScreen* screen : screens) {
        QRect geom = screen->geometry();
        totalRect = totalRect.united(geom);
        ScreenCapture cap;
        cap.geometry = geom;
        cap.dpr = screen->devicePixelRatio();
        cap.image = screen->grabWindow(0, 0, 0, geom.width(), geom.height()).toImage();
        m_captures.append(cap);
    }
    setGeometry(totalRect);

    initToolbar();
    setMode(Spacing);
}

PixelRulerOverlay::~PixelRulerOverlay() {
    if (m_toolbar) { m_toolbar->close(); m_toolbar->deleteLater(); }
}

bool PixelRulerOverlay::eventFilter(QObject* watched, QEvent* event) {
    if (event->type() == QEvent::HoverEnter) {
        QString text = watched->property("tooltipText").toString();
        if (!text.isEmpty()) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), text);
            return true;
        }
    } else if (event->type() == QEvent::HoverLeave) {
        ToolTipOverlay::hideTip();
        return true;
    }
    return QWidget::eventFilter(watched, event);
}

void PixelRulerOverlay::initToolbar() {
    // 将工具栏作为本窗体的子部件，确保它在最顶层且可交互
    m_toolbar = new QFrame(this);
    m_toolbar->setObjectName("rulerToolbar");
    m_toolbar->setStyleSheet(
        "QFrame#rulerToolbar { background: #1e1e1e; border-radius: 8px; border: 1px solid #444; }"
        "QPushButton { background: transparent; border: 1px solid transparent; border-radius: 4px; padding: 8px; }"
        "QPushButton:hover { background: #333; border: 1px solid #555; }"
        "QPushButton:checked { background: #007ACC; border: 1px solid #007ACC; }"
    );
    auto* l = new QHBoxLayout(m_toolbar);
    l->setContentsMargins(8, 4, 8, 4);
    l->setSpacing(8);

    auto addBtn = [&](const QString& icon, const QString& tip, Mode m, int key) {
        auto* btn = new QPushButton();
        btn->setAutoDefault(false);
        btn->setIcon(IconHelper::getIcon(icon, "#FFFFFF"));
        btn->setIconSize(QSize(20, 20));
        btn->setCheckable(true);
        btn->setProperty("tooltipText", QString("%1 (数字键 %2)").arg(tip).arg(key));
        btn->installEventFilter(this);
        connect(btn, &QPushButton::clicked, [this, m, btn](){
            for(auto* b : m_toolbar->findChildren<QPushButton*>()) b->setChecked(false);
            btn->setChecked(true);
            setMode(m);
        });
        l->addWidget(btn);
        if (m == Spacing) btn->setChecked(true);
        return btn;
    };

    addBtn("ruler_bounds", "边界测量", Bounds, 1);
    addBtn("ruler_spacing", "十字测量", Spacing, 2);
    addBtn("ruler_hor", "水平测量", Horizontal, 3);
    addBtn("ruler_ver", "垂直测量", Vertical, 4);

    auto* btnClose = new QPushButton();
    btnClose->setAutoDefault(false);
    btnClose->setIcon(IconHelper::getIcon("close", "#E81123"));
    btnClose->setIconSize(QSize(20, 20));
    connect(btnClose, &QPushButton::clicked, this, &QWidget::close);
    l->addWidget(btnClose);

    m_toolbar->adjustSize();
    m_toolbar->move((width() - m_toolbar->width()) / 2, 40);
    m_toolbar->show();
}

void PixelRulerOverlay::setMode(Mode m) {
    m_mode = m;
    m_startPoint = QPoint();
    update();
}

void PixelRulerOverlay::paintEvent(QPaintEvent*) {
    QPainter p(this);
    // 背景填充极低透明度，确保捕获鼠标移动
    p.fillRect(rect(), QColor(0, 0, 0, 1));
    p.setRenderHint(QPainter::Antialiasing);

    QPoint cur = mapFromGlobal(QCursor::pos());
    
    if (m_mode == Spacing) {
        drawCrossSpacing(p, cur);
    } else if (m_mode == Horizontal) {
        drawOneWaySpacing(p, cur, true);
    } else if (m_mode == Vertical) {
        drawOneWaySpacing(p, cur, false);
    } else if (m_mode == Bounds) {
        if (!m_startPoint.isNull()) drawBounds(p, m_startPoint, cur);
    }
}

// 绘制十字探测
void PixelRulerOverlay::drawCrossSpacing(QPainter& p, const QPoint& pos) {
    const ScreenCapture* cap = getCapture(mapToGlobal(pos));
    if (!cap) return;

    QPoint relPos = mapToGlobal(pos) - cap->geometry.topLeft();
    int px = relPos.x() * cap->dpr;
    int py = relPos.y() * cap->dpr;

    int left = findEdge(cap->image, px, py, -1, 0) / cap->dpr;
    int right = findEdge(cap->image, px, py, 1, 0) / cap->dpr;
    int top = findEdge(cap->image, px, py, 0, -1) / cap->dpr;
    int bottom = findEdge(cap->image, px, py, 0, 1) / cap->dpr;

    // 使用橙红色实线 (#ff5722)，对标用户提供的设计图
    p.setPen(QPen(QColor(255, 87, 34), 1, Qt::SolidLine));
    p.drawLine(pos.x() - left, pos.y(), pos.x() + right, pos.y());
    p.drawLine(pos.x(), pos.y() - top, pos.x(), pos.y() + bottom);

    // 绘制两端的小圆点 (对标 PowerToys 细节)
    p.setBrush(QColor(255, 87, 34));
    p.setPen(Qt::NoPen);
    p.drawEllipse(QPoint(pos.x() - left, pos.y()), 2, 2);
    p.drawEllipse(QPoint(pos.x() + right, pos.y()), 2, 2);
    p.drawEllipse(QPoint(pos.x(), pos.y() - top), 2, 2);
    p.drawEllipse(QPoint(pos.x(), pos.y() + bottom), 2, 2);

    // [CRITICAL] 采用单标签汇总模式，显示 W x H，避免四个标签互相遮挡
    // 偏移位置设在交叉点右下方，避免遮挡准星
    QString text = QString("%1 × %2").arg(left + right).arg(top + bottom);
    drawInfoBox(p, pos + QPoint(60, 30), text);
}

// 绘制单向探测 (水平或垂直)
void PixelRulerOverlay::drawOneWaySpacing(QPainter& p, const QPoint& pos, bool hor) {
    const ScreenCapture* cap = getCapture(mapToGlobal(pos));
    if (!cap) return;

    QPoint relPos = mapToGlobal(pos) - cap->geometry.topLeft();
    int px = relPos.x() * cap->dpr;
    int py = relPos.y() * cap->dpr;

    p.setPen(QPen(QColor(255, 87, 34), 1, Qt::SolidLine));
    if (hor) {
        int left = findEdge(cap->image, px, py, -1, 0) / cap->dpr;
        int right = findEdge(cap->image, px, py, 1, 0) / cap->dpr;
        p.drawLine(pos.x() - left, pos.y(), pos.x() + right, pos.y());
        // 绘制两端截止线
        p.drawLine(pos.x() - left, pos.y() - 10, pos.x() - left, pos.y() + 10);
        p.drawLine(pos.x() + right, pos.y() - 10, pos.x() + right, pos.y() + 10);
        drawLabel(p, pos.x() + (right - left)/2, pos.y() - 20, left + right, true, true);
    } else {
        int top = findEdge(cap->image, px, py, 0, -1) / cap->dpr;
        int bottom = findEdge(cap->image, px, py, 0, 1) / cap->dpr;
        p.drawLine(pos.x(), pos.y() - top, pos.x(), pos.y() + bottom);
        p.drawLine(pos.x() - 10, pos.y() - top, pos.x() + 10, pos.y() - top);
        p.drawLine(pos.x() - 10, pos.y() + bottom, pos.x() + 10, pos.y() + bottom);
        drawLabel(p, pos.x() + 20, pos.y() + (bottom - top)/2, top + bottom, false, true);
    }
}

void PixelRulerOverlay::drawLabel(QPainter& p, int x, int y, int val, bool isHor, bool isFixed) {
    if (val <= 1) return;
    QString text = QString::number(val);
    drawInfoBox(p, QPoint(x, y), text);
}

void PixelRulerOverlay::drawBounds(QPainter& p, const QPoint& s, const QPoint& e) {
    QRect r = QRect(s, e).normalized();
    p.setPen(QPen(Qt::cyan, 2));
    p.setBrush(QColor(0, 255, 255, 30));
    p.drawRect(r);

    QString text = QString("%1 × %2").arg(r.width()).arg(r.height());
    // [CRITICAL] 优化 Tip 位置：不再显示在选取中心，而是显示在选取下方且位于鼠标光标左下角
    QFontMetrics fm(p.font());
    int w = fm.horizontalAdvance(text) + 20;
    int h = 26;

    // 计算位置：右边缘靠近鼠标，且整体在选取区域下方
    int tipX = e.x() - 5 - w / 2;
    int tipY = std::max(r.bottom(), e.y()) + 10 + h / 2;
    
    drawInfoBox(p, QPoint(tipX, tipY), text);
}

void PixelRulerOverlay::drawInfoBox(QPainter& p, const QPoint& pos, const QString& text) {
    QFontMetrics fm(p.font());
    int w = fm.horizontalAdvance(text) + 20;
    int h = 26;
    // 以 pos 为中心绘制
    QRect r(pos.x() - w/2, pos.y() - h/2, w, h);
    
    // 自动边界调整，确保标签不超出屏幕
    if (r.right() > width()) r.moveRight(width() - 10);
    if (r.left() < 0) r.moveLeft(10);
    if (r.bottom() > height()) r.moveBottom(height() - 10);
    if (r.top() < 0) r.moveTop(10);

    // 添加 1 像素深灰色边框
    p.setPen(QPen(QColor(176, 176, 176), 1));
    p.setBrush(QColor(43, 43, 43)); // 移除透明度，改为完全不透明
    p.drawRoundedRect(r, 4, 4);
    p.setPen(Qt::white);
    p.drawText(r, Qt::AlignCenter, text);
}

int PixelRulerOverlay::findEdge(const QImage& img, int x, int y, int dx, int dy) {
    if (!img.rect().contains(x, y)) return 0;
    QColor startColor = img.pixelColor(x, y);
    int dist = 0;
    int curX = x + dx, curY = y + dy;
    while (img.rect().contains(curX, curY)) {
        QColor c = img.pixelColor(curX, curY);
        // 比较颜色差异,大于阈值则认为遇到了边界
        // 阈值 10: RGB 总差异 < 10 视为同色,提高边界检测精度
        if (colorDiff(startColor, c) > 10) break;
        dist++;
        curX += dx;
        curY += dy;
    }
    return dist;
}

int PixelRulerOverlay::colorDiff(const QColor& c1, const QColor& c2) {
    return std::abs(c1.red() - c2.red()) + std::abs(c1.green() - c2.green()) + std::abs(c1.blue() - c2.blue());
}

const PixelRulerOverlay::ScreenCapture* PixelRulerOverlay::getCapture(const QPoint& globalPos) {
    for (const auto& cap : m_captures) if (cap.geometry.contains(globalPos)) return &cap;
    return m_captures.isEmpty() ? nullptr : &m_captures[0];
}

void PixelRulerOverlay::mousePressEvent(QMouseEvent* event) {
    // [CRITICAL] 修正：如果点击在工具栏上，不触发测量逻辑
    if (m_toolbar->geometry().contains(event->pos())) {
        QWidget::mousePressEvent(event);
        return;
    }
    if (event->button() == Qt::LeftButton) {
        m_startPoint = event->pos();
        
        // 瞬间测量模式，点击即保存
        if (m_mode == Spacing || m_mode == Horizontal || m_mode == Vertical) {
            saveMeasurement(getMeasurementText(event->pos()));
        }
        
        update();
    } else if (event->button() == Qt::RightButton) {
        close();
    }
}

void PixelRulerOverlay::mouseMoveEvent(QMouseEvent* event) {
    update();
}

void PixelRulerOverlay::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton && !m_startPoint.isNull()) {
        // 边界测量模式，松开即保存
        if (m_mode == Bounds) {
            QRect r = QRect(m_startPoint, event->pos()).normalized();
            if (r.width() > 1 && r.height() > 1) {
                QString val = QString("%1 × %2").arg(r.width()).arg(r.height());
                saveMeasurement(val);
            }
        }
        m_startPoint = QPoint();
        update();
    }
}

QString PixelRulerOverlay::getMeasurementText(const QPoint& pos) {
    const ScreenCapture* cap = getCapture(mapToGlobal(pos));
    if (!cap) return "";

    QPoint relPos = mapToGlobal(pos) - cap->geometry.topLeft();
    int px = relPos.x() * cap->dpr;
    int py = relPos.y() * cap->dpr;

    if (m_mode == Spacing) {
        int left = findEdge(cap->image, px, py, -1, 0) / cap->dpr;
        int right = findEdge(cap->image, px, py, 1, 0) / cap->dpr;
        int top = findEdge(cap->image, px, py, 0, -1) / cap->dpr;
        int bottom = findEdge(cap->image, px, py, 0, 1) / cap->dpr;
        return QString("%1 × %2").arg(left + right).arg(top + bottom);
    } else if (m_mode == Horizontal) {
        int left = findEdge(cap->image, px, py, -1, 0) / cap->dpr;
        int right = findEdge(cap->image, px, py, 1, 0) / cap->dpr;
        return QString::number(left + right);
    } else if (m_mode == Vertical) {
        int top = findEdge(cap->image, px, py, 0, -1) / cap->dpr;
        int bottom = findEdge(cap->image, px, py, 0, 1) / cap->dpr;
        return QString::number(top + bottom);
    }
    return "";
}

void PixelRulerOverlay::saveMeasurement(const QString& val) {
    if (val.isEmpty()) return;
    
    DatabaseManager::instance().addNoteAsync(
        val,              // 标题改为像素值本身
        val,              // 内容改为像素值本身
        {"标尺", "测量", "像素"},
        "#ff5722", // 使用测量线的橙红色作为笔记卡片主色
        -1,
        "pixel_ruler"
    );
    
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 测量值已存入数据库: %1").arg(val));
}

void PixelRulerOverlay::keyPressEvent(QKeyEvent* event) {
    int key = event->key();
    if (key == Qt::Key_Escape) close();
    else if (key == Qt::Key_1) setMode(Bounds);
    else if (key == Qt::Key_2) setMode(Spacing);
    else if (key == Qt::Key_3) setMode(Horizontal);
    else if (key == Qt::Key_4) setMode(Vertical);
    
    // 同步工具栏按钮状态
    if (key >= Qt::Key_1 && key <= Qt::Key_4) {
        auto btns = m_toolbar->findChildren<QPushButton*>();
        int idx = key - Qt::Key_1;
        if (idx >= 0 && idx < btns.size()) {
            for(auto* b : btns) b->setChecked(false);
            btns[idx]->setChecked(true);
        }
    }
}
```

## 文件: `src/ui/PixelRulerOverlay.h`

```cpp
#ifndef PIXELRULEROVERLAY_H
#define PIXELRULEROVERLAY_H

#include <QWidget>
#include <QFrame>
#include <QImage>
#include <QRect>
#include <QList>

class PixelRulerOverlay : public QWidget {
    Q_OBJECT
    
    enum Mode { Bounds, Spacing, Horizontal, Vertical };
    
    struct ScreenCapture {
        QImage image;
        QRect geometry;
        qreal dpr;
    };

public:
    explicit PixelRulerOverlay(QWidget* parent = nullptr);
    ~PixelRulerOverlay();

    bool eventFilter(QObject* watched, QEvent* event) override;

protected:
    void initToolbar();
    void setMode(Mode m);
    void paintEvent(QPaintEvent*) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

private:
    // 绘制函数
    void drawCrossSpacing(QPainter& p, const QPoint& pos);
    void drawOneWaySpacing(QPainter& p, const QPoint& pos, bool hor);
    void drawLabel(QPainter& p, int x, int y, int val, bool isHor, bool isFixed = false);
    void drawBounds(QPainter& p, const QPoint& s, const QPoint& e);
    void drawInfoBox(QPainter& p, const QPoint& pos, const QString& text);
    
    // 工具函数
    int findEdge(const QImage& img, int x, int y, int dx, int dy);
    int colorDiff(const QColor& c1, const QColor& c2);
    const ScreenCapture* getCapture(const QPoint& globalPos);
    
    // 测量与保存
    QString getMeasurementText(const QPoint& pos);
    void saveMeasurement(const QString& val);

    Mode m_mode = Spacing;
    QPoint m_startPoint;
    QFrame* m_toolbar = nullptr;
    QList<ScreenCapture> m_captures;
};

#endif // PIXELRULEROVERLAY_H
```

## 文件: `src/ui/QuickNoteDelegate.h`

```cpp
#ifndef QUICKNOTEDELEGATE_H
#define QUICKNOTEDELEGATE_H

#include <QStyledItemDelegate>
#include <QPainter>
#include <QDateTime>
#include "../models/NoteModel.h"
#include "IconHelper.h"
#include "QuickWindow.h"

class QuickNoteDelegate : public QStyledItemDelegate {
    Q_OBJECT
public:
    explicit QuickNoteDelegate(QObject* parent = nullptr) : QStyledItemDelegate(parent) {}

    QSize sizeHint(const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        return QSize(option.rect.width(), 45); // 紧凑型高度
    }

    void paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const override {
        if (!index.isValid()) return;

        painter->save();
        painter->setRenderHint(QPainter::Antialiasing);

        QRect rect = option.rect;
        bool isSelected = (option.state & QStyle::State_Selected);
        bool isHovered = (option.state & QStyle::State_MouseOver);

        // 1. 绘制基础背景 (斑马纹对比度微调)
        QColor bgColor = (index.row() % 2 == 0) ? QColor("#1E1E1E") : QColor("#181818");
        if (isHovered && !isSelected) {
            bgColor = QColor(255, 255, 255, 20);
        }
        painter->fillRect(rect, bgColor);

        // 2. 绘制指示条 (根据置顶状态与选中状态动态调整)
        bool isPinned = index.data(NoteModel::PinnedRole).toBool();
        if (isPinned) {
            // 置顶项：在最左侧固定绘制 1px 红色条
            painter->fillRect(QRect(rect.left(), rect.top(), 1, rect.height()), QColor("#FF0000"));
        }

        if (isSelected) {
            // 只有在选中状态下才计算分类颜色
            QColor highlightColor("#4a90e2"); // 默认蓝
            QuickWindow* win = qobject_cast<QuickWindow*>(parent());
            if (win) {
                QString c = win->currentCategoryColor();
                if (!c.isEmpty() && QColor::isValidColorName(c)) {
                    highlightColor = QColor(c);
                }
            }

            if (isPinned) {
                // 置顶项被选中：在红条右侧绘制 4px 分类指示色
                painter->fillRect(QRect(rect.left() + 1, rect.top(), 4, rect.height()), highlightColor);
            } else {
                // 未置顶但已选中：绘制完整的 5px 分类指示色
                painter->fillRect(QRect(rect.left(), rect.top(), 5, rect.height()), highlightColor);
            }

            // 3. 选中项背景叠加层 (约 6% 不透明度)
            QColor overlay = highlightColor;
            overlay.setAlpha(15); 
            painter->fillRect(rect, overlay);
        }

        // 2. 分隔线 (对齐 Python 版，使用极浅的黑色半透明)
        painter->setPen(QColor(0, 0, 0, 25));
        painter->drawLine(rect.bottomLeft(), rect.bottomRight());

        // 图标 (DecorationRole)
        QIcon icon = index.data(Qt::DecorationRole).value<QIcon>();
        if (!icon.isNull()) {
            QString type = index.data(NoteModel::TypeRole).toString();
            if (type == "image") {
                // 如果是图片，绘制更大的缩略图 (32x32)
                int size = 32;
                icon.paint(painter, rect.left() + 10, rect.top() + (rect.height() - size) / 2, size, size);
            } else {
                icon.paint(painter, rect.left() + 10, rect.top() + (rect.height() - 20) / 2, 20, 20);
            }
        }

        // 标题文本 (根据用户要求，QuickWindow 仅显示笔记标题)
        QString text = index.data(NoteModel::TitleRole).toString();
        painter->setPen(isSelected ? Qt::white : QColor("#CCCCCC"));
        painter->setFont(QFont("Microsoft YaHei", 9));
        
        // 调整右侧边距 (-70) 以避开右侧的时间戳和星级
        QRect textRect = rect.adjusted(40, 0, -70, 0);
        painter->drawText(textRect, Qt::AlignLeft | Qt::AlignVCenter, 
                         painter->fontMetrics().elidedText(text, Qt::ElideRight, textRect.width()));

        // 时间 (极简展示) - 显示在右上方
        QString timeStr = index.data(NoteModel::TimeRole).toDateTime().toString("MM-dd HH:mm");
        painter->setPen(QColor("#666666"));
        painter->setFont(QFont("Segoe UI", 7));
        painter->drawText(rect.adjusted(0, 3, -10, 0), Qt::AlignRight | Qt::AlignTop, timeStr);

        // 星级 (Rating) - 显示在右下方 (仅显示实心星)
        int rating = index.data(NoteModel::RatingRole).toInt();
        if (rating > 0) {
            int starSize = 9;
            int spacing = 1;
            // 限制最大星级为 5
            int displayRating = qMin(rating, 5);
            int totalWidth = displayRating * starSize + (displayRating - 1) * spacing;
            int startX = rect.right() - 9 - totalWidth;
            int startY = rect.bottom() - starSize - 5;

            QIcon starFilled = IconHelper::getIcon("star_filled", "#F1C40F", starSize);

            for (int i = 0; i < displayRating; ++i) {
                QRect starRect(startX + i * (starSize + spacing), startY, starSize, starSize);
                starFilled.paint(painter, starRect);
            }
        }

        painter->restore();
    }
};

#endif // QUICKNOTEDELEGATE_H
```

## 文件: `src/viewmodels/QuickNoteViewModel.cpp`

```cpp
#include "QuickNoteViewModel.h"
#include "../core/ServiceLocator.h"

#include "../core/DatabaseManager.h"
#include <algorithm>

QuickNoteViewModel::QuickNoteViewModel(QObject* parent) : QObject(parent) {}

void QuickNoteViewModel::refreshData(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page) {
    m_currentFilterType = filterType;
    m_currentFilterValue = filterValue;
    m_currentPage = page;

    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;

    int totalCount = db->getNotesCount(keyword, filterType, filterValue);
    const int pageSize = 100;
    m_totalPages = std::max(1, (totalCount + pageSize - 1) / pageSize);
    
    if (m_currentPage > m_totalPages) m_currentPage = m_totalPages;
    if (m_currentPage < 1) m_currentPage = 1;

    auto notes = db->searchNotes(keyword, filterType, filterValue, m_currentPage, pageSize);
    emit dataRefreshed(notes, totalCount, m_totalPages);
}

void QuickNoteViewModel::deleteNotes(const QList<int>& ids, bool physical) {
    if (ids.isEmpty()) return;
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;

    if (physical || m_currentFilterType == "trash") {
        db->deleteNotesBatch(ids);
        emit statusMessageRequested(QString("✔ 已永久删除 %1 条数据").arg(ids.count()));
    } else {
        db->softDeleteNotes(ids);
        emit statusMessageRequested(QString("✔ 已移至回收站 %1 条数据").arg(ids.count()));
    }
    emit sidebarRefreshRequested();
}

void QuickNoteViewModel::toggleFavorite(const QList<int>& ids) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->toggleNoteState(id, "is_favorite");
    }
}

void QuickNoteViewModel::togglePin(const QList<int>& ids) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->toggleNoteState(id, "is_pinned");
    }
}

void QuickNoteViewModel::setRating(const QList<int>& ids, int rating) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->updateNoteState(id, "rating", rating);
    }
}

void QuickNoteViewModel::moveToCategory(const QList<int>& ids, int catId) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    db->moveNotesToCategory(ids, catId);
}

void QuickNoteViewModel::addTags(const QList<int>& ids, const QStringList& tags) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    for (int id : ids) {
        db->addTagsToNote(id, tags);
    }
}

void QuickNoteViewModel::updateTags(const QList<int>& ids, const QStringList& tags) {
    auto db = ServiceLocator::get<DatabaseManager>();
    if (!db) return;
    QString tagsStr = tags.join(", ");
    for (int id : ids) {
        db->updateNoteState(id, "tags", tagsStr);
    }
}
```

## 文件: `src/viewmodels/QuickNoteViewModel.h`

```cpp
#ifndef QUICKNOTEVIEWMODEL_H
#define QUICKNOTEVIEWMODEL_H

#include <QObject>
#include <QVariantMap>
#include <QList>
#include <QString>
#include <QVariant>

class QuickNoteViewModel : public QObject {
    Q_OBJECT
public:
    explicit QuickNoteViewModel(QObject* parent = nullptr);

    // 状态属性
    int currentPage() const { return m_currentPage; }
    int totalPages() const { return m_totalPages; }
    QString currentFilterType() const { return m_currentFilterType; }
    QVariant currentFilterValue() const { return m_currentFilterValue; }

    // 数据操作
    void refreshData(const QString& keyword, const QString& filterType, const QVariant& filterValue, int page);
    void deleteNotes(const QList<int>& ids, bool physical);
    void toggleFavorite(const QList<int>& ids);
    void togglePin(const QList<int>& ids);
    void setRating(const QList<int>& ids, int rating);
    void moveToCategory(const QList<int>& ids, int catId);
    void addTags(const QList<int>& ids, const QStringList& tags);
    void updateTags(const QList<int>& ids, const QStringList& tags);

signals:
    void dataRefreshed(const QList<QVariantMap>& notes, int totalCount, int totalPages);
    void statusMessageRequested(const QString& message, bool isError = false);
    void sidebarRefreshRequested();

private:
    int m_currentPage = 1;
    int m_totalPages = 1;
    QString m_currentFilterType = "all";
    QVariant m_currentFilterValue = -1;
};

#endif // QUICKNOTEVIEWMODEL_H
```

## 文件: `src/ui/QuickPreview.h`

```cpp
#include "ToolTipOverlay.h"
#ifndef QUICKPREVIEW_H
#define QUICKPREVIEW_H

#include <QWidget>
#include "StringUtils.h"

#include <QTextEdit>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QLabel>
#include <QKeyEvent>
#include <QGraphicsDropShadowEffect>
#include <QMouseEvent>
#include <QApplication>
#include <QClipboard>
#include <QKeyEvent>
#include "ToolTipOverlay.h"
#include <QCursor>
#include <QFrame>
#include <QShortcut>
#include <QAction>
#include <QScreen>
#include <QGuiApplication>
#include "IconHelper.h"
#include "../core/ShortcutManager.h"

class QuickPreview : public QWidget {
    Q_OBJECT
signals:
    void editRequested(int noteId);
    void prevRequested();
    void nextRequested();
    void historyNavigationRequested(int noteId);

public:
    explicit QuickPreview(QWidget* parent = nullptr) : QWidget(parent, Qt::Tool | Qt::FramelessWindowHint) {
        setObjectName("QuickPreview");
        setAttribute(Qt::WA_TranslucentBackground);
        setFocusPolicy(Qt::StrongFocus);
        
        auto* mainLayout = new QVBoxLayout(this);
        // [CRITICAL] 边距调整为 20px 以容纳阴影，防止出现“断崖式”阴影截止
        mainLayout->setContentsMargins(20, 20, 20, 20);

        m_container = new QFrame();
        m_container->setObjectName("previewContainer");
        m_container->setStyleSheet(
            "QFrame#previewContainer { background-color: #1e1e1e; border: 1px solid #444; border-radius: 8px; }"
            "QFrame#previewTitleBar { background-color: #1e1e1e; border-top-left-radius: 7px; border-top-right-radius: 7px; border-bottom: 1px solid #333; }"
            "QTextEdit { border-bottom-left-radius: 7px; border-bottom-right-radius: 7px; background: transparent; border: none; color: #ddd; font-size: 14px; padding: 10px; }"
            "QPushButton { border: none; border-radius: 4px; background: transparent; padding: 4px; }"
            "QPushButton:hover { background-color: #3e3e42; }"
            "QPushButton#btnClose:hover { background-color: #E81123; }"
        );
        
        auto* containerLayout = new QVBoxLayout(m_container);
        containerLayout->setContentsMargins(0, 0, 0, 0);
        containerLayout->setSpacing(0);

        // --- 标题栏 ---
        m_titleBar = new QFrame();
        m_titleBar->setObjectName("previewTitleBar");
        m_titleBar->setFixedHeight(36);
        m_titleBar->setAttribute(Qt::WA_StyledBackground);
        auto* titleLayout = new QHBoxLayout(m_titleBar);
        titleLayout->setContentsMargins(10, 0, 5, 0);
        titleLayout->setSpacing(5);

        m_titleLabel = new QLabel("预览");
        m_titleLabel->setStyleSheet("color: #888; font-size: 12px; font-weight: bold;");
        titleLayout->addWidget(m_titleLabel);
        titleLayout->addStretch();

        auto createBtn = [this](const QString& icon, const QString& tooltip, const QString& objName = "") {
            QPushButton* btn = new QPushButton();
            btn->setIcon(IconHelper::getIcon(icon, "#aaaaaa"));
            btn->setIconSize(QSize(16, 16));
            btn->setFixedSize(32, 32);
            btn->setToolTip(tooltip);
            if (!objName.isEmpty()) btn->setObjectName(objName);
            return btn;
        };

        m_btnBack = createBtn("nav_first", "后退 (Alt+Left)");
        m_btnBack->setFocusPolicy(Qt::NoFocus);
        m_btnForward = createBtn("nav_last", "前进 (Alt+Right)");
        m_btnForward->setFocusPolicy(Qt::NoFocus);

        QPushButton* btnPrev = createBtn("nav_prev", "上一个 (Alt+Up)");
        btnPrev->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnNext = createBtn("nav_next", "下一个 (Alt+Down)");
        btnNext->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnCopy = createBtn("copy", "复制内容 (Ctrl+C)");
        btnCopy->setFocusPolicy(Qt::NoFocus);
        m_btnPin = createBtn("pin_tilted", "置顶显示");
        m_btnPin->setCheckable(true);
        m_btnPin->setFocusPolicy(Qt::NoFocus);
        
        // 加载记忆状态
        QSettings settings("RapidNotes", "WindowStates");
        m_isPinned = settings.value("QuickPreview/StayOnTop", false).toBool();
        if (m_isPinned) {
            m_btnPin->setChecked(true);
            m_btnPin->setIcon(IconHelper::getIcon("pin_vertical", "#ffffff"));
            setWindowFlag(Qt::WindowStaysOnTopHint, true);
        }

        QPushButton* btnEdit = createBtn("edit", "编辑 (Ctrl+B)");
        btnEdit->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnMin = createBtn("minimize", "最小化");
        btnMin->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnMax = createBtn("maximize", "最大化");
        btnMax->setFocusPolicy(Qt::NoFocus);
        QPushButton* btnClose = createBtn("close", "关闭", "btnClose");
        btnClose->setFocusPolicy(Qt::NoFocus);

        connect(m_btnBack, &QPushButton::clicked, this, &QuickPreview::navigateBack);
        connect(m_btnForward, &QPushButton::clicked, this, &QuickPreview::navigateForward);

        connect(btnPrev, &QPushButton::clicked, this, &QuickPreview::prevRequested);
        connect(btnNext, &QPushButton::clicked, this, &QuickPreview::nextRequested);
        connect(btnCopy, &QPushButton::clicked, [this]() {
            // 仅复制正文内容，不包含预览窗口添加的标题和分割线
            if (m_pureContent.isEmpty()) {
                QApplication::clipboard()->setText(m_textEdit->toPlainText());
            } else {
                // 如果是 HTML 且包含 <html> 标签，复制为富文本
                if (m_pureContent.contains("<html", Qt::CaseInsensitive)) {
                    QMimeData* mime = new QMimeData();
                    mime->setHtml(m_pureContent);
                    mime->setText(StringUtils::htmlToPlainText(m_pureContent));
                    QApplication::clipboard()->setMimeData(mime);
                } else {
                    QApplication::clipboard()->setText(m_pureContent);
                }
            }
            ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #2ecc71;'>✔ 内容已复制到剪贴板</b>");
        });
        connect(m_btnPin, &QPushButton::toggled, [this](bool checked) {
            m_isPinned = checked;
            setWindowFlag(Qt::WindowStaysOnTopHint, m_isPinned);
            m_btnPin->setIcon(IconHelper::getIcon(m_isPinned ? "pin_vertical" : "pin_tilted", m_isPinned ? "#ffffff" : "#aaaaaa"));
            
            // 持久化记忆
            QSettings settings("RapidNotes", "WindowStates");
            settings.setValue("QuickPreview/StayOnTop", m_isPinned);
            
            show(); // 改变 flag 后需要 show 出来
        });

        connect(btnEdit, &QPushButton::clicked, [this]() {
            emit editRequested(m_currentNoteId);
        });
        connect(btnMin, &QPushButton::clicked, this, &QuickPreview::showMinimized);
        connect(btnMax, &QPushButton::clicked, [this]() {
            if (isMaximized()) showNormal();
            else showMaximized();
        });
        connect(btnClose, &QPushButton::clicked, this, &QuickPreview::hide);

        titleLayout->addWidget(m_btnBack);
        titleLayout->addWidget(m_btnForward);
        titleLayout->addSpacing(5);
        titleLayout->addWidget(btnPrev);
        titleLayout->addWidget(btnNext);
        titleLayout->addSpacing(5);
        titleLayout->addWidget(btnCopy);
        titleLayout->addWidget(m_btnPin);
        titleLayout->addSpacing(5);
        titleLayout->addWidget(btnEdit);
        titleLayout->addWidget(btnMin);
        titleLayout->addWidget(btnMax);
        titleLayout->addWidget(btnClose);

        containerLayout->addWidget(m_titleBar);

        m_textEdit = new QTextEdit();
        m_textEdit->setReadOnly(true);
        m_textEdit->setFocusPolicy(Qt::NoFocus); // 防止拦截空格键
        containerLayout->addWidget(m_textEdit);
        
        mainLayout->addWidget(m_container);
        
        auto* shadow = new QGraphicsDropShadowEffect(this);
        // [CRITICAL] 阴影模糊半径设为 20，配合 20px 的边距可确保阴影平滑过渡不被裁剪
        shadow->setBlurRadius(20);
        shadow->setColor(QColor(0, 0, 0, 120));
        shadow->setOffset(0, 4);
        m_container->setGraphicsEffect(shadow);
        
        resize(920, 720);

        setupShortcuts();
        connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &QuickPreview::updateShortcuts);
    }

    void showPreview(int noteId, const QString& title, const QString& content, const QPoint& pos, const QString& catName = "") {
        showPreview(noteId, title, content, "text", QByteArray(), pos, catName);
    }

    bool isPinned() const { return m_isPinned; }

    void showPreview(int noteId, const QString& title, const QString& content, const QString& type, const QByteArray& data, const QPoint& pos, const QString& catName = "") {
        m_currentNoteId = noteId;
        addToHistory(noteId);
        if (!catName.isEmpty()) {
            m_titleLabel->setText(QString("预览 - %1").arg(catName));
        } else {
            m_titleLabel->setText("预览");
        }
        m_pureContent = content; // 记忆原始纯净内容
        QString html;
        QString titleHtml = QString("<h3 style='color: #eee; margin-bottom: 5px;'>%1</h3>").arg(title.toHtmlEscaped());
        QString hrHtml = "<hr style='border: 0; border-top: 1px solid #444; margin: 10px 0;'>";

        if (type == "color") {
            html = QString("%1%2"
                           "<div style='margin: 20px; text-align: center;'>"
                           "  <div style='background-color: %3; width: 100%; height: 200px; border-radius: 12px; border: 1px solid #555;'></div>"
                           "  <h1 style='color: white; margin-top: 20px; font-family: Consolas; font-size: 32px;'>%3</h1>"
                           "</div>")
                   .arg(titleHtml, hrHtml, content);
        } else if (type == "image" && !data.isEmpty()) {
            html = QString("%1%2<div style='text-align: center;'><img src='data:image/png;base64,%3' width='450'></div>")
                   .arg(titleHtml, hrHtml, QString(data.toBase64()));
        } else {
            // 判定是否已经是 HTML
            QString trimmed = content.trimmed();
            bool isHtml = trimmed.startsWith("<!DOCTYPE", Qt::CaseInsensitive) || 
                          trimmed.startsWith("<html", Qt::CaseInsensitive) || 
                          trimmed.contains("<style", Qt::CaseInsensitive) ||
                          Qt::mightBeRichText(content);
            
            QString body;
            if (isHtml) {
                body = content; // 直接使用 HTML
            } else {
                body = content.toHtmlEscaped();
                body.replace("\n", "<br>");
                body = QString("<div style='line-height: 1.6; color: #ccc; font-size: 13px;'>%1</div>").arg(body);
            }
            html = QString("%1%2%3").arg(titleHtml, hrHtml, body);
        }
        m_textEdit->setHtml(html);
        
        // 边缘检测：确保预览窗口不超出当前屏幕
        QPoint adjustedPos = pos;
        QScreen *screen = QGuiApplication::screenAt(QCursor::pos());
        if (!screen) screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect screenGeom = screen->availableGeometry();
            if (adjustedPos.x() + width() > screenGeom.right()) adjustedPos.setX(screenGeom.right() - width());
            if (adjustedPos.x() < screenGeom.left()) adjustedPos.setX(screenGeom.left());
            if (adjustedPos.y() + height() > screenGeom.bottom()) adjustedPos.setY(screenGeom.bottom() - height());
            if (adjustedPos.y() < screenGeom.top()) adjustedPos.setY(screenGeom.top());
        }

        move(adjustedPos);
        show();
    }

protected:
    void mousePressEvent(QMouseEvent* event) override {
        if (event->button() == Qt::LeftButton && m_titleBar->rect().contains(m_titleBar->mapFrom(this, event->pos()))) {
            m_dragging = true;
            m_dragPos = event->globalPosition().toPoint() - frameGeometry().topLeft();
            event->accept();
        }
    }

    void mouseMoveEvent(QMouseEvent* event) override {
        if (m_dragging && event->buttons() & Qt::LeftButton) {
            move(event->globalPosition().toPoint() - m_dragPos);
            event->accept();
        }
    }

    void mouseReleaseEvent(QMouseEvent* event) override {
        m_dragging = false;
        QWidget::mouseReleaseEvent(event);
    }

    void mouseDoubleClickEvent(QMouseEvent* event) override {
        if (m_titleBar->rect().contains(m_titleBar->mapFrom(this, event->pos()))) {
            if (isMaximized()) showNormal();
            else showMaximized();
            event->accept();
        }
    }

    void setupShortcuts() {
        auto add = [&](const QString& id, std::function<void()> func) {
            auto* sc = new QShortcut(ShortcutManager::instance().getShortcut(id), this, func);
            sc->setProperty("id", id);
            m_shortcuts.append(sc);
        };

        add("pv_prev", [this](){ emit prevRequested(); });
        add("pv_next", [this](){ emit nextRequested(); });
        add("pv_back", [this](){ navigateBack(); });
        add("pv_forward", [this](){ navigateForward(); });
        add("pv_edit", [this](){ emit editRequested(m_currentNoteId); });
        add("pv_copy", [this](){
            if (!m_pureContent.isEmpty()) {
                if (m_pureContent.contains("<html", Qt::CaseInsensitive)) {
                    QMimeData* mime = new QMimeData();
                    mime->setHtml(m_pureContent);
                    mime->setText(StringUtils::htmlToPlainText(m_pureContent));
                    QApplication::clipboard()->setMimeData(mime);
                } else {
                    QApplication::clipboard()->setText(m_pureContent);
                }
            } else {
                QApplication::clipboard()->setText(m_textEdit->toPlainText());
            }
            ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #2ecc71;'>✔ 内容已复制到剪贴板</b>");
        });
        add("pv_close", [this](){ hide(); });

        // 移除 Space 快捷键，避免与 MainWindow 的全局预览快捷键冲突导致“关闭后立即重开”
        // auto* spaceSc = new QShortcut(QKeySequence("Space"), this, [this](){ hide(); }, Qt::WidgetWithChildrenShortcut);
        new QShortcut(QKeySequence("Escape"), this, [this](){ hide(); });
    }

    void updateShortcuts() {
        for (auto* sc : m_shortcuts) {
            QString id = sc->property("id").toString();
            sc->setKey(ShortcutManager::instance().getShortcut(id));
        }
    }

    void addToHistory(int noteId) {
        if (m_isNavigatingHistory) return;
        
        // 只有当新 ID 与当前历史位置 ID 不同时才记录
        if (!m_history.isEmpty() && m_historyIndex >= 0 && m_historyIndex < m_history.size()) {
            if (m_history.at(m_historyIndex) == noteId) return;
        }

        // 如果我们在历史中间进行了新操作，截断之后的前进记录
        while (m_historyIndex < m_history.size() - 1) {
            m_history.removeLast();
        }

        m_history.append(noteId);
        m_historyIndex = m_history.size() - 1;
        updateHistoryButtons();
    }

    void navigateBack() {
        if (m_historyIndex > 0) {
            m_historyIndex--;
            m_isNavigatingHistory = true;
            emit historyNavigationRequested(m_history.at(m_historyIndex));
            m_isNavigatingHistory = false;
            updateHistoryButtons();
        }
    }

    void navigateForward() {
        if (m_historyIndex < m_history.size() - 1) {
            m_historyIndex++;
            m_isNavigatingHistory = true;
            emit historyNavigationRequested(m_history.at(m_historyIndex));
            m_isNavigatingHistory = false;
            updateHistoryButtons();
        }
    }

    void updateHistoryButtons() {
        if (m_btnBack) m_btnBack->setEnabled(m_historyIndex > 0);
        if (m_btnForward) m_btnForward->setEnabled(m_historyIndex < m_history.size() - 1);
        
        if (m_btnBack) m_btnBack->setIcon(IconHelper::getIcon("nav_first", m_historyIndex > 0 ? "#aaaaaa" : "#444444"));
        if (m_btnForward) m_btnForward->setIcon(IconHelper::getIcon("nav_last", m_historyIndex < m_history.size() - 1 ? "#aaaaaa" : "#444444"));
    }

protected:
    void keyPressEvent(QKeyEvent* event) override {
        // [CRITICAL] 显式处理空格键关闭逻辑，确保在获得焦点时能可靠响应
        if (event->key() == Qt::Key_Escape) {
            hide();
            event->accept();
            return;
        }
        QWidget::keyPressEvent(event);
    }

    void hideEvent(QHideEvent* event) override {
        // 窗口关闭时，将焦点还给父窗口（列表），方便用户继续使用键盘导航
        if (parentWidget()) {
            parentWidget()->activateWindow();
            parentWidget()->setFocus();
        }
        QWidget::hideEvent(event);
    }

private:
    QFrame* m_container;
    QList<QShortcut*> m_shortcuts;
    QWidget* m_titleBar;
    QLabel* m_titleLabel;
    QTextEdit* m_textEdit;
    QString m_pureContent; // 纯净内容暂存
    int m_currentNoteId = -1;
    bool m_dragging = false;
    bool m_isPinned = false;
    QPushButton* m_btnPin = nullptr;
    QPushButton* m_btnBack = nullptr;
    QPushButton* m_btnForward = nullptr;
    QPoint m_dragPos;

    QList<int> m_history;
    int m_historyIndex = -1;
    bool m_isNavigatingHistory = false;
};

#endif // QUICKPREVIEW_H
```

## 文件: `src/ui/QuickWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "QuickWindow.h"
#include "NoteEditWindow.h"
#include "StringUtils.h"
#include "AdvancedTagSelector.h"
#include "IconHelper.h"
#include "QuickNoteDelegate.h"
#include "CategoryDelegate.h"
#include "../core/DatabaseManager.h"
#include "../core/ClipboardMonitor.h"
#include <QGuiApplication>
#include <utility>
#include <QScreen>
#include <QKeyEvent>
#include <QGraphicsDropShadowEffect>
#include <QSettings>
#include <QMenu>
#include <QWindow>
#include <QShortcut>
#include <QKeySequence>
#include <QClipboard>
#include <QMimeData>
#include <QDrag>
#include <QTimer>
#include <QApplication>
#include <QElapsedTimer>
#include <QActionGroup>
#include <QAction>
#include <QUrl>
#include <QBuffer>
#include <QToolTip>
#include <QRegularExpression>
#include <QImage>
#include <QMap>
#include <QFileInfo>
#include <QDir>
#include <QFile>
#include <QDesktopServices>
#include <QCoreApplication>
#include <QLineEdit>
#include <QTextEdit>
#include <QPlainTextEdit>
#include <QInputDialog>
#include <QColorDialog>
#include <QToolTip>
#include "FramelessDialog.h"
#include "CategoryPasswordDialog.h"
#include "SettingsWindow.h"
#include "OCRResultWindow.h"
#include "../core/ShortcutManager.h"
#include "../core/OCRManager.h"
#include <QRandomGenerator>
#include <QStyledItemDelegate>
#include <QPainter>
#include <QPropertyAnimation>
#include <QGraphicsOpacityEffect>

#ifdef Q_OS_WIN
#include <windows.h>
#include <windowsx.h>
#endif

// --- AppLockWidget 实现 (Eagle 风格启动锁) ---
class AppLockWidget : public QWidget {
    Q_OBJECT
public:
    AppLockWidget(const QString& correctPassword, QWidget* parent = nullptr)
        : QWidget(parent), m_correctPassword(correctPassword) {
        setObjectName("AppLockWidget");
        setFocusPolicy(Qt::StrongFocus);
        setAttribute(Qt::WA_StyledBackground);
        
        auto* layout = new QVBoxLayout(this);
        layout->setAlignment(Qt::AlignCenter);
        layout->setSpacing(20);

        // 背景色
        setStyleSheet("QWidget#AppLockWidget { background-color: #1C1C1C; border-radius: 10px; } "
                      "QLabel { background: transparent; border: none; }");

        // 1. 锁图标
        auto* lockIcon = new QLabel();
        lockIcon->setPixmap(IconHelper::getIcon("lock_secure", "#aaaaaa").pixmap(64, 64));
        lockIcon->setAlignment(Qt::AlignCenter);
        layout->addWidget(lockIcon);

        // 2. 标题文字
        auto* titleLabel = new QLabel("已锁定");
        titleLabel->setStyleSheet("color: #EEEEEE; font-size: 18px; font-weight: bold;");
        titleLabel->setAlignment(Qt::AlignCenter);
        layout->addWidget(titleLabel);

        // 3. 密码提示文字
        QSettings settings("RapidNotes", "QuickWindow");
        QString hint = settings.value("appPasswordHint", "请输入启动密码").toString();
        auto* hintLabel = new QLabel(hint);
        hintLabel->setStyleSheet("color: #666666; font-size: 12px;");
        hintLabel->setAlignment(Qt::AlignCenter);
        layout->addWidget(hintLabel);

        // 4. 密码输入框
        m_pwdEdit = new QLineEdit();
        m_pwdEdit->setEchoMode(QLineEdit::Password);
        m_pwdEdit->setPlaceholderText("请输入密码");
        m_pwdEdit->setFixedWidth(240);
        m_pwdEdit->setFixedHeight(36);
        m_pwdEdit->setAlignment(Qt::AlignCenter);
        m_pwdEdit->setStyleSheet(
            "QLineEdit {"
            "  background-color: #2A2A2A; border: 1px solid #333; border-radius: 6px;"
            "  color: white; font-size: 14px;"
            "}"
            "QLineEdit:focus { border: 1px solid #3A90FF; }"
        );
        connect(m_pwdEdit, &QLineEdit::returnPressed, this, &AppLockWidget::handleVerify);
        layout->addWidget(m_pwdEdit, 0, Qt::AlignHCenter);

        // 5. 右上角关闭按钮
        m_closeBtn = new QPushButton(this);
        m_closeBtn->setIcon(IconHelper::getIcon("close", "#aaaaaa"));
        m_closeBtn->setIconSize(QSize(18, 18));
        m_closeBtn->setFixedSize(32, 32);
        m_closeBtn->setCursor(Qt::PointingHandCursor);
        m_closeBtn->setStyleSheet(
            "QPushButton { border: none; border-radius: 4px; background: transparent; } "
            "QPushButton:hover { background-color: #E81123; }"
        );
        connect(m_closeBtn, &QPushButton::clicked, []() { QApplication::quit(); });

        // 初始焦点
        m_pwdEdit->setFocus();
    }

    void focusInput() {
        m_pwdEdit->setFocus();
        m_pwdEdit->selectAll();
    }

protected:
    void keyPressEvent(QKeyEvent* event) override {
        if (event->key() == Qt::Key_Escape) {
            QApplication::quit();
        }
        QWidget::keyPressEvent(event);
    }

    void resizeEvent(QResizeEvent* event) override {
        m_closeBtn->move(width() - m_closeBtn->width() - 10, 10);
        QWidget::resizeEvent(event);
    }

private slots:
    void handleVerify() {
        if (m_pwdEdit->text() == m_correctPassword) {
            startFadeOut();
        } else {
            startShake();
        }
    }

    void startFadeOut() {
        auto* opacityEffect = new QGraphicsOpacityEffect(this);
        setGraphicsEffect(opacityEffect);
        auto* animation = new QPropertyAnimation(opacityEffect, "opacity");
        animation->setDuration(300);
        animation->setStartValue(1.0);
        animation->setEndValue(0.0);
        animation->setEasingCurve(QEasingCurve::OutCubic);
        connect(animation, &QPropertyAnimation::finished, this, [this]() {
            emit unlocked();
            this->deleteLater();
        });
        animation->start(QAbstractAnimation::DeleteWhenStopped);
    }

    void startShake() {
        m_pwdEdit->clear();
        auto* anim = new QPropertyAnimation(m_pwdEdit, "pos");
        anim->setDuration(400);
        anim->setLoopCount(1);
        
        QPoint pos = m_pwdEdit->pos();
        anim->setKeyValueAt(0, pos);
        anim->setKeyValueAt(0.1, pos + QPoint(-10, 0));
        anim->setKeyValueAt(0.3, pos + QPoint(10, 0));
        anim->setKeyValueAt(0.5, pos + QPoint(-10, 0));
        anim->setKeyValueAt(0.7, pos + QPoint(10, 0));
        anim->setKeyValueAt(0.9, pos + QPoint(-10, 0));
        anim->setKeyValueAt(1, pos);
        
        anim->start(QAbstractAnimation::DeleteWhenStopped);
    }

signals:
    void unlocked();

private:
    QLineEdit* m_pwdEdit;
    QPushButton* m_closeBtn;
    QString m_correctPassword;
};


// 定义调整大小的边缘触发区域宽度 (与边距一致，改为 12px 以匹配新边距)
#define RESIZE_MARGIN 12

QuickWindow::QuickWindow(QWidget* parent) 
    : QWidget(parent, Qt::FramelessWindowHint) 
{
     setWindowTitle("快速笔记");
    setAcceptDrops(true);
    setAttribute(Qt::WA_TranslucentBackground);
    // [CRITICAL] 强制开启非活动窗口的 ToolTip 显示。
    setAttribute(Qt::WA_AlwaysShowToolTips);
    setAttribute(Qt::WA_DeleteOnClose, false);
    
    // 关键修复：开启鼠标追踪，否则不按住鼠标时无法检测边缘
    setMouseTracking(true);
    setAttribute(Qt::WA_Hover);
    
    initUI();

    m_refreshTimer = new QTimer(this);
    m_refreshTimer->setSingleShot(true);
    m_refreshTimer->setInterval(200);
    connect(m_refreshTimer, &QTimer::timeout, this, [this](){
        if (this->isVisible()) {
            refreshData();
            refreshSidebar();
        }
    });

    connect(&DatabaseManager::instance(), &DatabaseManager::noteAdded, this, &QuickWindow::onNoteAdded);
    connect(&DatabaseManager::instance(), &DatabaseManager::noteUpdated, this, &QuickWindow::scheduleRefresh);
    connect(&ClipboardMonitor::instance(), &ClipboardMonitor::newContentDetected, this, &QuickWindow::scheduleRefresh);

    connect(&DatabaseManager::instance(), &DatabaseManager::categoriesChanged, this, [this](){
        m_model->updateCategoryMap();
        
        // 如果当前正在查看某个分类，同步更新其高亮色
        if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
            auto categories = DatabaseManager::instance().getAllCategories();
            for (const auto& cat : std::as_const(categories)) {
                if (cat.value("id").toInt() == m_currentFilterValue) {
                    m_currentCategoryColor = cat.value("color").toString();
                    if (m_currentCategoryColor.isEmpty()) m_currentCategoryColor = "#4a90e2";
                    applyListTheme(m_currentCategoryColor);
                    break;
                }
            }
        }
        
        scheduleRefresh();
    });

#ifdef Q_OS_WIN
    m_monitorTimer = new QTimer(this);
    connect(m_monitorTimer, &QTimer::timeout, [this]() {
        HWND currentHwnd = GetForegroundWindow();
        if (currentHwnd == 0 || currentHwnd == (HWND)winId()) return;
        if (currentHwnd != m_lastActiveHwnd) {
            m_lastActiveHwnd = currentHwnd;
            m_lastThreadId = GetWindowThreadProcessId(m_lastActiveHwnd, nullptr);
            
            GUITHREADINFO gti;
            gti.cbSize = sizeof(GUITHREADINFO);
            if (GetGUIThreadInfo(m_lastThreadId, &gti)) {
                m_lastFocusHwnd = gti.hwndFocus;
            } else {
                m_lastFocusHwnd = nullptr;
            }
        }
    });
    m_monitorTimer->start(200);
#endif
}

void QuickWindow::initUI() {
    auto* mainLayout = new QVBoxLayout(this);
    // 【修改点1】边距调整为 12px，给窄阴影留出空间防止截断，同时保持紧凑
    mainLayout->setContentsMargins(12, 12, 12, 12); 

    auto* container = new QWidget();
    container->setObjectName("container");
    container->setMouseTracking(true); // 确保容器不阻断鼠标追踪
    container->setStyleSheet(
        "QWidget#container { background: #1E1E1E; border-radius: 10px; border: 1px solid #333; }"
        "QListView, QTreeView { background: transparent; border: none; color: #BBB; outline: none; }"
        "QTreeView::item { height: 22px; padding: 0px 4px; border-radius: 4px; }"
        "QTreeView::item:hover { background-color: #2a2d2e; }"
        "QTreeView::item:selected { background-color: transparent; color: white; }"
        "QListView::item { padding: 6px; border-bottom: 1px solid #2A2A2A; }"
    );
    
    // 【修改点2】阴影参数调整：更窄(BlurRadius 15)且不扩散
    auto* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(15);               // 变窄：15 (原25)
    shadow->setColor(QColor(0, 0, 0, 90));   // 变柔：90 (原100)，略微降低浓度
    shadow->setOffset(0, 2);                 // 变贴：垂直偏移2 (原4)
    container->setGraphicsEffect(shadow);

    auto* containerLayout = new QHBoxLayout(container);
    containerLayout->setContentsMargins(0, 0, 0, 0);
    containerLayout->setSpacing(0);

    // --- 左侧内容区域 ---
    auto* leftContent = new QWidget();
    leftContent->setObjectName("leftContent");
    leftContent->setStyleSheet("QWidget#leftContent { background: #1E1E1E; border-top-left-radius: 10px; border-bottom-left-radius: 10px; }");
    leftContent->setMouseTracking(true);
    auto* leftLayout = new QVBoxLayout(leftContent);
    leftLayout->setContentsMargins(10, 10, 10, 5);
    leftLayout->setSpacing(8);
    
    m_searchEdit = new SearchLineEdit();
    m_searchEdit->setPlaceholderText("搜索灵感 (双击查看历史)");
    m_searchEdit->setClearButtonEnabled(true);
    leftLayout->addWidget(m_searchEdit);

    m_splitter = new QSplitter(Qt::Horizontal);
    m_splitter->setHandleWidth(4);
    m_splitter->setChildrenCollapsible(false);
    
    m_listView = new DittoListView();
    m_listView->setDragEnabled(true);
    m_listView->setSelectionMode(QAbstractItemView::ExtendedSelection);
    m_listView->setIconSize(QSize(28, 28));
    m_listView->setAlternatingRowColors(true);
    m_listView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_listView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_listView->setMouseTracking(true);
    m_listView->setItemDelegate(new QuickNoteDelegate(this));
    m_model = new NoteModel(this);
    m_listView->setModel(m_model);
    m_listView->setContextMenuPolicy(Qt::CustomContextMenu);

    m_lockWidget = new CategoryLockWidget(this);
    m_lockWidget->setVisible(false);
    connect(m_lockWidget, &CategoryLockWidget::unlocked, this, [this](){
        refreshData();
    });
    connect(m_listView, &QListView::customContextMenuRequested, this, &QuickWindow::showListContextMenu);
    connect(m_listView, &QListView::doubleClicked, this, [this](const QModelIndex& index){
        activateNote(index);
    });

    auto* sidebarContainer = new QWidget();
    auto* sidebarLayout = new QVBoxLayout(sidebarContainer);
    sidebarLayout->setContentsMargins(0, 0, 0, 0);
    sidebarLayout->setSpacing(0);

    QString treeStyle = R"(
        QTreeView {
            background-color: transparent;
            border: none;
            outline: none;
            color: #ccc;
        }
        /* 针对我的分区标题进行加粗白色处理 */
        QTreeView::item:!selectable {
            color: #ffffff;
            font-weight: bold;
        }
        QTreeView::item {
            height: 22px;
            padding: 0px;
            border: none;
            background: transparent;
        }
        QTreeView::item:hover, QTreeView::item:selected {
            background: transparent;
        }
        QTreeView::branch:hover, QTreeView::branch:selected {
            background: transparent;
        }
        QTreeView::branch {
            image: none;
        }
    )";

    m_systemTree = new DropTreeView();
    m_systemTree->setStyleSheet(treeStyle);
    m_systemTree->setItemDelegate(new CategoryDelegate(this));
    m_systemModel = new CategoryModel(CategoryModel::System, this);
    m_systemTree->setModel(m_systemModel);
    m_systemTree->setHeaderHidden(true);
    m_systemTree->setMouseTracking(true);
    m_systemTree->setIndentation(12);
    m_systemTree->setFixedHeight(176); // 8 items * 22px = 176px
    m_systemTree->setEditTriggers(QAbstractItemView::NoEditTriggers); // 绝不可重命名
    m_systemTree->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_systemTree->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_systemTree, &QTreeView::customContextMenuRequested, this, &QuickWindow::showSidebarMenu);

    m_partitionTree = new DropTreeView();
    m_partitionTree->setStyleSheet(treeStyle);
    m_partitionTree->setItemDelegate(new CategoryDelegate(this));
    m_partitionModel = new CategoryModel(CategoryModel::User, this);
    m_partitionTree->setModel(m_partitionModel);
    m_partitionTree->setHeaderHidden(true);
    m_partitionTree->setMouseTracking(true);
    m_partitionTree->setIndentation(12);
    m_partitionTree->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_partitionTree->setDragEnabled(true);
    m_partitionTree->setAcceptDrops(true);
    m_partitionTree->setDropIndicatorShown(true);
    m_partitionTree->setDragDropMode(QAbstractItemView::InternalMove);
    m_partitionTree->setDefaultDropAction(Qt::MoveAction);
    m_partitionTree->expandAll();
    m_partitionTree->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_partitionTree, &QTreeView::customContextMenuRequested, this, &QuickWindow::showSidebarMenu);

    sidebarLayout->addWidget(m_systemTree);
    sidebarLayout->addWidget(m_partitionTree);

    // 树形菜单点击逻辑...
    auto onSelectionChanged = [this](DropTreeView* tree, const QModelIndex& index) {
        if (!index.isValid()) return;
        if (tree == m_systemTree) {
            m_partitionTree->selectionModel()->clearSelection();
            m_partitionTree->setCurrentIndex(QModelIndex());
        } else {
            m_systemTree->selectionModel()->clearSelection();
            m_systemTree->setCurrentIndex(QModelIndex());
        }
        m_currentFilterType = index.data(CategoryModel::TypeRole).toString();
        QString name = index.data(CategoryModel::NameRole).toString();
        updatePartitionStatus(name);

        // 统一从模型获取颜色，实现全分区变色联动
        m_currentCategoryColor = index.data(CategoryModel::ColorRole).toString();
        if (m_currentCategoryColor.isEmpty()) m_currentCategoryColor = "#4a90e2";

        if (m_currentFilterType == "category") {
            m_currentFilterValue = index.data(CategoryModel::IdRole).toInt();
            StringUtils::recordRecentCategory(m_currentFilterValue.toInt());
        } else {
            m_currentFilterValue = -1;
        }
        
        applyListTheme(m_currentCategoryColor);
        m_currentPage = 1;
        refreshData();
    };
    connect(m_systemTree, &QTreeView::clicked, this, [this, onSelectionChanged](const QModelIndex& idx){ onSelectionChanged(m_systemTree, idx); });
    connect(m_partitionTree, &QTreeView::clicked, this, [this, onSelectionChanged](const QModelIndex& idx){ onSelectionChanged(m_partitionTree, idx); });

    // 拖拽逻辑...
    auto onNotesDropped = [this](const QList<int>& ids, const QModelIndex& targetIndex) {
        if (!targetIndex.isValid()) return;
        QString type = targetIndex.data(CategoryModel::TypeRole).toString();
        
        if (type == "category") {
            int catId = targetIndex.data(CategoryModel::IdRole).toInt();
            DatabaseManager::instance().moveNotesToCategory(ids, catId);
            StringUtils::recordRecentCategory(catId);
        } else if (type == "uncategorized") {
            DatabaseManager::instance().moveNotesToCategory(ids, -1);
        } else {
            for (int id : ids) {
                if (type == "bookmark") DatabaseManager::instance().updateNoteState(id, "is_favorite", 1);
                else if (type == "trash") DatabaseManager::instance().updateNoteState(id, "is_deleted", 1);
            }
        }
        // refreshData 和 refreshSidebar 将通过 DatabaseManager 信号触发的 scheduleRefresh 异步执行，
        // 从而避免在 dropEvent 堆栈中立即 reset model 导致的潜在闪退。
    };
    connect(m_systemTree, &DropTreeView::notesDropped, this, onNotesDropped);
    connect(m_partitionTree, &DropTreeView::notesDropped, this, onNotesDropped);

    // 右键菜单...
    // (此处省略部分右键菜单代码以保持简洁，逻辑与原版保持一致)
    // 主要是 showSidebarMenu 的实现...

    m_splitter->addWidget(m_listView);
    m_splitter->addWidget(m_lockWidget);
    m_splitter->addWidget(sidebarContainer);
    m_splitter->setStretchFactor(0, 1);
    m_splitter->setStretchFactor(1, 1);
    m_splitter->setStretchFactor(2, 0);
    m_splitter->setSizes({550, 0, 150});
    leftLayout->addWidget(m_splitter);

    applyListTheme(""); // 【核心修复】初始化时即应用深色主题

    // --- 底部状态栏与标签输入框 ---
    auto* bottomLayout = new QHBoxLayout();
    bottomLayout->setContentsMargins(2, 0, 10, 5);
    bottomLayout->setSpacing(10);

    m_statusLabel = new QLabel("当前分区: 全部数据");
    m_statusLabel->setStyleSheet("font-size: 11px; color: #888;");
    m_statusLabel->setFixedHeight(32);
    bottomLayout->addWidget(m_statusLabel);

    m_tagEdit = new ClickableLineEdit();
    m_tagEdit->setPlaceholderText("输入标签添加... (双击显示历史)");
    m_tagEdit->setStyleSheet(
        "QLineEdit { background-color: rgba(255, 255, 255, 0.05); "
        "border: 1px solid rgba(255, 255, 255, 0.1); "
        "border-radius: 10px; "
        "padding: 6px 12px; "
        "font-size: 12px; "
        "color: #EEE; } "
        "QLineEdit:focus { border-color: #4a90e2; background-color: rgba(255, 255, 255, 0.08); } "
        "QLineEdit:disabled { background-color: transparent; border: 1px solid #333; color: #666; }"
    );
    m_tagEdit->setEnabled(false); // 初始禁用
    connect(m_tagEdit, &QLineEdit::returnPressed, this, &QuickWindow::handleTagInput);
    connect(m_tagEdit, &ClickableLineEdit::doubleClicked, this, [this](){
        this->openTagSelector();
    });
    bottomLayout->addWidget(m_tagEdit, 1);

    leftLayout->addLayout(bottomLayout);

    containerLayout->addWidget(leftContent);

    // --- 右侧垂直工具栏 (Custom Toolbar Implementation) ---
    // 【核心修正】根据图二 1:1 还原，压缩宽度，修正图标名，重构分页布局
    
    QWidget* customToolbar = new QWidget(this);
    customToolbar->setFixedWidth(40); // 压缩至 40px
    customToolbar->setStyleSheet(
        "QWidget { background-color: #252526; border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-left: 1px solid #333; }"
        "QPushButton { border: none; border-radius: 4px; background: transparent; padding: 0px; outline: none; }"
        "QPushButton:hover { background-color: #3e3e42; }"
        "QPushButton#btnClose:hover { background-color: #E81123; }"
        "QPushButton:pressed { background-color: #2d2d2d; }"
        "QLabel { color: #888; font-size: 11px; }"
        "QLineEdit { background: transparent; border: 1px solid #444; border-radius: 4px; color: white; font-size: 11px; font-weight: bold; padding: 0; }"
    );
    
    QVBoxLayout* toolLayout = new QVBoxLayout(customToolbar);
    toolLayout->setContentsMargins(4, 8, 4, 8); // 对齐 Python 版边距
    toolLayout->setSpacing(4); // 紧凑间距，匹配图二

    // 辅助函数：创建图标按钮，支持旋转
    auto createToolBtn = [](QString iconName, QString color, QString tooltip, int rotate = 0) {
        QPushButton* btn = new QPushButton();
        QIcon icon = IconHelper::getIcon(iconName, color);
        if (rotate != 0) {
            QPixmap pix = icon.pixmap(32, 32);
            QTransform trans;
            trans.rotate(rotate);
            btn->setIcon(QIcon(pix.transformed(trans, Qt::SmoothTransformation)));
        } else {
            btn->setIcon(icon);
        }
        btn->setIconSize(QSize(20, 20)); // 统一标准化为 20px 图标
        btn->setFixedSize(32, 32);
        btn->setToolTip(tooltip);
        btn->setCursor(Qt::PointingHandCursor);
        btn->setFocusPolicy(Qt::NoFocus);
        return btn;
    };

    // 1. 顶部窗口控制区 (修正图标名为 SvgIcons 中存在的名称)
    QPushButton* btnClose = createToolBtn("close", "#aaaaaa", "关闭");
    btnClose->setObjectName("btnClose");
    connect(btnClose, &QPushButton::clicked, this, &QuickWindow::hide);

    QPushButton* btnFull = createToolBtn("maximize", "#aaaaaa", "打开/关闭主窗口");
    connect(btnFull, &QPushButton::clicked, [this](){ emit toggleMainWindowRequested(); });

    QPushButton* btnMin = createToolBtn("minimize", "#aaaaaa", "最小化");
    connect(btnMin, &QPushButton::clicked, this, &QuickWindow::showMinimized);

    toolLayout->addWidget(btnClose, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnFull, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnMin, 0, Qt::AlignHCenter);

    toolLayout->addSpacing(8);

    // 2. 功能按钮区
    QPushButton* btnPin = createToolBtn("pin_tilted", "#aaaaaa", "置顶");
    btnPin->setCheckable(true);
    btnPin->setObjectName("btnPin");
    btnPin->setStyleSheet("QPushButton:checked { background-color: #3A90FF; }");
    if (windowFlags() & Qt::WindowStaysOnTopHint) {
        btnPin->setChecked(true);
        btnPin->setIcon(IconHelper::getIcon("pin_vertical", "#ffffff"));
    }
    connect(btnPin, &QPushButton::toggled, this, &QuickWindow::toggleStayOnTop);

    QPushButton* btnSidebar = createToolBtn("eye", "#aaaaaa", "显示/隐藏侧边栏");
    btnSidebar->setObjectName("btnSidebar");
    btnSidebar->setCheckable(true);
    btnSidebar->setChecked(true);
    btnSidebar->setStyleSheet("QPushButton:checked { background-color: #3A90FF; }");
    connect(btnSidebar, &QPushButton::clicked, this, &QuickWindow::toggleSidebar);

    QPushButton* btnRefresh = createToolBtn("refresh", "#aaaaaa", "刷新");
    connect(btnRefresh, &QPushButton::clicked, this, &QuickWindow::refreshData);

    QPushButton* btnToolbox = createToolBtn("toolbox", "#aaaaaa", "工具箱");
    btnToolbox->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(btnToolbox, &QPushButton::clicked, this, &QuickWindow::toolboxRequested);
    connect(btnToolbox, &QPushButton::customContextMenuRequested, this, &QuickWindow::showToolboxMenu);

    QPushButton* btnLock = createToolBtn("lock_secure", "#aaaaaa", "锁定应用");
    connect(btnLock, &QPushButton::clicked, this, &QuickWindow::doGlobalLock);

    toolLayout->addWidget(btnPin, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnSidebar, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnRefresh, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnToolbox, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnLock, 0, Qt::AlignHCenter);

    toolLayout->addStretch();

    // 3. 分页区 (完全复刻图二布局：箭头+输入框+下方总数)
    QPushButton* btnPrev = createToolBtn("nav_prev", "#aaaaaa", "上一页", 90);
    btnPrev->setFixedSize(32, 20);
    connect(btnPrev, &QPushButton::clicked, [this](){
        if (m_currentPage > 1) { m_currentPage--; refreshData(); }
    });

    QLineEdit* pageInput = new QLineEdit("1");
    pageInput->setObjectName("pageInput");
    pageInput->setAlignment(Qt::AlignCenter);
    pageInput->setFixedSize(28, 20);
    connect(pageInput, &QLineEdit::returnPressed, [this, pageInput](){
        int p = pageInput->text().toInt();
        if (p > 0 && p <= m_totalPages) { m_currentPage = p; refreshData(); }
    });

    QLabel* totalLabel = new QLabel("1");
    totalLabel->setObjectName("totalLabel");
    totalLabel->setAlignment(Qt::AlignCenter);
    totalLabel->setStyleSheet("color: #666; font-size: 10px; border: none; background: transparent;");

    QPushButton* btnNext = createToolBtn("nav_next", "#aaaaaa", "下一页", 90);
    btnNext->setFixedSize(32, 20);
    connect(btnNext, &QPushButton::clicked, [this](){
        if (m_currentPage < m_totalPages) { m_currentPage++; refreshData(); }
    });

    toolLayout->addWidget(btnPrev, 0, Qt::AlignHCenter);
    toolLayout->addWidget(pageInput, 0, Qt::AlignHCenter);
    toolLayout->addWidget(totalLabel, 0, Qt::AlignHCenter);
    toolLayout->addWidget(btnNext, 0, Qt::AlignHCenter);

    toolLayout->addSpacing(20); // 增加分页与标题间距

    // 4. 垂直标题 "快速笔记"
    QLabel* verticalTitle = new QLabel("快\n速\n笔\n记");
    verticalTitle->setAlignment(Qt::AlignCenter);
    verticalTitle->setStyleSheet("color: #444; font-size: 11px; font-weight: bold; border: none; background: transparent; line-height: 1.1;");
    toolLayout->addWidget(verticalTitle, 0, Qt::AlignHCenter);

    toolLayout->addSpacing(12);

    // 5. 底部 Logo (修正为 zap 图标以匹配图二蓝闪电)
    QPushButton* btnLogo = createToolBtn("zap", "#3A90FF", "RapidNotes");
    btnLogo->setCursor(Qt::ArrowCursor);
    btnLogo->setStyleSheet("background: transparent; border: none;");
    toolLayout->addWidget(btnLogo, 0, Qt::AlignHCenter);

    containerLayout->addWidget(customToolbar);
    
    // m_toolbar = new QuickToolbar(this); // 移除旧代码
    // containerLayout->addWidget(m_toolbar); // 移除旧代码
    
    mainLayout->addWidget(container);
    
    // 初始大小和最小大小
    resize(900, 630);
    setMinimumSize(400, 300);

    m_quickPreview = new QuickPreview(this);
    connect(m_quickPreview, &QuickPreview::editRequested, this, &QuickWindow::doEditNote);
    connect(m_quickPreview, &QuickPreview::prevRequested, this, [this](){
        QModelIndex current = m_listView->currentIndex();
        if (!current.isValid() || m_model->rowCount() == 0) return;

        int catId = current.data(NoteModel::CategoryIdRole).toInt();
        int row = current.row();
        int count = m_model->rowCount();
        
        for (int i = 1; i <= count; ++i) {
            int prevRow = (row - i + count) % count;
            QModelIndex idx = m_model->index(prevRow, 0);
            if (idx.data(NoteModel::CategoryIdRole).toInt() == catId) {
                m_listView->setCurrentIndex(idx);
                m_listView->scrollTo(idx);
                updatePreviewContent();
                if (prevRow > row) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "已回环至列表末尾相同分类");
                }
                return;
            }
        }
    });
    connect(m_quickPreview, &QuickPreview::nextRequested, this, [this](){
        QModelIndex current = m_listView->currentIndex();
        if (!current.isValid() || m_model->rowCount() == 0) return;

        int catId = current.data(NoteModel::CategoryIdRole).toInt();
        int row = current.row();
        int count = m_model->rowCount();

        for (int i = 1; i <= count; ++i) {
            int nextRow = (row + i) % count;
            QModelIndex idx = m_model->index(nextRow, 0);
            if (idx.data(NoteModel::CategoryIdRole).toInt() == catId) {
                m_listView->setCurrentIndex(idx);
                m_listView->scrollTo(idx);
                updatePreviewContent();
                if (nextRow < row) {
                    ToolTipOverlay::instance()->showText(QCursor::pos(), "已回环至列表起始相同分类");
                }
                return;
            }
        }
    });
    connect(m_quickPreview, &QuickPreview::historyNavigationRequested, this, [this](int id){
        for (int i = 0; i < m_model->rowCount(); ++i) {
            QModelIndex idx = m_model->index(i, 0);
            if (idx.data(NoteModel::IdRole).toInt() == id) {
                m_listView->setCurrentIndex(idx);
                m_listView->scrollTo(idx);
                return;
            }
        }
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        if (!note.isEmpty()) {
            m_quickPreview->showPreview(
                id,
                note.value("title").toString(),
                note.value("content").toString(),
                note.value("item_type").toString(),
                note.value("data_blob").toByteArray(),
                m_quickPreview->pos(),
                ""
            );
        }
    });
    m_listView->installEventFilter(this);
    m_systemTree->installEventFilter(this);
    m_partitionTree->installEventFilter(this);

    // 搜索逻辑
    m_searchTimer = new QTimer(this);
    m_searchTimer->setSingleShot(true);
    connect(m_searchTimer, &QTimer::timeout, this, &QuickWindow::refreshData);
    connect(m_searchEdit, &QLineEdit::textChanged, [this](const QString& text){
        m_currentPage = 1;
        m_searchTimer->start(300);
    });

    connect(m_searchEdit, &QLineEdit::returnPressed, [this](){
        QString text = m_searchEdit->text().trimmed();
        if (text.isEmpty()) return;
        m_searchEdit->addHistoryEntry(text);
        
        // 强制立即刷新一次数据，防止定时器延迟导致 rowCount 不准确
        m_searchTimer->stop();
        refreshData();
    });

    // 监听列表选择变化，动态切换输入框状态
    connect(m_listView->selectionModel(), &QItemSelectionModel::selectionChanged, this, [this](){
        auto selected = m_listView->selectionModel()->selectedIndexes();
        if (selected.isEmpty()) {
            m_tagEdit->setEnabled(false);
            m_tagEdit->clear();
            m_tagEdit->setPlaceholderText("请先选择一个项目");
        } else {
            m_tagEdit->setEnabled(true);
            m_tagEdit->setPlaceholderText(selected.size() == 1 ? "输入新标签... (双击显示历史)" : "批量添加标签... (双击显示历史)");
            
            // 联动更新：如果预览窗口处于显示状态，随选中项即时更新内容
            if (m_quickPreview->isVisible()) {
                updatePreviewContent();
            }
        }
    });

    setupShortcuts();
    connect(&ShortcutManager::instance(), &ShortcutManager::shortcutsChanged, this, &QuickWindow::updateShortcuts);
    restoreState();
    refreshData();
    setupAppLock();
}

void QuickWindow::setupAppLock() {
    if (m_appLockWidget) return;
    QSettings settings("RapidNotes", "QuickWindow");
    QString appPwd = settings.value("appPassword").toString();
    if (!appPwd.isEmpty()) {
        auto* lock = new AppLockWidget(appPwd, this);
        m_appLockWidget = lock;
        lock->resize(this->size());
        
        connect(lock, &AppLockWidget::unlocked, this, [this]() {
            m_appLockWidget = nullptr;
            m_searchEdit->setFocus();
        });
        
        lock->show();
        lock->raise();
    }
}

void QuickWindow::saveState() {
    QSettings settings("RapidNotes", "QuickWindow");
    settings.setValue("geometry", saveGeometry());
    settings.setValue("splitter", m_splitter->saveState());
    settings.setValue("sidebarHidden", m_systemTree->parentWidget()->isHidden());
    settings.setValue("stayOnTop", m_isStayOnTop);
    settings.setValue("autoCategorizeClipboard", m_autoCategorizeClipboard);
}

void QuickWindow::restoreState() {
    QSettings settings("RapidNotes", "QuickWindow");
    if (settings.contains("geometry")) {
        restoreGeometry(settings.value("geometry").toByteArray());
    }
    if (settings.contains("splitter")) {
        m_splitter->restoreState(settings.value("splitter").toByteArray());
    }
    if (settings.contains("sidebarHidden")) {
        bool hidden = settings.value("sidebarHidden").toBool();
        m_systemTree->parentWidget()->setHidden(hidden);
        
        // 同步刷新眼睛图标状态
        auto* btnSidebar = findChild<QPushButton*>("btnSidebar");
        if (btnSidebar) {
            bool visible = !hidden;
            btnSidebar->setChecked(visible);
            btnSidebar->setIcon(IconHelper::getIcon("eye", visible ? "#ffffff" : "#aaaaaa"));
        }
    }
    if (settings.contains("stayOnTop")) {
        toggleStayOnTop(settings.value("stayOnTop").toBool());
    }
    if (settings.contains("autoCategorizeClipboard")) {
        m_autoCategorizeClipboard = settings.value("autoCategorizeClipboard").toBool();
    }
}

void QuickWindow::setupShortcuts() {
    auto add = [&](const QString& id, std::function<void()> func) {
        auto* sc = new QShortcut(ShortcutManager::instance().getShortcut(id), this, func);
        sc->setProperty("id", id);
        m_shortcuts.append(sc);
    };

    add("qw_search", [this](){ m_searchEdit->setFocus(); m_searchEdit->selectAll(); });
    add("qw_delete_soft", [this](){ doDeleteSelected(false); });
    add("qw_delete_hard", [this](){ doDeleteSelected(true); });
    add("qw_favorite", [this](){ doToggleFavorite(); });
    add("qw_preview", [this](){ doPreview(); });
    add("qw_pin", [this](){ doTogglePin(); });
    add("qw_close", [this](){ hide(); });
    add("qw_lock_item", [this](){ doLockSelected(); });
    add("qw_new_idea", [this](){ doNewIdea(); });
    add("qw_select_all", [this](){ m_listView->selectAll(); });
    add("qw_extract", [this](){ doExtractContent(); });
    add("qw_lock_cat", [this](){
        if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
            DatabaseManager::instance().lockCategory(m_currentFilterValue.toInt());
            refreshSidebar();
            refreshData();
        }
    });
    add("qw_stay_on_top", [this](){ toggleStayOnTop(!m_isStayOnTop); });
    add("qw_toggle_main", [this](){ emit toggleMainWindowRequested(); });
    add("qw_toolbox", [this](){ emit toolboxRequested(); });
    add("qw_edit", [this](){ doEditSelected(); });
    add("qw_sidebar", [this](){ toggleSidebar(); });
    add("qw_prev_page", [this](){ if(m_currentPage > 1) { m_currentPage--; refreshData(); } });
    add("qw_next_page", [this](){ if(m_currentPage < m_totalPages) { m_currentPage++; refreshData(); } });
    add("qw_copy_tags", [this](){ doCopyTags(); });
    add("qw_paste_tags", [this](){ doPasteTags(); });
    
    for (int i = 0; i <= 5; ++i) {
        add(QString("qw_rating_%1").arg(i), [this, i](){ doSetRating(i); });
    }
}

void QuickWindow::updateShortcuts() {
    for (auto* sc : m_shortcuts) {
        QString id = sc->property("id").toString();
        sc->setKey(ShortcutManager::instance().getShortcut(id));
    }
}

void QuickWindow::scheduleRefresh() {
    m_refreshTimer->start();
}

void QuickWindow::onNoteAdded(const QVariantMap& note) {
    // 检查是否符合当前过滤条件
    bool matches = false;
    if (m_currentFilterType == "all") matches = true;
    else if (m_currentFilterType == "today") matches = true;
    else if (m_currentFilterType == "category") {
        matches = (note.value("category_id").toInt() == m_currentFilterValue.toInt());
    } else if (m_currentFilterType == "untagged") {
        matches = note.value("tags").toString().isEmpty();
    }
    
    if (matches && m_currentPage == 1) {
        m_model->prependNote(note);
    }
    
    // 依然需要触发侧边栏计数刷新 (节流执行)
    scheduleRefresh();
}

void QuickWindow::refreshData() {
    if (!isVisible()) return;

    // 记忆当前选中的 ID，以便在刷新后恢复选中状态
    int lastSelectedId = -1;
    QModelIndex currentIdx = m_listView->currentIndex();
    if (currentIdx.isValid()) {
        lastSelectedId = currentIdx.data(NoteModel::IdRole).toInt();
    }

    QString keyword = m_searchEdit->text();
    
    int totalCount = DatabaseManager::instance().getNotesCount(keyword, m_currentFilterType, m_currentFilterValue);
    
    const int pageSize = 100; // 对齐 Python 版
    m_totalPages = qMax(1, (totalCount + pageSize - 1) / pageSize); 
    if (m_currentPage > m_totalPages) m_currentPage = m_totalPages;
    if (m_currentPage < 1) m_currentPage = 1;

    // 检查当前分类是否锁定
    bool isLocked = false;
    if (m_currentFilterType == "category" && m_currentFilterValue != -1) {
        int catId = m_currentFilterValue.toInt();
        if (DatabaseManager::instance().isCategoryLocked(catId)) {
            isLocked = true;
            QString hint;
            auto cats = DatabaseManager::instance().getAllCategories();
            for(const auto& c : std::as_const(cats)) if(c.value("id").toInt() == catId) hint = c.value("password_hint").toString();
            m_lockWidget->setCategory(catId, hint);
        }
    }

    m_listView->setVisible(!isLocked);
    m_lockWidget->setVisible(isLocked);

    if (isLocked && m_quickPreview->isVisible()) {
        m_quickPreview->hide();
    }

    m_model->setNotes(isLocked ? QList<QVariantMap>() : DatabaseManager::instance().searchNotes(keyword, m_currentFilterType, m_currentFilterValue, m_currentPage, pageSize));
    
    // 恢复选中状态
    if (lastSelectedId != -1) {
        for (int i = 0; i < m_model->rowCount(); ++i) {
            QModelIndex idx = m_model->index(i, 0);
            if (idx.data(NoteModel::IdRole).toInt() == lastSelectedId) {
                m_listView->selectionModel()->select(idx, QItemSelectionModel::Select | QItemSelectionModel::Rows);
                m_listView->setCurrentIndex(idx);
                break;
            }
        }
    }

    // 更新工具栏页码 (对齐新版 1:1 布局)
    auto* pageInput = findChild<QLineEdit*>("pageInput");
    if (pageInput) pageInput->setText(QString::number(m_currentPage));
    
    auto* totalLabel = findChild<QLabel*>("totalLabel");
    if (totalLabel) totalLabel->setText(QString::number(m_totalPages));
}

void QuickWindow::updatePartitionStatus(const QString& name) {
    m_statusLabel->setText(QString("当前分区: %1").arg(name.isEmpty() ? "全部数据" : name));
    m_statusLabel->show();
}

void QuickWindow::refreshSidebar() {
    if (!isVisible()) return;
    // 保存选中状态
    QString selectedType;
    QVariant selectedValue;
    QModelIndex sysIdx = m_systemTree->currentIndex();
    QModelIndex partIdx = m_partitionTree->currentIndex();
    
    if (sysIdx.isValid()) {
        selectedType = sysIdx.data(CategoryModel::TypeRole).toString();
        selectedValue = sysIdx.data(CategoryModel::NameRole);
    } else if (partIdx.isValid()) {
        selectedType = partIdx.data(CategoryModel::TypeRole).toString();
        selectedValue = partIdx.data(CategoryModel::IdRole);
    }

    m_systemModel->refresh();
    m_partitionModel->refresh();
    m_partitionTree->expandAll();

    // 恢复选中
    if (!selectedType.isEmpty()) {
        if (selectedType != "category") {
            for (int i = 0; i < m_systemModel->rowCount(); ++i) {
                QModelIndex idx = m_systemModel->index(i, 0);
                if (idx.data(CategoryModel::TypeRole).toString() == selectedType &&
                    idx.data(CategoryModel::NameRole) == selectedValue) {
                    m_systemTree->setCurrentIndex(idx);
                    break;
                }
            }
        } else {
            std::function<void(const QModelIndex&)> findAndSelect = [&](const QModelIndex& parent) {
                for (int i = 0; i < m_partitionModel->rowCount(parent); ++i) {
                    QModelIndex idx = m_partitionModel->index(i, 0, parent);
                    if (idx.data(CategoryModel::IdRole) == selectedValue) {
                        m_partitionTree->setCurrentIndex(idx);
                        return;
                    }
                    if (m_partitionModel->rowCount(idx) > 0) findAndSelect(idx);
                }
            };
            findAndSelect(QModelIndex());
        }
    }
}

void QuickWindow::applyListTheme(const QString& colorHex) {
    QString style;
    if (!colorHex.isEmpty()) {
        QColor c(colorHex);
        // 对齐 Python 版，背景保持深色，高亮色由 Delegate 处理，这里主要设置斑马纹
        style = QString("QListView { "
                        "  border: none; "
                        "  background-color: #1e1e1e; "
                        "  alternate-background-color: #252526; "
                        "  selection-background-color: transparent; "
                        "  color: #eee; "
                        "  outline: none; "
                        "}");
    } else {
        style = "QListView { "
                "  border: none; "
                "  background-color: #1e1e1e; "
                "  alternate-background-color: #252526; "
                "  selection-background-color: transparent; "
                "  color: #eee; "
                "  outline: none; "
                "}";
    }
    m_listView->setStyleSheet(style);
}

void QuickWindow::activateNote(const QModelIndex& index) {
    if (!index.isValid()) return;

    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    
    // 记录访问
    DatabaseManager::instance().recordAccess(id);

    QString itemType = note.value("item_type").toString();
    QString content = note.value("content").toString();
    QByteArray blob = note.value("data_blob").toByteArray();
    
    if (itemType == "image") {
        QImage img;
        img.loadFromData(blob);
        ClipboardMonitor::instance().skipNext();
        QApplication::clipboard()->setImage(img);
    } else if (itemType == "local_file" || itemType == "local_folder" || itemType == "local_batch") {
        // 文件系统托管模式：从相对路径恢复绝对路径
        QString fullPath = QCoreApplication::applicationDirPath() + "/" + content;
        QFileInfo fi(fullPath);
        if (fi.exists()) {
            QMimeData* mimeData = new QMimeData();
            if (itemType == "local_batch") {
                // 批量托管模式：双击发送该批量的所有文件/文件夹内容
                QDir dir(fullPath);
                QList<QUrl> urls;
                for (const QString& fileName : dir.entryList(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot)) {
                    urls << QUrl::fromLocalFile(dir.absoluteFilePath(fileName));
                }
                if (urls.isEmpty()) urls << QUrl::fromLocalFile(fullPath); // 保底发送文件夹自身
                mimeData->setUrls(urls);
            } else {
                mimeData->setUrls({QUrl::fromLocalFile(fullPath)});
            }
            ClipboardMonitor::instance().skipNext();
            QApplication::clipboard()->setMimeData(mimeData);
        } else {
            QApplication::clipboard()->setText(content);
            ToolTipOverlay::instance()->showText(QCursor::pos(), "⚠️ 文件已丢失或被移动");
        }
    } else if (!blob.isEmpty() && (itemType == "file" || itemType == "folder")) {
        // 旧的数据库存储模式：导出到临时目录
        QString title = note.value("title").toString();
        QString exportDir = QDir::tempPath() + "/RapidNotes_Export";
        QDir().mkpath(exportDir);
        QString tempPath = exportDir + "/" + title;
        
        QFile f(tempPath);
        if (f.open(QIODevice::WriteOnly)) {
            f.write(blob);
            f.close();
            
            QMimeData* mimeData = new QMimeData();
            mimeData->setUrls({QUrl::fromLocalFile(tempPath)});
            QApplication::clipboard()->setMimeData(mimeData);
        } else {
            QApplication::clipboard()->setText(content);
        }
    } else if (itemType != "text" && !itemType.isEmpty()) {
        QStringList rawPaths = content.split(';', Qt::SkipEmptyParts);
        QList<QUrl> validUrls;
        QStringList missingFiles;
        
        for (const QString& p : std::as_const(rawPaths)) {
            QString path = p.trimmed().remove('\"');
            if (QFileInfo::exists(path)) {
                validUrls << QUrl::fromLocalFile(path);
            } else {
                missingFiles << QFileInfo(path).fileName();
            }
        }
        
        if (!validUrls.isEmpty()) {
            QMimeData* mimeData = new QMimeData();
            mimeData->setUrls(validUrls);
            QApplication::clipboard()->setMimeData(mimeData);
        } else {
            QApplication::clipboard()->setText(content);
            if (!missingFiles.isEmpty()) {
                ToolTipOverlay::instance()->showText(QCursor::pos(), "⚠️ 原文件已丢失，已复制路径文本");
            }
        }
    } else {
        StringUtils::copyNoteToClipboard(content);
    }

    // hide(); // 用户要求不隐藏窗口

#ifdef Q_OS_WIN
    if (m_lastActiveHwnd && IsWindow(m_lastActiveHwnd)) {
        DWORD currThread = GetCurrentThreadId();
        bool attached = false;
        if (m_lastThreadId != 0 && m_lastThreadId != currThread) {
            attached = AttachThreadInput(currThread, m_lastThreadId, TRUE);
        }

        if (IsIconic(m_lastActiveHwnd)) {
            ShowWindow(m_lastActiveHwnd, SW_RESTORE);
        }
        SetForegroundWindow(m_lastActiveHwnd);
        
        if (m_lastFocusHwnd && IsWindow(m_lastFocusHwnd)) {
            SetFocus(m_lastFocusHwnd);
        }

        DWORD lastThread = m_lastThreadId;
        QTimer::singleShot(300, [lastThread, attached]() {
            // 1. 使用 SendInput 强制清理所有修饰键状态 (L/R Ctrl, Shift, Alt, Win)
            // 替换旧的 keybd_event，确保清理逻辑更原子化
            INPUT releaseInputs[8];
            memset(releaseInputs, 0, sizeof(releaseInputs));
            BYTE keys[] = { VK_LCONTROL, VK_RCONTROL, VK_LSHIFT, VK_RSHIFT, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN };
            for (int i = 0; i < 8; ++i) {
                releaseInputs[i].type = INPUT_KEYBOARD;
                releaseInputs[i].ki.wVk = keys[i];
                releaseInputs[i].ki.dwFlags = KEYEVENTF_KEYUP;
            }
            SendInput(8, releaseInputs, sizeof(INPUT));

            // 2. 使用 SendInput 发送 Ctrl+V 序列 (显式指定 VK_LCONTROL 提高兼容性)
            INPUT inputs[4];
            memset(inputs, 0, sizeof(inputs));

            // Ctrl 按下
            inputs[0].type = INPUT_KEYBOARD;
            inputs[0].ki.wVk = VK_LCONTROL;
            inputs[0].ki.wScan = MapVirtualKey(VK_LCONTROL, MAPVK_VK_TO_VSC);

            // V 按下
            inputs[1].type = INPUT_KEYBOARD;
            inputs[1].ki.wVk = 'V';
            inputs[1].ki.wScan = MapVirtualKey('V', MAPVK_VK_TO_VSC);

            // V 抬起
            inputs[2].type = INPUT_KEYBOARD;
            inputs[2].ki.wVk = 'V';
            inputs[2].ki.wScan = MapVirtualKey('V', MAPVK_VK_TO_VSC);
            inputs[2].ki.dwFlags = KEYEVENTF_KEYUP;

            // Ctrl 抬起
            inputs[3].type = INPUT_KEYBOARD;
            inputs[3].ki.wVk = VK_LCONTROL;
            inputs[3].ki.wScan = MapVirtualKey(VK_LCONTROL, MAPVK_VK_TO_VSC);
            inputs[3].ki.dwFlags = KEYEVENTF_KEYUP;

            SendInput(4, inputs, sizeof(INPUT));

            if (attached) {
                // 确保按键消息推入后再分离线程
                AttachThreadInput(GetCurrentThreadId(), lastThread, FALSE);
            }
        });
    }
#endif
}

void QuickWindow::doDeleteSelected(bool physical) {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    bool inTrash = (m_currentFilterType == "trash");
    
    if (physical || inTrash) {
        // 物理删除前增加二次确认
        QString title = inTrash ? "清空项目" : "彻底删除";
        QString text = QString("确定要永久删除选中的 %1 条数据吗？\n此操作不可逆，数据将无法找回。").arg(selected.count());
        
        auto* msg = new FramelessMessageBox(title, text, this);
        msg->setAttribute(Qt::WA_DeleteOnClose);
        
        // 提取 ID 列表以备删除
        QList<int> idsToDelete;
        for (const auto& index : std::as_const(selected)) idsToDelete << index.data(NoteModel::IdRole).toInt();
        
        connect(msg, &FramelessMessageBox::confirmed, this, [this, idsToDelete]() {
            if (idsToDelete.isEmpty()) return;
            DatabaseManager::instance().deleteNotesBatch(idsToDelete);
            refreshData();
            refreshSidebar();
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已永久删除 %1 条数据").arg(idsToDelete.size()));
        });
        msg->show();
    } else {
        // 移至回收站：解除绑定
        QList<int> idsToTrash;
        for (const auto& index : std::as_const(selected)) idsToTrash << index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().softDeleteNotes(idsToTrash);
        refreshData();
    }
    refreshSidebar();
}

void QuickWindow::doRestoreTrash() {
    if (DatabaseManager::instance().restoreAllFromTrash()) {
        refreshData();
        refreshSidebar();
    }
}

void QuickWindow::doToggleFavorite() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().toggleNoteState(id, "is_favorite");
    }
    refreshData();
}

void QuickWindow::doTogglePin() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().toggleNoteState(id, "is_pinned");
    }
    refreshData();
}

void QuickWindow::doLockSelected() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    
    bool firstState = selected.first().data(NoteModel::LockedRole).toBool();
    bool targetState = !firstState;

    QList<int> ids;
    for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
    
    DatabaseManager::instance().updateNoteStateBatch(ids, "is_locked", targetState);
    refreshData();
}

void QuickWindow::doNewIdea() {
    NoteEditWindow* win = new NoteEditWindow();
    connect(win, &NoteEditWindow::noteSaved, this, &QuickWindow::refreshData);
    win->show();
}

void QuickWindow::doExtractContent() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    QStringList texts;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        QString type = note.value("item_type").toString();
        if (type == "text" || type.isEmpty()) {
            QString content = note.value("content").toString();
            texts << StringUtils::htmlToPlainText(content);
        }
    }
    if (!texts.isEmpty()) {
        ClipboardMonitor::instance().skipNext();
        QApplication::clipboard()->setText(texts.join("\n---\n"));
    }
}

void QuickWindow::doEditSelected() {
    QModelIndex index = m_listView->currentIndex();
    if (!index.isValid()) return;
    doEditNote(index.data(NoteModel::IdRole).toInt());
}

void QuickWindow::doEditNote(int id) {
    if (id <= 0) return;
    NoteEditWindow* win = new NoteEditWindow(id);
    connect(win, &NoteEditWindow::noteSaved, this, &QuickWindow::refreshData);
    win->show();
}

void QuickWindow::doSetRating(int rating) {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().updateNoteState(id, "rating", rating);
    }
    refreshData();
}

void QuickWindow::doGlobalLock() {
    // 0. 预检密码是否设定
    QSettings settings("RapidNotes", "QuickWindow");
    if (settings.value("appPassword").toString().isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 尚未设定应用密码，请先进行设定</b>");
        return;
    }

    // 1. 隐藏所有其它顶级业务窗口 (排除自身、悬浮球)
    for (QWidget* widget : QApplication::topLevelWidgets()) {
        if (widget == this) continue;
        if (widget->objectName() == "FloatingBall") continue;
        if (widget->inherits("QSystemTrayIcon")) continue; // 虽然不是 QWidget 但遍历通常不含它
        
        // 排除某些特定窗口类或对象名 (可选)
        if (widget->isVisible()) {
            widget->hide();
        }
    }

    // 2. 强制显示应用锁
    setupAppLock();

    // 3. 弹出极速窗口并聚焦
    showAuto();
    
    ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #2ecc71;'>✔ 应用已锁定</b>");
}

void QuickWindow::updatePreviewContent() {
    QModelIndex index = m_listView->currentIndex();
    if (!index.isValid()) return;
    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    
    // 记录访问
    DatabaseManager::instance().recordAccess(id);

    // 尽量保持当前预览窗口的位置，如果没显示则计算初始位置
    QPoint pos;
    if (m_quickPreview->isVisible()) {
        pos = m_quickPreview->pos();
    } else {
        pos = m_listView->mapToGlobal(m_listView->rect().center()) - QPoint(250, 300);
    }

    m_quickPreview->showPreview(
        id,
        note.value("title").toString(), 
        note.value("content").toString(), 
        note.value("item_type").toString(),
        note.value("data_blob").toByteArray(),
        pos,
        index.data(NoteModel::CategoryNameRole).toString()
    );
}

void QuickWindow::doPreview() {
    // 增加防抖保护，防止双重触发
    static QElapsedTimer timer;
    if (timer.isValid() && timer.elapsed() < 200) {
        return;
    }
    timer.restart();

    QWidget* focusWidget = QApplication::focusWidget();
    // 保护：如果焦点在搜索框或其他输入框，空格键应保留其原始功能
    // 但如果焦点在预览窗口内部，则允许切换预览
    if (focusWidget && (qobject_cast<QLineEdit*>(focusWidget) || 
                        qobject_cast<QTextEdit*>(focusWidget) ||
                        qobject_cast<QPlainTextEdit*>(focusWidget))) {
        if (focusWidget != m_quickPreview && !m_quickPreview->isAncestorOf(focusWidget)) {
            return;
        }
    }

    if (m_quickPreview->isVisible()) {
        m_quickPreview->hide();
        return;
    }
    
    updatePreviewContent();
    
    m_quickPreview->raise();
    m_quickPreview->activateWindow();
}

void QuickWindow::toggleStayOnTop(bool checked) {
    m_isStayOnTop = checked;

    if (isVisible()) {
#ifdef Q_OS_WIN
        HWND hwnd = (HWND)winId();
        SetWindowPos(hwnd, checked ? HWND_TOPMOST : HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#else
        Qt::WindowFlags f = windowFlags();
        if (checked) f |= Qt::WindowStaysOnTopHint;
        else f &= ~Qt::WindowStaysOnTopHint;
        setWindowFlags(f);
        show();
#endif
    }
    // 更新按钮状态与图标
    auto* btnPin = findChild<QPushButton*>("btnPin");
    if (btnPin) {
        if (btnPin->isChecked() != checked) btnPin->setChecked(checked);
        // 切换图标样式 (选中时白色垂直，未选中时灰色倾斜)
        btnPin->setIcon(IconHelper::getIcon(checked ? "pin_vertical" : "pin_tilted", checked ? "#ffffff" : "#aaaaaa"));
    }
}

void QuickWindow::toggleSidebar() {
    bool visible = !m_systemTree->parentWidget()->isVisible();
    m_systemTree->parentWidget()->setVisible(visible);
    
    // 更新按钮状态
    auto* btnSidebar = findChild<QPushButton*>("btnSidebar");
    if (btnSidebar) {
        btnSidebar->setChecked(visible);
        btnSidebar->setIcon(IconHelper::getIcon("eye", visible ? "#ffffff" : "#aaaaaa"));
    }

    QString name;
    if (m_systemTree->currentIndex().isValid()) name = m_systemTree->currentIndex().data().toString();
    else name = m_partitionTree->currentIndex().data().toString();
    
    updatePartitionStatus(name);
}

void QuickWindow::showListContextMenu(const QPoint& pos) {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) {
        QModelIndex index = m_listView->indexAt(pos);
        if (index.isValid()) {
            m_listView->setCurrentIndex(index);
            selected << index;
        } else {
            return;
        }
    }

    int selCount = selected.size();
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                       "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    if (selCount == 1) {
        menu.addAction(IconHelper::getIcon("eye", "#1abc9c", 18), "预览 (Space)", this, &QuickWindow::doPreview);
        
        QString type = selected.first().data(NoteModel::TypeRole).toString();
        if (type == "image") {
            menu.addAction(IconHelper::getIcon("screenshot_ocr", "#3498db", 18), "从图提取文字", this, &QuickWindow::doOCR);
        }
    }
    
    menu.addAction(IconHelper::getIcon("copy", "#1abc9c", 18), QString("复制内容 (%1)").arg(selCount), this, &QuickWindow::doExtractContent);
    menu.addSeparator();

    if (selCount == 1) {
        menu.addAction(IconHelper::getIcon("edit", "#4a90e2", 18), "编辑 (Ctrl+B)", this, &QuickWindow::doEditSelected);
        menu.addSeparator();
    }

    auto* ratingMenu = menu.addMenu(IconHelper::getIcon("star", "#f39c12", 18), QString("设置星级 (%1)").arg(selCount));
    ratingMenu->setStyleSheet(menu.styleSheet());
    auto* starGroup = new QActionGroup(this);
    int currentRating = (selCount == 1) ? selected.first().data(NoteModel::RatingRole).toInt() : -1;
    
    for (int i = 1; i <= 5; ++i) {
        QString stars = QString("★").repeated(i);
        QAction* action = ratingMenu->addAction(stars, [this, i]() { doSetRating(i); });
        action->setCheckable(true);
        if (i == currentRating) action->setChecked(true);
        starGroup->addAction(action);
    }
    ratingMenu->addSeparator();
    ratingMenu->addAction("清除评级", [this]() { doSetRating(0); });

    bool isFavorite = selected.first().data(NoteModel::FavoriteRole).toBool();
    menu.addAction(IconHelper::getIcon(isFavorite ? "bookmark_filled" : "bookmark", "#ff6b81", 18), 
                   isFavorite ? "取消书签" : "添加书签 (Ctrl+E)", this, &QuickWindow::doToggleFavorite);

    bool isPinned = selected.first().data(NoteModel::PinnedRole).toBool();
    menu.addAction(IconHelper::getIcon(isPinned ? "pin_vertical" : "pin_tilted", isPinned ? "#3A90FF" : "#aaaaaa", 18), 
                   isPinned ? "取消置顶" : "置顶选中项 (Ctrl+P)", this, &QuickWindow::doTogglePin);
    
    bool isLocked = selected.first().data(NoteModel::LockedRole).toBool();
    menu.addAction(IconHelper::getIcon("lock", isLocked ? "#aaaaaa" : "#888888", 18), 
                   isLocked ? "解锁选中项" : "锁定选中项 (Ctrl+S)", this, &QuickWindow::doLockSelected);
    
    menu.addSeparator();

    auto* catMenu = menu.addMenu(IconHelper::getIcon("branch", "#cccccc", 18), QString("移动选中项到分类 (%1)").arg(selCount));
    catMenu->setStyleSheet(menu.styleSheet());
    catMenu->addAction(IconHelper::getIcon("uncategorized", "#e67e22", 18), "未分类", [this]() { doMoveToCategory(-1); });
    
    QVariantList recentCats = StringUtils::getRecentCategories();
    auto allCategories = DatabaseManager::instance().getAllCategories();
    QMap<int, QVariantMap> catMap;
    for (const auto& cat : std::as_const(allCategories)) catMap[cat.value("id").toInt()] = cat;

    int count = 0;
    for (const auto& v : std::as_const(recentCats)) {
        if (count >= 10) break;
        int cid = v.toInt();
        if (catMap.contains(cid)) {
            const auto& cat = catMap.value(cid);
            catMenu->addAction(IconHelper::getIcon("branch", cat.value("color").toString(), 18), cat.value("name").toString(), [this, cid]() {
                doMoveToCategory(cid);
            });
            count++;
        }
    }

    menu.addSeparator();
    if (m_currentFilterType == "trash") {
        menu.addAction(IconHelper::getIcon("refresh", "#2ecc71", 18), "恢复 (还原到未分类)", [this, selected](){
            QList<int> ids;
            for (const auto& index : selected) ids << index.data(NoteModel::IdRole).toInt();
            DatabaseManager::instance().moveNotesToCategory(ids, -1);
            refreshData();
            refreshSidebar();
        });
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "彻底删除 (不可逆)", [this](){ doDeleteSelected(true); });
    } else {
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "移至回收站 (Delete)", [this](){ doDeleteSelected(false); });
    }

    menu.exec(m_listView->mapToGlobal(pos));
}

void QuickWindow::showSidebarMenu(const QPoint& pos) {
    auto* tree = qobject_cast<QTreeView*>(sender());
    if (!tree) return;

    QModelIndex index = tree->indexAt(pos);
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                       "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    if (!index.isValid() || index.data().toString() == "我的分区") {
        menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建分组", [this]() {
            bool ok;
            QString text = QInputDialog::getText(this, "新建组", "组名称:", QLineEdit::Normal, "", &ok);
            if (ok && !text.isEmpty()) {
                DatabaseManager::instance().addCategory(text);
            }
        });
        menu.exec(tree->mapToGlobal(pos));
        return;
    }

    QString type = index.data(CategoryModel::TypeRole).toString();
    if (type == "category") {
        int catId = index.data(CategoryModel::IdRole).toInt();
        QString currentName = index.data(CategoryModel::NameRole).toString();

        menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建数据", [this, catId]() {
            auto* win = new NoteEditWindow();
            win->setDefaultCategory(catId);
            connect(win, &NoteEditWindow::noteSaved, this, &QuickWindow::refreshData);
            win->show();
        });
        menu.addSeparator();
        menu.addAction(IconHelper::getIcon("palette", "#e67e22", 18), "设置颜色", [this, catId]() {
            auto* dlg = new QColorDialog(Qt::gray, this);
            dlg->setWindowTitle("选择分类颜色");
            dlg->setWindowFlags(dlg->windowFlags() | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);
            connect(dlg, &QColorDialog::colorSelected, [this, catId](const QColor& color){
                if (color.isValid()) {
                    DatabaseManager::instance().setCategoryColor(catId, color.name());
                    refreshSidebar();
                }
            });
            connect(dlg, &QColorDialog::finished, dlg, &QObject::deleteLater);
            dlg->show();
        });
        menu.addAction(IconHelper::getIcon("random_color", "#FF6B9D", 18), "随机颜色", [this, catId]() {
            static const QStringList palette = {
                "#FF6B6B", "#4ECDC4", "#45B7D1", "#96CEB4", "#FFEEAD",
                "#D4A5A5", "#9B59B6", "#3498DB", "#E67E22", "#2ECC71",
                "#E74C3C", "#F1C40F", "#1ABC9C", "#34495E", "#95A5A6"
            };
            QString chosenColor = palette.at(QRandomGenerator::global()->bounded(palette.size()));
            DatabaseManager::instance().setCategoryColor(catId, chosenColor);
            refreshData();
            refreshSidebar();
        });
        menu.addAction(IconHelper::getIcon("tag", "#FFAB91", 18), "设置预设标签", [this, catId]() {
            QString currentTags = DatabaseManager::instance().getCategoryPresetTags(catId);
            auto* dlg = new FramelessInputDialog("设置预设标签", "标签 (逗号分隔):", currentTags, this);
            connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                DatabaseManager::instance().setCategoryPresetTags(catId, dlg->text());
            });
            dlg->show();
        });
        menu.addSeparator();
        menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建分组", [this]() {
            auto* dlg = new FramelessInputDialog("新建分组", "组名称:", "", this);
            connect(dlg, &FramelessInputDialog::accepted, [this, dlg](){
                QString text = dlg->text();
                if (!text.isEmpty()) {
                    DatabaseManager::instance().addCategory(text);
                    refreshSidebar();
                }
            });
            dlg->show();
            dlg->activateWindow();
            dlg->raise();
        });
        menu.addAction(IconHelper::getIcon("add", "#3498db", 18), "新建子分区", [this, catId]() {
            auto* dlg = new FramelessInputDialog("新建子分区", "区名称:", "", this);
            connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                QString text = dlg->text();
                if (!text.isEmpty()) {
                    DatabaseManager::instance().addCategory(text, catId);
                    refreshSidebar();
                }
            });
            dlg->show();
            dlg->activateWindow();
            dlg->raise();
        });
        menu.addSeparator();

        menu.addAction(IconHelper::getIcon("edit", "#aaaaaa", 18), "重命名", [this, catId, currentName]() {
            auto* dlg = new FramelessInputDialog("重命名", "新名称:", currentName, this);
            connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg](){
                QString text = dlg->text();
                if (!text.isEmpty()) {
                    DatabaseManager::instance().renameCategory(catId, text);
                    refreshSidebar();
                }
            });
            dlg->show();
            dlg->activateWindow();
            dlg->raise();
        });
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "删除", [this, catId]() {
            auto* dlg = new FramelessMessageBox("确认删除", "确定要删除此分类吗？内容将移至未分类。", this);
            dlg->setAttribute(Qt::WA_DeleteOnClose);
            connect(dlg, &FramelessMessageBox::confirmed, [this, catId](){
                DatabaseManager::instance().deleteCategory(catId);
                refreshSidebar();
            });
            dlg->show();
        });

        menu.addSeparator();
        auto* sortMenu = menu.addMenu(IconHelper::getIcon("list_ol", "#aaaaaa", 18), "排列");
        sortMenu->setStyleSheet(menu.styleSheet());

        int parentId = -1;
        QModelIndex parentIdx = index.parent();
        if (parentIdx.isValid() && parentIdx.data(CategoryModel::TypeRole).toString() == "category") {
            parentId = parentIdx.data(CategoryModel::IdRole).toInt();
        }

        sortMenu->addAction("标题(当前层级) (A→Z)", [this, parentId]() {
            if (DatabaseManager::instance().reorderCategories(parentId, true))
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 排列已完成</b>");
        });
        sortMenu->addAction("标题(当前层级) (Z→A)", [this, parentId]() {
            if (DatabaseManager::instance().reorderCategories(parentId, false))
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 排列已完成</b>");
        });
        sortMenu->addAction("标题(全部) (A→Z)", [this]() {
            if (DatabaseManager::instance().reorderAllCategories(true))
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 全部排列已完成</b>");
        });
        sortMenu->addAction("标题(全部) (Z→A)", [this]() {
            if (DatabaseManager::instance().reorderAllCategories(false))
                ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color:#2ecc71;'>✔ 全部排列已完成</b>");
        });

        menu.addSeparator();
        auto* pwdMenu = menu.addMenu(IconHelper::getIcon("lock", "#aaaaaa", 18), "密码保护");
        pwdMenu->setStyleSheet(menu.styleSheet());

        pwdMenu->addAction("设置", [this, catId]() {
            QTimer::singleShot(0, [this, catId]() {
                auto* dlg = new CategoryPasswordDialog("设置密码", this);
                connect(dlg, &QDialog::accepted, [this, catId, dlg]() {
                    DatabaseManager::instance().setCategoryPassword(catId, dlg->password(), dlg->passwordHint());
                    refreshSidebar();
                    refreshData();
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
        });
        pwdMenu->addAction("修改", [this, catId]() {
            QTimer::singleShot(0, [this, catId]() {
                auto* verifyDlg = new FramelessInputDialog("验证旧密码", "请输入当前密码:", "", this);
                verifyDlg->setEchoMode(QLineEdit::Password);
                connect(verifyDlg, &FramelessInputDialog::accepted, [this, catId, verifyDlg]() {
                    if (DatabaseManager::instance().verifyCategoryPassword(catId, verifyDlg->text())) {
                        auto* dlg = new CategoryPasswordDialog("修改密码", this);
                        QString currentHint;
                        auto cats = DatabaseManager::instance().getAllCategories();
                        for(const auto& c : std::as_const(cats)) if(c.value("id").toInt() == catId) currentHint = c.value("password_hint").toString();
                        dlg->setInitialData(currentHint);
                        connect(dlg, &QDialog::accepted, [this, catId, dlg]() {
                            DatabaseManager::instance().setCategoryPassword(catId, dlg->password(), dlg->passwordHint());
                            refreshSidebar();
                            refreshData();
                        });
                        dlg->show();
                        dlg->activateWindow();
                        dlg->raise();
                    } else {
                        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 旧密码验证失败</b>");
                    }
                });
                verifyDlg->show();
                verifyDlg->activateWindow();
                verifyDlg->raise();
            });
        });
        pwdMenu->addAction("移除", [this, catId]() {
            QTimer::singleShot(0, [this, catId]() {
                auto* dlg = new FramelessInputDialog("验证密码", "请输入当前密码以移除保护:", "", this);
                dlg->setEchoMode(QLineEdit::Password);
                connect(dlg, &FramelessInputDialog::accepted, [this, catId, dlg]() {
                    if (DatabaseManager::instance().verifyCategoryPassword(catId, dlg->text())) {
                        DatabaseManager::instance().removeCategoryPassword(catId);
                        refreshSidebar();
                        refreshData();
                    } else {
                        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>✖ 密码错误</b>");
                    }
                });
                dlg->show();
                dlg->activateWindow();
                dlg->raise();
            });
        });
        pwdMenu->addAction("立即锁定", [this, catId]() {
            DatabaseManager::instance().lockCategory(catId);
            refreshSidebar();
            refreshData();
        })->setShortcut(QKeySequence("Ctrl+Shift+L"));
    } else if (type == "trash") {
        menu.addAction(IconHelper::getIcon("refresh", "#2ecc71", 18), "全部恢复 (到未分类)", this, &QuickWindow::doRestoreTrash);
        menu.addSeparator();
        menu.addAction(IconHelper::getIcon("trash", "#e74c3c", 18), "清空回收站", [this]() {
            auto* dlg = new FramelessMessageBox("确认清空", "确定要永久删除回收站中的所有内容吗？\n(此操作不可逆)", this);
            dlg->setAttribute(Qt::WA_DeleteOnClose);
            connect(dlg, &FramelessMessageBox::confirmed, [this](){
                DatabaseManager::instance().emptyTrash();
                refreshData();
                refreshSidebar();
            });
            dlg->show();
        });
    }

    menu.exec(tree->mapToGlobal(pos));
}

void QuickWindow::showToolboxMenu(const QPoint& pos) {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
                       /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
                       "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
                       "QMenu::icon { margin-left: 6px; } "
                       "QMenu::item:selected { background-color: #4a90e2; color: white; }");

    QString iconName = m_autoCategorizeClipboard ? "switch_on" : "switch_off";
    QString iconColor = m_autoCategorizeClipboard ? "#00A650" : "#000000";
    QAction* autoCatAction = menu.addAction(IconHelper::getIcon(iconName, iconColor, 18), "剪贴板自动归档到当前分类");
    autoCatAction->setCheckable(true);
    autoCatAction->setChecked(m_autoCategorizeClipboard);
    connect(autoCatAction, &QAction::triggered, [this](bool checked){
        m_autoCategorizeClipboard = checked;
        ToolTipOverlay::instance()->showText(QCursor::pos(), m_autoCategorizeClipboard ? "✅ 剪贴板自动归档已开启" : "❌ 剪贴板自动归档已关闭");
    });

    menu.addSeparator();
    
    menu.addAction(IconHelper::getIcon("settings", "#aaaaaa", 18), "更多设置...", [this]() {
        auto* dlg = new SettingsWindow(this);
        dlg->setAttribute(Qt::WA_DeleteOnClose);
        // 预定位：居中于当前极速窗口
        dlg->move(this->geometry().center() - dlg->rect().center());
        dlg->exec();
    });

    menu.exec(QCursor::pos());
}

void QuickWindow::doMoveToCategory(int catId) {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    if (catId != -1) {
        StringUtils::recordRecentCategory(catId);
    }

    QList<int> ids;
    for (const auto& index : std::as_const(selected)) ids << index.data(NoteModel::IdRole).toInt();
    
    DatabaseManager::instance().moveNotesToCategory(ids, catId);
    refreshData();
}

void QuickWindow::handleTagInput() {
    QString text = m_tagEdit->text().trimmed();
    if (text.isEmpty()) return;
    
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QStringList tags = { text };
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().addTagsToNote(id, tags);
    }
    
    m_tagEdit->clear();
    refreshData();
    m_listView->clearSelection();
    m_listView->setCurrentIndex(QModelIndex());
    ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 标签已添加");
}

void QuickWindow::openTagSelector() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QStringList currentTags;
    if (selected.size() == 1) {
        int id = selected.first().data(NoteModel::IdRole).toInt();
        QVariantMap note = DatabaseManager::instance().getNoteById(id);
        currentTags = note.value("tags").toString().split(",", Qt::SkipEmptyParts);
    }

    for (QString& t : currentTags) t = t.trimmed();

    auto* selector = new AdvancedTagSelector(this);
    auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
    auto allTags = DatabaseManager::instance().getAllTags();
    selector->setup(recentTags, allTags, currentTags);

    connect(selector, &AdvancedTagSelector::tagsConfirmed, [this, selected](const QStringList& tags){
        for (const auto& index : std::as_const(selected)) {
            int id = index.data(NoteModel::IdRole).toInt();
            DatabaseManager::instance().updateNoteState(id, "tags", tags.join(", "));
        }
        refreshData();
        m_listView->clearSelection();
        m_listView->setCurrentIndex(QModelIndex());
        ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 标签已更新");
    });

    selector->showAtCursor();
}

void QuickWindow::doCopyTags() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    // 获取选中的第一个项的标签
    int id = selected.first().data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    QString tagsStr = note.value("tags").toString();
    QStringList tags = tagsStr.split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
    for (QString& t : tags) t = t.trimmed();

    DatabaseManager::setTagClipboard(tags);
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✅ 已复制 %1 个标签").arg(tags.size()));
}

void QuickWindow::doOCR() {
    QModelIndex index = m_listView->currentIndex();
    if (!index.isValid()) return;

    int id = index.data(NoteModel::IdRole).toInt();
    QVariantMap note = DatabaseManager::instance().getNoteById(id);
    if (note.value("item_type").toString() != "image") return;

    QByteArray data = note.value("data_blob").toByteArray();
    QImage img;
    img.loadFromData(data);
    if (img.isNull()) return;

    auto* resWin = new OCRResultWindow(img, id);
    connect(&OCRManager::instance(), &OCRManager::recognitionFinished, resWin, &OCRResultWindow::setRecognizedText);
    
    QSettings settings("RapidNotes", "OCR");
    if (settings.value("autoCopy", false).toBool()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "⏳ 正在识别文字...");
    } else {
        resWin->show();
    }
    
    OCRManager::instance().recognizeAsync(img, id);
}

void QuickWindow::doPasteTags() {
    auto selected = m_listView->selectionModel()->selectedIndexes();
    if (selected.isEmpty()) return;

    QStringList tagsToPaste = DatabaseManager::getTagClipboard();
    if (tagsToPaste.isEmpty()) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "❌ 标签剪贴板为空");
        return;
    }

    // 直接覆盖标签 (符合粘贴语义)
    for (const auto& index : std::as_const(selected)) {
        int id = index.data(NoteModel::IdRole).toInt();
        DatabaseManager::instance().updateNoteState(id, "tags", tagsToPaste.join(", "));
    }

    refreshData();
    ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✅ 已覆盖粘贴标签至 %1 条数据").arg(selected.size()));
}

void QuickWindow::focusLockInput() {
    if (m_appLockWidget) {
        static_cast<AppLockWidget*>(m_appLockWidget)->focusInput();
    }
}

void QuickWindow::showAuto() {
#ifdef Q_OS_WIN
    HWND myHwnd = (HWND)winId();
    HWND current = GetForegroundWindow();
    if (current != myHwnd) {
        m_lastActiveHwnd = current;
        m_lastThreadId = GetWindowThreadProcessId(m_lastActiveHwnd, nullptr);
        GUITHREADINFO gti;
        gti.cbSize = sizeof(GUITHREADINFO);
        if (GetGUIThreadInfo(m_lastThreadId, &gti)) {
            m_lastFocusHwnd = gti.hwndFocus;
        } else {
            m_lastFocusHwnd = nullptr;
        }
    }
#endif

    // 仅在从未保存过位置时执行居中逻辑
    QSettings settings("RapidNotes", "QuickWindow");
    if (!settings.contains("geometry")) {
        QScreen *screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect screenGeom = screen->geometry();
            move(screenGeom.center() - rect().center());
        }
    }

    QPoint targetPos = pos();
    bool wasHidden = !isVisible() || isMinimized();

    if (isMinimized()) {
        showNormal();
    } else {
        show();
    }

    if (wasHidden) {
        setWindowOpacity(0);
        auto* fade = new QPropertyAnimation(this, "windowOpacity");
        fade->setDuration(300);
        fade->setStartValue(0.0);
        fade->setEndValue(1.0);
        fade->setEasingCurve(QEasingCurve::OutCubic);

        auto* slide = new QPropertyAnimation(this, "pos");
        slide->setDuration(300);
        slide->setStartValue(targetPos + QPoint(0, 10));
        slide->setEndValue(targetPos);
        slide->setEasingCurve(QEasingCurve::OutCubic);

        fade->start(QAbstractAnimation::DeleteWhenStopped);
        slide->start(QAbstractAnimation::DeleteWhenStopped);
    }
    
    raise();
    activateWindow();
    
#ifdef Q_OS_WIN
    // 强制置顶并激活，即使在其他窗口之后也能强制唤起
    SetForegroundWindow(myHwnd);
#endif

    if (isLocked()) {
        focusLockInput();
    } else {
        m_searchEdit->setFocus();
        m_searchEdit->selectAll();
    }
}

void QuickWindow::showEvent(QShowEvent* event) {
    QWidget::showEvent(event);
    
    // 强制每次显示时都清除选择，确保输入框初始处于禁用状态
    if (m_listView && m_listView->selectionModel()) {
        m_listView->clearSelection();
        m_listView->setCurrentIndex(QModelIndex());
    }

#ifdef Q_OS_WIN
    HWND myHwnd = (HWND)winId();
    if (m_isStayOnTop) {
        SetWindowPos(myHwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    } else {
        // 瞬间置顶再取消，确保能强制唤起
        SetWindowPos(myHwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        QTimer::singleShot(150, [myHwnd]() {
            SetWindowPos(myHwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        });
    }
#endif
}

#ifdef Q_OS_WIN
bool QuickWindow::nativeEvent(const QByteArray &eventType, void *message, qintptr *result) {
    MSG* msg = static_cast<MSG*>(message);
    if (msg->message == WM_NCHITTEST) {
        // 原生边缘检测，实现丝滑的双向箭头缩放体验
        int x = GET_X_LPARAM(msg->lParam);
        int y = GET_Y_LPARAM(msg->lParam);
        
        // 转换为本地坐标
        QPoint pos = mapFromGlobal(QPoint(x, y));
        int margin = RESIZE_MARGIN;
        int w = width();
        int h = height();

        bool left = pos.x() < margin;
        bool right = pos.x() > w - margin;
        bool top = pos.y() < margin;
        bool bottom = pos.y() > h - margin;

        if (top && left) *result = HTTOPLEFT;
        else if (top && right) *result = HTTOPRIGHT;
        else if (bottom && left) *result = HTBOTTOMLEFT;
        else if (bottom && right) *result = HTBOTTOMRIGHT;
        else if (top) *result = HTTOP;
        else if (bottom) *result = HTBOTTOM;
        else if (left) *result = HTLEFT;
        else if (right) *result = HTRIGHT;
        else return QWidget::nativeEvent(eventType, message, result);

        return true;
    }
    return QWidget::nativeEvent(eventType, message, result);
}
#endif

bool QuickWindow::event(QEvent* event) {
    return QWidget::event(event);
}

void QuickWindow::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        // 不在边距区域，启动移动窗口（只有点击空白处时）
        if (auto* handle = windowHandle()) {
            handle->startSystemMove();
        }
        event->accept();
    }
}

void QuickWindow::mouseMoveEvent(QMouseEvent* event) {
    QWidget::mouseMoveEvent(event);
}

void QuickWindow::mouseReleaseEvent(QMouseEvent* event) {
    QWidget::mouseReleaseEvent(event);
}

void QuickWindow::dragEnterEvent(QDragEnterEvent* event) {
    if (event->mimeData()->hasUrls() || event->mimeData()->hasText() || event->mimeData()->hasImage()) {
        event->acceptProposedAction();
    }
}

void QuickWindow::dragMoveEvent(QDragMoveEvent* event) {
    event->acceptProposedAction();
}

void QuickWindow::dropEvent(QDropEvent* event) {
    const QMimeData* mime = event->mimeData();
    int targetId = -1;
    if (m_currentFilterType == "category") {
        targetId = m_currentFilterValue.toInt();
    }

    QString itemType = "text";
    QString title;
    QString content;
    QByteArray dataBlob;
    QStringList tags;

    if (mime->hasText() && !mime->text().trimmed().isEmpty()) {
        content = mime->text();
        title = content.trimmed().left(50).replace("\n", " ");
        itemType = "text";
    } else if (mime->hasUrls()) {
        QList<QUrl> urls = mime->urls();
        QStringList paths;
        for (const QUrl& url : std::as_const(urls)) {
            if (url.isLocalFile()) {
                QString p = url.toLocalFile();
                paths << p;
                if (title.isEmpty()) {
                    QFileInfo info(p);
                    title = info.fileName();
                    itemType = info.isDir() ? "folder" : "file";
                }
            } else {
                paths << url.toString();
                if (title.isEmpty()) {
                    title = "外部链接";
                    itemType = "link";
                }
            }
        }
        content = paths.join(";");
        if (paths.size() > 1) {
            title = QString("批量导入 (%1个文件)").arg(paths.size());
            itemType = "files";
        }
    } else if (mime->hasImage()) {
        QImage img = qvariant_cast<QImage>(mime->imageData());
        if (!img.isNull()) {
            QBuffer buffer(&dataBlob);
            buffer.open(QIODevice::WriteOnly);
            img.save(&buffer, "PNG");
            itemType = "image";
            title = "[拖入图片] " + QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss");
            content = "[Image Data]";
        }
    }

    if (!content.isEmpty() || !dataBlob.isEmpty()) {
        DatabaseManager::instance().addNote(title, content, tags, "", targetId, itemType, dataBlob);
        event->acceptProposedAction();
    }
}

void QuickWindow::hideEvent(QHideEvent* event) {
    // 保护：仅在非系统自发（spontaneous）且窗口确实不可见时才可能退出
    // 防止初始化或某些 Windows 系统消息导致的误退
    if (m_appLockWidget && !event->spontaneous() && !isVisible()) {
        qDebug() << "[QuickWin] 退出程序，因为应用锁处于活动状态且窗口被隐藏";
        QApplication::quit();
    }
    saveState();
    QWidget::hideEvent(event);
}

void QuickWindow::resizeEvent(QResizeEvent* event) {
    if (m_appLockWidget) {
        m_appLockWidget->resize(this->size());
    }
    QWidget::resizeEvent(event);
    saveState();
}

void QuickWindow::moveEvent(QMoveEvent* event) {
    QWidget::moveEvent(event);
    saveState();
}

void QuickWindow::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Escape) {
        hide();
        return;
    }
    QWidget::keyPressEvent(event);
}

bool QuickWindow::eventFilter(QObject* watched, QEvent* event) {
    // 逻辑 1: 鼠标移动到列表或侧边栏范围内，立即恢复正常光标
    if (watched == m_listView || watched == m_systemTree || watched == m_partitionTree) {
        if (event->type() == QEvent::MouseMove || event->type() == QEvent::Enter) {
            setCursor(Qt::ArrowCursor);
        }
    }

    // 逻辑 2: 侧边栏点击分类且不释放左键时，显示手指光标
    if (watched == m_partitionTree && event->type() == QEvent::KeyPress) {
        QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
        int key = keyEvent->key();
        auto modifiers = keyEvent->modifiers();

        if ((key == Qt::Key_Up || key == Qt::Key_Down) && (modifiers & Qt::ControlModifier)) {
            QModelIndex current = m_partitionTree->currentIndex();
            if (current.isValid() && current.data(CategoryModel::TypeRole).toString() == "category") {
                int catId = current.data(CategoryModel::IdRole).toInt();
                DatabaseManager::MoveDirection dir;

                if (key == Qt::Key_Up) {
                    dir = (modifiers & Qt::ShiftModifier) ? DatabaseManager::Top : DatabaseManager::Up;
                } else {
                    dir = (modifiers & Qt::ShiftModifier) ? DatabaseManager::Bottom : DatabaseManager::Down;
                }

                if (DatabaseManager::instance().moveCategory(catId, dir)) {
                    refreshSidebar();
                    return true;
                }
            }
        }
    }

    if (watched == m_systemTree || watched == m_partitionTree) {
        if (event->type() == QEvent::MouseButtonPress) {
            QMouseEvent* me = static_cast<QMouseEvent*>(event);
            if (me->button() == Qt::LeftButton) {
                QTreeView* tree = qobject_cast<QTreeView*>(watched);
                if (tree && tree->indexAt(me->pos()).isValid()) {
                    setCursor(Qt::PointingHandCursor);
                }
            }
        } else if (event->type() == QEvent::MouseButtonRelease) {
            setCursor(Qt::ArrowCursor);
        }
    }

    if ((watched == m_listView || watched == m_searchEdit) && event->type() == QEvent::KeyPress) {
        QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
        if (keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Enter) {
            if (watched == m_listView) {
                activateNote(m_listView->currentIndex());
                return true;
            }
        }
        if (keyEvent->key() == Qt::Key_Escape) {
            hide();
            return true;
        }
    }
    return QWidget::eventFilter(watched, event);
}

void DittoListView::startDrag(Qt::DropActions supportedActions) {
    // 深度对齐 Ditto：禁用笨重的快照卡片 Pixmap，保持视觉清爽
    QDrag* drag = new QDrag(this);
    drag->setMimeData(model()->mimeData(selectedIndexes()));
    
    // 【深度修复】提供 1x1 透明占位符。
    // 许多现代应用（如 Chrome）在 Windows 上执行 DND 时会验证拖拽图像。
    // 如果完全没有 Pixmap，投放信号可能无法在网页输入框触发。
    QPixmap pix(1, 1);
    pix.fill(Qt::transparent);
    drag->setPixmap(pix);
    drag->setHotSpot(QPoint(0, 0));
    
    // 【核心修复】显式指定默认动作为 CopyAction。
    // 许多外部应用（特别是网页浏览器）需要明确的 Copy 握手信号。
    drag->exec(Qt::CopyAction | Qt::MoveAction, Qt::CopyAction);
}

void DittoListView::mousePressEvent(QMouseEvent* event) {
    QModelIndex index = indexAt(event->pos());
    if (!index.isValid()) {
        // 点击在空白区域，清除选择
        clearSelection();
        setCurrentIndex(QModelIndex());
    }
    QListView::mousePressEvent(event);
}

#include "QuickWindow.moc"
```

## 文件: `src/ui/QuickWindow.h`

```cpp
#ifndef QUICKWINDOW_H
#define QUICKWINDOW_H

#include <QWidget>
#include "SearchLineEdit.h"
#include <QListView>
#include <QTreeView>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QSplitter>
#include <QLabel>
#include <QTimer>
#include <QKeyEvent>
#include <QResizeEvent>
#include <QHideEvent>
#include "../models/NoteModel.h"
#include "../models/CategoryModel.h"
#include "QuickPreview.h"
#include "DropTreeView.h"
#include "CategoryLockWidget.h"
#include "ClickableLineEdit.h"
#include <QShortcut>

#ifdef Q_OS_WIN
#include <windows.h>
#include <windowsx.h>
#endif

// 自定义列表视图，实现 Ditto 风格的轻量化拖拽
class DittoListView : public QListView {
    Q_OBJECT
public:
    using QListView::QListView;
protected:
    void startDrag(Qt::DropActions supportedActions) override;
    void mousePressEvent(QMouseEvent* event) override;
};

class QuickWindow : public QWidget {
    Q_OBJECT
public:
    explicit QuickWindow(QWidget* parent = nullptr);
    void showAuto();
    void focusLockInput();
    void saveState();
    void restoreState();

public slots:
    void refreshData();
    void scheduleRefresh();
    void onNoteAdded(const QVariantMap& note);

signals:
    void toggleMainWindowRequested();
    void toolboxRequested();

protected:
#ifdef Q_OS_WIN
    bool nativeEvent(const QByteArray &eventType, void *message, qintptr *result) override;
#endif
    bool event(QEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;
    void showEvent(QShowEvent* event) override;
    void hideEvent(QHideEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void resizeEvent(QResizeEvent* event) override;
    void moveEvent(QMoveEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

private:
    void initUI();
    void setupAppLock();
    void activateNote(const QModelIndex& index);
    void setupShortcuts();
    void updatePartitionStatus(const QString& name);
    void refreshSidebar();
    void applyListTheme(const QString& colorHex);
    void updateShortcuts();
public:
    QString currentCategoryColor() const { return m_currentCategoryColor; }
    bool isAutoCategorizeEnabled() const { return m_autoCategorizeClipboard; }
    bool isLocked() const { return m_appLockWidget != nullptr; }
    int getCurrentCategoryId() const { return (m_currentFilterType == "category") ? m_currentFilterValue.toInt() : -1; }

    // 快捷键处理函数
    void doDeleteSelected(bool physical = false);
    void doToggleFavorite();
    void doTogglePin();
    void doLockSelected();
    void doNewIdea();
    void doExtractContent();
    void doOCR();
    void doEditSelected();
    void doEditNote(int id);
    void doSetRating(int rating);
    void doMoveToCategory(int catId);
    void doRestoreTrash();
    void doPreview();
    void doGlobalLock();
    void toggleStayOnTop(bool checked);
    void toggleSidebar();
    void showListContextMenu(const QPoint& pos);
    void showSidebarMenu(const QPoint& pos);
    void showToolboxMenu(const QPoint& pos);
    void updatePreviewContent();
    void handleTagInput();
    void openTagSelector();
    void doCopyTags();
    void doPasteTags();
    
    SearchLineEdit* m_searchEdit;
    QListView* m_listView;
    CategoryLockWidget* m_lockWidget;
    QWidget* m_appLockWidget = nullptr;
    NoteModel* m_model;
    QuickPreview* m_quickPreview;
    
    DropTreeView* m_systemTree;
    DropTreeView* m_partitionTree;
    CategoryModel* m_systemModel;
    CategoryModel* m_partitionModel;
    
    QTimer* m_searchTimer;
    QTimer* m_monitorTimer;
    QTimer* m_refreshTimer;
    QSplitter* m_splitter;
    QLabel* m_statusLabel;
    ClickableLineEdit* m_tagEdit;
    QList<QShortcut*> m_shortcuts;

    int m_currentPage = 1;
    int m_totalPages = 1;
    QString m_currentFilterType = "all";
    QVariant m_currentFilterValue = -1;
    QString m_currentCategoryColor = "#4a90e2"; // 默认蓝色
    bool m_autoCategorizeClipboard = false;
    bool m_isStayOnTop = false;

#ifdef Q_OS_WIN
    HWND m_lastActiveHwnd = nullptr;
    HWND m_lastFocusHwnd = nullptr;
    DWORD m_lastThreadId = 0;
#endif
};

#endif // QUICKWINDOW_H
```

## 文件: `src/ui/ResizeHandle.cpp`

```cpp
#include "ResizeHandle.h"

ResizeHandle::ResizeHandle(QWidget* target, QWidget* parent) 
    : QWidget(parent), m_target(target) 
{
    setFixedSize(20, 20);
    setCursor(Qt::SizeFDiagCursor);
}

void ResizeHandle::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_startPos = event->globalPosition().toPoint();
        m_startSize = m_target->size();
        event->accept();
    }
}

void ResizeHandle::mouseMoveEvent(QMouseEvent* event) {
    if (event->buttons() & Qt::LeftButton) {
        QPoint delta = event->globalPosition().toPoint() - m_startPos;
        int newW = qMax(m_startSize.width() + delta.x(), 600);
        int newH = qMax(m_startSize.height() + delta.y(), 400);
        m_target->resize(newW, newH);
        event->accept();
    }
}
```

## 文件: `src/ui/ResizeHandle.h`

```cpp
#ifndef RESIZEHANDLE_H
#define RESIZEHANDLE_H

#include <QWidget>
#include <QMouseEvent>

/**
 * @brief 隐形调整大小手柄
 */
class ResizeHandle : public QWidget {
    Q_OBJECT
public:
    explicit ResizeHandle(QWidget* target, QWidget* parent = nullptr);

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;

private:
    QWidget* m_target;
    QPoint m_startPos;
    QSize m_startSize;
};

#endif // RESIZEHANDLE_H
```

## 文件: `src/ui/ScreenshotTool.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "ScreenshotTool.h"
#include "StringUtils.h"

#include "IconHelper.h"
#include <QApplication>
#include <QScreen>
#include <QPainterPathStroker>
#include <QWheelEvent>
#include <QScrollArea>
#include <QScrollBar>
#include <QFileDialog>
#include <QClipboard>
#include <QMenu>
#include <QWidgetAction>
#include <QComboBox>
#include <QFontComboBox>
#include <QDateTime>
#include <QInputDialog>
#include <QFontMetrics>
#include <QStyle>
#include <QStyleOption>
#include <QColorDialog>
#include <QSettings>
#include <QToolTip>
#include <QAbstractItemView>
#include <QDir>
#include <QGraphicsDropShadowEffect>
#include <QCoreApplication>
#include <cmath>

#ifdef Q_OS_WIN
#include <windows.h>
#include <dwmapi.h>
#include <tchar.h>
#pragma comment(lib, "dwmapi.lib")

QRect getActualWindowRect(HWND hwnd) {
    RECT rect;
    if (SUCCEEDED(DwmGetWindowAttribute(hwnd, DWMWA_EXTENDED_FRAME_BOUNDS, &rect, sizeof(rect)))) {
        return QRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
    }
    GetWindowRect(hwnd, &rect);
    return QRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
}
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

static QList<QColor> getStandardColorList() {
    return {
        QColor(255, 0, 0), QColor(255, 165, 0), QColor(255, 255, 0), QColor(0, 255, 0),
        QColor(0, 255, 255), QColor(0, 0, 255), QColor(128, 0, 128), QColor(0, 0, 0), QColor(255, 255, 255)
    };
}

class IconFactory {
public:
    static QIcon createArrowStyleIcon(ArrowStyle style) {
        // 增大图标画布，以适应无文本的宽型菜单
        QPixmap pix(120, 32);
        pix.fill(Qt::transparent);
        QPainter p(&pix);
        p.setRenderHint(QPainter::Antialiasing);
        p.setPen(QPen(Qt::white, 2.5, Qt::SolidLine, Qt::FlatCap, Qt::RoundJoin));
        p.setBrush(Qt::white);
        
        QPointF start(10, 16), end(110, 16);
        QPointF dir = end - start;
        double angle = std::atan2(dir.y(), dir.x());
        double len = 100.0;

        bool isOutline = (style == ArrowStyle::OutlineSingle || style == ArrowStyle::OutlineDouble || style == ArrowStyle::OutlineDot);
        
        if (style == ArrowStyle::SolidSingle || style == ArrowStyle::OutlineSingle) {
            double hLen = 22;
            double bWid = 10;
            double wLen = 18;
            double wWid = 3;
            QPointF unit_dir = dir / len;
            QPointF perp_dir(-unit_dir.y(), unit_dir.x());

            if (isOutline) {
                p.setPen(QPen(Qt::white, 2.0));
                p.setBrush(Qt::transparent);
            } else {
                p.setPen(Qt::NoPen);
                p.setBrush(Qt::white);
            }
            p.drawPolygon(QPolygonF() << end 
                << end - unit_dir * hLen + perp_dir * bWid
                << end - unit_dir * wLen + perp_dir * wWid
                << start
                << end - unit_dir * wLen - perp_dir * wWid
                << end - unit_dir * hLen - perp_dir * bWid);
        } else if (style == ArrowStyle::Thin) {
            p.setPen(QPen(Qt::white, 3.0, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
            p.drawLine(start, end);
            double headSize = 18;
            p.drawLine(end, end - QPointF(headSize * std::cos(angle - 0.5), headSize * std::sin(angle - 0.5)));
            p.drawLine(end, end - QPointF(headSize * std::cos(angle + 0.5), headSize * std::sin(angle + 0.5)));
        } else if (style == ArrowStyle::SolidDouble || style == ArrowStyle::OutlineDouble) {
            p.setPen(QPen(Qt::white, 2.0));
            if (isOutline) p.setBrush(Qt::transparent); else p.setBrush(Qt::white);
            auto drawH = [&](const QPointF& e, double ang) {
                QPointF du(std::cos(ang), std::sin(ang));
                QPointF dp(-du.y(), du.x());
                p.drawPolygon(QPolygonF() << e << e - du * 16 + dp * 8 << e - du * 13 + dp * 2 << e - du * 13 - dp * 2 << e - du * 16 - dp * 8);
            };
            p.drawLine(start + (dir/len)*12, end - (dir/len)*12);
            drawH(end, angle); drawH(start, angle + M_PI);
        } else if (style == ArrowStyle::SolidDot || style == ArrowStyle::OutlineDot) {
            p.setPen(QPen(Qt::white, 2.0));
            if (isOutline) p.setBrush(Qt::transparent); else p.setBrush(Qt::white);
            p.drawLine(start, end - (dir/len)*12);
            p.drawEllipse(start, 5, 5);
            QPointF du(std::cos(angle), std::sin(angle));
            QPointF dp(-du.y(), du.x());
            p.drawPolygon(QPolygonF() << end << end - du * 16 + dp * 8 << end - du * 13 + dp * 2 << end - du * 13 - dp * 2 << end - du * 16 - dp * 8);
        } else if (style == ArrowStyle::Dimension) {
            p.setPen(QPen(Qt::white, 2.5, Qt::SolidLine, Qt::FlatCap, Qt::RoundJoin));
            p.drawLine(start, end);
            QPointF du(std::cos(angle), std::sin(angle));
            QPointF dp(-du.y(), du.x());
            p.drawLine(start + dp * 8, start - dp * 8);
            p.drawLine(end + dp * 8, end - dp * 8);
        }
        return QIcon(pix);
    }
};

PinnedScreenshotWidget::PinnedScreenshotWidget(const QPixmap& pixmap, const QRect& screenRect, QWidget* parent)
    : QWidget(nullptr, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool), m_pixmap(pixmap)
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_DeleteOnClose);
    setFixedSize(pixmap.size() / pixmap.devicePixelRatio());
    move(screenRect.topLeft());
}

void PinnedScreenshotWidget::paintEvent(QPaintEvent*) {
    QPainter p(this);
    p.drawPixmap(rect(), m_pixmap);
    p.setPen(QPen(QColor(0, 120, 255, 200), 2));
    p.drawRect(rect().adjusted(0, 0, -1, -1));
}

void PinnedScreenshotWidget::mousePressEvent(QMouseEvent* e) {
    if (e->button() == Qt::LeftButton) m_dragPos = e->globalPosition().toPoint() - frameGeometry().topLeft();
}

void PinnedScreenshotWidget::mouseMoveEvent(QMouseEvent* e) {
    if (e->buttons() & Qt::LeftButton) move(e->globalPosition().toPoint() - m_dragPos);
}

void PinnedScreenshotWidget::mouseDoubleClickEvent(QMouseEvent*) { close(); }
void PinnedScreenshotWidget::contextMenuEvent(QContextMenuEvent* e) {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    menu.addAction("复制", [this](){ 
        ClipboardMonitor::instance().forceNext();
        QApplication::clipboard()->setPixmap(m_pixmap); 
    });
    menu.addAction("保存", [this](){
        QString fileName = QString("RPN_%1.png").arg(QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss"));
        QString f = QFileDialog::getSaveFileName(this, "保存截图", fileName, "PNG(*.png)");
        if(!f.isEmpty()) m_pixmap.save(f);
    });
    menu.addSeparator();
    menu.addAction("关闭", this, &QWidget::close);
    menu.exec(e->globalPos());
}

SelectionInfoBar::SelectionInfoBar(QWidget* parent) : QWidget(parent) {
    setAttribute(Qt::WA_TransparentForMouseEvents);
    setFixedSize(180, 28);
    hide();
}
void SelectionInfoBar::updateInfo(const QRect& rect) {
    m_text = QString("%1, %2 | %3 x %4").arg(rect.x()).arg(rect.y()).arg(rect.width()).arg(rect.height());
    update();
}
void SelectionInfoBar::paintEvent(QPaintEvent*) {
    QPainter p(this); p.setRenderHint(QPainter::Antialiasing);
    p.setBrush(QColor(0, 0, 0, 200)); p.setPen(Qt::NoPen);
    p.drawRoundedRect(rect(), 4, 4);
    p.setPen(Qt::white); p.setFont(QFont("Arial", 9));
    p.drawText(rect(), Qt::AlignCenter, m_text);
}

ScreenshotToolbar::ScreenshotToolbar(ScreenshotTool* tool) 
    : QWidget(nullptr, Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint) 
{
    m_tool = tool;
    setObjectName("ScreenshotToolbar");
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_AlwaysShowToolTips);
    setMouseTracking(true);

    setStyleSheet(R"(
        #MainContainer { 
            background-color: #2D2D2D; 
            border: 1px solid rgba(255, 255, 255, 0.1); 
            border-radius: 12px; 
        }
        #ToolRow, #OptionWidget {
            background: transparent;
        }
        QPushButton { 
            background: transparent; 
            border: none; 
            border-radius: 4px; 
            padding: 4px; 
        }
        #MainContainer QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }
        #MainContainer QPushButton:checked { background-color: #007ACC; }
        #OptionWidget { 
            background: transparent; 
        }
        QPushButton[colorBtn="true"] { padding: 0px; border-radius: 2px; }
        QPushButton[sizeBtn="true"] { background-color: #777; border-radius: 50%; }
        QPushButton[sizeBtn="true"]:checked { background-color: #007ACC; }
        QPushButton[sizeBtn="true"]:checked { background-color: #007ACC; }
    )");
    setAttribute(Qt::WA_StyledBackground);

    auto* outerLayout = new QVBoxLayout(this);
    outerLayout->setContentsMargins(6, 6, 6, 6);
    outerLayout->setSpacing(0);
    outerLayout->setSizeConstraint(QLayout::SetFixedSize);

    QFrame* mainContainer = new QFrame;
    mainContainer->setObjectName("MainContainer");
    mainContainer->setAttribute(Qt::WA_StyledBackground);
    outerLayout->addWidget(mainContainer);

    auto* mainLayout = new QVBoxLayout(mainContainer);
    mainLayout->setContentsMargins(4, 2, 4, 2); mainLayout->setSpacing(0);
    // [CRITICAL] 设置尺寸约束为 SetFixedSize，确保工具栏在子部件隐藏时能自动收缩高度，防止出现多余背景 / Use SetFixedSize to ensure toolbar shrinks when options are hidden
    mainLayout->setSizeConstraint(QLayout::SetFixedSize);
    
    QWidget* toolRow = new QWidget;
    toolRow->setObjectName("ToolRow");
    auto* layout = new QHBoxLayout(toolRow);
    layout->setContentsMargins(6, 4, 6, 4); layout->setSpacing(2);

    addToolButton(layout, ScreenshotToolType::Rect, "screenshot_rect", "矩形 (R)");
    addToolButton(layout, ScreenshotToolType::Ellipse, "screenshot_ellipse", "椭圆 (E)");
    addToolButton(layout, ScreenshotToolType::Arrow, "screenshot_arrow", "箭头 (A)");
    addToolButton(layout, ScreenshotToolType::Line, "screenshot_line", "直线 (L)");
    
    addToolButton(layout, ScreenshotToolType::Pen, "screenshot_pen", "画笔 (P)");
    addToolButton(layout, ScreenshotToolType::Marker, "screenshot_marker", "记号笔 (M)");
    addToolButton(layout, ScreenshotToolType::Text, "screenshot_text", "文字 (T)");
    addToolButton(layout, ScreenshotToolType::Mosaic, "screenshot_mosaic", "画笔马赛克 (Z)");
    addToolButton(layout, ScreenshotToolType::MosaicRect, "screenshot_rect", "矩形马赛克 (M)");
    addToolButton(layout, ScreenshotToolType::Eraser, "screenshot_eraser", "橡皮擦 (X)");
    addToolButton(layout, ScreenshotToolType::Picker, "screen_picker", "取色器 (C)");

    layout->addSpacing(8);

    QFrame* divider = new QFrame();
    divider->setFrameShape(QFrame::VLine);
    divider->setFrameShadow(QFrame::Plain);
    divider->setStyleSheet("background-color: #555;");
    divider->setFixedWidth(1);
    divider->setFixedHeight(20);
    layout->addWidget(divider);

    layout->addSpacing(8);
    
    addActionButton(layout, "undo", "撤销 (Ctrl+Z)", [tool]{ tool->undo(); });
    addActionButton(layout, "redo", "重做 (Ctrl+Shift+Z)", [tool]{ tool->redo(); });
    addActionButton(layout, "screenshot_pin", "置顶截图 (F)", [tool]{ tool->pin(); });
    addActionButton(layout, "screenshot_ocr", "截图取文 (O)", [tool]{ tool->executeOCR(); });
    addActionButton(layout, "screenshot_save", "保存", [tool]{ tool->save(); });
    addActionButton(layout, "screenshot_copy", "复制 (Ctrl+C)", [tool]{ tool->copyToClipboard(); });
    addActionButton(layout, "screenshot_close", "取消 (Esc)", [tool]{ tool->cancel(); }); 
    addActionButton(layout, "screenshot_confirm", "完成 (Enter)", [tool]{ tool->confirm(); });

    mainLayout->addWidget(toolRow);

    // [CRITICAL] 水平分割线，用于分隔工具行和选项行 / Horizontal divider between tool row and option row
    m_horizontalDivider = new QFrame();
    m_horizontalDivider->setFrameShape(QFrame::HLine);
    m_horizontalDivider->setFrameShadow(QFrame::Plain);
    m_horizontalDivider->setStyleSheet("background-color: #555;");
    m_horizontalDivider->setFixedHeight(1);
    m_horizontalDivider->setVisible(false);
    mainLayout->addWidget(m_horizontalDivider);

    createOptionWidget();
    mainLayout->addWidget(m_optionWidget);
}

void ScreenshotToolbar::addToolButton(QBoxLayout* layout, ScreenshotToolType type, const QString& iconName, const QString& tip) {
    auto* btn = new QPushButton();
    btn->setAttribute(Qt::WA_StyledBackground);
    btn->setIcon(IconHelper::getIcon(iconName)); btn->setIconSize(QSize(20, 20));
    btn->setToolTip(tip); btn->setCheckable(true); btn->setFixedSize(32, 32);
    layout->addWidget(btn); m_buttons[type] = btn;
    connect(btn, &QPushButton::clicked, [this, type]{ selectTool(type); });
}

void ScreenshotToolbar::addActionButton(QBoxLayout* layout, const QString& iconName, const QString& tip, std::function<void()> func) {
    auto* btn = new QPushButton();
    btn->setAttribute(Qt::WA_StyledBackground);
    btn->setIcon(IconHelper::getIcon(iconName)); btn->setIconSize(QSize(20, 20));
    btn->setToolTip(tip); btn->setFixedSize(32, 32);
    layout->addWidget(btn); connect(btn, &QPushButton::clicked, func);
}

void ScreenshotToolbar::createOptionWidget() {
    m_optionWidget = new QWidget; m_optionWidget->setObjectName("OptionWidget");
    m_optionWidget->setAttribute(Qt::WA_TranslucentBackground);
    auto* layout = new QHBoxLayout(m_optionWidget); layout->setContentsMargins(8, 4, 8, 4); layout->setSpacing(4);

    // 1. 箭头样式按钮 (迁移至最左侧)
    m_arrowStyleBtn = new QPushButton(); m_arrowStyleBtn->setFixedSize(56, 24);
    updateArrowButtonIcon(m_tool->m_currentArrowStyle); m_arrowStyleBtn->setToolTip("箭头样式 (W)");
    connect(m_arrowStyleBtn, &QPushButton::clicked, this, &ScreenshotToolbar::showArrowMenu);
    layout->addWidget(m_arrowStyleBtn);

    // 2. 形状填充选项 (Rect/Ellipse)
    m_outlineBtn = new QPushButton();
    m_outlineBtn->setCheckable(true);
    m_outlineBtn->setFixedSize(24, 24);
    m_outlineBtn->setIcon(IconHelper::getIcon("screenshot_rect", "#ffffff"));
    m_outlineBtn->setToolTip("虚心 (Hollow)");
    m_outlineBtn->setStyleSheet("QPushButton { border: 1px solid #555; border-radius: 4px; } QPushButton:checked { background-color: #007ACC; border-color: #007ACC; }");
    
    m_solidBtn = new QPushButton();
    m_solidBtn->setCheckable(true);
    m_solidBtn->setFixedSize(24, 24);
    m_solidBtn->setIcon(IconHelper::getIcon("screenshot_fill", "#ffffff"));
    m_solidBtn->setToolTip("实心 (Solid)");
    m_solidBtn->setStyleSheet("QPushButton { border: 1px solid #555; border-radius: 4px; } QPushButton:checked { background-color: #007ACC; border-color: #007ACC; }");

    auto* fillGroup = new QButtonGroup(this);
    fillGroup->addButton(m_outlineBtn);
    fillGroup->addButton(m_solidBtn);
    layout->addWidget(m_outlineBtn);
    layout->addWidget(m_solidBtn);
    if (m_tool->m_fillEnabled) m_solidBtn->setChecked(true); else m_outlineBtn->setChecked(true);
    connect(m_outlineBtn, &QPushButton::clicked, [this]{ m_tool->setFillEnabled(false); });
    connect(m_solidBtn, &QPushButton::clicked, [this]{ m_tool->setFillEnabled(true); });

    // 3. 文字选项 (Text) - 采用独立胶囊布局 (Independent capsule layout)
    m_textOptionWidget = new QWidget;
    m_textOptionWidget->setAttribute(Qt::WA_TranslucentBackground);
    m_textOptionWidget->setStyleSheet("background: transparent; border: none;");
    auto* textOptionLayout = new QHBoxLayout(m_textOptionWidget);
    textOptionLayout->setContentsMargins(0, 0, 0, 0); textOptionLayout->setSpacing(4);

    auto createCapsule = [](QWidget* content, int width = -1) {
        QWidget* capsule = new QWidget;
        capsule->setFixedHeight(28);
        if (width > 0) capsule->setFixedWidth(width);
        capsule->setAttribute(Qt::WA_StyledBackground);
        capsule->setStyleSheet("background-color: #3D3D3D; border-radius: 6px; border: none;");
        auto* l = new QHBoxLayout(capsule);
        l->setContentsMargins(4, 0, 4, 0);
        l->setSpacing(0);
        l->addWidget(content);
        return capsule;
    };

    m_boldBtn = new QPushButton(); m_boldBtn->setCheckable(true); m_boldBtn->setFixedSize(24, 24);
    m_boldBtn->setIcon(IconHelper::getIcon("bold", "#ffffff")); m_boldBtn->setToolTip("加粗 (Bold)");
    m_boldBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } QPushButton:hover { background-color: #555; } QPushButton:checked { background-color: #007ACC; }");
    m_boldBtn->setChecked(m_tool->m_currentBold);
    connect(m_boldBtn, &QPushButton::toggled, [this](bool checked){ m_tool->setBold(checked); });
    textOptionLayout->addWidget(createCapsule(m_boldBtn, 32));

    m_italicBtn = new QPushButton(); m_italicBtn->setCheckable(true); m_italicBtn->setFixedSize(24, 24);
    m_italicBtn->setIcon(IconHelper::getIcon("italic", "#ffffff")); m_italicBtn->setToolTip("倾斜 (Italic)");
    m_italicBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } QPushButton:hover { background-color: #555; } QPushButton:checked { background-color: #007ACC; }");
    m_italicBtn->setChecked(m_tool->m_currentItalic);
    connect(m_italicBtn, &QPushButton::toggled, [this](bool checked){ m_tool->setItalic(checked); });
    textOptionLayout->addWidget(createCapsule(m_italicBtn, 32));

    auto* fontCombo = new QComboBox(); fontCombo->addItems({"微软雅黑", "宋体", "黑体", "楷体", "Arial", "Consolas"});
    fontCombo->setCurrentText(m_tool->m_currentFontFamily); fontCombo->setFixedSize(100, 28);
    fontCombo->setAttribute(Qt::WA_StyledBackground);
    fontCombo->setAttribute(Qt::WA_TranslucentBackground);
    fontCombo->view()->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    fontCombo->setStyleSheet(R"(
        QComboBox { background-color: #3D3D3D; color: white; border: 1px solid transparent; border-radius: 6px; padding-left: 8px; }
        QComboBox::drop-down { width: 0px; border: none; }
        QComboBox QAbstractItemView { 
            background-color: #3D3D3D; 
            color: white;
            selection-background-color: transparent;
            border: 1px solid #555; 
            border-radius: 6px; 
            outline: none;
            padding: 2px;
        }
        QComboBox QAbstractItemView::item { 
            height: 18px; 
            border-radius: 3px; 
            padding: 0px 4px; 
            margin: 1px 2px;
            color: white;
            border: none;
        }
        QComboBox QAbstractItemView::item:selected { 
            background-color: #007ACC; 
            color: white; 
        }
        QScrollBar:vertical { width: 0px; background: transparent; }
    )");
    connect(fontCombo, &QComboBox::currentTextChanged, [this](const QString& font){ m_tool->setFontFamily(font); });
    fontCombo->view()->window()->setAttribute(Qt::WA_TranslucentBackground);
    fontCombo->view()->window()->setWindowFlags(Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint);
    fontCombo->view()->setFixedWidth(100);
    textOptionLayout->addWidget(fontCombo);

    auto* sizeCombo = new QComboBox();
    for(int s : {10, 12, 14, 16, 18, 20, 24, 28, 32, 36, 48}) sizeCombo->addItem(QString::number(s), s);
    sizeCombo->setCurrentIndex(sizeCombo->findData(m_tool->m_currentFontSize)); sizeCombo->setFixedSize(50, 28);
    sizeCombo->setAttribute(Qt::WA_StyledBackground);
    sizeCombo->setAttribute(Qt::WA_TranslucentBackground);
    sizeCombo->view()->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    sizeCombo->setStyleSheet(R"(
        QComboBox { background-color: #3D3D3D; color: white; border: 1px solid transparent; border-radius: 6px; padding-left: 8px; }
        QComboBox::drop-down { width: 0px; border: none; }
        QComboBox QAbstractItemView { 
            background-color: #3D3D3D; 
            color: white;
            selection-background-color: transparent;
            border: 1px solid #555; 
            border-radius: 6px; 
            outline: none;
            padding: 2px;
        }
        QComboBox QAbstractItemView::item { 
            height: 18px; 
            border-radius: 3px; 
            padding: 0px 4px; 
            margin: 1px 2px;
            color: white;
            border: none;
        }
        QComboBox QAbstractItemView::item:selected { 
            background-color: #007ACC; 
            color: white; 
        }
        QScrollBar:vertical { width: 0px; background: transparent; }
    )");
    connect(sizeCombo, QOverload<int>::of(&QComboBox::currentIndexChanged), [this, sizeCombo](int index){ m_tool->setFontSize(sizeCombo->itemData(index).toInt()); });
    sizeCombo->view()->window()->setAttribute(Qt::WA_TranslucentBackground);
    sizeCombo->view()->window()->setWindowFlags(Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint);
    sizeCombo->view()->setFixedWidth(50);
    textOptionLayout->addWidget(sizeCombo);
    
    layout->addWidget(m_textOptionWidget);

    // [CRITICAL] 垂直分割线，用于分隔工具选项和粗细选项 / Vertical divider between tool options and size options
    m_textDivider = new QFrame();
    m_textDivider->setFrameShape(QFrame::VLine);
    m_textDivider->setFrameShadow(QFrame::Plain);
    m_textDivider->setStyleSheet("background-color: #555;");
    m_textDivider->setFixedWidth(1);
    m_textDivider->setFixedHeight(16);
    layout->addSpacing(4);
    layout->addWidget(m_textDivider);
    layout->addSpacing(4);

    // 4. 描边粗细 (Size Buttons)
    int sizes[] = {2, 4, 8};
    m_sizeGroup = new QButtonGroup(this);
    for(int s : sizes) {
        auto* btn = new QPushButton; btn->setProperty("sizeBtn", true); btn->setFixedSize(14 + s, 14 + s);
        btn->setCheckable(true); if(s == m_tool->m_currentStrokeWidth) btn->setChecked(true);
        layout->addWidget(btn); m_sizeGroup->addButton(btn);
        connect(btn, &QPushButton::clicked, [this, s]{ m_tool->setDrawWidth(s); });
    }

    // 分隔符
    QFrame* colorDivider = new QFrame();
    colorDivider->setFrameShape(QFrame::VLine);
    colorDivider->setFrameShadow(QFrame::Plain);
    colorDivider->setStyleSheet("background-color: #555;");
    colorDivider->setFixedWidth(1);
    colorDivider->setFixedHeight(16);
    layout->addSpacing(4);
    layout->addWidget(colorDivider);
    layout->addSpacing(4);

    // 5. 标准颜色选择区域 (9色)
    m_colorGroup = new QButtonGroup(this);
    m_colorGroup->setExclusive(false); // 改为非独占，实现全覆盖高亮
    for(const auto& c : getStandardColorList()) {
        auto* btn = new QPushButton; btn->setProperty("colorBtn", true); btn->setProperty("colorValue", c); 
        btn->setFixedSize(20, 20); btn->setCheckable(true);
        // [CRITICAL] 采用“等色边框”方案：非选中时边框颜色与背景一致，选中时变为白色。
        // 此变量极其重要：padding: 0px 和 border-color: %1 共同解决了 QSS 渲染时父容器背景色露底（黑色背景）的问题。
        // [CRITICAL] This variable is extremely important: padding: 0px and border-color: %1 
        // solve the issue of parent container background bleeding through (black background issue).
        btn->setStyleSheet(QString("QPushButton { background-color: %1; border: 2px solid %1; border-radius: 2px; padding: 0px; } "
                                   "QPushButton:hover { background-color: %1; border-color: %1; } "
                                   "QPushButton:checked { background-color: %1; border-color: white; }").arg(c.name()));
        layout->addWidget(btn); m_colorGroup->addButton(btn);
        connect(btn, &QPushButton::clicked, [this, c]{ m_tool->setDrawColor(c); });
    }

    // 分隔符 (右侧)
    QFrame* colorDividerRight = new QFrame();
    colorDividerRight->setFrameShape(QFrame::VLine);
    colorDividerRight->setFrameShadow(QFrame::Plain);
    colorDividerRight->setStyleSheet("background-color: #555;");
    colorDividerRight->setFixedWidth(1);
    colorDividerRight->setFixedHeight(16);
    layout->addSpacing(4);
    layout->addWidget(colorDividerRight);
    layout->addSpacing(4);

    // 6. 最近颜色展示区 (填满红色方框区域)
    auto* recentContainer = new QWidget;
    recentContainer->setStyleSheet("background: transparent; border: none;");
    m_recentLayout = new QHBoxLayout(recentContainer);
    m_recentLayout->setContentsMargins(0, 0, 0, 0); m_recentLayout->setSpacing(4);
    layout->addWidget(recentContainer);

    QSettings settings("RapidNotes", "Screenshot");
    for (const QString& name : settings.value("recentColors").toStringList()) { addRecentColor(QColor(name), false); }

    // --- 弹性间距 ---
    layout->addStretch();

    // 7. 右侧控制按钮统一管理
    // 色轮按钮 (图标换成调色盘)
    m_wheelBtn = new QPushButton(); m_wheelBtn->setFixedSize(32, 32);
    // [CRITICAL] 调色盘图标内部已设为彩色。此处传入当前颜色仅为染其外轮廓，以指示当前选色。
    // [CRITICAL] The palette icon now has fixed internal colors. Tinting here only affects the outline to indicate selection.
    m_wheelBtn->setIcon(IconHelper::getIcon("palette", m_tool->m_currentColor.name()));
    m_wheelBtn->setIconSize(QSize(20, 20));
    m_wheelBtn->setToolTip("自定义颜色 (C)");
    connect(m_wheelBtn, &QPushButton::clicked, [this]{
        QColorDialog dialog(m_tool->m_currentColor, m_tool);
        dialog.setWindowTitle("选择标注颜色"); dialog.setOptions(QColorDialog::ShowAlphaChannel | QColorDialog::DontUseNativeDialog);
        dialog.setWindowFlags(dialog.windowFlags() | Qt::WindowStaysOnTopHint);
        if (dialog.exec() == QDialog::Accepted) { QColor c = dialog.selectedColor(); m_tool->setDrawColor(c); addRecentColor(c); }
        m_tool->activateWindow(); m_tool->updateToolbarPosition();
    });
    layout->addWidget(m_wheelBtn);

    // 调色盘 (图标换成金色五角星)
    m_paletteBtn = new QPushButton(); m_paletteBtn->setFixedSize(32, 32);
    m_paletteBtn->setIcon(IconHelper::getIcon("star_filled", "#FFD700"));
    m_paletteBtn->setIconSize(QSize(20, 20));
    m_paletteBtn->setToolTip("颜色收藏夹 (G)");
    m_paletteBtn->setCursor(Qt::PointingHandCursor);
    layout->addWidget(m_paletteBtn);

    QList<QColor> fullColors = {
        QColor(255, 0, 0), QColor(255, 69, 0), QColor(255, 165, 0), QColor(255, 215, 0),
        QColor(255, 255, 0), QColor(154, 205, 50), QColor(0, 255, 0), QColor(34, 139, 34),
        QColor(0, 255, 255), QColor(0, 191, 255), QColor(0, 120, 255), QColor(0, 0, 255),
        QColor(138, 43, 226), QColor(128, 0, 128), QColor(255, 0, 255), QColor(255, 192, 203),
        QColor(255, 255, 255), QColor(192, 192, 192), QColor(128, 128, 128), QColor(0, 0, 0)
    };
    connect(m_paletteBtn, &QPushButton::clicked, [this, fullColors]{
        QMenu* menu = new QMenu(this);
        IconHelper::setupMenu(menu);
        menu->setStyleSheet("QMenu { background-color: #2D2D2D; border: 1px solid #555; padding: 4px; }");
        QWidget* gridContainer = new QWidget; QGridLayout* grid = new QGridLayout(gridContainer);
        grid->setContentsMargins(4, 4, 4, 4); grid->setSpacing(4);
        int row = 0, col = 0;
        for (const auto& c : fullColors) {
            auto* btn = new QPushButton; btn->setFixedSize(22, 22);
            btn->setStyleSheet(QString("background-color: %1; border: 1px solid #555; border-radius: 2px;").arg(c.name()));
            grid->addWidget(btn, row, col);
            connect(btn, &QPushButton::clicked, [this, c, menu]{ m_tool->setDrawColor(c); menu->close(); });
            if (++col >= 5) { col = 0; row++; }
        }
        QWidgetAction* action = new QWidgetAction(menu); action->setDefaultWidget(gridContainer); menu->addAction(action);
        menu->exec(QCursor::pos()); delete menu;
    });

    // 移除按钮
    m_removeColorBtn = new QPushButton("×");
    m_removeColorBtn->setFixedSize(18, 24); m_removeColorBtn->setToolTip("移除选中的最近颜色");
    m_removeColorBtn->setCursor(Qt::PointingHandCursor);
    m_removeColorBtn->setStyleSheet(R"(
        QPushButton { color: #999; background: transparent; border: none; font-size: 16px; font-weight: bold; }
        QPushButton:hover { color: #ff5555; }
    )");
    connect(m_removeColorBtn, &QPushButton::clicked, [this]{
        QColor current = m_tool->m_currentColor;
        for (int i = 0; i < m_recentLayout->count(); ++i) {
            auto* item = m_recentLayout->itemAt(i); auto* btn = qobject_cast<QPushButton*>(item->widget());
            if (btn && btn->property("colorValue").value<QColor>().rgba() == current.rgba()) {
                m_recentLayout->removeItem(item); btn->deleteLater(); delete item;
                QSettings settings("RapidNotes", "Screenshot"); QStringList recent = settings.value("recentColors").toStringList();
                recent.removeAll(current.name()); settings.setValue("recentColors", recent);
                break;
            }
        }
    });
    layout->addWidget(m_removeColorBtn);

    m_optionWidget->setVisible(false);
    syncColorSelection(m_tool->m_currentColor);
}

void ScreenshotToolbar::showArrowMenu() {
    QMenu menu(this);
    IconHelper::setupMenu(&menu);
    // 使用 QWidgetAction 替代 QMenu::setIconSize 以获得更好的版本兼容性和视觉控制
    menu.setStyleSheet(R"(
        QMenu { background-color: #2D2D2D; border: 1px solid #555; padding: 2px; }
        QMenu::item { padding: 0px; }
    )");

    auto addAct = [&](ArrowStyle s) {
        QWidgetAction* action = new QWidgetAction(&menu);
        QPushButton* btn = new QPushButton();
        btn->setFixedSize(120, 36);
        btn->setIcon(IconFactory::createArrowStyleIcon(s));
        btn->setIconSize(QSize(100, 24));
        btn->setCursor(Qt::PointingHandCursor);
        btn->setStyleSheet(R"(
            QPushButton { background-color: transparent; border: none; border-radius: 4px; }
            QPushButton:hover { background-color: #007ACC; }
        )");
        connect(btn, &QPushButton::clicked, [this, s, &menu]{ 
            m_tool->setArrowStyle(s); 
            updateArrowButtonIcon(s); 
            menu.close(); 
        });
        action->setDefaultWidget(btn);
        menu.addAction(action);
    };

    addAct(ArrowStyle::SolidSingle);
    addAct(ArrowStyle::SolidDouble);
    addAct(ArrowStyle::OutlineSingle);
    addAct(ArrowStyle::OutlineDouble);
    addAct(ArrowStyle::Dimension);
    addAct(ArrowStyle::Thin);
    addAct(ArrowStyle::SolidDot);
    addAct(ArrowStyle::OutlineDot);

    menu.exec(mapToGlobal(m_arrowStyleBtn->geometry().bottomLeft()));
}

void ScreenshotToolbar::addRecentColor(const QColor& c, bool save) {
    if (!m_recentLayout || !m_wheelBtn) return;
    
    // 1. 优先同步高亮状态 (Ensure highlight is synced even if not added to recent)
    syncColorSelection(c);

    // 2. 如果是 9 种标准色之一，则不重复添加到“最近颜色”
    for (const auto& sc : getStandardColorList()) {
        if (sc.rgba() == c.rgba()) return;
    }

    // 3. 检查是否已经在最近颜色列表中
    for (int i = 0; i < m_recentLayout->count(); ++i) {
        auto* b = qobject_cast<QPushButton*>(m_recentLayout->itemAt(i)->widget());
        if (b && b->property("colorValue").value<QColor>().rgba() == c.rgba()) return;
    }

    // 4. 限制最近颜色数量 (增加到 15 以填满区域)
    if (m_recentLayout->count() >= 15) {
        auto* item = m_recentLayout->takeAt(0);
        if (item->widget()) {
            if (m_colorGroup) m_colorGroup->removeButton(qobject_cast<QPushButton*>(item->widget()));
            item->widget()->deleteLater();
        }
        delete item;
    }

    // 5. 创建并添加新的最近颜色按钮
    auto* btn = new QPushButton; btn->setFixedSize(20, 20);
    btn->setProperty("colorBtn", true);
    btn->setProperty("colorValue", c);
    btn->setCheckable(true);
    // [CRITICAL] 采用与标准色一致的“等色边框”方案，这是解决颜色按钮黑色背景问题的核心逻辑。
    // [CRITICAL] This logic is the core fix for the color button's black background issue.
    btn->setStyleSheet(QString("QPushButton { background-color: %1; border: 2px solid %1; border-radius: 2px; padding: 0px; } "
                               "QPushButton:hover { background-color: %1; border-color: %1; } "
                               "QPushButton:checked { background-color: %1; border-color: white; }").arg(c.name()));
    btn->setToolTip(c.name());
    m_recentLayout->addWidget(btn);
    if (m_colorGroup) m_colorGroup->addButton(btn);

    connect(btn, &QPushButton::clicked, [this, c]{
        m_tool->setDrawColor(c);
    });

    if (save) {
        QSettings settings("RapidNotes", "Screenshot");
        QStringList recent = settings.value("recentColors").toStringList();
        if (!recent.contains(c.name())) {
            recent.append(c.name());
            if (recent.size() > 15) recent.removeFirst();
            settings.setValue("recentColors", recent);
        }
    }
    
    // 再次调用以确保新添加的按钮也被正确选中
    syncColorSelection(c);
}

void ScreenshotToolbar::syncColorSelection(const QColor& color) {
    if (!m_colorGroup) return;
    
    // 暂时阻塞信号，避免循环触发
    m_colorGroup->blockSignals(true);
    // m_colorGroup 包含标准色和最近色按钮，实现全覆盖同步 (Cover both standard and recent colors)
    for (auto* btn : m_colorGroup->buttons()) {
        QColor btnColor = btn->property("colorValue").value<QColor>();
        // 使用 rgba 进行精确对比，实现全覆盖高亮 (All coverage highlight)
        if (btnColor.rgba() == color.rgba()) {
            btn->setChecked(true);
        } else {
            btn->setChecked(false);
        }
    }
    
    // [CRITICAL] 同步更新调色盘图标的外轮廓颜色，而内部色点保持彩色。
    if (m_wheelBtn) {
        m_wheelBtn->setIcon(IconHelper::getIcon("palette", color.name()));
    }
    
    m_colorGroup->blockSignals(false);
}

void ScreenshotToolbar::updateArrowButtonIcon(ArrowStyle style) {
    m_arrowStyleBtn->setIcon(IconFactory::createArrowStyleIcon(style)); 
    m_arrowStyleBtn->setIconSize(QSize(48, 16));
}

void ScreenshotToolbar::selectTool(ScreenshotToolType type) {
    for(auto* b : std::as_const(m_buttons)) b->setChecked(false);
    if(m_buttons.contains(type)) m_buttons[type]->setChecked(true);
    
    // 恢复原来的两行逻辑：显示就展示选项卡
    bool hasOptions = (type != ScreenshotToolType::None);
    m_optionWidget->setVisible(hasOptions);
    if (m_horizontalDivider) m_horizontalDivider->setVisible(hasOptions);

    bool isArrow = (type == ScreenshotToolType::Arrow);
    bool isRectOrEllipse = (type == ScreenshotToolType::Rect || type == ScreenshotToolType::Ellipse);
    bool isText = (type == ScreenshotToolType::Text);

    m_arrowStyleBtn->setVisible(isArrow);
    m_outlineBtn->setVisible(isRectOrEllipse);
    m_solidBtn->setVisible(isRectOrEllipse);
    m_textOptionWidget->setVisible(isText);

    if (m_textDivider) {
        m_textDivider->setVisible(isArrow || isRectOrEllipse || isText);
    }

    m_tool->setTool(type); 
    
    // [CRITICAL] 必须调用此系列方法以强制触发窗口尺寸重新计算，消除高度异常 / Force UI update to recalculate size
    m_optionWidget->updateGeometry();
    if (m_horizontalDivider) m_horizontalDivider->updateGeometry();
    if (layout()) layout()->activate();
    adjustSize(); 
    m_tool->updateToolbarPosition();
}

void ScreenshotToolbar::mousePressEvent(QMouseEvent *event) {
    if (event->button() == Qt::LeftButton) {
        m_isDragging = true; m_dragPosition = event->globalPosition().toPoint() - frameGeometry().topLeft();
    }
}
void ScreenshotToolbar::mouseMoveEvent(QMouseEvent *event) {
    if (m_isDragging) move(event->globalPosition().toPoint() - m_dragPosition);
}
void ScreenshotToolbar::mouseReleaseEvent(QMouseEvent *) { m_isDragging = false; }
void ScreenshotToolbar::paintEvent(QPaintEvent *) {
    // 作为透明容器，不再执行默认绘制逻辑，完全由 MainContainer 处理背景
}

void ScreenshotToolbar::keyPressEvent(QKeyEvent* event) {
    if (event->key() == Qt::Key_Escape) {
        m_tool->cancel();
    } else {
        QWidget::keyPressEvent(event);
    }
}

ScreenshotTool::~ScreenshotTool() {
    if (m_toolbar) m_toolbar->deleteLater();
    qDeleteAll(m_annotations);
    qDeleteAll(m_redoStack);
    delete m_activeShape;
}

ScreenshotTool::ScreenshotTool(QWidget* parent) 
    : QWidget(parent, Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint) 
{
    setAttribute(Qt::WA_TranslucentBackground);
    setAttribute(Qt::WA_QuitOnClose, false);
    setAttribute(Qt::WA_DeleteOnClose);
    setWindowState(Qt::WindowFullScreen);
    setMouseTracking(true);
    m_screenPixmap = QGuiApplication::primaryScreen()->grabWindow(0);
    m_screenImage = m_screenPixmap.toImage();
    QImage small = m_screenImage.scaled(m_screenImage.width()/15, m_screenImage.height()/15, Qt::IgnoreAspectRatio, Qt::FastTransformation);
    m_mosaicPixmap = QPixmap::fromImage(small.scaled(m_screenImage.size(), Qt::IgnoreAspectRatio, Qt::FastTransformation));

    QSettings settings("RapidNotes", "Screenshot");
    m_currentColor = settings.value("color", QColor(255, 50, 50)).value<QColor>();
    m_currentStrokeWidth = settings.value("strokeWidth", 3).toInt();
    m_currentArrowStyle = static_cast<ArrowStyle>(settings.value("arrowStyle", 0).toInt());
    m_currentTool = static_cast<ScreenshotToolType>(settings.value("tool", 0).toInt());
    m_currentFontFamily = settings.value("fontFamily", "Microsoft YaHei").toString();
    m_currentFontSize = settings.value("fontSize", 14).toInt();
    m_currentBold = settings.value("bold", true).toBool();
    m_currentItalic = settings.value("italic", false).toBool();
    m_isConfirmed = false;

    m_toolbar = new ScreenshotToolbar(this); m_toolbar->hide();
    m_infoBar = new SelectionInfoBar(this);
    m_lastMouseMovePos = mapFromGlobal(QCursor::pos());
    m_textInput = new QLineEdit(this); m_textInput->hide(); m_textInput->setFrame(false);
    m_textInput->installEventFilter(this);
    connect(m_textInput, &QLineEdit::editingFinished, this, &ScreenshotTool::commitTextInput);
}

void ScreenshotTool::showEvent(QShowEvent* event) { QWidget::showEvent(event); detectWindows(); }
void ScreenshotTool::cancel() { emit screenshotCanceled(); if (m_toolbar) m_toolbar->close(); close(); }

int BaseShape::getHandleAt(const QPoint& pos) const {
    auto handles = getHandles();
    for (int i = 0; i < handles.size(); ++i) {
        if (handles[i].contains(pos)) return i;
    }
    return -1;
}

void BaseShape::moveBy(const QPoint& delta) {
    for (auto& p : data.points) p += delta;
}

static bool isNearLine(const QPointF& p, const QPointF& s, const QPointF& e, int threshold) {
    double l2 = QPointF::dotProduct(e - s, e - s);
    if (l2 == 0.0) return (p - s).manhattanLength() < threshold;
    double t = std::max(0.0, std::min(1.0, QPointF::dotProduct(p - s, e - s) / l2));
    QPointF projection = s + t * (e - s);
    return (p - projection).manhattanLength() < threshold;
}

void RectShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    p.setPen(QPen(data.color, data.strokeWidth, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
    p.setBrush(data.isFilled ? QBrush(data.color) : Qt::NoBrush);
    p.drawRect(QRectF(data.points[0], data.points[1]).normalized());
}

bool RectShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    if (data.isFilled && r.contains(pos)) return true;
    int t = std::max(5, data.strokeWidth + 2);
    return std::abs(pos.x() - r.left()) < t || std::abs(pos.x() - r.right()) < t ||
           std::abs(pos.y() - r.top()) < t || std::abs(pos.y() - r.bottom()) < t;
}

QList<QRect> RectShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    h << QRect(r.left()-s/2, r.top()-s/2, s, s) << QRect(r.right()-s/2, r.top()-s/2, s, s)
      << QRect(r.right()-s/2, r.bottom()-s/2, s, s) << QRect(r.left()-s/2, r.bottom()-s/2, s, s);
    return h;
}

void RectShape::updatePoint(int index, const QPoint& pos) {
    if (data.points.size() < 2) return;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    if (index == 0) { r.setTopLeft(pos); }
    else if (index == 1) { r.setTopRight(pos); }
    else if (index == 2) { r.setBottomRight(pos); }
    else if (index == 3) { r.setBottomLeft(pos); }
    data.points[0] = r.topLeft(); data.points[1] = r.bottomRight();
}

void EllipseShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    p.setPen(QPen(data.color, data.strokeWidth, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
    p.setBrush(data.isFilled ? QBrush(data.color) : Qt::NoBrush);
    p.drawEllipse(QRectF(data.points[0], data.points[1]).normalized());
}

bool EllipseShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    QPainterPath path; path.addEllipse(r);
    if (data.isFilled && path.contains(pos)) return true;
    QPainterPathStroker stroker; stroker.setWidth(std::max(10, data.strokeWidth + 4));
    return stroker.createStroke(path).contains(pos);
}

QList<QRect> EllipseShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    h << QRect(r.left()-s/2, r.top()-s/2, s, s) << QRect(r.right()-s/2, r.top()-s/2, s, s)
      << QRect(r.right()-s/2, r.bottom()-s/2, s, s) << QRect(r.left()-s/2, r.bottom()-s/2, s, s);
    return h;
}

void EllipseShape::updatePoint(int index, const QPoint& pos) {
    if (data.points.size() < 2) return;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    if (index == 0) { r.setTopLeft(pos); }
    else if (index == 1) { r.setTopRight(pos); }
    else if (index == 2) { r.setBottomRight(pos); }
    else if (index == 3) { r.setBottomLeft(pos); }
    data.points[0] = r.topLeft(); data.points[1] = r.bottomRight();
}

void LineShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    p.setPen(QPen(data.color, data.strokeWidth, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
    p.drawLine(data.points[0], data.points[1]);
}

bool LineShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    return isNearLine(pos, data.points[0], data.points[1], std::max(8, data.strokeWidth + 3));
}

QList<QRect> LineShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    h << QRect(data.points[0].toPoint().x()-s/2, data.points[0].toPoint().y()-s/2, s, s)
      << QRect(data.points[1].toPoint().x()-s/2, data.points[1].toPoint().y()-s/2, s, s);
    return h;
}

void ArrowShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    QPointF start = data.points[0], end = data.points[1];
    QPointF dir = end - start;
    double len = std::sqrt(QPointF::dotProduct(dir, dir));
    if (len < 2) return;
    QPointF unit = dir / len; QPointF perp(-unit.y(), unit.x());
    double angle = std::atan2(dir.y(), dir.x());
    
    // 增加基础尺寸，使其更显眼
    double baseSize = 24 + data.strokeWidth * 2.0;
    double headLen = baseSize;
    bool isOutline = (data.arrowStyle == ArrowStyle::OutlineSingle || data.arrowStyle == ArrowStyle::OutlineDouble || data.arrowStyle == ArrowStyle::OutlineDot);
    
    if (data.arrowStyle == ArrowStyle::SolidSingle || data.arrowStyle == ArrowStyle::OutlineSingle) {
        if (isOutline) {
            QPointF neck = end - unit * (headLen * 0.8); double w = data.strokeWidth + 2;
            QPolygonF poly; poly << end << neck + perp * (headLen*0.5) << neck + perp * w << start + perp * w << start - perp * w << neck - perp * w << neck - perp * (headLen*0.5);
            p.setBrush(Qt::transparent); p.setPen(QPen(data.color, 2.5)); p.drawPolygon(poly);
        } else {
            double barbWidth = headLen * 0.55; double waistLen = headLen * 0.75; double waistWidth = data.strokeWidth + 1;
            p.setPen(Qt::NoPen); p.setBrush(data.color);
            p.drawPolygon(QPolygonF() << end << end - unit * headLen + perp * barbWidth << end - unit * waistLen + perp * waistWidth << start << end - unit * waistLen - perp * waistWidth << end - unit * headLen - perp * barbWidth);
        }
    } else if (data.arrowStyle == ArrowStyle::Thin) {
        p.setPen(QPen(data.color, data.strokeWidth + 1, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
        p.drawLine(start, end);
        double thinAngle = 0.5; double thinLen = headLen * 0.8;
        p.drawLine(end, end - QPointF(thinLen * std::cos(angle - thinAngle), thinLen * std::sin(angle - thinAngle)));
        p.drawLine(end, end - QPointF(thinLen * std::cos(angle + thinAngle), thinLen * std::sin(angle + thinAngle)));
    } else if (data.arrowStyle == ArrowStyle::SolidDouble || data.arrowStyle == ArrowStyle::OutlineDouble) {
        p.setPen(QPen(data.color, data.strokeWidth + 1)); p.drawLine(start + unit * (headLen*0.7), end - unit * (headLen*0.7));
        p.setPen(isOutline ? QPen(data.color, 2.0) : Qt::NoPen);
        p.setBrush(isOutline ? Qt::transparent : data.color);
        auto drawH = [&](const QPointF& e, double ang) {
            QPointF u(std::cos(ang), std::sin(ang)), pr(-u.y(), u.x());
            p.drawPolygon(QPolygonF() << e << e - u * headLen + pr * (headLen*0.5) << e - u * (headLen*0.7) + pr * (data.strokeWidth) << e - u * (headLen*0.7) - pr * (data.strokeWidth) << e - u * headLen - pr * (headLen*0.5));
        };
        drawH(end, angle); drawH(start, angle + M_PI);
    } else if (data.arrowStyle == ArrowStyle::SolidDot || data.arrowStyle == ArrowStyle::OutlineDot) {
        p.setPen(QPen(data.color, data.strokeWidth + 1)); p.drawLine(start, end - unit * (headLen*0.7));
        p.setPen(isOutline ? QPen(data.color, 2.0) : Qt::NoPen);
        p.setBrush(isOutline ? Qt::transparent : data.color);
        p.drawEllipse(start, 5+data.strokeWidth, 5+data.strokeWidth);
        p.drawPolygon(QPolygonF() << end << end - unit * headLen + perp * (headLen*0.5) << end - unit * (headLen*0.7) + perp * (data.strokeWidth) << end - unit * (headLen*0.7) - perp * (data.strokeWidth) << end - unit * headLen - perp * (headLen*0.5));
    } else if (data.arrowStyle == ArrowStyle::Dimension) {
        p.setPen(QPen(data.color, data.strokeWidth + 1, Qt::SolidLine, Qt::FlatCap, Qt::RoundJoin));
        p.drawLine(start, end);
        p.drawLine(start + perp * (10 + data.strokeWidth), start - perp * (10 + data.strokeWidth));
        p.drawLine(end + perp * (10 + data.strokeWidth), end - perp * (10 + data.strokeWidth));
    }
}

bool ArrowShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    return isNearLine(pos, data.points[0], data.points[1], std::max(15, data.strokeWidth + 8));
}

QList<QRect> ArrowShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    h << QRect(data.points[0].toPoint().x()-s/2, data.points[0].toPoint().y()-s/2, s, s)
      << QRect(data.points[1].toPoint().x()-s/2, data.points[1].toPoint().y()-s/2, s, s);
    return h;
}

void PenShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.size() < 2) return;
    p.setPen(QPen(data.color, data.strokeWidth, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));
    QPainterPath path; path.moveTo(data.points[0]);
    for(int i=1; i<data.points.size(); ++i) path.lineTo(data.points[i]);
    p.drawPath(path);
}

bool PenShape::hitTest(const QPoint& pos) const {
    for (int i = 0; i < data.points.size() - 1; ++i) {
        if (isNearLine(pos, data.points[i], data.points[i+1], std::max(10, data.strokeWidth + 4))) return true;
    }
    return false;
}

void MarkerShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.isEmpty()) return;
    p.setBrush(data.color); p.setPen(Qt::NoPen); int r = 12 + data.strokeWidth;
    p.drawEllipse(data.points[0], r, r); p.setPen(Qt::white); p.setFont(QFont("Arial", r, QFont::Bold));
    p.drawText(QRectF(data.points[0].x()-r, data.points[0].y()-r, r*2, r*2), Qt::AlignCenter, data.text);
}

bool MarkerShape::hitTest(const QPoint& pos) const {
    if (data.points.isEmpty()) return false;
    int r = 12 + data.strokeWidth;
    return (pos - data.points[0].toPoint()).manhattanLength() < r + 5;
}

void TextShape::draw(QPainter& p, const QPixmap&) const {
    if (data.points.isEmpty() || data.text.isEmpty()) return;
    p.setPen(data.color);
    QFont font(data.fontFamily, data.fontSize);
    font.setBold(data.isBold);
    font.setItalic(data.isItalic);
    p.setFont(font);
    p.drawText(data.points[0], data.text);
}

bool TextShape::hitTest(const QPoint& pos) const {
    if (data.points.isEmpty() || data.text.isEmpty()) return false;
    QFont font(data.fontFamily, data.fontSize);
    font.setBold(data.isBold); font.setItalic(data.isItalic);
    QRect r = QFontMetrics(font).boundingRect(data.text);
    r.moveTo(data.points[0].toPoint().x(), data.points[0].toPoint().y() - r.height());
    return r.adjusted(-10, -10, 10, 10).contains(pos);
}

QList<QRect> TextShape::getHandles() const {
    if (data.points.isEmpty() || data.text.isEmpty()) return {};
    QList<QRect> h; int s = 10;
    // 为文字左上角提供一个移动句柄
    h << QRect(data.points[0].toPoint().x()-s/2, data.points[0].toPoint().y()-s/2, s, s);
    return h;
}

void MosaicShape::draw(QPainter& p, const QPixmap& mosaicPixmap) const {
    if (data.points.size() < 2) return;
    p.save();
    QPainterPath path; path.moveTo(data.points[0]);
    for(int i=1; i<data.points.size(); ++i) path.lineTo(data.points[i]);
    QPainterPathStroker s; s.setWidth(data.strokeWidth * 6);
    p.setClipPath(s.createStroke(path));
    p.drawPixmap(0, 0, mosaicPixmap);
    p.restore();
}

bool MosaicShape::hitTest(const QPoint& pos) const {
    for (int i = 0; i < data.points.size() - 1; ++i) {
        if (isNearLine(pos, data.points[i], data.points[i+1], data.strokeWidth * 3)) return true;
    }
    return false;
}

void MosaicRectShape::draw(QPainter& p, const QPixmap& mosaicPixmap) const {
    if (data.points.size() < 2) return;
    p.save();
    p.setClipRect(QRectF(data.points[0], data.points[1]).normalized());
    p.drawPixmap(0, 0, mosaicPixmap);
    p.restore();
}

bool MosaicRectShape::hitTest(const QPoint& pos) const {
    if (data.points.size() < 2) return false;
    return QRectF(data.points[0], data.points[1]).normalized().contains(pos);
}

QList<QRect> MosaicRectShape::getHandles() const {
    if (data.points.size() < 2) return {};
    QList<QRect> h; int s = 10;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    h << QRect(r.left()-s/2, r.top()-s/2, s, s) << QRect(r.right()-s/2, r.top()-s/2, s, s)
      << QRect(r.right()-s/2, r.bottom()-s/2, s, s) << QRect(r.left()-s/2, r.bottom()-s/2, s, s);
    return h;
}

void MosaicRectShape::updatePoint(int index, const QPoint& pos) {
    if (data.points.size() < 2) return;
    QRect r = QRectF(data.points[0], data.points[1]).normalized().toRect();
    if (index == 0) { r.setTopLeft(pos); }
    else if (index == 1) { r.setTopRight(pos); }
    else if (index == 2) { r.setBottomRight(pos); }
    else if (index == 3) { r.setBottomLeft(pos); }
    data.points[0] = r.topLeft(); data.points[1] = r.bottomRight();
}

static BaseShape* createShape(const DrawingAnnotation& ann) {
    switch(ann.type) {
        case ScreenshotToolType::Rect: return new RectShape(ann);
        case ScreenshotToolType::Ellipse: return new EllipseShape(ann);
        case ScreenshotToolType::Line: return new LineShape(ann);
        case ScreenshotToolType::Arrow: return new ArrowShape(ann);
        case ScreenshotToolType::Pen: return new PenShape(ann);
        case ScreenshotToolType::Marker: return new MarkerShape(ann);
        case ScreenshotToolType::Text: return new TextShape(ann);
        case ScreenshotToolType::Mosaic: return new MosaicShape(ann);
        case ScreenshotToolType::MosaicRect: return new MosaicRectShape(ann);
        default: return nullptr;
    }
}

void ScreenshotTool::mousePressEvent(QMouseEvent* e) {
    m_lastMouseMovePos = e->pos();
    setFocus();
    if(m_textInput->isVisible() && !m_textInput->geometry().contains(e->pos())) commitTextInput();
    
    if (m_currentTool == ScreenshotToolType::Picker && e->button() == Qt::LeftButton) {
        QColor c = m_screenImage.pixelColor(e->pos());
        setDrawColor(c);
        // 取色后切回上一个工具，如果上一个是 None 则保持 None
        setTool(ScreenshotToolType::None);
        m_toolbar->selectTool(ScreenshotToolType::None);
        update();
        return;
    }
    if(e->button() == Qt::RightButton) {
        if (m_isDrawing) { m_isDrawing = false; delete m_activeShape; m_activeShape = nullptr; update(); return; }
        if (m_currentTool != ScreenshotToolType::None) { m_currentTool = ScreenshotToolType::None; m_toolbar->selectTool(ScreenshotToolType::None); update(); return; }
        cancel(); return;
    }
    if(e->button() != Qt::LeftButton) return;
    m_dragHandle = -1; m_editHandle = -1;

    // 强化：在按下鼠标时重新进行一次命中测试，确保 hoveredShape 准确
    if (m_state == ScreenshotState::Editing && !m_isDragging && !m_isDrawing) {
        m_hoveredShape = nullptr;
        for (int i = m_annotations.size() - 1; i >= 0; --i) {
            if (m_annotations[i]->hitTest(e->pos()) || m_annotations[i]->getHandleAt(e->pos()) != -1) {
                m_hoveredShape = m_annotations[i];
                break;
            }
        }
    }

    if (m_state == ScreenshotState::Selecting) {
        m_startPoint = e->pos(); m_endPoint = m_startPoint; m_isDragging = true; m_toolbar->hide(); m_infoBar->hide();
    } else {
        // 优先处理已有标注的句柄
        if (m_hoveredShape) {
            int handle = m_hoveredShape->getHandleAt(e->pos());
            // [CRITICAL] 使用 m_dragOrigin 而不是 m_startPoint，防止修改选区大小 / Use m_dragOrigin to prevent selection resize
            if (handle != -1) { m_editHandle = handle; m_dragOrigin = e->pos(); m_isDragging = true; update(); return; }
            if (m_hoveredShape->hitTest(e->pos())) { m_editHandle = 100; m_dragOrigin = e->pos(); m_isDragging = true; update(); return; }
        }

        int handle = getHandleAt(e->pos());
        if (selectionRect().contains(e->pos()) && m_currentTool != ScreenshotToolType::None && handle == -1) {
            if (m_currentTool == ScreenshotToolType::Text) { showTextInput(e->pos()); return; }
            m_isDrawing = true; m_currentAnnotation = {m_currentTool, {e->pos()}, m_currentColor, "", m_currentStrokeWidth, LineStyle::Solid, m_currentArrowStyle, m_fillEnabled, 
                                                       m_currentFontFamily, m_currentFontSize, m_currentBold, m_currentItalic};
            if(m_currentTool == ScreenshotToolType::Marker) {
                int c = 1; for(auto* a : std::as_const(m_annotations)) if(a->data.type == ScreenshotToolType::Marker) c++;
                m_currentAnnotation.text = QString::number(c);
            }
            delete m_activeShape;
            m_activeShape = createShape(m_currentAnnotation);
        } else if (handle != -1) {
            m_dragHandle = handle; m_isDragging = true;
        } else if (selectionRect().contains(e->pos())) {
            // [CRITICAL] 移动选区时使用 m_dragOrigin / Use m_dragOrigin when moving selection
            m_dragHandle = 8; m_dragOrigin = e->pos(); m_isDragging = true;
        }
    }
    update();
}

void ScreenshotTool::mouseMoveEvent(QMouseEvent* e) {
    m_lastMouseMovePos = e->pos();
    if (m_state == ScreenshotState::Selecting && !m_isDragging) {
        QRect smallest; long long minArea = -1;
        for (const QRect& r : std::as_const(m_detectedRects)) {
            if (r.contains(e->pos())) {
                long long area = (long long)r.width() * r.height();
                if (minArea == -1 || area < minArea) { minArea = area; smallest = r; }
            }
        }
        if (m_highlightedRect != smallest) { m_highlightedRect = smallest; update(); }
    } else {
        m_highlightedRect = QRect();
    }

    if (!m_isDragging && !m_isDrawing && m_state == ScreenshotState::Editing) {
        BaseShape* prevHover = m_hoveredShape; m_hoveredShape = nullptr;
        for (int i = m_annotations.size() - 1; i >= 0; --i) {
            if (m_annotations[i]->hitTest(e->pos()) || m_annotations[i]->getHandleAt(e->pos()) != -1) {
                m_hoveredShape = m_annotations[i]; break;
            }
        }
        if (prevHover != m_hoveredShape) update();
    }

    if (m_isDragging) {
        QPoint p = e->pos();
        if (m_editHandle != -1 && m_hoveredShape) {
            if (m_editHandle == 100) { m_hoveredShape->moveBy(p - m_dragOrigin); m_dragOrigin = p; }
            else { m_hoveredShape->updatePoint(m_editHandle, p); }
            update(); return;
        }
        if (m_currentTool == ScreenshotToolType::Eraser) {
            bool changed = false;
            for (int i = m_annotations.size() - 1; i >= 0; --i) {
                if (m_annotations[i]->hitTest(p)) { m_redoStack.append(m_annotations.takeAt(i)); changed = true; if(m_hoveredShape == m_redoStack.last()) m_hoveredShape = nullptr; }
            }
            if (changed) update(); return;
        }
        if (m_state == ScreenshotState::Selecting) {
            m_endPoint = e->pos();
        } else if (m_dragHandle == 8) {
            QPoint delta = e->pos() - m_dragOrigin;
            m_startPoint += delta; m_endPoint += delta;
            m_dragOrigin = e->pos();
        } else if (m_dragHandle != -1) {
            if(m_dragHandle==0) m_startPoint = p; else if(m_dragHandle==1) m_startPoint.setY(p.y()); else if(m_dragHandle==2) { m_startPoint.setY(p.y()); m_endPoint.setX(p.x()); }
            else if(m_dragHandle==3) m_endPoint.setX(p.x()); else if(m_dragHandle==4) m_endPoint = p; else if(m_dragHandle==5) m_endPoint.setY(p.y());
            else if(m_dragHandle==6) { m_endPoint.setY(p.y()); m_startPoint.setX(p.x()); } else if(m_dragHandle==7) m_startPoint.setX(p.x());
        }
        if (!selectionRect().isEmpty()) {
            if (!m_isImmediateOCR) {
                m_infoBar->updateInfo(selectionRect()); m_infoBar->show(); m_infoBar->move(selectionRect().left(), selectionRect().top() - 35); m_infoBar->raise();
            }
            updateToolbarPosition();
        }
    } else if (m_isDrawing && m_activeShape) {
        updateToolbarPosition();
        if (m_currentTool == ScreenshotToolType::Arrow || m_currentTool == ScreenshotToolType::Line || m_currentTool == ScreenshotToolType::Rect || m_currentTool == ScreenshotToolType::Ellipse || m_currentTool == ScreenshotToolType::MosaicRect) {
            if (m_activeShape->data.points.size() > 1) m_activeShape->data.points[1] = e->pos(); else m_activeShape->data.points.append(e->pos());
        } else m_activeShape->data.points.append(e->pos());
    } else updateCursor(e->pos());
    update();
}

void ScreenshotTool::mouseReleaseEvent(QMouseEvent* e) {
    if (m_isDrawing) {
        m_isDrawing = false;
        if (m_activeShape) {
            m_annotations.append(m_activeShape);
            m_activeShape = nullptr;
            qDeleteAll(m_redoStack);
            m_redoStack.clear();
        }
    }
    else if (m_isDragging) {
        m_isDragging = false;
        m_editHandle = -1;
        if (m_state == ScreenshotState::Selecting) {
            if ((e->pos() - m_startPoint).manhattanLength() < 5) {
                if (!m_highlightedRect.isEmpty()) { m_startPoint = m_highlightedRect.topLeft(); m_endPoint = m_highlightedRect.bottomRight(); }
            }
            if (selectionRect().width() > 2 && selectionRect().height() > 2) {
                m_state = ScreenshotState::Editing;
                m_highlightedRect = QRect();
                m_detectedRects.clear();
            }
        }
    }
    if (m_state == ScreenshotState::Editing) {
        if (m_isImmediateOCR) {
            confirm();
            return;
        }
        updateToolbarPosition(); m_toolbar->show(); m_infoBar->updateInfo(selectionRect());
        m_infoBar->show(); m_infoBar->move(selectionRect().left(), selectionRect().top() - 35);
    }
    update();
}

void ScreenshotTool::updateToolbarPosition() {
    QRect r = selectionRect(); if(r.isEmpty()) return; m_toolbar->adjustSize();
    // 补偿 6px 的外边距，并将视觉位置贴近选区边缘（保留 4px 视觉间距）
    int x = r.right() - m_toolbar->width() + 6;
    int y = r.bottom() - 4; 
    
    if (x < -6) x = -6; 
    if (y + m_toolbar->height() - 6 > height()) y = r.top() - m_toolbar->height() + 4;
    
    m_toolbar->move(x, y); 
    if (!m_isImmediateOCR) {
        if (m_state == ScreenshotState::Editing && !m_toolbar->isVisible()) m_toolbar->show();
        if (m_toolbar->isVisible()) m_toolbar->raise();
    }
}

void ScreenshotTool::wheelEvent(QWheelEvent* event) {
    int delta = event->angleDelta().y();
    if (m_hoveredShape) {
        if (m_hoveredShape->data.type == ScreenshotToolType::Text) {
            int newSize = m_hoveredShape->data.fontSize + (delta > 0 ? 2 : -2);
            m_hoveredShape->data.fontSize = std::max(8, std::min(100, newSize));
        } else {
            int newWidth = m_hoveredShape->data.strokeWidth + (delta > 0 ? 1 : -1);
            m_hoveredShape->data.strokeWidth = std::max(1, std::min(50, newWidth));
        }
        update();
    } else {
        // 如果没有悬浮标注，修改全局设置
        if (m_currentTool == ScreenshotToolType::Text) {
            m_currentFontSize += (delta > 0 ? 2 : -2);
            m_currentFontSize = std::max(8, std::min(100, m_currentFontSize));
        } else {
            m_currentStrokeWidth += (delta > 0 ? 1 : -1);
            m_currentStrokeWidth = std::max(1, std::min(50, m_currentStrokeWidth));
        }
    }
    event->accept();
}

void ScreenshotTool::paintEvent(QPaintEvent*) {
    QPainter p(this); p.setRenderHint(QPainter::Antialiasing);
    p.drawPixmap(0,0,m_screenPixmap);
    QRect r = selectionRect(); QPainterPath path; path.addRect(rect());
    if(r.isValid()) path.addRect(r); p.fillPath(path, QColor(0,0,0,120));

    if (m_state == ScreenshotState::Selecting && !m_isDragging && !m_highlightedRect.isEmpty()) {
        p.setPen(QPen(QColor(0, 120, 255, 200), 2)); p.setBrush(QColor(0, 120, 255, 30)); p.drawRect(m_highlightedRect);
    }
    if(r.isValid()) {
        p.setPen(QPen(QColor(0, 120, 255), 2)); p.drawRect(r);
        auto h = getHandleRects(); p.setBrush(Qt::white); for(auto& hr : h) p.drawEllipse(hr);
        p.save(); // [CRITICAL] 保存状态以防 clip 影响后续绘制
        p.setClipRect(r);
        for(auto* a : std::as_const(m_annotations)) {
            a->draw(p, m_mosaicPixmap);
            if (a == m_hoveredShape) {
                p.save();
                p.setRenderHint(QPainter::Antialiasing);
                p.setPen(QPen(Qt::cyan, 1.2, Qt::DashLine));
                p.setBrush(Qt::NoBrush);
                
                // 针对不同形状绘制更有意义的连接虚线
                if (a->data.type == ScreenshotToolType::Line || a->data.type == ScreenshotToolType::Arrow) {
                    if (a->data.points.size() >= 2) p.drawLine(a->data.points[0], a->data.points[1]);
                } else if (a->data.type == ScreenshotToolType::Rect || a->data.type == ScreenshotToolType::Ellipse || a->data.type == ScreenshotToolType::MosaicRect) {
                    if (a->data.points.size() >= 2) p.drawRect(QRectF(a->data.points[0], a->data.points[1]).normalized());
                } else if (a->data.type == ScreenshotToolType::Text) {
                    // 文字工具显示边界框
                    QFont font(a->data.fontFamily, a->data.fontSize);
                    font.setBold(a->data.isBold); font.setItalic(a->data.isItalic);
                    QRect r = QFontMetrics(font).boundingRect(a->data.text);
                    r.moveTo(a->data.points[0].toPoint().x(), a->data.points[0].toPoint().y() - r.height());
                    p.drawRect(r.adjusted(-4, -2, 4, 2));
                }

                // 绘制编辑句柄
                auto handles = a->getHandles();
                for(const auto& hh : std::as_const(handles)) {
                    p.setPen(QPen(Qt::white, 1));
                    p.setBrush(QColor(0, 120, 255));
                    p.drawRect(hh);
                }
                p.restore();
            }
        }
        if(m_isDrawing && m_activeShape) {
            m_activeShape->draw(p, m_mosaicPixmap);
        }
        p.restore(); // [CRITICAL] 恢复状态，解除选区 clip
    }

    // [CRITICAL] 放大镜绘制必须在选区 clip 之外，以防被裁剪
    if (m_state == ScreenshotState::Selecting || m_isDragging || m_isDrawing || m_currentTool == ScreenshotToolType::Picker) {
        drawMagnifier(p, m_lastMouseMovePos);
    }
}

void ScreenshotTool::setTool(ScreenshotToolType t) { if(m_textInput->isVisible()) commitTextInput(); m_currentTool = t; QSettings("RapidNotes", "Screenshot").setValue("tool", static_cast<int>(t)); }
void ScreenshotTool::setDrawColor(const QColor& c) { 
    m_currentColor = c; 
    QSettings("RapidNotes", "Screenshot").setValue("color", c); 
    if (m_toolbar) m_toolbar->addRecentColor(c);
}
void ScreenshotTool::setDrawWidth(int w) { m_currentStrokeWidth = w; QSettings("RapidNotes", "Screenshot").setValue("strokeWidth", w); }
void ScreenshotTool::setArrowStyle(ArrowStyle s) { m_currentArrowStyle = s; QSettings("RapidNotes", "Screenshot").setValue("arrowStyle", static_cast<int>(s)); }
void ScreenshotTool::setFillEnabled(bool enabled) { m_fillEnabled = enabled; }
void ScreenshotTool::setBold(bool bold) { m_currentBold = bold; QSettings("RapidNotes", "Screenshot").setValue("bold", bold); }
void ScreenshotTool::setItalic(bool italic) { m_currentItalic = italic; QSettings("RapidNotes", "Screenshot").setValue("italic", italic); }
void ScreenshotTool::setFontFamily(const QString& family) { m_currentFontFamily = family; QSettings("RapidNotes", "Screenshot").setValue("fontFamily", family); }
void ScreenshotTool::setFontSize(int size) { m_currentFontSize = size; QSettings("RapidNotes", "Screenshot").setValue("fontSize", size); }

void ScreenshotTool::undo() { if(!m_annotations.isEmpty()) { m_redoStack.append(m_annotations.takeLast()); update(); } }
void ScreenshotTool::redo() { if(!m_redoStack.isEmpty()) { m_annotations.append(m_redoStack.takeLast()); update(); } }
void ScreenshotTool::copyToClipboard() { 
    QImage img = generateFinalImage();
    emit screenshotCaptured(img, false);
    ClipboardMonitor::instance().forceNext();
    QApplication::clipboard()->setImage(img); 
    autoSaveImage(img);
    cancel(); 
}
void ScreenshotTool::save() { 
    QImage img = generateFinalImage();
    emit screenshotCaptured(img, false);
    QString fileName = QString("RPN_%1.png").arg(QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss"));
    QString f = QFileDialog::getSaveFileName(this, "保存截图", fileName, "PNG(*.png)"); 
    if(!f.isEmpty()) img.save(f); 
    autoSaveImage(img);
    cancel(); 
}
void ScreenshotTool::confirm() { 
    if (m_isConfirmed) return;
    m_isConfirmed = true;
    QImage img = generateFinalImage();
    emit screenshotCaptured(img, m_isImmediateOCR); 
    autoSaveImage(img);
    cancel(); 
}
void ScreenshotTool::pin() { QImage img = generateFinalImage(); if (img.isNull()) return; auto* widget = new PinnedScreenshotWidget(QPixmap::fromImage(img), selectionRect()); widget->show(); cancel(); }

QRect ScreenshotTool::selectionRect() const { return QRect(m_startPoint, m_endPoint).normalized(); }
QList<QRect> ScreenshotTool::getHandleRects() const {
    QRect r = selectionRect(); QList<QRect> l; if(r.isEmpty()) return l; int s = 10;
    l << QRect(r.left()-s/2, r.top()-s/2, s, s) << QRect(r.center().x()-s/2, r.top()-s/2, s, s)
      << QRect(r.right()-s/2, r.top()-s/2, s, s) << QRect(r.right()-s/2, r.center().y()-s/2, s, s)
      << QRect(r.right()-s/2, r.bottom()-s/2, s, s) << QRect(r.center().x()-s/2, r.bottom()-s/2, s, s)
      << QRect(r.left()-s/2, r.bottom()-s/2, s, s) << QRect(r.left()-s/2, r.center().y()-s/2, s, s);
    return l;
}
int ScreenshotTool::getHandleAt(const QPoint& p) const { auto l = getHandleRects(); for(int i=0; i<l.size(); ++i) if(l[i].contains(p)) return i; return -1; }
void ScreenshotTool::updateCursor(const QPoint& p) {
    if (m_state == ScreenshotState::Editing) {
        int handle = getHandleAt(p); if (handle != -1) {
            switch (handle) { case 0: case 4: setCursor(Qt::SizeFDiagCursor); break; case 1: case 5: setCursor(Qt::SizeVerCursor); break; case 2: case 6: setCursor(Qt::SizeBDiagCursor); break; case 3: case 7: setCursor(Qt::SizeHorCursor); break; }
            return;
        }
        if (selectionRect().contains(p)) { if (m_currentTool != ScreenshotToolType::None) setCursor(Qt::CrossCursor); else setCursor(Qt::SizeAllCursor); return; }
    }
    setCursor(Qt::ArrowCursor);
}
void ScreenshotTool::showTextInput(const QPoint& p) { 
    m_textInput->move(p); 
    m_textInput->resize(200, 30); 
    QFont font(m_currentFontFamily, m_currentFontSize);
    font.setBold(m_currentBold);
    font.setItalic(m_currentItalic);
    m_textInput->setFont(font);
    m_textInput->setStyleSheet(QString("color: %1; background: transparent;").arg(m_currentColor.name()));
    m_textInput->show(); 
    m_textInput->setFocus(); 
}
void ScreenshotTool::commitTextInput() {
    if(m_textInput->text().isEmpty()) { m_textInput->hide(); return; }
    DrawingAnnotation ann = {ScreenshotToolType::Text, {m_textInput->pos()}, m_currentColor, m_textInput->text(), m_currentStrokeWidth, LineStyle::Solid, ArrowStyle::SolidSingle, false,
                             m_currentFontFamily, m_currentFontSize, m_currentBold, m_currentItalic};
    BaseShape* shape = createShape(ann);
    if (shape) {
        m_annotations.append(shape);
        qDeleteAll(m_redoStack);
        m_redoStack.clear();
    }
    m_textInput->hide(); m_textInput->clear(); update();
}

#ifdef Q_OS_WIN
BOOL CALLBACK EnumChildProc(HWND hwnd, LPARAM lParam) {
    QList<QRect>* rects = reinterpret_cast<QList<QRect>*>(lParam);
    // 子窗口使用 GetWindowRect 即可，DWM 扩展边框通常只针对顶层窗口
    if (IsWindowVisible(hwnd)) {
        RECT rect;
        if (GetWindowRect(hwnd, &rect)) {
            QRect qr(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
            if (qr.width() > 5 && qr.height() > 5) rects->append(qr);
        }
    }
    return TRUE;
}
BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam) {
    QList<QRect>* rects = reinterpret_cast<QList<QRect>*>(lParam);
    if (IsWindowVisible(hwnd) && !IsIconic(hwnd)) {
        TCHAR className[256]; GetClassName(hwnd, className, 256);
        if (_tcscmp(className, _T("Qt662QWindowIcon")) == 0) return TRUE;
        int cloaked = 0; DwmGetWindowAttribute(hwnd, DWMWA_CLOAKED, &cloaked, sizeof(cloaked));
        if (cloaked) return TRUE;
        QRect qr = getActualWindowRect(hwnd); if (qr.width() > 10 && qr.height() > 10) { rects->append(qr); EnumChildWindows(hwnd, EnumChildProc, lParam); }
    }
    return TRUE;
}
#endif
void ScreenshotTool::detectWindows() { 
    if (m_state != ScreenshotState::Selecting) return;
    m_detectedRects.clear();
#ifdef Q_OS_WIN
    EnumWindows(EnumWindowsProc, reinterpret_cast<LPARAM>(&m_detectedRects));
#endif

    // 关键优化：遍历本应用内所有活跃的 Qt 部件，实现对搜索框、分类栏等细微控件的精确侦测
    for (QWidget* top : QApplication::topLevelWidgets()) {
        if (top->isVisible() && !top->isMinimized() && top != this && top->windowOpacity() > 0) {
            collectQtWidgets(top);
        }
    }

    // 统一坐标系转换
    QPoint offset = mapToGlobal(QPoint(0,0)); 
    for(QRect& r : m_detectedRects) r.translate(-offset);
    
    // 去重并过滤极小区域
    QList<QRect> filtered;
    for (const QRect& r : std::as_const(m_detectedRects)) {
        if (r.width() > 5 && r.height() > 5 && !filtered.contains(r)) {
            filtered.append(r);
        }
    }
    m_detectedRects = filtered;
}

void ScreenshotTool::drawMagnifier(QPainter& p, const QPoint& pos) {
    if (pos.x() < 0 || pos.y() < 0 || pos.x() >= m_screenImage.width() || pos.y() >= m_screenImage.height()) return;

    p.save();
    const int zoom = 12;
    const int cols = 21;
    const int rows = 11;
    const int magWidth = cols * zoom;
    const int magHeight = rows * zoom;
    const int infoHeight = 130;
    
    int margin = 30;
    QRect sel = selectionRect();
    QRect magRect(pos.x() + margin, pos.y() + margin, magWidth, magHeight);

    // [CRITICAL] 放大镜绘制逻辑：当鼠标在选区内时，尝试在四个方向寻找空间放置放大镜，避免遮挡。
    if (m_state == ScreenshotState::Editing && sel.contains(pos)) {
        if (sel.right() + margin + magWidth < width()) magRect.moveTo(sel.right() + margin, pos.y() - magHeight / 2);
        else if (sel.left() - margin - magWidth > 0) magRect.moveTo(sel.left() - margin - magWidth, pos.y() - magHeight / 2);
        else if (sel.top() - margin - magHeight - infoHeight > 0) magRect.moveTo(pos.x() - magWidth / 2, sel.top() - margin - magHeight - infoHeight);
        else if (sel.bottom() + margin < height()) magRect.moveTo(pos.x() - magWidth / 2, sel.bottom() + margin);
    }

    // 边界安全检查，确保放大镜和信息面板不超出屏幕
    if (magRect.right() > width()) magRect.moveRight(width() - 5);
    if (magRect.left() < 0) magRect.moveLeft(5);
    if (magRect.bottom() + infoHeight > height()) magRect.moveBottom(height() - infoHeight - 5);
    if (magRect.top() < 0) magRect.moveTop(5);
    
    p.setRenderHint(QPainter::Antialiasing, false);
    
    // 1. 绘制放大区域背景及边框
    p.setPen(QPen(Qt::white, 1));
    p.setBrush(Qt::black);
    p.drawRect(magRect.adjusted(-1, -1, 1, 1));
    
    // 这里的源矩形取自原始屏幕像素
    QRect srcRect(pos.x() - cols/2, pos.y() - rows/2, cols, rows);
    p.drawPixmap(magRect, m_screenPixmap, srcRect);
    
    // 2. 绘制像素网格
    p.setPen(QPen(QColor(255, 255, 255, 50), 1));
    for (int i = 0; i <= magWidth; i += zoom) p.drawLine(magRect.left() + i, magRect.top(), magRect.left() + i, magRect.bottom());
    for (int i = 0; i <= magHeight; i += zoom) p.drawLine(magRect.left(), magRect.top() + i, magRect.right(), magRect.top() + i);
    
    // 3. 绘制中心像素高亮框
    p.setPen(QPen(Qt::white, 1));
    p.setBrush(Qt::NoBrush);
    p.drawRect(magRect.left() + (cols/2)*zoom, magRect.top() + (rows/2)*zoom, zoom, zoom);
    
    // 4. 绘制下方黑色信息面板
    QRect infoRect(magRect.left(), magRect.bottom() + 1, magWidth, infoHeight);
    p.fillRect(infoRect, Qt::black);
    
    QColor color = m_screenImage.pixelColor(pos);
    QString colorStr;
    if (m_colorFormatIndex == 0) colorStr = color.name(QColor::HexRgb).toUpper();
    else if (m_colorFormatIndex == 1) colorStr = QString("%1, %2, %3").arg(color.red()).arg(color.green()).arg(color.blue());
    else {
        // HSL 格式处理
        int h = color.hslHue() < 0 ? 0 : color.hslHue();
        int s = int(color.hslSaturationF() * 100);
        int l = int(color.lightnessF() * 100);
        colorStr = QString("HSL(%1, %2, %3)").arg(h).arg(s).arg(l);
    }

    p.setPen(Qt::white);
    p.setRenderHint(QPainter::TextAntialiasing);
    QFont font("Microsoft YaHei", 10);
    p.setFont(font);

    // 第一行：坐标 (x , y)
    QString coordStr = QString("(%1 , %2)").arg(pos.x()).arg(pos.y());
    p.drawText(infoRect.adjusted(0, 10, 0, 0), Qt::AlignHCenter | Qt::AlignTop, coordStr);

    // 第二行：颜色预览方块 + 色值文本
    int textWidth = p.fontMetrics().horizontalAdvance(colorStr);
    int totalContentWidth = 16 + 8 + textWidth; // 方块(16) + 间距(8) + 文本
    int startX = infoRect.left() + (magWidth - totalContentWidth) / 2;
    int line2Y = infoRect.top() + 38;
    
    p.setBrush(color);
    p.setPen(QPen(Qt::white, 1));
    p.drawRect(startX, line2Y, 16, 16);
    
    p.setPen(Qt::white);
    p.drawText(startX + 24, line2Y + 13, colorStr);

    // 第三、四、五行：功能提示
    font.setPointSize(9);
    p.setFont(font);
    p.drawText(infoRect.adjusted(0, 65, 0, 0), Qt::AlignHCenter | Qt::AlignTop, "Shift:  切换颜色格式");
    p.drawText(infoRect.adjusted(0, 86, 0, 0), Qt::AlignHCenter | Qt::AlignTop, "C:  复制色值");
    p.drawText(infoRect.adjusted(0, 107, 0, 0), Qt::AlignHCenter | Qt::AlignTop, "M:  复制坐标");

    p.restore();
}

void ScreenshotTool::collectQtWidgets(QWidget* parent) {
    if (!parent || !parent->isVisible()) return;

    // 记录当前部件的全局几何信息
    QRect r = parent->rect();
    QPoint globalPos = parent->mapToGlobal(QPoint(0,0));
    r.moveTo(globalPos);
    m_detectedRects.append(r);

    // 递归处理子部件
    const QObjectList& children = parent->children();
    for (QObject* childObj : children) {
        QWidget* child = qobject_cast<QWidget*>(childObj);
        if (child && child->isVisible() && !child->rect().isEmpty()) {
            collectQtWidgets(child);
        }
    }
}
void ScreenshotTool::executeOCR() {
    QImage img = generateFinalImage();
    emit screenshotCaptured(img, true);
    cancel();
}

QImage ScreenshotTool::generateFinalImage() {
    QRect r = selectionRect(); if(r.isEmpty()) return QImage();
    QPixmap p = m_screenPixmap.copy(r); QPainter painter(&p); painter.translate(-r.topLeft());
    for(auto* a : std::as_const(m_annotations)) a->draw(painter, m_mosaicPixmap);
    return p.toImage();
}

void ScreenshotTool::autoSaveImage(const QImage& img) {
    if (img.isNull()) return;
    
    QSettings settings("RapidNotes", "Screenshot");
    QString defaultPath = QCoreApplication::applicationDirPath() + "/RPN_screenshot";
    QString savePath = settings.value("savePath", defaultPath).toString();
    
    QDir dir(savePath);
    if (!dir.exists()) {
        dir.mkpath(".");
    }
    
    QString fileName = QString("RPN_%1.png").arg(QDateTime::currentDateTime().toString("yyyyMMdd_HHmmss"));
    QString fullPath = dir.absoluteFilePath(fileName);
    
    if (img.save(fullPath)) {
        // 使用非阻塞彩色反馈告知用户已自动保存
        ToolTipOverlay::instance()->showText(QCursor::pos(), QString("✔ 已自动保存至:\n%1").arg(fullPath));
    } else {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "✖ 自动保存失败，请检查路径权限");
    }
}
void ScreenshotTool::keyPressEvent(QKeyEvent* e) { 
    if(e->key() == Qt::Key_Escape) cancel(); 
    else if(e->key() == Qt::Key_Return || e->key() == Qt::Key_Enter || e->key() == Qt::Key_Space) { if(m_state == ScreenshotState::Editing) confirm(); }
    else if (e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_Z) undo();
    else if (e->modifiers() == (Qt::ControlModifier | Qt::ShiftModifier) && e->key() == Qt::Key_Z) redo();
    else if (e->modifiers() == Qt::ControlModifier && e->key() == Qt::Key_O) executeOCR();
    else if (e->key() == Qt::Key_F) pin();
    else if (e->key() == Qt::Key_C) { 
        // 如果放大镜可见，C 键用于复制当前像素色值
        if (m_state == ScreenshotState::Selecting || m_isDragging || m_isDrawing || m_currentTool == ScreenshotToolType::Picker) {
            QColor color = m_screenImage.pixelColor(m_lastMouseMovePos);
            QString colorStr;
            if (m_colorFormatIndex == 0) colorStr = color.name(QColor::HexRgb).toUpper();
            else if (m_colorFormatIndex == 1) colorStr = QString("%1, %2, %3").arg(color.red()).arg(color.green()).arg(color.blue());
            else colorStr = QString("HSL(%1, %2, %3)").arg(color.hslHue() < 0 ? 0 : color.hslHue()).arg(int(color.hslSaturationF()*100)).arg(int(color.lightnessF()*100));
            
            ClipboardMonitor::instance().forceNext();
            QApplication::clipboard()->setText(colorStr);
            ToolTipOverlay::instance()->showText(QCursor::pos(), QString("已复制色值: %1").arg(colorStr));
        } else {
            m_toolbar->selectTool(ScreenshotToolType::Picker); 
        }
    }
    else if (e->key() == Qt::Key_Shift) {
        m_colorFormatIndex = (m_colorFormatIndex + 1) % 3;
        update();
    }
    else if (e->key() == Qt::Key_M) {
        QString coordStr = QString("%1, %2").arg(m_lastMouseMovePos.x()).arg(m_lastMouseMovePos.y());
        ClipboardMonitor::instance().forceNext();
        QApplication::clipboard()->setText(coordStr);
        ToolTipOverlay::instance()->showText(QCursor::pos(), QString("已复制坐标: %1").arg(coordStr));
    }
}
void ScreenshotTool::mouseDoubleClickEvent(QMouseEvent* e) { if(selectionRect().contains(e->pos())) confirm(); }

bool ScreenshotTool::eventFilter(QObject* watched, QEvent* event) {
    if (watched == m_textInput && event->type() == QEvent::KeyPress) {
        QKeyEvent* ke = static_cast<QKeyEvent*>(event);
        if (ke->key() == Qt::Key_Escape) {
            cancel();
            return true;
        }
    }
    return QWidget::eventFilter(watched, event);
}
```

## 文件: `src/ui/ScreenshotTool.h`

```cpp
#ifndef SCREENSHOTTOOL_H
#define SCREENSHOTTOOL_H

#include <QWidget>
#include <QMouseEvent>
#include <QGuiApplication>
#include <QScreen>
#include <QPixmap>
#include <QPainter>
#include <QPainterPath>
#include <QPushButton>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QMap>
#include <QLineEdit>
#include <QButtonGroup>
#include <QMenu>
#include <QColorDialog>
#include <QList>
#include <functional>
#include <utility>

enum class ScreenshotState { Selecting, Editing };
enum class ScreenshotToolType { None, Rect, Ellipse, Arrow, Line, Pen, Marker, Text, Mosaic, MosaicRect, Eraser, Picker };
enum class ArrowStyle { 
    SolidSingle, OutlineSingle, 
    SolidDouble, OutlineDouble, 
    SolidDot, OutlineDot,
    Thin,
    Dimension
};
enum class LineStyle { Solid, Dash, Dot };

struct DrawingAnnotation {
    ScreenshotToolType type;
    QList<QPointF> points;
    QColor color;
    QString text;
    int strokeWidth;
    LineStyle lineStyle;
    ArrowStyle arrowStyle;
    bool isFilled = false;
    // 文本相关属性
    QString fontFamily = "Microsoft YaHei";
    int fontSize = 12;
    bool isBold = false;
    bool isItalic = false;
};

class BaseShape {
public:
    BaseShape(const DrawingAnnotation& ann) : data(ann) {}
    virtual ~BaseShape() = default;
    virtual void draw(QPainter& painter, const QPixmap& mosaicPixmap) const = 0;
    virtual bool hitTest(const QPoint& pos) const = 0;
    virtual QList<QRect> getHandles() const { return {}; }
    virtual int getHandleAt(const QPoint& pos) const;
    virtual void updatePoint(int index, const QPoint& pos) { if(index >= 0 && index < data.points.size()) data.points[index] = pos; }
    virtual void moveBy(const QPoint& delta);
    DrawingAnnotation data;
};

class RectShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
    void updatePoint(int index, const QPoint& pos) override;
};

class EllipseShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
    void updatePoint(int index, const QPoint& pos) override;
};

class LineShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
};

class ArrowShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
};

class PenShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
};

class MarkerShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
};

class TextShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
};

class MosaicShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
};

class MosaicRectShape : public BaseShape {
public:
    using BaseShape::BaseShape;
    void draw(QPainter& painter, const QPixmap& mosaicPixmap) const override;
    bool hitTest(const QPoint& pos) const override;
    QList<QRect> getHandles() const override;
    void updatePoint(int index, const QPoint& pos) override;
};

class ScreenshotTool;
class ScreenshotToolbar;

class PinnedScreenshotWidget : public QWidget {
    Q_OBJECT
public:
    explicit PinnedScreenshotWidget(const QPixmap& pixmap, const QRect& screenRect, QWidget* parent = nullptr);
protected:
    void paintEvent(QPaintEvent*) override;
    void mousePressEvent(QMouseEvent*) override;
    void mouseMoveEvent(QMouseEvent*) override;
    void mouseDoubleClickEvent(QMouseEvent*) override;
    void contextMenuEvent(QContextMenuEvent*) override;
private:
    QPixmap m_pixmap;
    QPoint m_dragPos;
};

class ScreenshotToolbar : public QWidget {
    Q_OBJECT
public:
    explicit ScreenshotToolbar(ScreenshotTool* tool);
    void addToolButton(QBoxLayout* layout, ScreenshotToolType type, const QString& iconType, const QString& tip);
    void addActionButton(QBoxLayout* layout, const QString& iconName, const QString& tip, std::function<void()> func);
    void selectTool(ScreenshotToolType type);
    void updateArrowButtonIcon(ArrowStyle style);
    void addRecentColor(const QColor& c, bool save = true);
    void syncColorSelection(const QColor& color);

protected:
    void paintEvent(QPaintEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;

private:
    void createOptionWidget();
    void showArrowMenu();

public:
    ScreenshotTool* m_tool;
    QMap<ScreenshotToolType, QPushButton*> m_buttons;
    QWidget* m_optionWidget = nullptr;
    QPushButton* m_arrowStyleBtn = nullptr;
    QPushButton* m_outlineBtn = nullptr;
    QPushButton* m_solidBtn = nullptr;
    QPushButton* m_wheelBtn = nullptr;
    QBoxLayout* m_recentLayout = nullptr;
    QWidget* m_textOptionWidget = nullptr;
    QWidget* m_sizeOptionWidget = nullptr;
    QFrame* m_textDivider = nullptr;
    QFrame* m_horizontalDivider = nullptr;
    QPushButton* m_boldBtn = nullptr;
    QPushButton* m_italicBtn = nullptr;
    QPushButton* m_removeColorBtn = nullptr; // 用于删除最近颜色

    bool m_isDragging = false;
    QPoint m_dragPosition;

    QButtonGroup* m_colorGroup = nullptr;
    QButtonGroup* m_sizeGroup = nullptr;
    QPushButton* m_paletteBtn = nullptr;
};

class SelectionInfoBar : public QWidget {
    Q_OBJECT
    friend class ScreenshotToolbar;
public:
    explicit SelectionInfoBar(QWidget* parent = nullptr);
    void updateInfo(const QRect& rect);
protected:
    void paintEvent(QPaintEvent*) override;
private:
    QString m_text;
};

class ScreenshotTool : public QWidget {
    Q_OBJECT
    friend class ScreenshotToolbar;
public:
    explicit ScreenshotTool(QWidget* parent = nullptr);
    ~ScreenshotTool() override;
    
    void setDrawColor(const QColor& color);
    void setDrawWidth(int width);
    void setArrowStyle(ArrowStyle style);
    void setFillEnabled(bool enabled);
    void setBold(bool bold);
    void setItalic(bool italic);
    void setFontFamily(const QString& family);
    void setFontSize(int size);
    
    void updateToolbarPosition();
    void undo();
    void redo();
    void copyToClipboard();
    void save();
    void confirm();
    void pin();
    void cancel(); 
    void executeOCR();

    void setImmediateOCRMode(bool enabled) { m_isImmediateOCR = enabled; }

signals:
    void screenshotCaptured(const QImage& image, bool isOcr = false);
    void screenshotCanceled();

protected:
    void paintEvent(QPaintEvent*) override;
    void wheelEvent(QWheelEvent* event) override;
    void showEvent(QShowEvent* event) override;
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void mouseDoubleClickEvent(QMouseEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

public slots:
    void setTool(ScreenshotToolType type);

private:
    QRect selectionRect() const;
    QList<QRect> getHandleRects() const;
    int getHandleAt(const QPoint& pos) const;
    void updateCursor(const QPoint& pos);
    void showTextInput(const QPoint& pos);
    void commitTextInput();
    QImage generateFinalImage();
    void autoSaveImage(const QImage& img);
    void detectWindows();
    void collectQtWidgets(QWidget* parent);
    void drawMagnifier(QPainter& p, const QPoint& pos);

    QPixmap m_screenPixmap;
    QImage m_screenImage;
    QPixmap m_mosaicPixmap;
    
    ScreenshotState m_state = ScreenshotState::Selecting;
    ScreenshotToolType m_currentTool = ScreenshotToolType::None;
    
    QList<QRect> m_detectedRects;
    QRect m_highlightedRect;

    QPoint m_startPoint, m_endPoint;
    QPoint m_dragOrigin; // 新增：用于记录拖拽操作的起始点，避免污染 m_startPoint
    bool m_isDragging = false;
    int m_dragHandle = -1; 
    bool m_isConfirmed = false;

    QList<BaseShape*> m_annotations;
    QList<BaseShape*> m_redoStack;
    BaseShape* m_activeShape = nullptr;
    BaseShape* m_hoveredShape = nullptr;
    int m_editHandle = -1;
    DrawingAnnotation m_currentAnnotation;
    bool m_isDrawing = false;

    ScreenshotToolbar* m_toolbar = nullptr;
    SelectionInfoBar* m_infoBar = nullptr;
    QLineEdit* m_textInput = nullptr;
    QPoint m_lastMouseMovePos;
    int m_colorFormatIndex = 0; // 0: Hex, 1: RGB, 2: HSL
    bool m_isImmediateOCR = false;

    QColor m_currentColor = QColor(255, 50, 50); 
    int m_currentStrokeWidth = 3; 
    ArrowStyle m_currentArrowStyle = ArrowStyle::SolidSingle;
    bool m_fillEnabled = false;
    LineStyle m_currentLineStyle = LineStyle::Solid;

    QString m_currentFontFamily = "Microsoft YaHei";
    int m_currentFontSize = 14;
    bool m_currentBold = true;
    bool m_currentItalic = false;
};

#endif // SCREENSHOTTOOL_H
```

## 文件: `src/ui/SearchLineEdit.cpp`

```cpp
#include "SearchLineEdit.h"
#include "IconHelper.h"
#include <QSettings>
#include <QMenu>
#include <QFrame>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QScrollArea>
#include <QLayout>
#include <QStyle>
#include <QGraphicsDropShadowEffect>
#include <QPropertyAnimation>
#include "FlowLayout.h"

// --- History Chip ---
class HistoryChip : public QFrame {
    Q_OBJECT
public:
    HistoryChip(const QString& text, QWidget* parent = nullptr) : QFrame(parent), m_text(text) {
        setAttribute(Qt::WA_StyledBackground);
        setCursor(Qt::PointingHandCursor);
        setObjectName("HistoryChip");
        
        auto* layout = new QHBoxLayout(this);
        layout->setContentsMargins(10, 6, 10, 6);
        layout->setSpacing(10);
        
        auto* lbl = new QLabel(text);
        lbl->setStyleSheet("border: none; background: transparent; color: #DDD; font-size: 13px;");
        layout->addWidget(lbl);
        layout->addStretch();
        
        m_btnDel = new QPushButton();
        m_btnDel->setIcon(IconHelper::getIcon("close", "#666", 16));
        m_btnDel->setIconSize(QSize(10, 10));
        m_btnDel->setFixedSize(16, 16);
        m_btnDel->setCursor(Qt::PointingHandCursor);
        m_btnDel->setStyleSheet(
            "QPushButton {"
            "  background-color: transparent;"
            "  border-radius: 4px;"
            "  padding: 0px;"
            "}"
            "QPushButton:hover {"
            "  background-color: #E74C3C;"
            "}"
        );
        
        connect(m_btnDel, &QPushButton::clicked, this, [this](){ emit deleted(m_text); });
        layout->addWidget(m_btnDel);

        setStyleSheet(
            "#HistoryChip {"
            "  background-color: transparent;"
            "  border: none;"
            "  border-radius: 4px;"
            "}"
            "#HistoryChip:hover {"
            "  background-color: #3E3E42;"
            "}"
        );
    }
    
    void mousePressEvent(QMouseEvent* e) override { 
        if(e->button() == Qt::LeftButton && !m_btnDel->underMouse()) {
            emit clicked(m_text); 
        }
        QFrame::mousePressEvent(e);
    }

signals:
    void clicked(const QString& text);
    void deleted(const QString& text);
private:
    QString m_text;
    QPushButton* m_btnDel;
};

// --- SearchHistoryPopup ---
class SearchHistoryPopup : public QWidget {
    Q_OBJECT
public:
    explicit SearchHistoryPopup(SearchLineEdit* edit) 
        : QWidget(edit->window(), Qt::Popup | Qt::FramelessWindowHint | Qt::NoDropShadowWindowHint) 
    {
        m_edit = edit;
        setAttribute(Qt::WA_TranslucentBackground);
        
        auto* rootLayout = new QVBoxLayout(this);
        rootLayout->setContentsMargins(m_shadowMargin, m_shadowMargin, m_shadowMargin, m_shadowMargin);
        
        m_container = new QFrame();
        m_container->setObjectName("PopupContainer");
        m_container->setStyleSheet(
            "#PopupContainer {"
            "  background-color: #252526;"
            "  border: 1px solid #444;"
            "  border-radius: 10px;"
            "}"
        );
        rootLayout->addWidget(m_container);

        auto* shadow = new QGraphicsDropShadowEffect(m_container);
        shadow->setBlurRadius(20); shadow->setXOffset(0); shadow->setYOffset(5);
        shadow->setColor(QColor(0, 0, 0, 120));
        m_container->setGraphicsEffect(shadow);

        auto* layout = new QVBoxLayout(m_container);
        layout->setContentsMargins(12, 12, 12, 12);
        layout->setSpacing(10);

        auto* top = new QHBoxLayout();
        auto* icon = new QLabel();
        icon->setPixmap(IconHelper::getIcon("clock", "#888").pixmap(14, 14));
        icon->setStyleSheet("border: none; background: transparent;");
        top->addWidget(icon);

        auto* title = new QLabel("搜索历史");
        title->setStyleSheet("color: #888; font-weight: bold; font-size: 11px; background: transparent; border: none;");
        top->addWidget(title);
        top->addStretch();
        auto* clearBtn = new QPushButton("清空");
        clearBtn->setCursor(Qt::PointingHandCursor);
        clearBtn->setStyleSheet("QPushButton { background: transparent; color: #666; border: none; font-size: 11px; } QPushButton:hover { color: #E74C3C; }");
        connect(clearBtn, &QPushButton::clicked, [this](){
            m_edit->clearHistory();
            refreshUI();
        });
        top->addWidget(clearBtn);
        layout->addLayout(top);

        auto* scroll = new QScrollArea();
        scroll->setWidgetResizable(true);
        scroll->setStyleSheet(
            "QScrollArea { background-color: transparent; border: none; }"
            "QScrollArea > QWidget > QWidget { background-color: transparent; }"
        );
        scroll->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
        scroll->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);

        m_chipsWidget = new QWidget();
        m_chipsWidget->setStyleSheet("background-color: transparent;");
        m_vLayout = new QVBoxLayout(m_chipsWidget);
        m_vLayout->setContentsMargins(0, 0, 0, 0);
        m_vLayout->setSpacing(2);
        m_vLayout->addStretch();
        scroll->setWidget(m_chipsWidget);
        layout->addWidget(scroll);

        m_opacityAnim = new QPropertyAnimation(this, "windowOpacity");
        m_opacityAnim->setDuration(200);
        m_opacityAnim->setEasingCurve(QEasingCurve::OutCubic);

        refreshUI();
    }

    void refreshUI() {
        QLayoutItem* item;
        while ((item = m_vLayout->takeAt(0))) {
            if(item->widget()) item->widget()->deleteLater();
            delete item;
        }
        m_vLayout->addStretch(); // 底部拉伸
        
        QStringList history = m_edit->getHistory();
        int targetContentWidth = m_edit->width();
        int contentHeight = 0;

        if(history.isEmpty()) {
            auto* lbl = new QLabel("暂无历史记录");
            lbl->setAlignment(Qt::AlignCenter);
            lbl->setStyleSheet("color: #555; font-style: italic; margin: 20px; background: transparent; border: none;");
            m_vLayout->insertWidget(0, lbl);
            contentHeight = 100;
        } else {
            for(const QString& text : history) {
                auto* chip = new HistoryChip(text);
                chip->setFixedHeight(32);
                connect(chip, &HistoryChip::clicked, this, [this](const QString& t){ 
                    m_edit->setText(t); 
                    emit m_edit->returnPressed(); 
                    close(); 
                });
                connect(chip, &HistoryChip::deleted, this, [this](const QString& t){ 
                    m_edit->removeHistoryEntry(t); 
                    refreshUI(); 
                });
                m_vLayout->insertWidget(m_vLayout->count() - 1, chip); // 插入到 stretch 之前
            }
            
            contentHeight = qMin(410, (int)history.size() * 34 + 60);
        }
        
        this->resize(targetContentWidth + (m_shadowMargin * 2), contentHeight + (m_shadowMargin * 2));
    }

    void showAnimated() {
        refreshUI();
        
        // 坐标对齐逻辑
        QPoint pos = m_edit->mapToGlobal(QPoint(0, m_edit->height()));
        int xPos = pos.x() - m_shadowMargin;
        int yPos = pos.y() + 5 - m_shadowMargin; // 5px 间距
        move(xPos, yPos);
        
        setWindowOpacity(0);
        show();
        
        m_opacityAnim->setStartValue(0);
        m_opacityAnim->setEndValue(1);
        m_opacityAnim->start();
    }

private:
    SearchLineEdit* m_edit;
    QFrame* m_container;
    QWidget* m_chipsWidget;
    QVBoxLayout* m_vLayout;
    QPropertyAnimation* m_opacityAnim;
    int m_shadowMargin = 12;
};

// --- SearchLineEdit Implementation ---
SearchLineEdit::SearchLineEdit(QWidget* parent) : QLineEdit(parent) {
    setClearButtonEnabled(true);
    setStyleSheet(
        "QLineEdit { "
        "  background-color: #252526; "
        "  border: 1px solid #333; "
        "  border-radius: 6px; "
        "  padding: 8px 15px; "
        "  color: #eee; "
        "  font-size: 14px; "
        "} "
        "QLineEdit:focus { border: 1px solid #4a90e2; } "
    );
}

void SearchLineEdit::mouseDoubleClickEvent(QMouseEvent* e) {
    if (e->button() == Qt::LeftButton) showPopup();
    QLineEdit::mouseDoubleClickEvent(e);
}

void SearchLineEdit::showPopup() {
    if(!m_popup) m_popup = new SearchHistoryPopup(this);
    m_popup->showAnimated();
}

void SearchLineEdit::addHistoryEntry(const QString& text) {
    if(text.isEmpty()) return;
    QSettings settings("RapidNotes", "SearchHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(text);
    history.prepend(text);
    while(history.size() > 10) history.removeLast();
    settings.setValue("list", history);
}

QStringList SearchLineEdit::getHistory() const {
    QSettings settings("RapidNotes", "SearchHistory");
    return settings.value("list").toStringList();
}

void SearchLineEdit::clearHistory() {
    QSettings settings("RapidNotes", "SearchHistory");
    settings.setValue("list", QStringList());
}

void SearchLineEdit::removeHistoryEntry(const QString& text) {
    QSettings settings("RapidNotes", "SearchHistory");
    QStringList history = settings.value("list").toStringList();
    history.removeAll(text);
    settings.setValue("list", history);
}

#include "SearchLineEdit.moc"
```

## 文件: `src/ui/SearchLineEdit.h`

```cpp
#ifndef SEARCHLINEEDIT_H
#define SEARCHLINEEDIT_H

#include <QLineEdit>
#include <QMouseEvent>

class SearchHistoryPopup;

class SearchLineEdit : public QLineEdit {
    Q_OBJECT
public:
    explicit SearchLineEdit(QWidget* parent = nullptr);
    void addHistoryEntry(const QString& text);
    QStringList getHistory() const;
    void clearHistory();
    void removeHistoryEntry(const QString& text);

protected:
    void mouseDoubleClickEvent(QMouseEvent* e) override;

private:
    void showPopup();
    SearchHistoryPopup* m_popup = nullptr;
};

#endif // SEARCHLINEEDIT_H
```

## 文件: `src/core/ServiceLocator.h`

```cpp
#ifndef SERVICELOCATOR_H
#define SERVICELOCATOR_H

#include <memory>
#include <map>
#include <typeindex>
#include <mutex>

class ServiceLocator {
public:
    template<typename T>
    static void registerService(std::shared_ptr<T> service) {
        std::lock_guard<std::mutex> lock(instance().m_mutex);
        instance().m_services[typeid(T)] = service;
    }

    template<typename T>
    static std::shared_ptr<T> get() {
        std::lock_guard<std::mutex> lock(instance().m_mutex);
        auto it = instance().m_services.find(typeid(T));
        if (it != instance().m_services.end()) {
            return std::static_pointer_cast<T>(it->second);
        }
        return nullptr;
    }

private:
    ServiceLocator() = default;
    static ServiceLocator& instance() {
        static ServiceLocator inst;
        return inst;
    }

    std::map<std::type_index, std::shared_ptr<void>> m_services;
    std::mutex m_mutex;
};

#endif // SERVICELOCATOR_H
```

## 文件: `src/ui/SettingsWindow.cpp`

```cpp
#include "SettingsWindow.h"
#include "CategoryPasswordDialog.h"
#include "../core/HotkeyManager.h"
#include "../core/ShortcutManager.h"
#include <QHBoxLayout>
#include <QSettings>
#include <QFileDialog>
#include <QScrollArea>
#include <QApplication>
#include <QInputDialog>
#include "ToolTipOverlay.h"

#ifdef Q_OS_WIN
#include <windows.h>
#endif

// --- HotkeyEdit 实现 ---
HotkeyEdit::HotkeyEdit(QWidget* parent) : QLineEdit(parent) {
    setReadOnly(true);
    setPlaceholderText("按键设置...");
    setAlignment(Qt::AlignCenter);
    setStyleSheet("QLineEdit { background: #1a1a1a; color: #4a90e2; font-weight: bold; border-radius: 4px; padding: 4px; border: 1px solid #333; }");
}

void HotkeyEdit::setKeyData(uint mods, uint vk) {
    m_mods = mods;
    m_vk = vk;
    setText(keyToString(mods, vk));
}

void HotkeyEdit::keyPressEvent(QKeyEvent* event) {
    int key = event->key();
    if (key == Qt::Key_Escape || key == Qt::Key_Backspace) {
        m_mods = 0;
        m_vk = 0;
        setText("");
        return;
    }

    if (key >= Qt::Key_Control && key <= Qt::Key_Meta) return;

    uint winMods = 0;
    if (event->modifiers() & Qt::ControlModifier) winMods |= 0x0002; // MOD_CONTROL
    if (event->modifiers() & Qt::AltModifier)     winMods |= 0x0001; // MOD_ALT
    if (event->modifiers() & Qt::ShiftModifier)   winMods |= 0x0004; // MOD_SHIFT
    if (event->modifiers() & Qt::MetaModifier)    winMods |= 0x0008; // MOD_WIN

    m_mods = winMods;
    m_vk = event->nativeVirtualKey();
    if (m_vk == 0) m_vk = key; // 兜底处理

    setText(keyToString(m_mods, m_vk));
}

QString HotkeyEdit::keyToString(uint mods, uint vk) {
    if (vk == 0) return "";
    QStringList parts;
    if (mods & 0x0002) parts << "Ctrl";
    if (mods & 0x0001) parts << "Alt";
    if (mods & 0x0004) parts << "Shift";
    if (mods & 0x0008) parts << "Win";
    
    // 简单模拟 VK 到 字符串转换
    QKeySequence ks(vk);
    parts << ks.toString();
    return parts.join(" + ");
}

// --- ShortcutEdit 实现 ---
ShortcutEdit::ShortcutEdit(QWidget* parent) : QLineEdit(parent) {
    setReadOnly(true);
    setPlaceholderText("录制快捷键...");
}

void ShortcutEdit::setKeySequence(const QKeySequence& seq) {
    m_seq = seq;
    setText(m_seq.toString());
}

void ShortcutEdit::keyPressEvent(QKeyEvent* event) {
    int key = event->key();
    if (key == Qt::Key_Escape || key == Qt::Key_Backspace) {
        m_seq = QKeySequence();
        setText("");
        return;
    }
    if (key >= Qt::Key_Control && key <= Qt::Key_Meta) return;

    m_seq = QKeySequence(event->modifiers() | key);
    setText(m_seq.toString());
}

// --- SettingsWindow 实现 ---
SettingsWindow::SettingsWindow(QWidget* parent)
    : FramelessDialog("系统设置", parent)
{
    setFixedSize(700, 500);
    initUi();
    loadSettings();
}

void SettingsWindow::initUi() {
    auto* mainLayout = new QHBoxLayout(m_contentArea);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    // 左侧导航
    m_navBar = new QListWidget();
    m_navBar->setFixedWidth(160);
    m_navBar->setSpacing(0);
    m_navBar->setStyleSheet(
        "QListWidget { background-color: #1e1e1e; border: none; border-right: 1px solid #333; outline: none; padding: 0px; }"
        "QListWidget::item { height: 40px; min-height: 40px; max-height: 40px; padding: 0px; padding-left: 15px; margin: 0px; color: #aaa; border: none; }"
        "QListWidget::item:selected { background-color: #2d2d2d; color: #3a90ff; border-left: 3px solid #3a90ff; }"
        "QListWidget::item:hover { background-color: #252525; }"
    );
    
    QStringList categories = {"安全设置", "全局热键", "局内快捷键", "截图设置", "软件激活"};
    m_navBar->addItems(categories);
    connect(m_navBar, &QListWidget::currentRowChanged, this, &SettingsWindow::onCategoryChanged);

    // 右侧内容
    m_contentStack = new QStackedWidget();
    m_contentStack->addWidget(createSecurityPage());
    m_contentStack->addWidget(createGlobalHotkeyPage());
    m_contentStack->addWidget(createAppShortcutPage());
    m_contentStack->addWidget(createScreenshotPage());
    m_contentStack->addWidget(createActivationPage());

    auto* rightLayout = new QVBoxLayout();
    rightLayout->setContentsMargins(20, 20, 20, 20);
    rightLayout->addWidget(m_contentStack);
    
    // 底部按钮
    auto* btnLayout = new QHBoxLayout();
    
    auto* btnRestore = new QPushButton("恢复默认设置");
    btnRestore->setFixedSize(120, 36);
    btnRestore->setStyleSheet("QPushButton { background: #444; color: #ccc; border-radius: 4px; font-weight: normal; }"
                              "QPushButton:hover { background: #555; color: white; }");
    connect(btnRestore, &QPushButton::clicked, this, &SettingsWindow::onRestoreDefaults);
    btnLayout->addWidget(btnRestore);

    btnLayout->addStretch();
    auto* btnSave = new QPushButton("保存并生效");
    btnSave->setFixedSize(120, 36);
    btnSave->setStyleSheet("QPushButton { background: #3a90ff; color: white; border-radius: 4px; font-weight: bold; }"
                           "QPushButton:hover { background: #2b7ae6; }");
    connect(btnSave, &QPushButton::clicked, this, &SettingsWindow::onSaveClicked);
    btnLayout->addWidget(btnSave);
    rightLayout->addLayout(btnLayout);

    mainLayout->addWidget(m_navBar);
    mainLayout->addLayout(rightLayout);
    
    m_navBar->setCurrentRow(0);
}

QWidget* SettingsWindow::createSecurityPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    layout->setSpacing(20);

    m_lblPwdStatus = new QLabel("当前状态：未设置锁定窗口密码");
    m_lblPwdStatus->setStyleSheet("color: #888; font-size: 14px;");
    layout->addWidget(m_lblPwdStatus);

    m_btnSetPwd = new QPushButton("设置锁定窗口密码");
    m_btnModifyPwd = new QPushButton("修改启动密码");
    m_btnRemovePwd = new QPushButton("彻底移除密码");

    QString btnStyle = "QPushButton { height: 40px; background: #2d2d2d; color: #eee; border: 1px solid #444; border-radius: 6px; }"
                       "QPushButton:hover { background: #3d3d3d; }";
    m_btnSetPwd->setStyleSheet(btnStyle);
    m_btnModifyPwd->setStyleSheet(btnStyle);
    m_btnRemovePwd->setStyleSheet("QPushButton { height: 40px; background: #442222; color: #f66; border: 1px solid #633; border-radius: 6px; }"
                                  "QPushButton:hover { background: #552222; }");

    connect(m_btnSetPwd, &QPushButton::clicked, this, &SettingsWindow::onSetPassword);
    connect(m_btnModifyPwd, &QPushButton::clicked, this, &SettingsWindow::onModifyPassword);
    connect(m_btnRemovePwd, &QPushButton::clicked, this, &SettingsWindow::onRemovePassword);

    layout->addWidget(m_btnSetPwd);
    layout->addWidget(m_btnModifyPwd);
    layout->addWidget(m_btnRemovePwd);
    layout->addStretch();
    return page;
}

QWidget* SettingsWindow::createActivationPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    layout->setSpacing(15);

    layout->addWidget(new QLabel("软件激活："));
    
    m_editSecretKey = new QLineEdit();
    m_editSecretKey->setEchoMode(QLineEdit::Password);
    m_editSecretKey->setPlaceholderText("请输入激活密钥...");
    m_editSecretKey->setStyleSheet("QLineEdit { height: 36px; padding: 0 10px; background: #1a1a1a; color: #fff; border: 1px solid #333; border-radius: 4px; }");
    layout->addWidget(m_editSecretKey);

    auto* btnActivate = new QPushButton("立即激活");
    btnActivate->setFixedHeight(40);
    btnActivate->setStyleSheet("QPushButton { background: #3a90ff; color: white; border-radius: 4px; font-weight: bold; }"
                               "QPushButton:hover { background: #2b7ae6; }");
    connect(btnActivate, &QPushButton::clicked, this, &SettingsWindow::onVerifySecretKey);
    layout->addWidget(btnActivate);

    layout->addWidget(new QLabel("<span style='color: #666; font-size: 11px;'>提示：输入正确的密钥并激活后，系统将重置试用次数。</span>"));

    layout->addStretch();
    return page;
}

#include "../core/DatabaseManager.h"

void SettingsWindow::onVerifySecretKey() {
    QString key = m_editSecretKey->text().trimmed();
    if (key == "CAC90F82-2C22-4B45-BC0C-8B34BA3CE25C") {
        DatabaseManager::instance().resetUsageCount();
        m_editSecretKey->clear();
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            "<b style='color: #2ecc71;'>✅ 激活成功，感谢支持！</b>", 5000, QColor("#2ecc71"));
    } else {
        ToolTipOverlay::instance()->showText(QCursor::pos(), "<b style='color: #e74c3c;'>❌ 密钥错误，激活失败</b>");
    }
}

QWidget* SettingsWindow::createGlobalHotkeyPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    
    auto addRow = [&](const QString& label, HotkeyEdit*& edit) {
        auto* hl = new QHBoxLayout();
        hl->addWidget(new QLabel(label));
        edit = new HotkeyEdit();
        edit->setFixedWidth(200);
        hl->addWidget(edit);
        layout->addLayout(hl);
    };

    layout->addWidget(new QLabel("系统全局热键，修改后点击保存立即生效："));
    layout->addSpacing(10);
    addRow("激活极速窗口:", m_hkQuickWin);
    addRow("快速收藏/加星:", m_hkFavorite);
    addRow("截图功能:", m_hkScreenshot);
    addRow("截图取文 (OCR):", m_hkOcr);
    
    layout->addStretch();
    return page;
}

QWidget* SettingsWindow::createAppShortcutPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    
    auto* scroll = new QScrollArea();
    scroll->setWidgetResizable(true);
    scroll->setStyleSheet("QScrollArea { border: none; background: transparent; }");
    
    auto* container = new QWidget();
    auto* vLayout = new QVBoxLayout(container);
    
    auto& sm = ShortcutManager::instance();
    QString currentCat = "";
    
    for (const auto& info : sm.getAllShortcuts()) {
        if (info.category != currentCat) {
            currentCat = info.category;
            auto* catLabel = new QLabel(currentCat);
            catLabel->setStyleSheet("color: #3a90ff; font-weight: bold; margin-top: 15px; border-bottom: 1px solid #333;");
            vLayout->addWidget(catLabel);
        }
        
        auto* row = new QHBoxLayout();
        row->addWidget(new QLabel(info.description));
        auto* edit = new ShortcutEdit();
        edit->setKeySequence(sm.getShortcut(info.id));
        edit->setProperty("id", info.id);
        edit->setFixedWidth(150);
        row->addWidget(edit);
        vLayout->addLayout(row);
    }
    
    scroll->setWidget(container);
    layout->addWidget(scroll);
    return page;
}

QWidget* SettingsWindow::createScreenshotPage() {
    auto* page = new QWidget();
    auto* layout = new QVBoxLayout(page);
    
    layout->addWidget(new QLabel("截图自动保存路径："));
    auto* row = new QHBoxLayout();
    m_editScreenshotPath = new QLineEdit();
    row->addWidget(m_editScreenshotPath);
    
    auto* btnBrowse = new QPushButton("浏览...");
    connect(btnBrowse, &QPushButton::clicked, this, &SettingsWindow::onBrowsePath);
    row->addWidget(btnBrowse);
    layout->addLayout(row);
    
    layout->addWidget(new QLabel("提示：若未设置，默认保存至程序目录下的 /RPN_screenshot"));
    layout->addStretch();
    return page;
}

void SettingsWindow::onCategoryChanged(int index) {
    m_contentStack->setCurrentIndex(index);
}

void SettingsWindow::loadSettings() {
    // 1. 加载安全设置
    updateSecurityUI();

    // 2. 加载全局热键
    QSettings hotkeys("RapidNotes", "Hotkeys");
    m_hkQuickWin->setKeyData(hotkeys.value("quickWin_mods", 0x0001).toUInt(), hotkeys.value("quickWin_vk", 0x20).toUInt());
    m_hkFavorite->setKeyData(hotkeys.value("favorite_mods", 0x0002 | 0x0004).toUInt(), hotkeys.value("favorite_vk", 0x45).toUInt());
    m_hkScreenshot->setKeyData(hotkeys.value("screenshot_mods", 0x0002 | 0x0001).toUInt(), hotkeys.value("screenshot_vk", 0x41).toUInt());
    m_hkOcr->setKeyData(hotkeys.value("ocr_mods", 0x0002 | 0x0001).toUInt(), hotkeys.value("ocr_vk", 0x51).toUInt());

    // 3. 局内快捷键在创建页面时已加载

    // 4. 加载截图路径
    QSettings ss("RapidNotes", "Screenshot");
    m_editScreenshotPath->setText(ss.value("savePath", qApp->applicationDirPath() + "/RPN_screenshot").toString());
}

void SettingsWindow::updateSecurityUI() {
    QSettings settings("RapidNotes", "QuickWindow");
    bool hasPwd = !settings.value("appPassword").toString().isEmpty();
    
    m_btnSetPwd->setVisible(!hasPwd);
    m_btnModifyPwd->setVisible(hasPwd);
    m_btnRemovePwd->setVisible(hasPwd);
    m_lblPwdStatus->setText(hasPwd ? "当前状态：已启用启动密码" : "当前状态：未设置锁定窗口密码");
}

void SettingsWindow::onSetPassword() {
    CategoryPasswordDialog dlg("设置锁定窗口密码", this);
    if (dlg.exec() == QDialog::Accepted) {
        QSettings settings("RapidNotes", "QuickWindow");
        settings.setValue("appPassword", dlg.password());
        settings.setValue("appPasswordHint", dlg.passwordHint());
        updateSecurityUI();
    }
}

void SettingsWindow::onModifyPassword() {
    // 简单起见，这里复用对话框，逻辑上通常先验证旧密码，这里按提示直接覆盖或弹出交互
    CategoryPasswordDialog dlg("修改启动密码", this);
    QSettings settings("RapidNotes", "QuickWindow");
    dlg.setInitialData(settings.value("appPasswordHint").toString());
    if (dlg.exec() == QDialog::Accepted) {
        settings.setValue("appPassword", dlg.password());
        settings.setValue("appPasswordHint", dlg.passwordHint());
        updateSecurityUI();
    }
}

void SettingsWindow::onRemovePassword() {
    // 移除前需要验证（此处为了逻辑闭环简单弹窗验证，或要求输入当前密码）
    QSettings settings("RapidNotes", "QuickWindow");
    QString realPwd = settings.value("appPassword").toString();

    // 弹出简单对话框要求确认
    bool ok = false;
    QString input = QInputDialog::getText(this, "身份验证", "请输入当前密码以移除：", QLineEdit::Password, "", &ok);
    if (ok && input == realPwd) {
        settings.remove("appPassword");
        settings.remove("appPasswordHint");
        updateSecurityUI();
    } else if (ok) {
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            "<b style='color: #e74c3c;'>❌ 密码错误，无法移除</b>");
    }
}

void SettingsWindow::onBrowsePath() {
    QString dir = QFileDialog::getExistingDirectory(this, "选择截图保存目录", m_editScreenshotPath->text());
    if (!dir.isEmpty()) {
        m_editScreenshotPath->setText(dir);
    }
}

void SettingsWindow::onSaveClicked() {
    // 1. 保存全局热键
    QSettings hotkeys("RapidNotes", "Hotkeys");
    hotkeys.setValue("quickWin_mods", m_hkQuickWin->mods());
    hotkeys.setValue("quickWin_vk", m_hkQuickWin->vk());
    hotkeys.setValue("favorite_mods", m_hkFavorite->mods());
    hotkeys.setValue("favorite_vk", m_hkFavorite->vk());
    hotkeys.setValue("screenshot_mods", m_hkScreenshot->mods());
    hotkeys.setValue("screenshot_vk", m_hkScreenshot->vk());
    hotkeys.setValue("ocr_mods", m_hkOcr->mods());
    hotkeys.setValue("ocr_vk", m_hkOcr->vk());
    
    HotkeyManager::instance().reapplyHotkeys();

    // 2. 保存局内快捷键
    auto& sm = ShortcutManager::instance();
    auto edits = m_contentStack->widget(2)->findChildren<ShortcutEdit*>();
    for (auto* edit : edits) {
        sm.setShortcut(edit->property("id").toString(), edit->keySequence());
    }
    sm.save();

    // 3. 保存截图设置
    QSettings ss("RapidNotes", "Screenshot");
    ss.setValue("savePath", m_editScreenshotPath->text());

    ToolTipOverlay::instance()->showText(QCursor::pos(), 
        "<b style='color: #2ecc71;'>✅ 设置已保存并立即生效</b>");
}

void SettingsWindow::onRestoreDefaults() {
    bool ok = false;
    QString input = QInputDialog::getText(this, "恢复默认设置", 
                                          "确认恢复默认设置？所有配置都将被重置。\n请输入“confirm”以继续：", 
                                          QLineEdit::Normal, "", &ok);
    
    if (ok && input.toLower() == "confirm") {
        // 1. 清除各部分的设置
        QSettings("RapidNotes", "Hotkeys").clear();
        QSettings("RapidNotes", "QuickWindow").clear();
        QSettings("RapidNotes", "Screenshot").clear();
        
        // 2. 局内快捷键重置
        ShortcutManager::instance().resetToDefaults();
        ShortcutManager::instance().save();
        
        // 3. 立即重载热键
        HotkeyManager::instance().reapplyHotkeys();
        
        // 4. 重新加载界面
        loadSettings();
        
        ToolTipOverlay::instance()->showText(QCursor::pos(), 
            "<b style='color: #3498db;'>ℹ️ 已恢复默认设置</b>");
    }
}
```

## 文件: `src/ui/SettingsWindow.h`

```cpp
#ifndef SETTINGSWINDOW_H
#define SETTINGSWINDOW_H

#include "FramelessDialog.h"
#include <QLineEdit>
#include <QKeySequence>
#include <QKeyEvent>
#include <QPushButton>
#include <QLabel>
#include <QListWidget>
#include <QStackedWidget>
#include <QVBoxLayout>

/**
 * @brief 全局热键捕获控件
 */
class HotkeyEdit : public QLineEdit {
    Q_OBJECT
public:
    explicit HotkeyEdit(QWidget* parent = nullptr);
    void setKeyData(uint mods, uint vk);
    uint mods() const { return m_mods; }
    uint vk() const { return m_vk; }

protected:
    void keyPressEvent(QKeyEvent* event) override;

private:
    uint m_mods = 0;
    uint m_vk = 0;
    QString keyToString(uint mods, uint vk);
};

/**
 * @brief 局内快捷键捕获控件
 */
class ShortcutEdit : public QLineEdit {
    Q_OBJECT
public:
    explicit ShortcutEdit(QWidget* parent = nullptr);
    void setKeySequence(const QKeySequence& seq);
    QKeySequence keySequence() const { return m_seq; }

protected:
    void keyPressEvent(QKeyEvent* event) override;

private:
    QKeySequence m_seq;
};

/**
 * @brief 设置窗口
 */
class SettingsWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit SettingsWindow(QWidget* parent = nullptr);

private slots:
    void onCategoryChanged(int index);
    void onSaveClicked();
    void onRestoreDefaults();
    
    // 安全设置相关
    void onSetPassword();
    void onModifyPassword();
    void onRemovePassword();
    void updateSecurityUI();

    // 软件激活相关
    void onVerifySecretKey();

    // 截图设置相关
    void onBrowsePath();

private:
    void initUi();
    void loadSettings();
    
    QWidget* createSecurityPage();
    QWidget* createGlobalHotkeyPage();
    QWidget* createAppShortcutPage();
    QWidget* createScreenshotPage();
    QWidget* createActivationPage();

    QListWidget* m_navBar;
    QStackedWidget* m_contentStack;

    // 安全设置组件
    QPushButton* m_btnSetPwd;
    QPushButton* m_btnModifyPwd;
    QPushButton* m_btnRemovePwd;
    QLabel* m_lblPwdStatus;

    // 全局热键组件
    HotkeyEdit* m_hkQuickWin;
    HotkeyEdit* m_hkFavorite;
    HotkeyEdit* m_hkScreenshot;
    HotkeyEdit* m_hkOcr;

    // 截图设置组件
    QLineEdit* m_editScreenshotPath;

    // 软件激活组件
    QLineEdit* m_editSecretKey;
};

#endif // SETTINGSWINDOW_H
```

## 文件: `src/core/ShortcutManager.cpp`

```cpp
#include "ShortcutManager.h"

ShortcutManager& ShortcutManager::instance() {
    static ShortcutManager inst;
    return inst;
}

ShortcutManager::ShortcutManager(QObject* parent) : QObject(parent) {
    initDefaults();
    load();
}

void ShortcutManager::initDefaults() {
    auto add = [&](const QString& id, const QString& desc, const QString& def, const QString& cat) {
        m_shortcuts[id] = {id, desc, QKeySequence(def), cat};
    };

    // QuickWindow shortcuts
    add("qw_search", "搜索灵感", "Ctrl+F", "极速窗口");
    add("qw_delete_soft", "移至回收站", "Delete", "极速窗口");
    add("qw_delete_hard", "彻底删除", "Shift+Delete", "极速窗口");
    add("qw_favorite", "切换书签状态", "Ctrl+E", "极速窗口");
    add("qw_preview", "快速预览内容", "Space", "极速窗口");
    add("qw_pin", "置顶/取消置顶项目", "Ctrl+P", "极速窗口");
    add("qw_close", "关闭窗口", "Ctrl+W", "极速窗口");
    add("qw_lock_item", "锁定/解锁项目", "Ctrl+S", "极速窗口");
    add("qw_new_idea", "新建灵感", "Ctrl+N", "极速窗口");
    add("qw_select_all", "全选列表", "Ctrl+A", "极速窗口");
    add("qw_extract", "提取内容到剪贴板", "Ctrl+T", "极速窗口");
    add("qw_lock_cat", "立即锁定当前分类", "Ctrl+Shift+L", "极速窗口");
    add("qw_stay_on_top", "切换窗口置顶", "Alt+D", "极速窗口");
    add("qw_toggle_main", "打开主窗口", "Alt+W", "极速窗口");
    add("qw_toolbox", "打开工具箱", "Ctrl+Shift+T", "极速窗口");
    add("qw_edit", "编辑选中项", "Ctrl+B", "极速窗口");
    add("qw_sidebar", "显示/隐藏侧边栏", "Ctrl+Q", "极速窗口");
    add("qw_prev_page", "上一页", "Alt+S", "极速窗口");
    add("qw_next_page", "下一页", "Alt+X", "极速窗口");
    add("qw_copy_tags", "复制标签", "Ctrl+Shift+C", "极速窗口");
    add("qw_paste_tags", "粘贴标签", "Ctrl+Shift+V", "极速窗口");
    for (int i = 0; i <= 5; ++i) {
        add(QString("qw_rating_%1").arg(i), QString("设置星级 %1").arg(i), QString("Ctrl+%1").arg(i), "极速窗口");
    }

    // MainWindow shortcuts
    add("mw_filter", "开启高级筛选", "Ctrl+G", "主窗口");
    add("mw_preview", "预览选中项", "Space", "主窗口");
    add("mw_meta", "开启元数据面板", "Ctrl+I", "主窗口");
    add("mw_refresh", "刷新列表", "F5", "主窗口");
    add("mw_search", "聚焦搜索框", "Ctrl+F", "主窗口");
    add("mw_new", "新建笔记", "Ctrl+N", "主窗口");
    add("mw_save", "保存笔记/锁定项", "Ctrl+S", "主窗口");
    add("mw_edit", "编辑笔记", "Ctrl+B", "主窗口");
    add("mw_extract", "提取内容", "Ctrl+T", "主窗口");
    add("mw_lock_cat", "锁定分类", "Ctrl+Shift+L", "主窗口");
    add("mw_delete_soft", "移至回收站", "Delete", "主窗口");
    add("mw_delete_hard", "彻底删除", "Shift+Delete", "主窗口");
    add("mw_copy_tags", "复制标签", "Ctrl+Shift+C", "主窗口");
    add("mw_paste_tags", "粘贴标签", "Ctrl+Shift+V", "主窗口");
    add("mw_close", "关闭窗口", "Ctrl+W", "主窗口");
    for (int i = 0; i <= 5; ++i) {
        add(QString("mw_rating_%1").arg(i), QString("设置星级 %1").arg(i), QString("Ctrl+%1").arg(i), "主窗口");
    }

    // NoteEditWindow
    add("ed_save", "保存修改", "Ctrl+S", "编辑器");
    add("ed_close", "关闭编辑器", "Ctrl+W", "编辑器");
    add("ed_search", "内容内查找", "Ctrl+F", "编辑器");

    // QuickPreview
    add("pv_prev", "上一个项目", "Alt+Up", "预览窗");
    add("pv_next", "下一个项目", "Alt+Down", "预览窗");
    add("pv_back", "历史后退", "Alt+Left", "预览窗");
    add("pv_forward", "历史前进", "Alt+Right", "预览窗");
    add("pv_copy", "复制内容", "Ctrl+C", "预览窗");
    add("pv_edit", "编辑项目", "Ctrl+B", "预览窗");
    add("pv_close", "关闭预览", "Ctrl+W", "预览窗");

    // FileSearch & KeywordSearch
    add("fs_select_all", "全选结果", "Ctrl+A", "搜索窗口");
    add("fs_copy", "复制选中内容", "Ctrl+C", "搜索窗口");
    add("fs_delete", "删除选中项", "Delete", "搜索窗口");
    add("fs_scan", "开始/重新扫描", "F5", "搜索窗口");

    add("ks_search", "执行搜索", "Ctrl+F", "关键字搜索");
    add("ks_replace", "执行替换", "Ctrl+R", "关键字搜索");
    add("ks_undo", "撤销上次替换", "Ctrl+Z", "关键字搜索");
    add("ks_swap", "交换查找与替换内容", "Ctrl+Shift+S", "关键字搜索");
}

QKeySequence ShortcutManager::getShortcut(const QString& id) const {
    if (m_customKeys.contains(id)) return m_customKeys[id];
    if (m_shortcuts.contains(id)) return m_shortcuts[id].defaultKey;
    return QKeySequence();
}

void ShortcutManager::setShortcut(const QString& id, const QKeySequence& key) {
    m_customKeys[id] = key;
}

QList<ShortcutManager::ShortcutInfo> ShortcutManager::getShortcutsByCategory(const QString& category) const {
    QList<ShortcutInfo> result;
    for (const auto& info : m_shortcuts) {
        if (info.category == category) result << info;
    }
    return result;
}

void ShortcutManager::save() {
    QSettings settings("RapidNotes", "InternalHotkeys");
    settings.beginGroup("Custom");
    for (auto it = m_customKeys.begin(); it != m_customKeys.end(); ++it) {
        settings.setValue(it.key(), it.value().toString());
    }
    settings.endGroup();
    emit shortcutsChanged();
}

void ShortcutManager::load() {
    QSettings settings("RapidNotes", "InternalHotkeys");
    settings.beginGroup("Custom");
    QStringList keys = settings.allKeys();
    for (const QString& key : keys) {
        m_customKeys[key] = QKeySequence(settings.value(key).toString());
    }
    settings.endGroup();
}

void ShortcutManager::resetToDefaults() {
    m_customKeys.clear();
    QSettings settings("RapidNotes", "InternalHotkeys");
    settings.remove("Custom");
    emit shortcutsChanged();
}
```

## 文件: `src/core/ShortcutManager.h`

```cpp
#ifndef SHORTCUTMANAGER_H
#define SHORTCUTMANAGER_H

#include <QObject>
#include <QKeySequence>
#include <QMap>
#include <QString>
#include <QSettings>

class ShortcutManager : public QObject {
    Q_OBJECT
public:
    struct ShortcutInfo {
        QString id;
        QString description;
        QKeySequence defaultKey;
        QString category;
    };

    static ShortcutManager& instance();

    QKeySequence getShortcut(const QString& id) const;
    void setShortcut(const QString& id, const QKeySequence& key);
    
    QList<ShortcutInfo> getAllShortcuts() const { return m_shortcuts.values(); }
    QList<ShortcutInfo> getShortcutsByCategory(const QString& category) const;

    void save();
    void load();
    void resetToDefaults();

signals:
    void shortcutsChanged();

private:
    ShortcutManager(QObject* parent = nullptr);
    void initDefaults();

    QMap<QString, ShortcutInfo> m_shortcuts;
    QMap<QString, QKeySequence> m_customKeys;
};

#endif // SHORTCUTMANAGER_H
```

## 文件: `src/ui/StringUtils.h`

```cpp
#ifndef STRINGUTILS_H
#define STRINGUTILS_H

#include <QString>
#include <QTextDocument>
#include <QMimeData>
#include <QClipboard>
#include <QApplication>
#include <QRegularExpression>
#include <QSettings>
#include <QVariantList>
#include <QUrl>
#include <vector>
#include "../core/ClipboardMonitor.h"

#ifdef Q_OS_WIN
#include <windows.h>
#endif

class StringUtils {
public:
    /**
     * @brief 智能语言拆分：中文作为标题，非中文作为内容
     */
    static void smartSplitLanguage(const QString& text, QString& title, QString& content) {
        QString trimmedText = text.trimmed();
        if (trimmedText.isEmpty()) {
            title = "新笔记";
            content = "";
            return;
        }

        // 匹配中文字符范围
        static QRegularExpression chineseRegex("[\\x{4e00}-\\x{9fa5}]+");
        // 匹配非中文且非空白非标点的字符（识别泰文、英文等）
        static QRegularExpression otherRegex("[^\\x{4e00}-\\x{9fa5}\\s\\p{P}]+");

        bool hasChinese = trimmedText.contains(chineseRegex);
        bool hasOther = trimmedText.contains(otherRegex);

        if (hasChinese && hasOther) {
            // 提取所有中文块作为标题
            QStringList chineseBlocks;
            QRegularExpressionMatchIterator i = chineseRegex.globalMatch(trimmedText);
            while (i.hasNext()) {
                chineseBlocks << i.next().captured();
            }
            title = chineseBlocks.join(" ").simplified();
            if (title.isEmpty()) title = "未命名";

            // 移除中文块后的剩余部分作为内容
            QString remaining = trimmedText;
            remaining.replace(chineseRegex, " ");
            content = remaining.simplified();
            
            // 如果拆分后内容为空（例如全是标点），则保留全文
            if (content.isEmpty()) content = trimmedText;
        } else {
            // 单一语种或无法识别：首行作为标题，全文作为内容
            QStringList lines = trimmedText.split('\n', Qt::SkipEmptyParts);
            if (!lines.isEmpty()) {
                title = lines[0].trimmed();
                if (title.length() > 60) title = title.left(57) + "...";
                content = trimmedText;
            } else {
                title = "新笔记";
                content = trimmedText;
            }
        }
    }

    /**
     * @brief 智能识别语言：判断文本是否包含中文
     */
    static bool containsChinese(const QString& text) {
        static QRegularExpression chineseRegex("[\\x{4e00}-\\x{9fa5}]+");
        return text.contains(chineseRegex);
    }

    /**
     * @brief 偶数行配对拆分：每两行为一组
     * 规则：含中文的行为标题，若同语种则第一行为标题。
     */
    static QList<QPair<QString, QString>> smartSplitPairs(const QString& text) {
        QList<QPair<QString, QString>> results;
        QStringList lines = text.split('\n', Qt::SkipEmptyParts);
        
        if (lines.isEmpty()) return results;

        // 如果是偶数行，执行配对逻辑
        if (lines.size() > 0 && lines.size() % 2 == 0) {
            for (int i = 0; i < lines.size(); i += 2) {
                QString line1 = lines[i].trimmed();
                QString line2 = lines[i+1].trimmed();
                
                bool c1 = containsChinese(line1);
                bool c2 = containsChinese(line2);
                
                if (c1 && !c2) {
                    results.append({line1, line2});
                } else if (!c1 && c2) {
                    results.append({line2, line1});
                } else {
                    // 同语种，第一行为标题
                    results.append({line1, line2});
                }
            }
        } else {
            // 奇数行或单行，沿用之前的单条逻辑
            QString title, content;
            smartSplitLanguage(text, title, content);
            results.append({title, content});
        }
        
        return results;
    }

public:
    static bool isHtml(const QString& text) {
        return text.contains("<!DOCTYPE HTML") || text.contains("<html>") || text.contains("<style");
    }

    static QString htmlToPlainText(const QString& html) {
        if (!isHtml(html)) return html;
        QTextDocument doc;
        doc.setHtml(html);
        return doc.toPlainText();
    }

    static void copyNoteToClipboard(const QString& content) {
        ClipboardMonitor::instance().skipNext();
        QMimeData* mimeData = new QMimeData();
        if (isHtml(content)) {
            mimeData->setHtml(content);
            mimeData->setText(htmlToPlainText(content));
        } else {
            mimeData->setText(content);
        }
        QApplication::clipboard()->setMimeData(mimeData);
    }

    /**
     * @brief 简繁转换 (利用 Windows 原生 API)
     * @param toSimplified true 为转简体，false 为转繁体
     */
    static QString convertChineseVariant(const QString& text, bool toSimplified) {
#ifdef Q_OS_WIN
        if (text.isEmpty()) return text;
        
        // 转换为宽字符
        std::wstring wstr = text.toStdWString();
        DWORD flags = toSimplified ? LCMAP_SIMPLIFIED_CHINESE : LCMAP_TRADITIONAL_CHINESE;
        
        // 第一次调用获取长度
        int size = LCMapStringEx(LOCALE_NAME_USER_DEFAULT, flags, wstr.c_str(), -1, NULL, 0, NULL, NULL, 0);
        if (size > 0) {
            std::vector<wchar_t> buffer(size);
            // 第二次调用执行转换
            LCMapStringEx(LOCALE_NAME_USER_DEFAULT, flags, wstr.c_str(), -1, buffer.data(), size, NULL, NULL, 0);
            return QString::fromWCharArray(buffer.data());
        }
#endif
        return text;
    }

    /**
     * @brief 记录最近访问或使用的分类
     */
    static void recordRecentCategory(int catId) {
        if (catId <= 0) return;
        QSettings settings("RapidNotes", "QuickWindow");
        QVariantList recentCats = settings.value("recentCategories").toList();
        
        // 转换为 int 列表方便操作
        QList<int> ids;
        for(const auto& v : recentCats) ids << v.toInt();
        
        ids.removeAll(catId);
        ids.prepend(catId);
        
        // 限制为最近 10 个
        while (ids.size() > 10) ids.removeLast();
        
        QVariantList result;
        for(int id : ids) result << id;
        settings.setValue("recentCategories", result);
        settings.sync();
    }

    /**
     * @brief 获取最近访问或使用的分类 ID 列表
     */
    static QVariantList getRecentCategories() {
        QSettings settings("RapidNotes", "QuickWindow");
        return settings.value("recentCategories").toList();
    }
};

#endif // STRINGUTILS_H
```

## 文件: `src/ui/SvgIcons.h`

```cpp
#ifndef SVGICONS_H
#define SVGICONS_H

#include <QString>
#include <QMap>

namespace SvgIcons {
    inline const QMap<QString, QString> icons = {
        {"text", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="11" x2="14" y2="11"></line><line x1="4" y1="16" x2="20" y2="16"></line><line x1="4" y1="21" x2="14" y2="21"></line></svg>)svg"},
        {"untagged", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line><path d="M11 11l4 4m0-4l-4 4" /></svg>)svg"},
        {"tag", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>)svg"},
        {"file", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>)svg"},
        {"code", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>)svg"},
        {"link", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>)svg"},
        {"image", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>)svg"},
        {"branch", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="3"></circle><path d="M12 8v5"></path><path d="M12 13l-5 4"></path><path d="M12 13l5 4"></path><circle cx="7" cy="19" r="3"></circle><circle cx="17" cy="19" r="3"></circle></svg>)svg"},
        {"category", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="8" y="2" width="8" height="6" rx="1"></rect><path d="M12 8 v3"></path><path d="M12 11 h-6"></path><path d="M12 11 h6"></path><rect x="2" y="13" width="8" height="5" rx="1"></rect><rect x="14" y="13" width="8" height="5" rx="1"></rect><circle cx="12" cy="5" r="1" fill="currentColor"></circle><circle cx="6" cy="15.5" r="1" fill="currentColor"></circle><circle cx="18" cy="15.5" r="1" fill="currentColor"></circle></svg>)svg"},
        {"uncategorized", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M5 8 C5 4 10 4 10 8 C10 11 7 12 7 14" /><circle cx="7" cy="19" r="1" fill="currentColor" stroke="none"/><path d="M14 5 v14" /><path d="M14 6 h3" /> <circle cx="20" cy="6" r="2" /><path d="M14 12 h3" /> <circle cx="20" cy="12" r="2" /><path d="M14 18 h3" /> <circle cx="20" cy="18" r="2" /></svg>)svg"},
        {"trash", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6" /><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" /><line x1="10" y1="11" x2="10" y2="17" /><line x1="14" y1="11" x2="14" y2="17" /></svg>)svg"},
        {"refresh", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6"></path><path d="M2.5 22v-6h6"></path><path d="M21.5 8A10 10 0 0 0 6 3.5l-3.5 4"></path><path d="M2.5 16A10 10 0 0 0 18 20.5l3.5-4"></path><circle cx="12" cy="12" r="1.5" fill="currentColor" opacity="0.3"></circle></svg>)svg"},
        {"search", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>)svg"},
        {"add", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>)svg"},
        {"edit", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>)svg"},
        {"bookmark", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>)svg"},
        {"star", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>)svg"},
        {"location", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>)svg"},
        {"pin", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 12V6H8v6l-2 2v2h5v8l1 1 1-1v-8h5v-2l-2-2z"></path></svg>)svg"},
        {"lock", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>)svg"},
        {"lock_secure", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><path fill-rule="evenodd" d="M12 2a5 5 0 0 0-5 5v3H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2h-1V7a5 5 0 0 0-5-5zM9 10V7a3 3 0 0 1 6 0v3H9zm3 4a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3zm-0.75 3h1.5v3h-1.5v-3z" clip-rule="evenodd"/></svg>)svg"},
        // 专门用于"密码生成器"的图标：锁+密码位样式
        {"password_generator", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M16 11V7a4 4 0 0 0-8 0v4" />
            <rect x="3" y="11" width="13" height="10" rx="2" />
            <rect x="11" y="14" width="11" height="7" rx="3.5" />
            <rect x="13.5" y="16.5" width="1.5" height="1.5" fill="currentColor" stroke="none" />
            <rect x="16.25" y="16.5" width="1.5" height="1.5" fill="currentColor" stroke="none" />
            <rect x="19" y="16.5" width="1.5" height="1.5" fill="currentColor" stroke="none" />
        </svg>)svg"},
        {"message", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 15a2 2 0 0 0 2 2h12l4 4V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2z"></path><line x1="8" y1="9" x2="16" y2="9"></line><line x1="8" y1="13" x2="14" y2="13"></line></svg>)svg"},
        {"eye", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>)svg"},
        {"toolbox", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M6 7V5a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v2"></path><line x1="12" y1="12" x2="12" y2="16"></line><line x1="8" y1="12" x2="8" y2="16"></line><line x1="16" y1="12" x2="16" y2="16"></line></svg>)svg"},
        {"today", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>)svg"},
        {"all_data", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path></svg>)svg"},
        {"sidebar", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>)svg"},
        {"sidebar_right", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="15" y1="3" x2="15" y2="21"></line></svg>)svg"},
        {"nav_first", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline></svg>)svg"},
        {"nav_prev", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>)svg"},
        {"nav_next", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>)svg"},
        {"nav_last", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline></svg>)svg"},
        {"undo", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"></path><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"></path></svg>)svg"},
        {"coffee", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8h1a4 4 0 0 1 0 8h-1"/><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"/><line x1="6" y1="1" x2="6" y2="4"/><line x1="10" y1="1" x2="10" y2="4"/><line x1="14" y1="1" x2="14" y2="4"/></svg>)svg"},
        {"grid", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/></svg>)svg"},
        {"book", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20v2H6.5A2.5 2.5 0 0 1 4 19.5z"/><path d="M4 5.5A2.5 2.5 0 0 1 6.5 3H20v2H6.5A2.5 2.5 0 0 1 4 5.5z"/></svg>)svg"},
        {"leaf", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 12c0-4.42-3.58-8-8-8S4 7.58 4 12s3.58 8 8 8 8-3.58 8-8z"/><path d="M12 2a10 10 0 0 0-10 10h20a10 10 0 0 0-10-10z"/></svg>)svg"},
        {"book_open", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>)svg"},
        {"redo", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"></path><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"></path></svg>)svg"},
        {"list_ul", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>)svg"},
        {"list_ol", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="10" y1="6" x2="21" y2="6"></line><line x1="10" y1="12" x2="21" y2="12"></line><line x1="10" y1="18" x2="21" y2="18"></line><path d="M4 6h1v4"></path><path d="M4 10h2"></path><path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"></path></svg>)svg"},
        {"todo", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><path d="M9 12l2 2 4-4"></path></svg>)svg"},
        {"close", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>)svg"},
        {"save", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>)svg"},
        {"filter", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>)svg"},
        {"select", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>)svg"},
        {"grip_diagonal", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="19" cy="19" r="1"></circle><circle cx="19" cy="14" r="1"></circle><circle cx="14" cy="19" r="1"></circle><circle cx="19" cy="9" r="1"></circle><circle cx="14" cy="14" r="1"></circle><circle cx="9" cy="19" r="1"></circle></svg>)svg"},
        {"folder", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>)svg"},
        {"file_managed", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M12 18h6v3h-6z" fill="currentColor" stroke="none" /><path d="M12 15h6v1h-6z" fill="currentColor" stroke="none" /></svg>)svg"},
        {"folder_managed", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><path d="M12 18h8v3h-8z" fill="currentColor" stroke="none" /><path d="M12 15h8v1h-8z" fill="currentColor" stroke="none" /></svg>)svg"},
        {"settings", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>)svg"},
        {"calendar", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>)svg"},
        {"clock", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>)svg"},
        {"palette", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="13.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="10.5" r="2.5"></circle><circle cx="8.5" cy="7.5" r="2.5"></circle><circle cx="6.5" cy="12.5" r="2.5"></circle><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"></path></svg>)svg"},
        {"zap", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>)svg"},
        {"monitor", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>)svg"},
        {"power", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line></svg>)svg"},
        {"minimize", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>)svg"},
        {"maximize", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>)svg"},
        {"restore", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="10" height="10" rx="1"></rect><rect x="11" y="3" width="10" height="10" rx="1"></rect></svg>)svg"},
        {"copy", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>)svg"},
        {"pin_vertical", R"svg(<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M16 9V4h1c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 1.66-1.34 3-3 3v2h5.97v7l1.03 1 1.03-1v-7H19v-2c-1.66 0-3-1.34-3-3z"></path></svg>)svg"},
        {"pin_tilted", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" transform="rotate(45 12 12)"><path d="M16 12V6H8v6l-2 2v2h5v8l1 1 1-1v-8h5v-2l-2-2z"></path></svg>)svg"},
        {"star_filled", R"svg(<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>)svg"},
        {"bookmark_filled", R"svg(<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>)svg"},
        {"circle_filled", R"svg(<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><circle cx="12" cy="12" r="8"></circle></svg>)svg"},
        {"edit_clear", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.5 19H9a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h8.5L22 12l-4.5 7z"></path><path d="M12 9l4 4"></path><path d="M16 9l-4 4"></path></svg>)svg"},
        {"no_color", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>)svg"},
        {"random_color", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>)svg"},
        {"screen_picker", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 2 4 4"/><path d="m17 7 3-3"/><path d="M19 9 8.7 19.3c-1 1-2.5 1-3.4 0l-.6-.6c-1-1-1-2.5 0-3.4L15 5"/><path d="m9 11 4 4"/><path d="m5 19-3 3"/><path d="m14 4 6 6"/></svg>)svg"},
        {"pixel_ruler", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2" transform="rotate(45 12 12)"/><path d="m8.5 9.5 1 1"/><path d="m11 12 1 1"/><path d="m13.5 14.5 1 1"/><path d="m16 17 1 1"/></svg>)svg"},
        {"ruler_bounds", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 8V4h4m8 0h4v4m0 8v4h-4M8 20H4v-4"/></svg>)svg"},
        {"ruler_spacing", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 4v16m-8-8h16"/></svg>)svg"},
        {"ruler_hor", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="2" y1="12" x2="22" y2="12"/><line x1="2" y1="8" x2="2" y2="16"/><line x1="22" y1="8" x2="22" y2="16"/></svg>)svg"},
        {"ruler_ver", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="2" x2="12" y2="22"/><line x1="8" y1="2" x2="16" y2="2"/><line x1="8" y1="22" x2="16" y2="22"/></svg>)svg"},
        {"screenshot_rect", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>)svg"},
        {"screenshot_fill", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/></svg>)svg"},
        {"screenshot_ellipse", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/></svg>)svg"},
        {"screenshot_arrow", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><path d="M22 2L11 5L14 8L4 18L6 20L16 10L19 13L22 2Z"/></svg>)svg"},
        {"screenshot_pen", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg>)svg"},
        {"screenshot_marker", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><text x="12" y="16" text-anchor="middle" font-size="12" font-weight="bold" fill="currentColor">1</text></svg>)svg"},
        {"screenshot_mosaic", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="6" height="6"/><rect x="9" y="3" width="6" height="6"/><rect x="15" y="3" width="6" height="6"/><rect x="3" y="9" width="6" height="6"/><rect x="9" y="9" width="6" height="6"/><rect x="15" y="9" width="6" height="6"/><rect x="3" y="15" width="6" height="6"/><rect x="9" y="15" width="6" height="6"/><rect x="15" y="15" width="6" height="6"/></svg>)svg"},
        {"screenshot_confirm", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>)svg"},
        {"screenshot_text", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>)svg"},
        {"screenshot_line", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="5" y1="19" x2="19" y2="5"></line></svg>)svg"},
        {"screenshot_save", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>)svg"},
        {"screenshot_copy", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>)svg"},
        {"screenshot_close", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>)svg"},
        {"screenshot_eraser", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>)svg"},
        {"screenshot_pin", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 12V6H8v6l-2 2v2h5v8l1 1 1-1v-8h5v-2l-2-2z"></path></svg>)svg"},
        {"screenshot_ocr", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 3H5a2 2 0 0 0-2 2v2M17 3h2a2 2 0 0 1 2 2v2M7 21H5a2 2 0 0 1-2-2v-2M17 21h2a2 2 0 0 0 2-2v-2M8 8h8M8 12h8M8 16h5"/></svg>)svg"},
        {"bold", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>)svg"},
        {"italic", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>)svg"},
        {"color_wheel", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 2v20M2 12h20M12 2a10 10 0 0 1 7.07 17.07M12 2A10 10 0 0 0 4.93 19.07"/></svg>)svg"},
        {"typesetting", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 6h16M4 12h10M4 18h16"/></svg>)svg"},
        {"find_keyword", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><circle cx="11.5" cy="14.5" r="2.5"></circle><line x1="13.5" y1="16.5" x2="15.5" y2="18.5"></line></svg>)svg"},
        {"swap", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 10l5-5 5 5M17 14l-5 5-5-5M12 5v14"/></svg>)svg"},
        {"merge", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 21V10"/><path d="M12 10l-4-4"/><path d="M12 10l4-4"/><path d="M8 6V3"/><path d="M16 6V3"/></svg>)svg"},
        {"cut", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></svg>)svg"},
        {"rotate", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M18 4H10a4 4 0 0 0-4 4v12"/><polyline points="3 17 6 20 9 17"/><path d="M6 20h8a4 4 0 0 0 4-4V4"/><polyline points="21 7 18 4 15 7"/></svg>)svg"},
        {"menu_dots", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/></svg>)svg"},
        {"move", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" y1="12" x2="22" y2="12"/><line x1="12" y1="2" x2="12" y2="22"/></svg>)svg"},
        {"help", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>)svg"},
        {"scan", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7V5a2 2 0 0 1 2-2h2"></path><path d="M17 3h2a2 2 0 0 1 2 2v2"></path><path d="M21 17v2a2 2 0 0 1-2 2h-2"></path><path d="M7 21H5a2 2 0 0 1-2-2v-2"></path><line x1="7" y1="12" x2="17" y2="12"></line></svg>)svg"},
        {"camera", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>)svg"},
        {"ball_on", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8v4l3 2"></path></svg>)svg"},
        {"ball_off", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>)svg"},
        {"paint_bucket", R"svg(<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2a2 2 0 0 0 2.8 0L19 11Z"/>
            <path d="m5 2 5 5"/>
            <path d="m2 13 5 5"/>
            <path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z" fill="currentColor" stroke="none"/>
        </svg>)svg"},
        {"clipboard_auto", R"svg(<svg viewBox="0 -960 960 960" fill="currentColor"><path d="M280-240q-100 0-170-70T40-480q0-100 70-170t170-70h400q100 0 170 70t70 170q0 100-70 170t-170 70H280Zm0-80h400q66 0 113-47t47-113q0-66-47-113t-113-47H280q-66 0-113 47t-47 113q0 66 47 113t113 47Zm85-75q35-35 35-85t-35-85q-35-35-85-35t-85 35q-35 35-35 85t35 85q35 35 85 35t85-35Zm115-85Z"/></svg>)svg"},
        {"switch_on", R"svg(<svg viewBox="0 0 24 24"><rect x="2" y="5" width="20" height="14" rx="7" fill="white" /><rect x="3.5" y="6.5" width="17" height="11" rx="5.5" fill="currentColor" /><circle cx="15" cy="12" r="3.5" fill="white" /></svg>)svg"},
        {"switch_off", R"svg(<svg viewBox="0 0 24 24"><rect x="2" y="5" width="20" height="14" rx="7" fill="white" /><rect x="3.5" y="6.5" width="17" height="11" rx="5.5" fill="currentColor" /><circle cx="9" cy="12" r="3.5" fill="white" /></svg>)svg"},
        {"arrow_up", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 4 L2 20 L22 20 Z"/></svg>)svg"},
        {"arrow_down", R"svg(<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 20 L2 4 L22 4 Z"/></svg>)svg"},
    };
}

#endif // SVGICONS_H
```

## 文件: `src/ui/SystemTray.cpp`

```cpp
#include "SystemTray.h"
#include "StringUtils.h"

#include "IconHelper.h"
#include "FloatingBall.h"
#include <QApplication>
#include <QIcon>
#include <QStyle>

SystemTray::SystemTray(QObject* parent) : QObject(parent) {
    m_trayIcon = new QSystemTrayIcon(this);
    
    // 复刻 Python 版：使用渲染的悬浮球作为托盘图标
    m_trayIcon->setIcon(FloatingBall::generateBallIcon());
    m_trayIcon->setToolTip("快速笔记");

    m_menu = new QMenu();
    IconHelper::setupMenu(m_menu);
    m_menu->setStyleSheet(
        "QMenu { background-color: #2D2D2D; color: #EEE; border: 1px solid #444; padding: 4px; } "
        /* 10px 间距规范：padding-left 10px + icon margin-left 6px */
        "QMenu::item { padding: 6px 10px 6px 10px; border-radius: 3px; } "
        "QMenu::icon { margin-left: 6px; } "
        "QMenu::item:selected { background-color: #4a90e2; color: white; }"
    );
    
    m_menu->addAction(IconHelper::getIcon("monitor", "#aaaaaa", 18), "显示主界面", this, &SystemTray::showMainWindow);
    m_menu->addAction(IconHelper::getIcon("zap", "#aaaaaa", 18), "显示快速笔记", this, &SystemTray::showQuickWindow);
    
    m_ballAction = new QAction("隐藏悬浮球", this);
    m_ballAction->setIcon(IconHelper::getIcon("ball_off", "#aaaaaa", 18));
    connect(m_ballAction, &QAction::triggered, this, [this](){
        bool willBeVisible = (m_ballAction->text() == "显示悬浮球");
        emit toggleFloatingBall(willBeVisible);
    });
    m_menu->addAction(m_ballAction);

    m_menu->addAction(IconHelper::getIcon("help", "#aaaaaa", 18), "使用说明", this, &SystemTray::showHelpRequested);
    m_menu->addAction(IconHelper::getIcon("settings", "#aaaaaa", 18), "设置", this, &SystemTray::showSettings);
    m_menu->addSeparator();
    m_menu->addAction(IconHelper::getIcon("power", "#aaaaaa", 18), "退出程序", this, &SystemTray::quitApp);

    m_trayIcon->setContextMenu(m_menu);

    connect(m_trayIcon, &QSystemTrayIcon::activated, this, [this](QSystemTrayIcon::ActivationReason reason){
        if (reason == QSystemTrayIcon::Trigger) {
            emit showQuickWindow();
        }
    });
}

void SystemTray::show() {
    m_trayIcon->show();
}

void SystemTray::updateBallAction(bool visible) {
    if (visible) {
        m_ballAction->setText("隐藏悬浮球");
        m_ballAction->setIcon(IconHelper::getIcon("ball_off", "#aaaaaa", 18));
    } else {
        m_ballAction->setText("显示悬浮球");
        m_ballAction->setIcon(IconHelper::getIcon("ball_on", "#aaaaaa", 18));
    }
}
```

## 文件: `src/ui/SystemTray.h`

```cpp
#ifndef SYSTEMTRAY_H
#define SYSTEMTRAY_H

#include <QSystemTrayIcon>
#include <QMenu>
#include <QObject>

class SystemTray : public QObject {
    Q_OBJECT
public:
    explicit SystemTray(QObject* parent = nullptr);
    void show();

signals:
    void showMainWindow();
    void showQuickWindow();
    void showHelpRequested();
    void showSettings();
    void quitApp();
    void toggleFloatingBall(bool visible);

public slots:
    void updateBallAction(bool visible);

private:
    QSystemTrayIcon* m_trayIcon;
    QMenu* m_menu;
    QAction* m_ballAction;
};

#endif // SYSTEMTRAY_H
```

## 文件: `src/ui/TagEditDialog.cpp`

```cpp
#include "TagEditDialog.h"
#include "AdvancedTagSelector.h"
#include "../core/DatabaseManager.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QRegularExpression>

TagEditDialog::TagEditDialog(const QString& currentTags, QWidget* parent) 
    : FramelessDialog("设置预设标签", parent) 
{
    // 1. 严格执行 500x350 规格要求
    resize(500, 350);
    setMinimumSize(500, 300);

    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(20, 15, 20, 20);
    layout->setSpacing(12);

    auto* lbl = new QLabel("标签 (胶囊化展示):");
    lbl->setStyleSheet("color: #aaa; font-size: 13px; font-weight: bold;");
    layout->addWidget(lbl);

    // 2. 集成胶囊标签编辑器
    m_tagEditor = new TagEditorWidget(this);
    QStringList tagList = currentTags.split(QRegularExpression("[,，]"), Qt::SkipEmptyParts);
    for(QString& t : tagList) t = t.trimmed();
    m_tagEditor->setTags(tagList);
    
    // 连接双击信号，唤起高级选择器
    connect(m_tagEditor, &TagEditorWidget::doubleClicked, this, &TagEditDialog::openTagSelector);
    layout->addWidget(m_tagEditor);

    auto* tips = new QLabel("提示：双击空白区域可打开高级标签面板");
    tips->setStyleSheet("color: #666; font-size: 11px;");
    layout->addWidget(tips);

    layout->addStretch();

    // 3. 底部按钮
    auto* btnLayout = new QHBoxLayout();
    btnLayout->addStretch();
    
    auto* btnCancel = new QPushButton("取消");
    btnCancel->setFixedSize(80, 32);
    btnCancel->setCursor(Qt::PointingHandCursor);
    btnCancel->setStyleSheet("QPushButton { background-color: #333; color: #EEE; border: none; border-radius: 4px; } QPushButton:hover { background-color: #444; }");
    connect(btnCancel, &QPushButton::clicked, this, &QDialog::reject);
    btnLayout->addWidget(btnCancel);

    auto* btnOk = new QPushButton("确定");
    btnOk->setFixedSize(80, 32);
    btnOk->setCursor(Qt::PointingHandCursor);
    btnOk->setStyleSheet("QPushButton { background-color: #4a90e2; color: white; border: none; border-radius: 4px; font-weight: bold; } QPushButton:hover { background-color: #357abd; }");
    connect(btnOk, &QPushButton::clicked, this, [this](){
        emit tagsConfirmed(getTags());
        accept();
    });
    btnLayout->addWidget(btnOk);

    layout->addLayout(btnLayout);
}

QString TagEditDialog::getTags() const {
    return m_tagEditor->tags().join(", ");
}

void TagEditDialog::openTagSelector() {
    auto* selector = new AdvancedTagSelector(this);
    
    // 准备数据
    auto recentTags = DatabaseManager::instance().getRecentTagsWithCounts(20);
    QStringList allTags = DatabaseManager::instance().getAllTags();
    QStringList selected = m_tagEditor->tags();

    selector->setup(recentTags, allTags, selected);
    
    // 监听确认并更新胶囊
    connect(selector, &AdvancedTagSelector::tagsConfirmed, [this](const QStringList& tags){
        m_tagEditor->setTags(tags);
    });

    selector->showAtCursor();
}
```

## 文件: `src/ui/TagEditDialog.h`

```cpp
#ifndef TAGEDITDIALOG_H
#define TAGEDITDIALOG_H

#include "FramelessDialog.h"
#include "TagEditorWidget.h"

class TagEditDialog : public FramelessDialog {
    Q_OBJECT
public:
    explicit TagEditDialog(const QString& currentTags, QWidget* parent = nullptr);
    QString getTags() const;

signals:
    void tagsConfirmed(const QString& tags);

private slots:
    void openTagSelector();

private:
    TagEditorWidget* m_tagEditor;
};

#endif // TAGEDITDIALOG_H
```

## 文件: `src/ui/TagEditorWidget.cpp`

```cpp
#include "TagEditorWidget.h"
#include "IconHelper.h"
#include <QMouseEvent>
#include <QVariant>
#include <QRegularExpression>
#include <utility>
#include "StringUtils.h"

TagEditorWidget::TagEditorWidget(QWidget* parent) : QFrame(parent) {
    setObjectName("TagEditor");
    setMinimumHeight(150);
    setCursor(Qt::IBeamCursor);
    
    // 基础样式：圆角矩形，深色半透明感
    setStyleSheet(
        "QFrame#TagEditor {"
        "  background-color: #1A1A1A;"
        "  border: 1px solid #333;"
        "  border-radius: 8px;"
        "}"
        "QFrame#TagEditor:hover {"
        "  border: 1px solid #4a90e2;"
        "}"
    );

    auto* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(10, 10, 10, 10);
    
    // 使用 FlowLayout 自动换行
    m_flow = new FlowLayout(0, 8, 8);
    mainLayout->addLayout(m_flow);
    mainLayout->addStretch();
}

void TagEditorWidget::setTags(const QStringList& tags) {
    m_tags = tags;
    updateChips();
}

void TagEditorWidget::addTag(const QString& tag) {
    if (tag.isEmpty() || m_tags.contains(tag)) return;
    m_tags.append(tag);
    updateChips();
    emit tagsChanged();
}

void TagEditorWidget::removeTag(const QString& tag) {
    if (m_tags.removeAll(tag) > 0) {
        updateChips();
        emit tagsChanged();
    }
}

void TagEditorWidget::clear() {
    m_tags.clear();
    updateChips();
    emit tagsChanged();
}

void TagEditorWidget::mouseDoubleClickEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        emit doubleClicked();
    }
    QFrame::mouseDoubleClickEvent(event);
}

void TagEditorWidget::updateChips() {
    // 清空现有 Chips
    QLayoutItem* child;
    while ((child = m_flow->takeAt(0)) != nullptr) {
        if (child->widget()) {
            child->widget()->deleteLater();
        }
        delete child;
    }

    // 重新创建
    for (const QString& tag : std::as_const(m_tags)) {
        m_flow->addWidget(createChip(tag));
    }
}

QWidget* TagEditorWidget::createChip(const QString& tag) {
    auto* chip = new QWidget();
    chip->setObjectName("TagChip");
    chip->setStyleSheet(
        "QWidget#TagChip {"
        "  background-color: #2D2D2D;"
        "  border: 1px solid #444;"
        "  border-radius: 12px;"
        "}"
        "QWidget#TagChip:hover {"
        "  background-color: #383838;"
        "}"
    );

    auto* layout = new QHBoxLayout(chip);
    layout->setContentsMargins(10, 4, 10, 4);
    layout->setSpacing(6);

    auto* label = new QLabel(tag);
    label->setStyleSheet("color: #EEE; font-size: 12px; border: none; background: transparent;");
    layout->addWidget(label);

    auto* btnClose = new QPushButton();
    btnClose->setFixedSize(14, 14);
    btnClose->setCursor(Qt::PointingHandCursor);
    btnClose->setIcon(IconHelper::getIcon("close", "#888", 12));
    btnClose->setToolTip("移除标签");
    btnClose->setStyleSheet(
        "QPushButton { background: transparent; border: none; border-radius: 7px; }"
        "QPushButton:hover { background-color: #e74c3c; }"
    );
    
    connect(btnClose, &QPushButton::clicked, this, [this, tag](){
        removeTag(tag);
    });
    
    layout->addWidget(btnClose);
    return chip;
}
```

## 文件: `src/ui/TagEditorWidget.h`

```cpp
#ifndef TAGEDITORWIDGET_H
#define TAGEDITORWIDGET_H

#include <QFrame>
#include <QStringList>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include "FlowLayout.h"

class TagEditorWidget : public QFrame {
    Q_OBJECT
public:
    explicit TagEditorWidget(QWidget* parent = nullptr);

    void setTags(const QStringList& tags);
    QStringList tags() const { return m_tags; }
    
    void addTag(const QString& tag);
    void removeTag(const QString& tag);
    void clear();

signals:
    void tagsChanged();
    void doubleClicked();

protected:
    void mouseDoubleClickEvent(QMouseEvent* event) override;

private:
    void updateChips();
    QWidget* createChip(const QString& tag);

    QStringList m_tags;
    FlowLayout* m_flow;
};

#endif // TAGEDITORWIDGET_H
```

## 文件: `src/ui/TagManagerWindow.cpp`

```cpp
#include "ToolTipOverlay.h"
#include "TagManagerWindow.h"
#include "StringUtils.h"

#include "IconHelper.h"
#include "../core/DatabaseManager.h"
#include "FramelessDialog.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QHeaderView>
#include <QMouseEvent>
#include <QGraphicsDropShadowEffect>
#include <QToolTip>

TagManagerWindow::TagManagerWindow(QWidget* parent) : FramelessDialog("标签管理", parent) {
    setObjectName("TagManagerWindow");
    loadWindowSettings();
    resize(430, 580);

    initUI();
    refreshData();
}

TagManagerWindow::~TagManagerWindow() {
}

void TagManagerWindow::initUI() {
    auto* contentLayout = new QVBoxLayout(m_contentArea);
    contentLayout->setContentsMargins(20, 10, 20, 20);
    contentLayout->setSpacing(12);

    // Search Bar
    m_searchEdit = new QLineEdit();
    m_searchEdit->setPlaceholderText("搜索标签...");
    m_searchEdit->setStyleSheet("QLineEdit { background-color: #2D2D2D; border: 1px solid #444; border-radius: 6px; color: white; padding: 6px 10px; font-size: 13px; } "
                               "QLineEdit:focus { border-color: #f1c40f; }");
    connect(m_searchEdit, &QLineEdit::textChanged, this, &TagManagerWindow::handleSearch);
    contentLayout->addWidget(m_searchEdit);

    // Table
    m_tagTable = new QTableWidget(0, 2);
    m_tagTable->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_tagTable->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_tagTable->setHorizontalHeaderLabels({"标签名称", "使用次数"});
    m_tagTable->horizontalHeader()->setStretchLastSection(false);
    m_tagTable->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Stretch);
    m_tagTable->horizontalHeader()->setSectionResizeMode(1, QHeaderView::ResizeToContents);
    m_tagTable->verticalHeader()->setVisible(false);
    m_tagTable->setSelectionBehavior(QAbstractItemView::SelectRows);
    m_tagTable->setSelectionMode(QAbstractItemView::SingleSelection);
    m_tagTable->setEditTriggers(QAbstractItemView::NoEditTriggers);
    m_tagTable->setStyleSheet(
        "QTableWidget { background-color: #252526; border: 1px solid #333; border-radius: 6px; color: #CCC; gridline-color: #333; outline: none; } "
        "QTableWidget::item { padding: 5px; } "
        "QTableWidget::item:selected { background-color: #3E3E42; color: #FFF; } "
        "QHeaderView::section { background-color: #2D2D30; color: #888; border: none; height: 30px; font-weight: bold; font-size: 12px; border-bottom: 1px solid #333; }"
    );
    contentLayout->addWidget(m_tagTable);

    // Action Buttons
    auto* btnLayout = new QHBoxLayout();
    
    auto* btnRename = new QPushButton("重命名");
    btnRename->setStyleSheet("QPushButton { background-color: #333; color: #EEE; border: none; border-radius: 4px; padding: 8px 15px; font-weight: bold; } "
                             "QPushButton:hover { background-color: #444; }");
    connect(btnRename, &QPushButton::clicked, this, &TagManagerWindow::handleRename);
    btnLayout->addWidget(btnRename);

    auto* btnDelete = new QPushButton("删除");
    btnDelete->setStyleSheet("QPushButton { background-color: rgba(231, 76, 60, 0.2); color: #e74c3c; border: 1px solid rgba(231, 76, 60, 0.4); border-radius: 4px; padding: 8px 15px; font-weight: bold; } "
                             "QPushButton:hover { background-color: rgba(231, 76, 60, 0.3); }");
    connect(btnDelete, &QPushButton::clicked, this, &TagManagerWindow::handleDelete);
    btnLayout->addWidget(btnDelete);

    contentLayout->addLayout(btnLayout);
}

void TagManagerWindow::refreshData() {
    m_tagTable->setRowCount(0);
    
    QVariantMap filterStats = DatabaseManager::instance().getFilterStats();
    QVariantMap tagStats = filterStats.value("tags").toMap();
    
    QString keyword = m_searchEdit->text().trimmed().toLower();
    
    // Sort by name
    QStringList tagNames = tagStats.keys();
    tagNames.sort();

    for (const QString& name : std::as_const(tagNames)) {
        if (!keyword.isEmpty() && !name.toLower().contains(keyword)) continue;

        int row = m_tagTable->rowCount();
        m_tagTable->insertRow(row);
        
        auto* nameItem = new QTableWidgetItem(name);
        auto* countItem = new QTableWidgetItem(tagStats.value(name).toString());
        countItem->setTextAlignment(Qt::AlignCenter);
        
        m_tagTable->setItem(row, 0, nameItem);
        m_tagTable->setItem(row, 1, countItem);
    }
}

void TagManagerWindow::handleRename() {
    int row = m_tagTable->currentRow();
    if (row < 0) return;

    QString oldName = m_tagTable->item(row, 0)->text();
    auto* dlg = new FramelessInputDialog("重命名标签", "新标签名称:", oldName, this);
    connect(dlg, &FramelessInputDialog::accepted, [this, oldName, dlg](){
        QString newName = dlg->text().trimmed();
        if (!newName.isEmpty() && newName != oldName) {
            if (DatabaseManager::instance().renameTagGlobally(oldName, newName)) {
                ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 标签已重命名并同步至所有笔记");
                refreshData();
            }
        }
    });
    dlg->show();
}

void TagManagerWindow::handleDelete() {
    int row = m_tagTable->currentRow();
    if (row < 0) return;

    QString tagName = m_tagTable->item(row, 0)->text();
    auto* dlg = new FramelessMessageBox("确认删除", QString("确定要从所有笔记中移除标签 '%1' 吗？").arg(tagName), this);
    connect(dlg, &FramelessMessageBox::confirmed, [this, tagName](){
        if (DatabaseManager::instance().deleteTagGlobally(tagName)) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), "✅ 标签已从所有笔记中移除");
            refreshData();
        }
    });
    dlg->show();
}

void TagManagerWindow::handleSearch(const QString& text) {
    refreshData();
}

```

## 文件: `src/ui/TagManagerWindow.h`

```cpp
#ifndef TAGMANAGERWINDOW_H
#define TAGMANAGERWINDOW_H

#include "FramelessDialog.h"
#include <QTableWidget>
#include <QLineEdit>
#include <QPushButton>
#include <QVBoxLayout>
#include <QLabel>
#include <QPoint>

class TagManagerWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit TagManagerWindow(QWidget* parent = nullptr);
    ~TagManagerWindow();

public slots:
    void refreshData();


private:
    void initUI();
    void handleRename();
    void handleDelete();
    void handleSearch(const QString& text);

    QTableWidget* m_tagTable;
    QLineEdit* m_searchEdit;
    QPoint m_dragPos;
};

#endif // TAGMANAGERWINDOW_H
```

## 文件: `src/ui/TimePasteWindow.cpp`

```cpp
#include "TimePasteWindow.h"
#include "IconHelper.h"
#include "../core/KeyboardHook.h"
#include <QDateTime>
#include <QMouseEvent>
#include <QApplication>
#include <QClipboard>
#include <QPushButton>
#include <QPainter>
#include <QPainterPath>

#ifdef Q_OS_WIN
#include <windows.h>
#endif

TimePasteWindow::TimePasteWindow(QWidget* parent) : FramelessDialog("时间输出工具", parent) {
    setObjectName("TimePasteWindow");
    setFixedSize(380, 330); 

    loadWindowSettings();
    initUI();

    m_timer = new QTimer(this);
    connect(m_timer, &QTimer::timeout, this, &TimePasteWindow::updateDateTime);
    m_timer->start(100);
    updateDateTime();

    // 使用 QueuedConnection 确保钩子回调立即返回，避免阻塞导致按键泄漏
    connect(&KeyboardHook::instance(), &KeyboardHook::digitPressed, this, &TimePasteWindow::onDigitPressed, Qt::QueuedConnection);
}

TimePasteWindow::~TimePasteWindow() {
}

void TimePasteWindow::initUI() {
    auto* layout = new QVBoxLayout(m_contentArea);
    layout->setContentsMargins(20, 10, 20, 20);
    layout->setSpacing(10);

    m_dateLabel = new QLabel();
    m_dateLabel->setAlignment(Qt::AlignCenter);
    m_dateLabel->setStyleSheet("color: #B0B0B0; font-size: 16px; padding: 5px;");
    layout->addWidget(m_dateLabel);

    m_timeLabel = new QLabel();
    m_timeLabel->setAlignment(Qt::AlignCenter);
    m_timeLabel->setStyleSheet("color: #E0E0E0; font-size: 28px; font-weight: bold; padding: 5px; font-family: 'Consolas', 'Monaco', monospace;");
    layout->addWidget(m_timeLabel);

    auto* sep = new QLabel();
    sep->setFixedHeight(2);
    sep->setStyleSheet("background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 transparent, stop:0.5 #555555, stop:1 transparent);");
    layout->addWidget(sep);

    m_buttonGroup = new QButtonGroup(this);
    m_radioPrev = new QRadioButton("退 (往前 N 分钟)");
    m_radioPrev->setChecked(true);
    m_radioPrev->setStyleSheet(getRadioStyle());
    m_buttonGroup->addButton(m_radioPrev, 0);
    layout->addWidget(m_radioPrev);

    m_radioNext = new QRadioButton("进 (往后 N 分钟)");
    m_radioNext->setStyleSheet(getRadioStyle());
    m_buttonGroup->addButton(m_radioNext, 1);
    layout->addWidget(m_radioNext);

    auto* tip = new QLabel("按主键盘数字键 0-9 输出时间");
    tip->setAlignment(Qt::AlignCenter);
    tip->setStyleSheet("color: #666666; font-size: 11px; padding: 5px;");
    layout->addWidget(tip);

}

QString TimePasteWindow::getRadioStyle() {
    return "QRadioButton { color: #E0E0E0; font-size: 14px; padding: 6px; spacing: 8px; } "
           "QRadioButton::indicator { width: 18px; height: 18px; border-radius: 9px; border: 2px solid #555555; background: #2A2A2A; } "
           "QRadioButton::indicator:checked { background: qradialgradient(cx:0.5, cy:0.5, radius:0.5, fx:0.5, fy:0.5, stop:0 #4A9EFF, stop:0.7 #4A9EFF, stop:1 #2A2A2A); border: 2px solid #4A9EFF; } "
           "QRadioButton::indicator:hover { border: 2px solid #4A9EFF; }";
}

void TimePasteWindow::updateDateTime() {
    QDateTime now = QDateTime::currentDateTime();
    m_dateLabel->setText(now.toString("yyyy-MM-dd"));
    m_timeLabel->setText(now.toString("HH:mm:ss"));
}

void TimePasteWindow::onDigitPressed(int digit) {
    if (!isVisible()) return;

    QDateTime target = QDateTime::currentDateTime();
    if (m_radioPrev->isChecked())
        target = target.addSecs(-digit * 60);
    else
        target = target.addSecs(digit * 60);
    
    QString timeStr = target.toString("HH:mm");

    // 1. 立即更新剪贴板（满足用户同步需求）
    QApplication::clipboard()->setText(timeStr);

    // 2. 异步延迟处理，确保系统剪贴板通知完成且焦点稳定
    QTimer::singleShot(100, this, [timeStr]() {
#ifdef Q_OS_WIN
        // A. 显式释放所有修饰键 (L/R Ctrl, Shift, Alt, Win)，防止干扰模拟输入
        INPUT releaseInputs[8];
        memset(releaseInputs, 0, sizeof(releaseInputs));
        BYTE keys[] = { VK_LCONTROL, VK_RCONTROL, VK_LSHIFT, VK_RSHIFT, VK_LMENU, VK_RMENU, VK_LWIN, VK_RWIN };
        for (int i = 0; i < 8; ++i) {
            releaseInputs[i].type = INPUT_KEYBOARD;
            releaseInputs[i].ki.wVk = keys[i];
            releaseInputs[i].ki.dwFlags = KEYEVENTF_KEYUP;
        }
        SendInput(8, releaseInputs, sizeof(INPUT));

        // B. 使用 Unicode 方式模拟打字输入 (比 Ctrl+V 稳定，不产生剪贴板竞争)
        int len = timeStr.length();
        QVector<INPUT> inputs(len * 2);
        for (int i = 0; i < len; ++i) {
            inputs[i*2].type = INPUT_KEYBOARD;
            inputs[i*2].ki.wVk = 0;
            inputs[i*2].ki.wScan = timeStr[i].unicode();
            inputs[i*2].ki.dwFlags = KEYEVENTF_UNICODE;
            
            inputs[i*2+1] = inputs[i*2];
            inputs[i*2+1].ki.dwFlags |= KEYEVENTF_KEYUP;
        }
        SendInput(inputs.size(), inputs.data(), sizeof(INPUT));
#endif
    });
}

void TimePasteWindow::showEvent(QShowEvent* event) {
    FramelessDialog::showEvent(event);
    KeyboardHook::instance().setDigitInterceptEnabled(true);

#ifdef Q_OS_WIN
    // 设置 WS_EX_NOACTIVATE 使得点击窗口时（如切换加减模式）不会夺取当前编辑器的焦点
    HWND hwnd = (HWND)winId();
    SetWindowLong(hwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_NOACTIVATE);
#endif
}

void TimePasteWindow::hideEvent(QHideEvent* event) {
    KeyboardHook::instance().setDigitInterceptEnabled(false);
    FramelessDialog::hideEvent(event);
}
```

## 文件: `src/ui/TimePasteWindow.h`

```cpp
#ifndef TIMEPASTEWINDOW_H
#define TIMEPASTEWINDOW_H

#include "FramelessDialog.h"
#include <QLabel>
#include <QRadioButton>
#include <QButtonGroup>
#include <QTimer>

class TimePasteWindow : public FramelessDialog {
    Q_OBJECT
public:
    explicit TimePasteWindow(QWidget* parent = nullptr);
    ~TimePasteWindow();

protected:
    void showEvent(QShowEvent* event) override;
    void hideEvent(QHideEvent* event) override;

private slots:
    void updateDateTime();
    void onDigitPressed(int digit);

private:
    void initUI();
    QString getRadioStyle();

    QLabel* m_dateLabel;
    QLabel* m_timeLabel;
    QRadioButton* m_radioPrev;
    QRadioButton* m_radioNext;
    QButtonGroup* m_buttonGroup;
    QTimer* m_timer;
    QPoint m_dragPos;
};

#endif // TIMEPASTEWINDOW_H
```

## 文件: `src/ui/TitleEditorDialog.h`

```cpp
#ifndef TITLEEDITORDIALOG_H
#define TITLEEDITORDIALOG_H

#include <QDialog>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QTextEdit>
#include <QPushButton>
#include <QGraphicsDropShadowEffect>
#include <QCursor>

/**
 * @brief 通用标题编辑对话框，用于元数据面板和笔记编辑窗口的标题快速编辑。
 */
class TitleEditorDialog : public QDialog {
    Q_OBJECT
public:
    explicit TitleEditorDialog(const QString& currentText, QWidget* parent = nullptr) : QDialog(parent) {
        setWindowFlags(Qt::FramelessWindowHint | Qt::Popup | Qt::NoDropShadowWindowHint);
        setAttribute(Qt::WA_TranslucentBackground);
        setFixedSize(400, 170);

        auto* layout = new QVBoxLayout(this);
        // [CRITICAL] 边距调整为 20px 以容纳阴影，防止出现“断崖式”阴影截止
        layout->setContentsMargins(20, 20, 20, 20);

        auto* container = new QWidget(this);
        container->setObjectName("container");
        container->setStyleSheet("QWidget#container { background-color: #1e1e1e; border: 1px solid #333; border-radius: 10px; }");
        layout->addWidget(container);

        auto* innerLayout = new QVBoxLayout(container);
        innerLayout->setContentsMargins(12, 12, 12, 10);
        innerLayout->setSpacing(8);

        m_textEdit = new QTextEdit();
        m_textEdit->setText(currentText);
        m_textEdit->setPlaceholderText("请输入标题...");
        m_textEdit->setStyleSheet("QTextEdit { background-color: #252526; border: 1px solid #444; border-radius: 6px; color: white; font-size: 14px; padding: 8px; } QTextEdit:focus { border: 1px solid #4a90e2; }");
        innerLayout->addWidget(m_textEdit);

        auto* btnLayout = new QHBoxLayout();
        btnLayout->addStretch();
        auto* btnSave = new QPushButton("完成");
        btnSave->setFixedSize(64, 30);
        btnSave->setCursor(Qt::PointingHandCursor);
        btnSave->setStyleSheet("QPushButton { background-color: #4a90e2; color: white; border: none; border-radius: 4px; font-weight: bold; } QPushButton:hover { background-color: #357abd; }");
        connect(btnSave, &QPushButton::clicked, this, &QDialog::accept);
        btnLayout->addWidget(btnSave);
        innerLayout->addLayout(btnLayout);

        // 1:1 匹配 QuickWindow 阴影规范 (同步修复模糊截止问题)
        auto* shadow = new QGraphicsDropShadowEffect(this);
        shadow->setBlurRadius(20);
        shadow->setColor(QColor(0, 0, 0, 120));
        shadow->setOffset(0, 4);
        container->setGraphicsEffect(shadow);
    }

    QString getText() const { return m_textEdit->toPlainText().trimmed(); }

    void showAtCursor() {
        QPoint pos = QCursor::pos();
        // 尝试居中显示在鼠标点击位置附近
        move(pos.x() - width() / 2, pos.y() - 40);
        show();
        m_textEdit->setFocus();
        m_textEdit->selectAll();
    }

private:
    QTextEdit* m_textEdit;
};

#endif // TITLEEDITORDIALOG_H
```

## 文件: `src/ui/Toolbox.cpp`

```cpp
#include "Toolbox.h"
#include "ToolTipOverlay.h"
#include "IconHelper.h"
#include "StringUtils.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QScreen>
#include <QApplication>
#include <QGuiApplication>
#include <QMouseEvent>
#include <QToolTip>
#include <QSettings>
#include <QCheckBox>
#include <QDialog>
#include <QWindow>

Toolbox::Toolbox(QWidget* parent) : FramelessDialog("工具箱", parent) {
    setObjectName("ToolboxLauncher");
    
    // [CRITICAL] 强制开启非活动窗口的 ToolTip 显示。
    // setAttribute(Qt::WA_AlwaysShowToolTips); // Custom tooltip doesn't need this
    
    // 设置为工具窗口：任务栏不显示，且置顶
    setWindowFlags(windowFlags() | Qt::Tool | Qt::WindowStaysOnTopHint);

    // 关键修复：强制注入 ToolTip 样式。
    // 在 Windows 平台下，Qt::Tool 窗口的子控件在弹出 ToolTip 时往往无法正确继承全局 QSS。
    this->setStyleSheet("");
    
    // 允许通过拉伸边缘来调整大小
    setMinimumSize(40, 40);

    // 修改工具箱圆角为 6px
    QWidget* container = findChild<QWidget*>("DialogContainer");
    if (container) {
        container->setStyleSheet(container->styleSheet().replace("border-radius: 12px;", "border-radius: 6px;"));
    }

    initUI();
    loadSettings();
    updateLayout(m_orientation);
}

Toolbox::~Toolbox() {
    saveSettings();
}

void Toolbox::showEvent(QShowEvent* event) {
    saveSettings();
    FramelessDialog::showEvent(event);
}

void Toolbox::hideEvent(QHideEvent* event) {
    saveSettings();
    FramelessDialog::hideEvent(event);
}

void Toolbox::initUI() {
    // 隐藏默认标题文字，因为我们要把图标放上去
    m_titleLabel->hide();

    // 置顶按钮在工具箱中永久隐藏
    if (m_btnPin) m_btnPin->hide();

    // 将最小化按钮改为移动手柄
    if (m_minBtn) {
        // 仅断开与基类的连接，避免使用通配符 disconnect() 触发 destroyed 信号警告
        m_minBtn->disconnect(this); 
        m_minBtn->setIcon(IconHelper::getIcon("move", "#888888"));
        // m_minBtn->setToolTip("按住移动");
        m_minBtn->setToolTip(""); // [CRITICAL] 清除基类的“最小化”原生 Tooltip，避免与下方的 tooltipText 冲突
        m_minBtn->setProperty("tooltipText", "按住移动");
        m_minBtn->setCursor(Qt::SizeAllCursor);
        // 保留 Hover 背景提供视觉反馈
        m_minBtn->setStyleSheet("QPushButton { background: transparent; border: none; border-radius: 4px; } "
                             "QPushButton:hover { background-color: rgba(255, 255, 255, 0.1); }");
        
        // 安装事件过滤器以实现拖拽
        m_minBtn->installEventFilter(this);
    }
    
    // 清空内容区原有边距
    m_contentArea->layout() ? delete m_contentArea->layout() : (void)0;

    // 创建按钮列表
    auto addTool = [&](const QString& id, const QString& tip, const QString& icon, const QString& color, auto signal) {
        ToolInfo info;
        info.id = id;
        info.tip = tip;
        info.icon = icon;
        info.color = color;
        info.callback = [this, signal]() { emit (this->*signal)(); };
        info.btn = createToolButton(tip, icon, color);
        connect(info.btn, &QPushButton::clicked, this, info.callback);
        m_toolInfos.append(info);
    };

    addTool("time", "时间输出", "clock", "#1abc9c", &Toolbox::showTimePasteRequested);
    addTool("password", "密码生成器", "password_generator", "#3498db", &Toolbox::showPasswordGeneratorRequested);
    addTool("ocr", "批量识别", "text", "#4a90e2", &Toolbox::showOCRRequested);
    addTool("immediate_ocr", "截图取文", "screenshot_ocr", "#3498db", &Toolbox::startOCRRequested);
    addTool("tag", "标签管理", "tag", "#f1c40f", &Toolbox::showTagManagerRequested);
    addTool("file_storage", "存储文件", "file_managed", "#e67e22", &Toolbox::showFileStorageRequested);
    addTool("file_search", "查找文件", "search", "#95a5a6", &Toolbox::showFileSearchRequested);
    addTool("keyword_search", "查找关键字", "find_keyword", "#3498db", &Toolbox::showKeywordSearchRequested);
    addTool("color_picker", "颜色提取器", "paint_bucket", "#ff6b81", &Toolbox::showColorPickerRequested);
    addTool("pixel_ruler", "标尺", "pixel_ruler", "#e67e22", &Toolbox::showPixelRulerRequested);
    addTool("immediate_color_picker", "选取颜色", "screen_picker", "#ff4757", &Toolbox::startColorPickerRequested);
    addTool("screenshot", "截图", "camera", "#e74c3c", &Toolbox::screenshotRequested);
    addTool("main_window", "主界面", "maximize", "#4FACFE", &Toolbox::showMainWindowRequested);
    addTool("quick_window", "快速笔记", "zap", "#F1C40F", &Toolbox::showQuickWindowRequested);

    m_btnRotate = createToolButton("切换布局", "rotate", "#aaaaaa");
    connect(m_btnRotate, &QPushButton::clicked, this, &Toolbox::toggleOrientation);

    m_btnMenu = createToolButton("配置按钮", "menu_dots", "#aaaaaa");
    connect(m_btnMenu, &QPushButton::clicked, this, &Toolbox::showConfigPanel);
}

void Toolbox::updateLayout(Orientation orientation) {
    m_orientation = orientation;
    
    // 获取控制按钮 (使用基类成员)
    auto* btnPin = m_btnPin;
    auto* minBtn = m_minBtn; // 在工具箱中作为“移动”手柄
    auto* closeBtn = m_closeBtn;

    // 根据方向设置菜单图标（垂直模式下旋转90度变为横向三点）
    if (m_btnMenu) {
        m_btnMenu->setIcon(IconHelper::getIcon("menu_dots", "#aaaaaa"));
        if (orientation == Orientation::Vertical) {
            QPixmap pix = m_btnMenu->icon().pixmap(32, 32);
            QTransform trans;
            trans.rotate(90);
            m_btnMenu->setIcon(QIcon(pix.transformed(trans, Qt::SmoothTransformation)));
        }
    }

    // 寻找标题栏 widget
    QWidget* titleBar = nullptr;
    if (m_mainLayout->count() > 0) {
        titleBar = m_mainLayout->itemAt(0)->widget();
    }
    if (!titleBar) return;

    // 彻底重置标题栏布局与尺寸限制，防止横纵切换冲突导致的 squashed 状态
    titleBar->setMinimumSize(0, 0);
    titleBar->setMaximumSize(16777215, 16777215);
    
    // 移除基类默认的 10px 底部边距，确保尺寸严格受控
    m_mainLayout->setContentsMargins(0, 0, 0, 0);

    if (titleBar->layout()) {
        QLayoutItem* item;
        while ((item = titleBar->layout()->takeAt(0)) != nullptr) {
            // 不删除 widget，只移除
        }
        delete titleBar->layout();
    }

    // 统一隐藏内容区，所有按钮都放在标题栏内以便在纵向时能正确拉伸且顺序一致
    m_contentArea->hide();

    int visibleCount = 0;
    for (const auto& info : m_toolInfos) if (info.visible) visibleCount++;

    if (orientation == Orientation::Horizontal) {
        titleBar->setFixedHeight(42);
        titleBar->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
        titleBar->setStyleSheet("background-color: transparent; border: none;");
        auto* layout = new QHBoxLayout(titleBar);
        layout->setContentsMargins(8, 0, 8, 0);
        layout->setSpacing(2); // 紧凑间距
        
        // 1. 功能按钮
        for (auto& info : m_toolInfos) {
            if (info.visible) {
                layout->addWidget(info.btn, 0, Qt::AlignVCenter);
                info.btn->show();
            } else {
                info.btn->hide();
            }
        }
        // 2. 旋转与配置按钮
        layout->addWidget(m_btnRotate, 0, Qt::AlignVCenter);
        layout->addWidget(m_btnMenu, 0, Qt::AlignVCenter);
        
        // 4. 系统控制按钮 (统一间距，移除 Stretch)
        if (minBtn) layout->addWidget(minBtn, 0, Qt::AlignVCenter);
        if (closeBtn) layout->addWidget(closeBtn, 0, Qt::AlignVCenter);

        // 确保 m_mainLayout 正确分配空间
        m_mainLayout->setStretchFactor(titleBar, 0);
    } else {
        titleBar->setFixedWidth(42);
        titleBar->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Expanding);
        titleBar->setStyleSheet("background-color: transparent; border: none;");
        auto* layout = new QVBoxLayout(titleBar);
        layout->setContentsMargins(0, 8, 0, 8);
        layout->setSpacing(2); // 紧凑间距
        layout->setAlignment(Qt::AlignHCenter);

        // 垂直模式下，顺序完全反转：系统按钮在最上方
        if (closeBtn) layout->addWidget(closeBtn, 0, Qt::AlignHCenter);
        if (minBtn) layout->addWidget(minBtn, 0, Qt::AlignHCenter);
        // 置顶按钮在垂直模式也隐藏

        // 旋转与配置按钮 (反转顺序，移除 Stretch 实现统一间距)
        layout->addWidget(m_btnMenu, 0, Qt::AlignHCenter);
        layout->addWidget(m_btnRotate, 0, Qt::AlignHCenter);

        // 功能工具按钮 (反转顺序)
        for (int i = m_toolInfos.size() - 1; i >= 0; --i) {
            auto& info = m_toolInfos[i];
            if (info.visible) {
                layout->addWidget(info.btn, 0, Qt::AlignHCenter);
                info.btn->show();
            } else {
                info.btn->hide();
            }
        }

        // 在纵向模式下，让 titleBar 填满整个布局
        m_mainLayout->setStretchFactor(titleBar, 1);
    }

    // 强制触发布局计算与尺寸同步，确保 sizeHint 有效且不触发 Windows 渲染报错
    titleBar->updateGeometry();
    m_mainLayout->activate();
    
    setMinimumSize(0, 0);
    setMaximumSize(16777215, 16777215);

    // 先通过 adjustSize 让窗口系统同步布局，再锁定固定尺寸，防止 UpdateLayeredWindowIndirect 报错
    adjustSize();
    setFixedSize(sizeHint());
    update();
}

void Toolbox::mouseMoveEvent(QMouseEvent* event) {
    FramelessDialog::mouseMoveEvent(event);
    // 这里可以添加吸附预览效果
}

void Toolbox::mouseReleaseEvent(QMouseEvent* event) {
    FramelessDialog::mouseReleaseEvent(event);
    checkSnapping();
}

void Toolbox::moveEvent(QMoveEvent* event) {
    FramelessDialog::moveEvent(event);
    // 仅在窗口可见且非最小化时保存位置，防止启动时的异常坐标或最小化状态被记录
    if (isVisible() && !isMinimized()) {
        saveSettings();
    }
}

bool Toolbox::eventFilter(QObject* watched, QEvent* event) {
    if (watched == m_minBtn) {
        if (event->type() == QEvent::MouseButtonPress) {
            auto* me = static_cast<QMouseEvent*>(event);
            if (me->button() == Qt::LeftButton) {
                // 转发给窗口处理拖拽逻辑
                this->mousePressEvent(me);
                return true; // 拦截，不触发按钮点击
            }
        } else if (event->type() == QEvent::MouseMove) {
            auto* me = static_cast<QMouseEvent*>(event);
            if (me->buttons() & Qt::LeftButton) {
                this->mouseMoveEvent(me);
                return true;
            }
        } else if (event->type() == QEvent::MouseButtonRelease) {
            auto* me = static_cast<QMouseEvent*>(event);
            this->mouseReleaseEvent(me);
            return true;
        }
    }
    
    if (event->type() == QEvent::HoverEnter) {
        QString text = watched->property("tooltipText").toString();
        if (!text.isEmpty()) {
            ToolTipOverlay::instance()->showText(QCursor::pos(), text);
            // Don't return true, let buttons process hover for style updates
        }
    } else if (event->type() == QEvent::HoverLeave) {
        ToolTipOverlay::hideTip();
    }
    
    return FramelessDialog::eventFilter(watched, event);
}

void Toolbox::checkSnapping() {
    QScreen *screen = QGuiApplication::primaryScreen();
    if (!screen) return;

    QRect screenGeom = screen->availableGeometry();
    QRect winGeom = frameGeometry();
    const int threshold = 40;

    int targetX = winGeom.x();
    int targetY = winGeom.y();
    Orientation newOrientation = m_orientation;

    bool snapped = false;

    // 考虑 FramelessDialog 的 15px 外部边距 (用于阴影)
    const int margin = 15;

    // 检查左右边缘
    if (winGeom.left() + margin - screenGeom.left() < threshold) {
        targetX = screenGeom.left() - margin;
        newOrientation = Orientation::Vertical;
        snapped = true;
    } else if (screenGeom.right() - (winGeom.right() - margin) < threshold) {
        targetX = screenGeom.right() - winGeom.width() + margin;
        newOrientation = Orientation::Vertical;
        snapped = true;
    }

    // 检查上下边缘
    if (winGeom.top() + margin - screenGeom.top() < threshold) {
        targetY = screenGeom.top() - margin;
        if (!snapped) newOrientation = Orientation::Horizontal;
        snapped = true;
    } else if (screenGeom.bottom() - (winGeom.bottom() - margin) < threshold) {
        targetY = screenGeom.bottom() - winGeom.height() + margin;
        if (!snapped) newOrientation = Orientation::Horizontal;
        snapped = true;
    }

    if (snapped) {
        if (newOrientation != m_orientation) {
            updateLayout(newOrientation);
            adjustSize(); // 确保获取更新布局后的最新尺寸
            // 切换布局后再次校验边界，防止超出屏幕 (针对 Requirement 4)
            QRect newWinGeom = frameGeometry();
            if (targetX + newWinGeom.width() - margin > screenGeom.right()) {
                targetX = screenGeom.right() - newWinGeom.width() + margin;
            }
            if (targetY + newWinGeom.height() - margin > screenGeom.bottom()) {
                targetY = screenGeom.bottom() - newWinGeom.height() + margin;
            }
        }
        move(targetX, targetY);
        saveSettings(); // 吸附后显式保存，确保位置被记录
    }
}

void Toolbox::toggleOrientation() {
    Orientation next = (m_orientation == Orientation::Horizontal) ? Orientation::Vertical : Orientation::Horizontal;
    updateLayout(next);
    // 旋转后立即触发吸附与边界检测，防止因高度/宽度增加而溢出屏幕
    checkSnapping();
    saveSettings();
}

void Toolbox::showConfigPanel() {
    auto* panel = new QDialog(this, Qt::Popup | Qt::FramelessWindowHint);
    panel->setAttribute(Qt::WA_TranslucentBackground, true);
    
    auto* mainLayout = new QVBoxLayout(panel);
    mainLayout->setContentsMargins(0, 0, 0, 0);

    // 引入背景容器 QFrame，彻底解决圆角处直角溢出的问题
    auto* bgFrame = new QFrame(panel);
    bgFrame->setObjectName("ConfigBgFrame");
    bgFrame->setAttribute(Qt::WA_StyledBackground, true);
    
    // 移除 500 像素硬编码宽度，改回自适应内容宽度
    panel->setMinimumWidth(150);

    bgFrame->setStyleSheet(
        "#ConfigBgFrame { background-color: #252526; border: 1px solid #444; border-radius: 10px; }"
        "QLabel { color: #888; border: none; font-size: 11px; font-weight: bold; padding: 2px 5px; background: transparent; }"
        "QCheckBox { background-color: #333336; color: #bbb; border: 1px solid #444; font-size: 11px; padding: 4px 15px; margin: 2px 0px; border-radius: 12px; spacing: 8px; }"
        "QCheckBox:hover { background-color: #404044; color: #fff; border-color: #555; }"
        "QCheckBox::indicator { width: 0px; height: 0px; } " // 胶囊样式下隐藏复选框勾选图标
        "QCheckBox:checked { background-color: rgba(0, 122, 204, 0.3); color: #fff; font-weight: bold; border-color: #007ACC; }"
        "QCheckBox:checked:hover { background-color: rgba(0, 122, 204, 0.4); border-color: #0098FF; }"
    );

    auto* contentLayout = new QVBoxLayout(bgFrame);
    contentLayout->setContentsMargins(12, 12, 12, 12);
    contentLayout->setSpacing(6);

    mainLayout->addWidget(bgFrame);

    auto* titleLabel = new QLabel("显示/隐藏功能按钮");
    contentLayout->addWidget(titleLabel);

    for (int i = 0; i < m_toolInfos.size(); ++i) {
        auto* cb = new QCheckBox(m_toolInfos[i].tip);
        cb->setIcon(IconHelper::getIcon(m_toolInfos[i].icon, m_toolInfos[i].color));
        cb->setIconSize(QSize(18, 18));
        cb->setCursor(Qt::PointingHandCursor);
        cb->setChecked(m_toolInfos[i].visible);
        connect(cb, &QCheckBox::toggled, this, [this, i](bool checked) {
            m_toolInfos[i].visible = checked;
            saveSettings();
            updateLayout(m_orientation);
        });
        contentLayout->addWidget(cb);
    }

    panel->adjustSize();

    QPoint pos = m_btnMenu->mapToGlobal(QPoint(0, 0));
    
    // 获取当前屏幕可用区域，确保不超出边界
    QScreen *screen = QGuiApplication::primaryScreen();
    if (this->window() && this->window()->windowHandle()) {
        screen = this->window()->windowHandle()->screen();
    }
    QRect screenGeom = screen ? screen->availableGeometry() : QRect(0, 0, 1920, 1080);

    int x = pos.x();
    int y = pos.y();

    if (m_orientation == Orientation::Horizontal) {
        // 优先向上弹出
        y = pos.y() - panel->height() - 5;
        if (y < screenGeom.top()) {
            // 空间不足则向下弹出
            y = pos.y() + m_btnMenu->height() + 5;
        }
        // 水平修正，保持在按钮附近
        if (x + panel->width() > screenGeom.right()) {
            x = screenGeom.right() - panel->width() - 5;
        }
    } else {
        // 纵向模式下，向左弹出
        x = pos.x() - panel->width() - 5;
        if (x < screenGeom.left()) {
            // 空间不足则向右弹出
            x = pos.x() + m_btnMenu->width() + 5;
        }
        // 垂直修正
        if (y + panel->height() > screenGeom.bottom()) {
            y = screenGeom.bottom() - panel->height() - 5;
        }
    }

    panel->move(x, y);
    panel->show();
}

void Toolbox::loadSettings() {
    QSettings settings("RapidNotes", "Toolbox");
    m_orientation = (Orientation)settings.value("orientation", (int)Orientation::Vertical).toInt();
    
    if (settings.value("isOpen", false).toBool()) {
        show();
    }

    // 恢复位置
    if (settings.contains("pos")) {
        move(settings.value("pos").toPoint());
    } else {
        // 首次运行：默认停靠在屏幕右侧
        QScreen *screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect geom = screen->availableGeometry();
            move(geom.right() - 50, geom.center().y() - 150);
        }
    }

    for (auto& info : m_toolInfos) {
        info.visible = settings.value("visible_" + info.id, true).toBool();
    }
}

void Toolbox::saveSettings() {
    QSettings settings("RapidNotes", "Toolbox");
    settings.setValue("orientation", (int)m_orientation);
    settings.setValue("isOpen", isVisible());
    
    // 记录最后一次有效位置
    if (isVisible() && !isMinimized()) {
        settings.setValue("pos", pos());
    }
    
    for (const auto& info : m_toolInfos) {
        settings.setValue("visible_" + info.id, info.visible);
    }
}

QPushButton* Toolbox::createToolButton(const QString& tooltip, const QString& iconName, const QString& color) {
    auto* btn = new QPushButton();
    btn->setIcon(IconHelper::getIcon(iconName, color));
    btn->setIconSize(QSize(20, 20));
    btn->setFixedSize(32, 32);
    // 使用简单的 HTML 包装以确保在所有平台上触发 QSS 样式化的富文本渲染
    // btn->setToolTip(tooltip);
    btn->setProperty("tooltipText", tooltip);
    btn->installEventFilter(this);
    btn->setCursor(Qt::PointingHandCursor);
    btn->setFocusPolicy(Qt::NoFocus);
    
    btn->setStyleSheet("QPushButton {"
        "  background-color: transparent;"
        "  border: none;"
        "  border-radius: 6px;"
        "}"
        "QPushButton:hover {"
        "  background-color: rgba(255, 255, 255, 0.08);"
        "}"
        "QPushButton:pressed {"
        "  background-color: rgba(255, 255, 255, 0.15);"
        "}"
    );
    
    return btn;
}
```

## 文件: `src/ui/Toolbox.h`

```cpp
#ifndef TOOLBOX_H
#define TOOLBOX_H

#include "FramelessDialog.h"
#include <QPushButton>
#include <QPoint>
#include <QMoveEvent>
#include <QBoxLayout>
#include <functional>

class ToolTipOverlay;

class Toolbox : public FramelessDialog {
    Q_OBJECT
public:
    explicit Toolbox(QWidget* parent = nullptr);
    ~Toolbox();

    enum class Orientation {
        Horizontal,
        Vertical
    };

signals:
    void showMainWindowRequested();
    void showQuickWindowRequested();
    void showTimePasteRequested();
    void showPasswordGeneratorRequested();
    void showOCRRequested();
    void startOCRRequested();
    void showTagManagerRequested();
    void showFileStorageRequested();
    void showFileSearchRequested();
    void showKeywordSearchRequested();
    void showColorPickerRequested();
    void startColorPickerRequested();
    void showPixelRulerRequested();
    void showHelpRequested();
    void screenshotRequested();

protected:
    void mouseReleaseEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void moveEvent(QMoveEvent* event) override;
    void showEvent(QShowEvent* event) override;
    void hideEvent(QHideEvent* event) override;
    bool eventFilter(QObject* watched, QEvent* event) override;

    // 工具箱自身始终置顶且由构造函数控制，跳过基类的通用置顶记忆逻辑
    void loadWindowSettings() override {}
    void saveWindowSettings() override {}

private slots:
    void toggleOrientation();
    void showConfigPanel();

private:
    void initUI();
    void updateLayout(Orientation orientation);
    void checkSnapping();
    QPushButton* createToolButton(const QString& tooltip, const QString& iconName, const QString& color);
    void loadSettings();
    void saveSettings();

    Orientation m_orientation = Orientation::Vertical;
    
    struct ToolInfo {
        QString id;
        QString tip;
        QString icon;
        QString color;
        std::function<void()> callback;
        QPushButton* btn = nullptr;
        bool visible = true;
    };
    QList<ToolInfo> m_toolInfos;

    QPushButton* m_btnRotate = nullptr;
    QPushButton* m_btnMenu = nullptr;
};

#endif // TOOLBOX_H
```

## 文件: `src/ui/ToolTipOverlay.h`

```cpp
#ifndef TOOLTIPOVERLAY_H
#define TOOLTIPOVERLAY_H

#include <QWidget>
#include <QPainter>
#include <QScreen>
#include <QGuiApplication>
#include <QApplication>
#include <QTimer>
#include <QFontMetrics>
#include <QTextDocument>
#include <QPointer>
#include <QPainterPath>
#include <QColor>
#include <QPen>
#include <QBrush>
#include <QRectF>

// ----------------------------------------------------------------------------
// ToolTipOverlay: 全局统一的自定义 Tooltip
// [CRITICAL] 本项目严禁使用任何形式的“Windows 系统默认 Tip 样式”！
// [RULE] 1. 杜绝原生内容带来的系统阴影和不透明度。
// [RULE] 2. 所有的 ToolTip 逻辑必须通过此 ToolTipOverlay 渲染。
// [RULE] 3. 此组件必须保持扁平化 (Flat)，严禁添加任何阴影特效。
// ----------------------------------------------------------------------------
class ToolTipOverlay : public QWidget {
    Q_OBJECT
public:
    static ToolTipOverlay* instance() {
        static QPointer<ToolTipOverlay> inst;
        if (!inst) {
            inst = new ToolTipOverlay();
        }
        return inst;
    }

    void showText(const QPoint& globalPos, const QString& text, int timeout = 3000, const QColor& borderColor = QColor("#B0B0B0")) {
        if (text.isEmpty()) { hide(); return; }
        m_currentBorderColor = borderColor;

        // [BLOCKER FIX] 之前的逻辑仅判断 startsWith("<") 极其不稳
        // 现在统一使用标准的 HTML 包装器，并确保内部文字颜色强制覆盖
        QString htmlBody;
        if (text.contains("<") && text.contains(">")) {
            // 如果疑似 HTML，尝试去除可能存在的 body/html 标签（简单处理）
            htmlBody = text;
        } else {
            // 纯文本：进行 HTML 转义并保留换行
            htmlBody = text.toHtmlEscaped().replace("\n", "<br>");
        }

        m_text = QString(
            "<html><head><style>div, p, span, body { color: #EEEEEE !important; }</style></head>"
            "<body style='margin:0; padding:0; color:#EEEEEE; font-family:\"Microsoft YaHei\",\"Segoe UI\",sans-serif;'>"
            "<div style='color:#EEEEEE !important;'>%1</div>"
            "</body></html>"
        ).arg(htmlBody);
        
        m_doc.setHtml(m_text);
        m_doc.setDocumentMargin(0); // 彻底消除文档默认边距，保证边距完全由 pad 决定
        
        // 1. 弹性计算尺寸
        m_doc.setTextWidth(-1); // 先恢复自然宽度
        qreal idealW = m_doc.idealWidth();
        
        if (idealW > 450) {
            m_doc.setTextWidth(450); // 超过限制则强制折行
        } else {
            m_doc.setTextWidth(idealW); // 否则保持内容宽度
        }
        
        QSize textSize = m_doc.size().toSize();
        
        int padX = 12; 
        int padY = 8;
        
        int w = textSize.width() + padX * 2;
        int h = textSize.height() + padY * 2;
        
        // 最小宽高限制
        w = qMax(w, 40);
        h = qMax(h, 24);
        
        resize(w, h);
        
        // 2. 位置计算 (视觉偏移 15, 15)
        QPoint pos = globalPos + QPoint(15, 15);
        
        // 3. 边缘检测
        QScreen* screen = QGuiApplication::screenAt(globalPos);
        if (!screen) screen = QGuiApplication::primaryScreen();
        if (screen) {
            QRect screenGeom = screen->geometry();
            if (pos.x() + width() > screenGeom.right()) {
                pos.setX(globalPos.x() - width() - 15);
            }
            if (pos.y() + height() > screenGeom.bottom()) {
                pos.setY(globalPos.y() - height() - 15);
            }
        }
        
        move(pos);
        show();
        raise();
        update();

        // 自动隐藏逻辑：如果是正数则启动定时器
        if (timeout > 0) {
            m_hideTimer.start(timeout);
        } else {
            m_hideTimer.stop();
        }
    }

    static void hideTip() {
        if (instance()) instance()->hide();
    }

protected:
    explicit ToolTipOverlay() : QWidget(nullptr) {
        // [CRITICAL] 彻底杜绝系统阴影：必须显式包含 Qt::NoDropShadowWindowHint 标志。
        setWindowFlags(Qt::ToolTip | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | 
                      Qt::WindowTransparentForInput | Qt::NoDropShadowWindowHint);
        // 显式禁用阴影（特定于某些环境）
        setObjectName("ToolTipOverlay");
        setAttribute(Qt::WA_TranslucentBackground);
        setAttribute(Qt::WA_ShowWithoutActivating);
        
        m_doc.setUndoRedoEnabled(false);
        // [ULTIMATE FIX] 强制锁定调色板颜色，防止继承自全局黑色的 QSS。
        QPalette pal = palette();
        pal.setColor(QPalette::WindowText, QColor("#EEEEEE"));
        pal.setColor(QPalette::Text, QColor("#EEEEEE"));
        pal.setColor(QPalette::ButtonText, QColor("#EEEEEE"));
        setPalette(pal);

        // 终极样式兜底：针对所有可能的标签应用颜色，并使用 !important
        m_doc.setDefaultStyleSheet("body, div, p, span, b, i { color: #EEEEEE !important; font-family: 'Microsoft YaHei', 'Segoe UI'; }"); 
        setStyleSheet("QWidget { color: #EEEEEE !important; background: transparent; }");

        QFont f = font();
        f.setPointSize(9);
        m_doc.setDefaultFont(f);

        m_hideTimer.setSingleShot(true);
        connect(&m_hideTimer, &QTimer::timeout, this, &ToolTipOverlay::hide);

        hide();
    }

    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        p.setRenderHint(QPainter::Antialiasing);
        
        // 彻底去阴影，保持扁平矩形风格
        // 1 像素物理偏移校准位
        QRectF rectF(0.5, 0.5, width() - 1, height() - 1);
        
        // 背景色: #2B2B2B
        // 边框色: 动态传入, 默认 #B0B0B0, 宽度 1px
        p.setPen(QPen(m_currentBorderColor, 1));
        p.setBrush(QColor("#2B2B2B"));
        p.drawRoundedRect(rectF, 4, 4);
        
        // 绘制内容预览
        p.save();
        p.translate(12, 8); // Padding Offset
        p.setPen(QColor("#EEEEEE")); // 备用画笔颜色
        m_doc.drawContents(&p);
        p.restore();
    }

private:
    QString m_text;
    QTextDocument m_doc;
    QTimer m_hideTimer;
    QColor m_currentBorderColor = QColor("#B0B0B0");
};

#endif // TOOLTIPOVERLAY_H
```

## 文件: `src/core/Win32System.h`

```cpp
#ifndef WIN32SYSTEM_H
#define WIN32SYSTEM_H

#include "IPlatformSystem.h"
#include <windows.h>
#include <psapi.h>
#include <QFileInfo>

class Win32System : public IPlatformSystem {
public:
    bool isBrowserActive() override {
        HWND hwnd = GetForegroundWindow();
        if (!hwnd) return false;

        DWORD pid;
        GetWindowThreadProcessId(hwnd, &pid);
        
        HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
        if (!process) return false;

        wchar_t buffer[MAX_PATH];
        if (GetModuleFileNameExW(process, NULL, buffer, MAX_PATH)) {
            QString exeName = QFileInfo(QString::fromWCharArray(buffer)).fileName().toLower();
            static const QStringList browserExes = {
                "chrome.exe", "msedge.exe", "firefox.exe", "brave.exe", 
                "opera.exe", "iexplore.exe", "vivaldi.exe", "safari.exe"
            };
            CloseHandle(process);
            return browserExes.contains(exeName);
        }

        CloseHandle(process);
        return false;
    }

    QString getForegroundAppPath() override {
        HWND hwnd = GetForegroundWindow();
        if (!hwnd) return "";
        DWORD pid;
        GetWindowThreadProcessId(hwnd, &pid);
        HANDLE process = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
        if (!process) return "";
        wchar_t buffer[MAX_PATH];
        QString path;
        if (GetModuleFileNameExW(process, NULL, buffer, MAX_PATH)) {
            path = QString::fromWCharArray(buffer);
        }
        CloseHandle(process);
        return path;
    }

    void simulateCopy() override {
        // 显式释放修饰键，防止干扰 Ctrl+C
        keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
        keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0); // Alt

        keybd_event(VK_CONTROL, 0, 0, 0);
        keybd_event('C', 0, 0, 0);
        keybd_event('C', 0, KEYEVENTF_KEYUP, 0);
        keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
    }

    void simulateSelectAll() override {
        keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
        keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);

        keybd_event(VK_CONTROL, 0, 0, 0);
        keybd_event('A', 0, 0, 0);
        keybd_event('A', 0, KEYEVENTF_KEYUP, 0);
        keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
    }

    void simulateKeyStroke(int vk, bool alt = false, bool ctrl = false, bool shift = false) override {
        if (ctrl) keybd_event(VK_CONTROL, 0, 0, 0);
        if (alt) keybd_event(VK_MENU, 0, 0, 0);
        if (shift) keybd_event(VK_SHIFT, 0, 0, 0);

        keybd_event(vk, 0, 0, 0);
        keybd_event(vk, 0, KEYEVENTF_KEYUP, 0);

        if (shift) keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
        if (alt) keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);
        if (ctrl) keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
    }

public:

    bool registerGlobalHotkey(int id, uint modifiers, uint vk) override {
        return RegisterHotKey(nullptr, id, modifiers, vk);
    }

    bool unregisterGlobalHotkey(int id) override {
        return UnregisterHotKey(nullptr, id);
    }
};

#endif // WIN32SYSTEM_H
```

## 文件: `src/ui/WritingAnimation.cpp`

```cpp
#include "WritingAnimation.h"
```

## 文件: `src/ui/WritingAnimation.h`

```cpp
#ifndef WRITINGANIMATION_H
#define WRITINGANIMATION_H

#include <QWidget>
#include <QTimer>
#include <QPainter>
#include <QPainterPath>
#include <QLinearGradient>
#include <QtMath>

class WritingAnimation : public QWidget {
    Q_OBJECT
public:
    explicit WritingAnimation(QWidget* parent = nullptr) : QWidget(parent) {
        setFixedSize(40, 40);
        m_timer = new QTimer(this);
        connect(m_timer, &QTimer::timeout, this, &WritingAnimation::updatePhysics);
    }

    void start() {
        m_time = 0;
        m_timer->start(20);
        show();
    }

protected:
    void paintEvent(QPaintEvent*) override {
        QPainter p(this);
        p.setRenderHint(QPainter::Antialiasing);
        
        float cx = width() / 2.0f;
        float cy = height() / 2.0f;

        // 1. 绘制书本
        p.save();
        p.translate(cx, cy + m_bookY);
        p.scale(0.4, 0.4);
        drawBook(&p);
        p.restore();

        // 2. 绘制钢笔
        p.save();
        p.translate(cx + m_penX, cy + m_penY - 5);
        p.scale(0.4, 0.4);
        p.rotate(m_angle);
        drawPen(&p);
        p.restore();
    }

private:
    void drawBook(QPainter* p) {
        // 模仿 Python 版的 Mocha 书本
        p->setPen(Qt::NoPen);
        p->setBrush(QColor("#f5f0e1")); // 纸张
        p->drawRoundedRect(QRectF(-22, -32, 56, 76), 3, 3);
        
        QLinearGradient grad(-28, -38, 28, 38);
        grad.setColorAt(0, QColor("#5a3c32"));
        grad.setColorAt(1, QColor("#321e19"));
        p->setBrush(grad); // 封面
        p->drawRoundedRect(QRectF(-28, -38, 56, 76), 3, 3);
        
        p->setBrush(QColor("#78141e")); // 书脊装饰
        p->drawRect(QRectF(13, -38, 8, 76));
    }

    void drawPen(QPainter* p) {
        // 模仿 Python 版的通用钢笔
        p->setPen(Qt::NoPen);
        QLinearGradient bodyGrad(-6, 0, 6, 0);
        bodyGrad.setColorAt(0, QColor("#b43c46"));
        bodyGrad.setColorAt(0.5, QColor("#8c141e"));
        bodyGrad.setColorAt(1, QColor("#3c050a"));
        p->setBrush(bodyGrad);
        p->drawRoundedRect(QRectF(-6, -23, 12, 46), 5, 5);

        // 笔尖
        QPainterPath tipPath;
        tipPath.moveTo(-3, 23);
        tipPath.lineTo(3, 23);
        tipPath.lineTo(0, 37);
        tipPath.closeSubpath();
        p->setBrush(QColor("#f0e6b4"));
        p->drawPath(tipPath);
    }

private slots:
    void updatePhysics() {
        m_time += 0.1;
        
        // 模拟物理惯性与书写抖动
        float targetAngle = -65.0f;
        float speed = m_time * 3.0f;
        float targetX = qSin(speed) * 4.0f;
        float targetY = 2.0f + qCos(speed * 2.0f) * 1.0f;

        float easing = 0.1f;
        m_angle += (targetAngle - m_angle) * easing;
        m_penX += (targetX - m_penX) * easing;
        m_penY += (targetY - m_penY) * easing;
        m_bookY += (-1.0f - m_bookY) * easing;

        update();
        if (m_time > 5.0) {
            m_timer->stop();
            hide();
        }
    }

private:
    QTimer* m_timer;
    float m_time = 0;
    float m_angle = -45;
    float m_penX = 0, m_penY = 0, m_bookY = 0;
};

#endif // WRITINGANIMATION_H
```

```

